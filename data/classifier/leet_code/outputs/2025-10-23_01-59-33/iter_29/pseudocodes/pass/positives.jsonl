{"task_id": "string-to-integer-atoi", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "wildcard-matching", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "jump-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "combinations", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "gray-code", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "palindrome-partitioning-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "evaluate-reverse-polish-notation", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION evalRPN(tokens)  \n        SET stack TO an empty list  \n        FOR each token IN tokens  \n            IF token EQUALS one of the symbols plus MINUS MULTIPLY DIVIDE  \n                SET b TO the last element removed from stack  \n                SET a TO the last element removed from stack  \n                IF token EQUALS plus  \n                    APPEND a PLUS b TO stack  \n                ELSE IF token EQUALS minus  \n                    APPEND a MINUS b TO stack  \n                ELSE IF token EQUALS multiply  \n                    APPEND a MULTIPLIED BY b TO stack  \n                ELSE IF token EQUALS divide  \n                    APPEND the integer value of a DIVIDED BY b TO stack  \n                END IF  \n            ELSE  \n                APPEND the integer value of token TO stack  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stack  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "fraction-to-recurring-decimal", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-primes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "h-index", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "perfect-squares", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-product-of-word-lengths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters of word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the intersection of element at position i of word_sets AND element at position j of word_sets EQUALS empty set  \n                    SET product TO the LENGTH OF element at position i of words MULTIPLIED BY the LENGTH OF element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "coin-change", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "self-crossing", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isSelfCrossing(distance)  \n        SET n TO the LENGTH OF distance  \n        IF n LESS THAN four  \n            RETURN False  \n        END IF  \n        FOR i FROM three TO n MINUS one  \n            IF element at position i of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance AND element at position i MINUS one of distance LESS THAN OR EQUAL TO element at position i MINUS three of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO four AND element at position i MINUS one of distance EQUALS element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO five AND element at position i MINUS two of distance GREATER THAN OR EQUAL TO element at position i MINUS four of distance AND element at position i MINUS three of distance GREATER THAN OR EQUAL TO element at position i MINUS one of distance AND element at position i MINUS one of distance PLUS element at position i MINUS five of distance GREATER THAN OR EQUAL TO element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-numbers-with-unique-digits", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n INCLUSIVE  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            SET available_digits TO available_digits MINUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "perfect-rectangle", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sentence-screen-fitting", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        SET s TO the concatenation of all elements of sentence with a single space between each followed by a single space character  \n        SET total_length TO the LENGTH OF s  \n        SET position TO zero  \n        \n        FOR each iteration IN the range from one TO rows  \n            INCREMENT position BY cols  \n            \n            IF the element at position MODULO total_length of s EQUALS a space character  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position GREATER THAN zero AND the element at position MINUS one MODULO total_length of s NOT EQUALS a space character  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN position DIVIDED BY total_length  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "strong-password-checker", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION strongPasswordChecker(password)  \n        SET n TO the LENGTH OF password  \n        \n        SET has_lower TO BOOLEAN VALUE OF WHETHER any character IN password is a lowercase letter  \n        SET has_upper TO BOOLEAN VALUE OF WHETHER any character IN password is an uppercase letter  \n        SET has_digit TO BOOLEAN VALUE OF WHETHER any character IN password is a digit  \n        \n        SET missing_types TO three MINUS the SUM OF has_lower PLUS has_upper PLUS has_digit  \n        \n        SET replace TO zero  \n        SET one TO zero  \n        SET two TO zero  \n        SET i TO two  \n        WHILE i LESS THAN n  \n            IF the character at position i of password EQUALS the character at position i MINUS one of password AND the character at position i of password EQUALS the character at position i MINUS two of password  \n                SET length TO two  \n                WHILE i LESS THAN n AND the character at position i of password EQUALS the character at position i MINUS one of password  \n                    INCREMENT length BY one  \n                    INCREMENT i BY one  \n                END WHILE  \n                INCREMENT replace BY the INTEGER DIVISION of length BY three  \n                IF the MODULO of length BY three EQUALS zero  \n                    INCREMENT one BY one  \n                ELSE IF the MODULO of length BY three EQUALS one  \n                    INCREMENT two BY one  \n                END IF  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        \n        IF n LESS THAN six  \n            RETURN the GREATER VALUE BETWEEN missing_types AND six MINUS n  \n        ELSE IF n LESS THAN OR EQUAL TO twenty  \n            RETURN the GREATER VALUE BETWEEN missing_types AND replace  \n        ELSE  \n            SET delete TO n MINUS twenty  \n            \n            SET replace TO replace MINUS the SMALLER VALUE BETWEEN delete AND one  \n            SET replace TO replace MINUS the INTEGER DIVISION BY two OF the SMALLER VALUE BETWEEN the GREATER VALUE BETWEEN delete MINUS one AND zero AND two MULTIPLIED BY two  \n            SET replace TO replace MINUS the INTEGER DIVISION BY three OF the GREATER VALUE BETWEEN delete MINUS one MINUS two MULTIPLIED BY two AND zero  \n            \n            RETURN delete PLUS the GREATER VALUE BETWEEN missing_types AND replace  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reconstruct-original-digits-from-english", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "arithmetic-slices-ii-subsequence", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n LESS THAN three  \n            RETURN zero  \n        END IF  \n        \n        SET dp TO a list OF default dictionaries EACH mapping integer TO integer WITH the LENGTH OF n  \n        SET total_count TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                SET d TO the element at position i of nums MINUS the element at position j of nums  \n                \n                IF dp at position j CONTAINS key d  \n                    INCREMENT the value at key d in dp at position i BY the value at key d in dp at position j PLUS one  \n                    INCREMENT total_count BY the value at key d in dp at position j  \n                ELSE  \n                    INCREMENT the value at key d in dp at position i BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "ones-and-zeroes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        SET dp TO a two dimensional list with the dimensions of m plus one by n plus one where each element is zero  \n        FOR each string s IN strs  \n            SET count_0 TO the number of elements EQUALS to zero in the string s  \n            SET count_1 TO the number of elements EQUALS to one in the string s  \n            FOR variable i FROM m DOWN TO count_0  \n                FOR variable j FROM n DOWN TO count_1  \n                    SET dp at position i and position j TO the maximum value between dp at position i and position j AND the value of dp at position i MINUS count_0 and position j MINUS count_1 PLUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp at position m and position n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "output-contest-matches", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        SET teams TO an empty list  \n        FOR number FROM one TO n  \n            APPEND the string representation of number TO teams  \n        END FOR  \n        WHILE n GREATER THAN one  \n            FOR i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO the concatenation of an open parenthesis concatenated with the element at position i of teams concatenated with a comma concatenated with the element at position n MINUS one MINUS i of teams concatenated with a close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN the element at position zero of teams  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "student-attendance-record-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION checkRecord(n)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a three dimensional list of zeroes with dimensions n PLUS one BY two BY three  \n        SET element at position zero BY zero BY zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO one  \n                FOR k FROM zero TO two  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp PLUS element at position i MINUS one BY j BY k of dp  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp MODULO MOD  \n                    IF j EQUALS zero  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp PLUS element at position i MINUS one BY zero BY k of dp  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp MODULO MOD  \n                    END IF  \n                    IF k LESS THAN two  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp PLUS element at position i MINUS one BY j BY k of dp  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        SET result TO zero  \n        FOR j FROM zero TO one  \n            FOR k FROM zero TO two  \n                SET result TO result PLUS element at position n BY j BY k of dp  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-closest-palindrome", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO integer VALUE OF n  \n            RETURN string REPRESENTATION OF numeric_value MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        SET power_length TO TEN RAISED TO THE power OF length  \n        SET power_length_minus_one TO TEN RAISED TO THE power OF length MINUS one  \n        \n        ADD the VALUE OF power_length PLUS one TO candidates  \n        ADD the VALUE OF power_length_minus_one MINUS one TO candidates  \n        \n        SET prefix TO integer VALUE OF substring FROM position one TO position (length PLUS one) DIVIDED BY two of n  \n        \n        FOR i FROM negative one TO positive one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO string REPRESENTATION OF new_prefix_numeric  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSED STRING OF new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH reversed_part  \n            ELSE  \n                SET substring_reversed TO the REVERSED STRING OF substring FROM position one TO LENGTH OF new_prefix MINUS one of new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH substring_reversed  \n            END IF  \n            \n            SET candidate_numeric TO integer VALUE OF candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO integer VALUE OF n  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO NULL  \n        SET smallest_distance TO INFINITY  \n        FOR each number IN candidates  \n            SET current_distance TO the ABSOLUTE VALUE OF number MINUS original_number  \n            IF current_distance LESS THAN smallest_distance OR (current_distance EQUALS smallest_distance AND number LESS THAN closest)  \n                SET closest TO number  \n                SET smallest_distance TO current_distance  \n            END IF  \n        END FOR  \n        \n        RETURN string REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "k-inverse-pairs-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kInversePairs(n, k)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a two dimensional list of zeros with dimension n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp  \n                IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                IF j GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of element at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                SET element at position j of element at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-square-numbers", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET left TO zero  \n        SET right TO integer VALUE OF the SQUARE ROOT OF c  \n        WHILE left LESS THAN OR EQUAL TO right holds  \n            SET current_sum TO left MULTIPLIED BY left PLUS right MULTIPLIED BY right  \n            IF current_sum EQUALS c THEN  \n                RETURN true  \n            ELSE IF current_sum LESS THAN c THEN  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "dota2-senate", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        ASSIGN reference TO new double-ended queue named radiant  \n        ASSIGN reference TO new double-ended queue named dire  \n\n        FOR each index i AND character s IN senate  \n            IF character s EQUALS the character representing Radiant party  \n                APPEND index i TO radiant  \n            ELSE  \n                APPEND index i TO dire  \n            END IF  \n        END FOR  \n\n        WHILE radiant is not empty AND dire is not empty  \n            REMOVE and ASSIGN the first element from radiant TO r_index  \n            REMOVE and ASSIGN the first element from dire TO d_index  \n\n            IF r_index LESS THAN d_index  \n                APPEND r_index PLUS the length of senate TO radiant  \n            ELSE  \n                APPEND d_index PLUS the length of senate TO dire  \n            END IF  \n        END WHILE  \n\n        IF radiant is not empty  \n            RETURN the word Radiant  \n        ELSE  \n            RETURN the word Dire  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "non-decreasing-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "repeated-string-match", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        SET minimum repetitions TO the smallest integer greater than or equal to the LENGTH OF b DIVIDED BY the LENGTH OF a  \n        IF string b IS a substring of string a repeated minimum repetitions times  \n            RETURN minimum repetitions  \n        END IF  \n        IF string b IS a substring of string a repeated minimum repetitions PLUS one times  \n            RETURN minimum repetitions PLUS one  \n        END IF  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "longest-word-in-dictionary", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN LEXICOGRAPHICAL ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO an empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from position one TO position LENGTH OF word MINUS one IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "pour-water", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN zero AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            INCREMENT element at position k of heights BY one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "swap-adjacent-in-lr-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reaching-points", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "domino-and-tromino-tiling", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO the one billion PLUS seven  \n        \n        SET dp TO a list of zeros with LENGTH n PLUS one  \n        SET dp1 TO a list of zeros with LENGTH n PLUS one  \n        \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder of the sum of element at position i MINUS one of dp PLUS element at position i MINUS two of dp PLUS two MULTIPLIED BY element at position i MINUS one of dp1 when divided by MOD  \n            SET element at position i of dp1 TO the remainder of the sum of element at position i MINUS two of dp PLUS element at position i MINUS one of dp1 when divided by MOD  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "valid-tic-tac-toe-state", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "soup-servings", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred THEN  \n            RETURN one point zero  \n        END IF  \n        SET n TO n PLUS twenty four DIVIDED BY twenty five  \n        SET memo TO empty dictionary  \n        FUNCTION dp(a, b)  \n            IF tuple of a AND b EXISTS IN memo THEN  \n                RETURN value of tuple of a AND b IN memo  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point five  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero THEN  \n                RETURN one point zero  \n            END IF  \n            IF b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point zero  \n            END IF  \n            SET prob TO zero point two five MULTIPLIED BY sum of dp of a MINUS four AND b PLUS dp of a MINUS three AND b MINUS one PLUS dp of a MINUS two AND b MINUS two PLUS dp of a MINUS one AND b MINUS three  \n            SET value of tuple of a AND b IN memo TO prob  \n            RETURN prob  \n        END FUNCTION  \n        RETURN dp of n AND n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "bus-routes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from keys to empty lists  \n        FOR each bus WITH index bus_index AND route IN routes  \n            FOR each stop IN route  \n                APPEND bus_index TO the list corresponding to stop IN stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at the source stop FROM stop_to_buses  \n            APPEND the tuple consisting of bus AND one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element FROM bus_queue AND ASSIGN the elements TO current_bus AND bus_count  \n\n            FOR each stop IN the route at position current_bus OF routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop NOT IN visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop FROM stop_to_buses  \n                        IF next_bus NOT IN visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the tuple consisting of next_bus AND bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "card-flipping-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "binary-trees-with-factors", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "split-array-into-fibonacci-sequence", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS the character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE TO the next iteration of the loop  \n                END IF  \n                SET next_num TO the integer value of the substring of num from position start TO position end MINUS one  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at the position LENGTH OF path MINUS one of path PLUS the element at the position LENGTH OF path MINUS two of path  \n                    SET result TO the call of backtrack WITH parameters end AND the concatenation of path AND the list containing next_num  \n                    IF result IS NOT an empty list  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        RETURN the call of backtrack WITH parameters zero AND an empty list  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "shortest-path-visiting-all-nodes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathLength(graph)  \n        IF graph EQUALS empty collection THEN  \n            RETURN zero  \n        END IF  \n      \n        SET n TO the LENGTH OF graph  \n        SET queue TO a new double-ended queue containing pairs of each node in the range from zero TO n MINUS one together with a value obtained by ONE SHIFTED LEFT BY node  \n        SET visited TO a new set containing the same pairs as in queue  \n      \n        SET steps TO zero  \n        SET all_nodes_visited TO ONE SHIFTED LEFT BY n MINUS one  \n      \n        WHILE queue is not empty  \n            SET current_level_size TO the LENGTH OF queue  \n            FOR iteration FROM one TO current_level_size  \n                REMOVE the leftmost element from queue and DESCTRUCTURE INTO current_node and visited_nodes  \n              \n                IF visited_nodes EQUALS all_nodes_visited THEN  \n                    RETURN steps  \n                END IF  \n              \n                FOR each neighbor IN the element at position current_node of graph  \n                    SET next_visited_nodes TO visited_nodes OR ONE SHIFTED LEFT BY neighbor  \n                    SET next_state TO pair of neighbor and next_visited_nodes  \n                  \n                    IF next_state NOT IN visited THEN  \n                        ADD next_state TO visited  \n                        APPEND next_state TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n          \n            INCREMENT steps BY one  \n        END WHILE  \n      \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "loud-and-rich", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION loudAndRich(richer, quiet)  \n        SET graph TO a new default dictionary with list as the default value type  \n        FOR each pair of elements named a and b IN the collection richer  \n            APPEND element a TO the list associated with key b in graph  \n        END FOR  \n        \n        SET n TO the length of the collection quiet  \n        SET answer TO a list of length n filled with minus one values  \n        \n        FUNCTION dfs(person)  \n            IF the element at position person of answer EQUALS minus one THEN  \n                SET the element at position person of answer TO person  \n                FOR each element neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs with argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position of answer at person of quiet THEN  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        \n        FOR index i FROM zero TO n MINUS one  \n            CALL dfs with argument i  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "super-egg-drop", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        SET dp TO a list of zeros with length k PLUS one  \n        SET moves TO zero  \n        WHILE element at position k of dp LESS THAN n holds  \n            INCREMENT moves BY one  \n            FOR eggs FROM k DOWN TO one  \n                SET element at position eggs of dp TO one PLUS element at position eggs MINUS one of dp PLUS element at position eggs of dp  \n            END FOR  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-subsequence-widths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MOD TO one billion PLUS seven  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list of length n FILLED WITH one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO element at position i MINUS one of power MULTIPLIED BY two MODULO MOD  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS element at position i of nums MULTIPLIED BY element at position i of power MINUS element at position n MINUS i MINUS one of power  \n            SET total_sum TO total_sum MODULO MOD  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "stamping-the-sequence", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION movesToStamp(stamp string, target string) RETURNS list of integers  \n        SET m TO the LENGTH OF stamp  \n        SET n TO the LENGTH OF target  \n        SET indeg TO a list of size n MINUS m PLUS one where each element is m  \n        SET q TO an empty double ended queue  \n        SET g TO a list of size n where each element is an empty list  \n        FOR i FROM zero TO n MINUS m  \n            FOR j FROM zero TO m MINUS one  \n                SET c TO element at position j of stamp  \n                IF element at position i PLUS j of target EQUALS c THEN  \n                    DECREMENT element at position i of indeg BY one  \n                    IF element at position i of indeg EQUALS zero THEN  \n                        APPEND i TO q  \n                    END IF  \n                ELSE  \n                    APPEND i TO element at position i PLUS j of g  \n                END IF  \n            END FOR  \n        END FOR  \n        SET ans TO an empty list  \n        SET vis TO a list of size n where each element is False  \n        WHILE q is not empty  \n            SET i TO the element removed from the left of q  \n            APPEND i TO ans  \n            FOR j FROM zero TO m MINUS one  \n                IF element at position i PLUS j of vis EQUALS False THEN  \n                    SET element at position i PLUS j of vis TO True  \n                    FOR each k IN element at position i PLUS j of g  \n                        DECREMENT element at position k of indeg BY one  \n                        IF element at position k of indeg EQUALS zero THEN  \n                            APPEND k TO q  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n        IF all elements of vis are True THEN  \n            RETURN ans in reverse order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "distinct-subsequences-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        SET MOD TO ten POWER nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        SET dp TO a list OF zeroes WITH LENGTH n PLUS one  \n        SET the element at position zero of dp TO one  \n        SET last TO an empty mapping  \n        FOR i FROM one TO n  \n            SET char TO the element at position i MINUS one of s  \n            SET the element at position i of dp TO the element at position i MINUS one of dp MULTIPLIED BY two  \n            SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            IF char EXISTS IN the keys OF last  \n                SET the element at position i of dp TO the element at position i of dp MINUS the element at position last at char MINUS one of dp PLUS MOD  \n                SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            END IF  \n            ASSIGN last at char TO i  \n        END FOR  \n        RETURN the element at position n of dp MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "triples-with-bitwise-and-equal-to-zero", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        SET pair_and_count TO a new default dictionary of integers  \n        FOR each element i IN nums  \n            FOR each element j IN nums  \n                SET current_key TO the bitwise AND of i AND j  \n                INCREMENT the value at current_key in pair_and_count BY one  \n            END FOR  \n        END FOR  \n        SET triplet_count TO zero  \n        FOR each element k IN nums  \n            FOR each key pair_and and associated count IN pair_and_count items  \n                IF the bitwise AND of pair_and AND k EQUALS zero THEN  \n                    INCREMENT triplet_count BY count  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN triplet_count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "string-transforms-into-another-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO an empty mapping from characters to characters  \n        FOR each pair of characters char1 and char2 FROM str1 AND str2 in order  \n            IF char1 IS IN conversion_map  \n                IF the value mapped from char1 in conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET the value mapped from char1 in conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the number of unique characters IN str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "last-substring-in-lexicographical-order", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sort-items-by-groups-respecting-dependencies", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION sortItems(n, m, group, beforeItems)  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of group EQUALS minus one  \n                SET element at position i of group TO m  \n                INCREMENT m BY one  \n            END IF  \n        END FOR  \n        \n        SET group_items TO a mapping from keys to empty lists  \n        SET group_graph TO a mapping from keys to empty lists  \n        SET item_graph TO a mapping from keys to empty lists  \n        SET item_in_degree TO a list consisting of zero repeated n times  \n        SET group_in_degree TO a list consisting of zero repeated m times  \n        \n        FOR i FROM zero TO n MINUS one  \n            APPEND i TO list at key element at position i of group in group_items  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR each before_element IN element at position i of beforeItems  \n                IF element at position before_element of group EQUALS element at position i of group  \n                    APPEND i TO list at key before_element in item_graph  \n                    INCREMENT element at position i of item_in_degree BY one  \n                ELSE  \n                    APPEND element at position i of group TO list at key element at position before_element of group in group_graph  \n                    INCREMENT element at position element at position i of group of group_in_degree BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION topological_sort(graph, in_degree, items)  \n            SET queue TO a double-ended queue initialized with elements from items WHERE element at position element of in_degree EQUALS zero  \n            SET result TO empty list  \n            \n            WHILE queue is not empty  \n                REMOVE element from front of queue and assign to u  \n                APPEND u TO result  \n                FOR each v IN list at key u in graph  \n                    DECREMENT element at position v of in_degree BY one  \n                    IF element at position v of in_degree EQUALS zero  \n                        APPEND v TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            IF LENGTH OF result EQUALS LENGTH OF items  \n                RETURN result  \n            ELSE  \n                RETURN empty list  \n            END IF  \n        END FUNCTION  \n        \n        SET sorted_within_groups TO empty list  \n        FOR each items_list IN all values of group_items  \n            SET sorted_items TO topological_sort(item_graph, item_in_degree, items_list)  \n            IF LENGTH OF sorted_items EQUALS zero  \n                RETURN empty list  \n            END IF  \n            EXTEND sorted_within_groups BY sorted_items  \n        END FOR  \n        \n        SET sorted_groups TO topological_sort(group_graph, group_in_degree, list of elements from zero TO m MINUS one)  \n        IF LENGTH OF sorted_groups EQUALS zero  \n            RETURN empty list  \n        END IF  \n        \n        SET group_to_items_map TO a mapping from keys to empty lists  \n        FOR each item IN sorted_within_groups  \n            APPEND item TO list at key element at position item of group in group_to_items_map  \n        END FOR  \n        \n        SET result TO empty list  \n        FOR each grp IN sorted_groups  \n            EXTEND result BY list at key grp in group_to_items_map  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-vowels-permutation", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each index FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder when a_next is DIVIDED BY MOD  \n            SET e TO the remainder when e_next is DIVIDED BY MOD  \n            SET i TO the remainder when i_next is DIVIDED BY MOD  \n            SET o TO the remainder when o_next is DIVIDED BY MOD  \n            SET u TO the remainder when u_next is DIVIDED BY MOD  \n        END FOR  \n        SET total_count TO the sum of a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO the remainder when total_count is DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-difficulty-of-a-job-schedule", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minDifficulty(jobDifficulty, d)  \n        SET n TO the LENGTH OF jobDifficulty  \n        \n        IF n LESS THAN d  \n            RETURN negative one  \n        END IF  \n        \n        FUNCTION dp(i, d)  \n            IF d EQUALS one  \n                RETURN the MAXIMUM value IN the SUBLIST of jobDifficulty from position i TO the END  \n            END IF  \n            \n            SET min_difficulty TO positive infinity  \n            SET current_max TO zero  \n            \n            FOR each j FROM i TO n MINUS d  \n                SET current_max TO the GREATER BETWEEN current_max AND element at position j OF jobDifficulty  \n                SET candidate TO current_max PLUS dp(j PLUS one, d MINUS one)  \n                IF candidate LESS THAN min_difficulty  \n                    SET min_difficulty TO candidate  \n                END IF  \n            END FOR  \n            \n            RETURN min_difficulty  \n        END FUNCTION  \n        \n        RETURN dp(zero, d)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "restore-the-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF the element at position zero of mat  \n        SET initial_sum TO zero  \n        FOR each row IN mat  \n            INCREMENT initial_sum BY the element at position zero of row  \n        END FOR  \n        SET initial_indices TO a tuple of zero repeated m times  \n        SET min_heap TO a list containing a tuple of initial_sum and initial_indices  \n        SET visited TO a set containing initial_indices  \n        \n        WHILE k GREATER THAN zero  \n            EXTRACT the tuple containing current_sum and indices by removing the smallest element from min_heap  \n            DECREMENT k BY one  \n            \n            IF k EQUALS zero  \n                RETURN current_sum  \n            END IF  \n            \n            FOR i FROM zero TO m MINUS one  \n                IF the element at position i of indices PLUS one LESS THAN n  \n                    SET new_indices_list TO a list converted from indices  \n                    INCREMENT the element at position i of new_indices_list BY one  \n                    SET new_indices_tuple TO a tuple converted from new_indices_list  \n                    SET new_sum TO current_sum MINUS the element at position i of mat AT the element at position i of indices PLUS the element at position i of mat AT the element at position i of new_indices_tuple  \n                    \n                    IF new_indices_tuple NOT IN visited  \n                        ADD new_indices_tuple TO visited  \n                        ADD the tuple containing new_sum and new_indices_tuple TO min_heap  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "max-dot-product-of-two-subsequences", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxDotProduct(nums1 PARAMETER, nums2 PARAMETER)  \n        SET m TO the LENGTH OF nums1  \n        SET n TO the LENGTH OF nums2  \n        SET dp TO a new list of lists where each inner list has n PLUS one elements each set TO negative infinity and the outer list has m PLUS one such inner lists  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                SET current_product TO the element at position i MINUS one of nums1 MULTIPLIED BY the element at position j MINUS one of nums2  \n                SET dp element at position i element at position j TO the maximum of the following four values  \n                    current_product  \n                    dp element at position i MINUS one element at position j  \n                    dp element at position i element at position j MINUS one  \n                    dp element at position i MINUS one element at position j MINUS one PLUS current_product  \n            END FOR  \n        END FOR  \n        RETURN dp element at position m element at position n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "cherry-pickup-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dp(r c1 c2)  \n            IF c1 LESS THAN zero OR c1 GREATER THAN OR EQUAL TO cols OR c2 LESS THAN zero OR c2 GREATER THAN OR EQUAL TO cols THEN  \n                RETURN zero  \n            END IF  \n            \n            IF c1 EQUALS c2 THEN  \n                SET cherries TO element at position r of grid element at position c1  \n            ELSE  \n                SET cherries TO element at position r of grid element at position c1 PLUS element at position r of grid element at position c2  \n            END IF  \n            \n            IF r EQUALS rows MINUS one THEN  \n                RETURN cherries  \n            END IF  \n            \n            SET max_cherries TO zero  \n            FOR each dc1 IN list containing negative one zero and one  \n                FOR each dc2 IN list containing negative one zero and one  \n                    SET possible TO dp(r PLUS one c1 PLUS dc1 c2 PLUS dc2)  \n                    IF possible GREATER THAN max_cherries THEN  \n                        SET max_cherries TO possible  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN cherries PLUS max_cherries  \n        END FUNCTION  \n        \n        RETURN dp(zero zero cols MINUS one)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-incompatibility", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        CREATE counter_object AS a COUNT of each element IN nums  \n        IF any count IN the VALUES OF counter_object is GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        CREATE empty dictionary subset_incompatibility  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask  \n            IF bit_count EQUALS subset_size THEN  \n                CREATE empty list elements  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BITWISE AND OF mask AND TWO RAISED TO THE POWER OF i is NOT EQUAL TO zero THEN  \n                        APPEND element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the NUMBER OF UNIQUE ELEMENTS IN elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM ELEMENT IN elements MINUS the MINIMUM ELEMENT IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT key mask  \n                END IF  \n            END IF  \n        END FOR  \n        CREATE list dp WITH LENGTH TWO RAISED TO THE POWER OF n FILLED WITH infinity  \n        SET dp AT position zero TO zero  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            IF the REMAINDER OF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask DIVIDED BY subset_size IS NOT EQUAL TO zero THEN  \n                CONTINUE TO the NEXT iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND OF mask AND subset_mask EQUALS subset_mask THEN  \n                    SET candidate_value TO dp AT position mask MINUS subset_mask PLUS subset_incompatibility AT subset_mask  \n                    IF candidate_value IS LESS THAN dp AT position mask THEN  \n                        SET dp AT position mask TO candidate_value  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET full_mask TO TWO RAISED TO THE POWER OF n MINUS one  \n        IF dp AT position full_mask IS NOT EQUAL TO infinity THEN  \n            RETURN dp AT position full_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "gcd-sort-of-an-array", "label": "true_positive", "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n        SET self.rank TO list containing size copies of one  \n    END FUNCTION  \n\n    FUNCTION find(self, p)  \n        IF element at position p of self.parent NOT EQUALS p  \n            SET element at position p of self.parent TO self.find(element at position p of self.parent)  \n        END IF  \n        RETURN element at position p of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, p, q)  \n        SET rootP TO self.find(p)  \n        SET rootQ TO self.find(q)  \n        IF rootP EQUALS rootQ  \n            RETURN False  \n        END IF  \n        IF element at position rootP of self.rank GREATER THAN element at position rootQ of self.rank  \n            SET element at position rootQ of self.parent TO rootP  \n        ELSE IF element at position rootP of self.rank LESS THAN element at position rootQ of self.rank  \n            SET element at position rootP of self.parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of self.parent TO rootP  \n            INCREMENT element at position rootP of self.rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION gcdSort(self, nums)  \n        SET sorted_nums TO nums sorted in ascending order  \n        SET max_val TO the maximum value in nums  \n        SET uf TO a new UnionFind object initialized with max_val PLUS one  \n\n        FOR each num IN nums  \n            FOR each factor FROM two TO the integer part of the square root of num PLUS one  \n                IF num MODULO factor EQUALS zero  \n                    CALL uf.union(num, factor)  \n                    CALL uf.union(num, num DIVIDED BY factor)  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each i FROM zero TO the length of nums MINUS one  \n            IF uf.find(element at position i of nums) NOT EQUALS uf.find(element at position i of sorted_nums)  \n                RETURN False  \n            END IF  \n        END FOR  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter of list of integers k parameter of integer) RETURNS integer  \n        SET total_sum TO the sum of all elements of nums  \n        SET n TO the length of nums  \n        \n        CREATE left_diff as a dictionary with default integer zero  \n        CREATE right_diff as a dictionary with default integer zero  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value associated with diff in right_diff BY one  \n        END FOR  \n        \n        SET max_ways TO the value associated with zero in right_diff  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            \n            SET diff_change TO k MINUS the element at position i of nums  \n            \n            SET new_ways TO the value associated with negative diff_change in left_diff PLUS the value associated with diff_change in right_diff  \n            \n            IF new_ways GREATER THAN max_ways  \n                SET max_ways TO new_ways  \n            END IF  \n            \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value associated with diff in right_diff BY one  \n            INCREMENT the value associated with diff in left_diff BY one  \n        END FOR  \n        \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "second-minimum-time-to-reach-destination", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION secondMinimum(n  \n                            edges  \n                            time  \n                            change)  \n        SET graph TO list of empty lists for each integer from one TO n PLUS one  \n        FOR each pair u AND v IN edges  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n          \n        SET queue TO a double ended queue containing a tuple of one current vertex AND zero current time AND zero count  \n        SET minTimes TO list containing two elements each set to infinite value for each integer from one TO n PLUS one  \n        SET element at position one of minTimes at position zero TO zero  \n          \n        WHILE queue is not empty  \n            REMOVE the first element FROM queue AND ASSIGN TO current AND currentTime AND count  \n              \n            IF current EQUALS n AND count EQUALS one  \n                RETURN currentTime  \n            END IF  \n              \n            IF integer division of currentTime BY change MODULO two EQUALS zero  \n                SET nextTime TO currentTime PLUS time  \n            ELSE  \n                SET nextTime TO (integer division of currentTime BY change PLUS one) MULTIPLIED BY change PLUS time  \n            END IF  \n              \n            FOR each neighbor IN element at position current of graph  \n                IF element at position neighbor of minTimes at position zero GREATER THAN nextTime  \n                    SET element at position neighbor of minTimes at position one TO element at position neighbor of minTimes at position zero  \n                    SET element at position neighbor of minTimes at position zero TO nextTime  \n                    APPEND tuple containing neighbor AND nextTime AND zero TO queue  \n                ELSE IF element at position neighbor of minTimes at position zero LESS THAN nextTime AND nextTime LESS THAN element at position neighbor of minTimes at position one  \n                    SET element at position neighbor of minTimes at position one TO nextTime  \n                    APPEND tuple containing neighbor AND nextTime AND one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-good-people-based-on-statements", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-array-pairs-divisible-by-k", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET gcd_count TO a new counter collection  \n        \n        FOR each num IN nums  \n            INCREMENT the count in gcd_count for the gcd of num AND k BY one  \n        END FOR  \n        \n        SET total_pairs TO zero  \n        \n        SET gcd_values TO the list of keys of gcd_count  \n        SET n TO the length of gcd_values  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET gcd1 TO the element at position i of gcd_values  \n                SET gcd2 TO the element at position j of gcd_values  \n                \n                IF the remainder of gcd1 MULTIPLIED BY gcd2 DIVIDED BY k EQUALS zero THEN  \n                    IF i EQUALS j THEN  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd1 in gcd_count MINUS one DIVIDED BY two  \n                    ELSE  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd2 in gcd_count  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_pairs  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-cost-of-trip-with-k-highways", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumCost(n, highways, k)  \n        CREATE graph AS a default mapping FROM a key TO a list  \n        FOR each city1 city2 toll IN highways  \n            APPEND the pair of city2 and toll TO the list in graph at key city1  \n            APPEND the pair of city1 and toll TO the list in graph at key city2  \n        END FOR  \n  \n        FUNCTION dfs(city visited cost highways_used)  \n            DECLARE max_cost AS nonlocal variable  \n  \n            IF highways_used EQUALS k THEN  \n                SET max_cost TO the greater value BETWEEN max_cost AND cost  \n                RETURN  \n            END IF  \n  \n            FOR each neighbor toll IN the list at graph at key city  \n                IF neighbor NOT IN visited THEN  \n                    ADD neighbor TO visited  \n                    CALL dfs WITH neighbor visited cost PLUS toll highways_used PLUS one  \n                    REMOVE neighbor FROM visited  \n                END IF  \n            END FOR  \n        END FUNCTION  \n  \n        SET max_cost TO negative one  \n        FOR start_city FROM zero TO n MINUS one  \n            SET visited TO a set containing start_city  \n            CALL dfs WITH start_city visited zero zero  \n        END FOR  \n  \n        RETURN max_cost  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "escape-the-spreading-fire", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO the LIST of elements each being a PAIR consisting of one and zero MINUS one and zero zero and one zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two-dimensional list of size m by n each element set TO infinity  \n            SET queue TO an empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one  \n                        APPEND the TRIPLE consisting of i j and zero TO queue  \n                        SET element at position i and j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx and ny of grid EQUALS zero AND element at position nx and ny of fire_times EQUALS infinity  \n                        SET element at position nx and ny of fire_times TO t PLUS one  \n                        APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a double-ended queue containing a single TRIPLE consisting of zero zero and wait  \n            SET visited TO a set containing the PAIR zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the PAIR nx ny NOT IN visited AND element at position nx and ny of grid EQUALS zero  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one  \n                            IF element at position nx and ny of fire_times GREATER THAN OR EQUAL TO t PLUS one  \n                                RETURN true  \n                            ELSE  \n                                RETURN false  \n                            END IF  \n                        END IF  \n                        IF element at position nx and ny of fire_times GREATER THAN t PLUS one  \n                            ADD the PAIR nx ny TO visited  \n                            APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two rounded down to the nearest integer  \n            IF can_escape(mid)  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result NOT EQUALS m MULTIPLIED BY n  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "total-appeal-of-a-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION appealSum(s)  \n        SET last TO a list of length twenty six with each element set to minus one  \n        SET total_appeal TO zero  \n        SET current_appeal TO zero  \n        FOR each position i AND character char IN the enumeration of s  \n            SET index TO the numeric code of character char MINUS the numeric code of character a  \n            INCREMENT current_appeal BY position i MINUS element at position index of last  \n            INCREMENT total_appeal BY current_appeal  \n            SET element at position index of last TO position i  \n        END FOR  \n        RETURN total_appeal  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "encode-string-with-shortest-length", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION encode(s)  \n        FUNCTION get_encoded_length(count, substring)  \n            RETURN the LENGTH OF the string CONVERTED FROM count PLUS the LENGTH OF substring PLUS two  \n        END FUNCTION  \n\n        FUNCTION dp(i, j)  \n            SET substring TO the element at position i UP TO and INCLUDING position j OF s  \n            SET n TO j MINUS i PLUS one  \n            IF n LESS THAN five THEN  \n                RETURN substring  \n            END IF  \n\n            SET shortest TO substring  \n            FOR k FROM one TO n DIVIDED BY two PLUS one  \n                IF n MODULO k EQUALS zero THEN  \n                    SET repeat_count TO n DIVIDED BY k  \n                    IF substring EQUALS substring from position zero UP TO but NOT INCLUDING position k REPEATED repeat_count TIMES THEN  \n                        SET encoded_candidate TO string CONVERTED FROM repeat_count CONCATENATED WITH the LEFT SQUARE BRACKET CONCATENATED WITH dp(i, i PLUS k MINUS one) CONCATENATED WITH the RIGHT SQUARE BRACKET  \n                        IF the LENGTH OF encoded_candidate LESS THAN the LENGTH OF shortest THEN  \n                            SET shortest TO encoded_candidate  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n\n            FOR k FROM i TO j MINUS one  \n                SET left_encoded TO dp(i, k)  \n                SET right_encoded TO dp(k PLUS one, j)  \n                SET combined TO left_encoded CONCATENATED WITH right_encoded  \n                IF the LENGTH OF combined LESS THAN the LENGTH OF shortest THEN  \n                    SET shortest TO combined  \n                END IF  \n            END FOR  \n\n            RETURN shortest  \n        END FUNCTION  \n\n        RETURN dp(zero, the LENGTH OF s MINUS one)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "number-of-distinct-islands-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO LENGTH OF element at position zero of grid OR element at position x of grid at position y EQUALS zero  \n                RETURN  \n            END IF  \n            SET element at position x of grid at position y TO zero  \n            APPEND tuple of x and y TO island  \n            CALL dfs WITH x PLUS one AND y AND island  \n            CALL dfs WITH x MINUS one AND y AND island  \n            CALL dfs WITH x AND y PLUS one AND island  \n            CALL dfs WITH x AND y MINUS one AND island  \n        END FUNCTION  \n\n        FUNCTION normalize(island)  \n            SET shapes TO empty list  \n            FOR each pair dx and dy IN list of pairs of one and one PLUS one and minus one PLUS minus one and one PLUS minus one and minus one  \n                SET new_island TO empty list  \n                FOR each pair x and y IN island  \n                    APPEND tuple of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island  \n                END FOR  \n                SORT new_island in ascending order  \n                SET min_x TO the minimum x among all pairs in new_island  \n                SET min_y TO the minimum y among all pairs in new_island  \n                APPEND tuple of pairs where each x MINUS min_x AND each y MINUS min_y from new_island TO shapes  \n            END FOR  \n            SET original_length TO LENGTH OF shapes  \n            FOR index FROM zero TO original_length MINUS one  \n                APPEND tuple of pairs where y AND negative x from shape at position index TO shapes  \n            END FOR  \n            RETURN the minimal element in shapes according to lexicographical order  \n        END FUNCTION  \n\n        SET islands TO empty set  \n        FOR i FROM zero TO LENGTH OF grid MINUS one  \n            FOR j FROM zero TO LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET island TO empty list  \n                    CALL dfs WITH i AND j AND island  \n                    ADD normalize of island TO islands  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN LENGTH OF islands  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
