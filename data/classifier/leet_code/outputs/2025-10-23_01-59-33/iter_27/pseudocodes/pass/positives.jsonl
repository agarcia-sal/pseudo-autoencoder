{"task_id": "longest-palindromic-substring", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "string-to-integer-atoi", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "jump-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "combinations", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "palindrome-partitioning-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "fraction-to-recurring-decimal", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-primes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "different-ways-to-add-parentheses", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION diffWaysToCompute(expression)  \n        FUNCTION compute(left, right, operator)  \n            SET results TO an empty list  \n            FOR each l IN left  \n                FOR each r IN right  \n                    IF operator EQUALS the plus symbol  \n                        APPEND l PLUS r TO results  \n                    ELSE IF operator EQUALS the minus symbol  \n                        APPEND l MINUS r TO results  \n                    ELSE IF operator EQUALS the multiplication symbol  \n                        APPEND l MULTIPLIED BY r TO results  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        FUNCTION helper(sub_expr)  \n            IF the entirety of sub_expr CONSISTS OF DIGITS  \n                RETURN a list containing the integer value of sub_expr  \n            END IF  \n          \n            SET results TO an empty list  \n            FOR index i FROM zero TO the LENGTH OF sub_expr MINUS one  \n                IF the element at position i of sub_expr EQUALS any of the plus symbol OR the minus symbol OR the multiplication symbol  \n                    SET left_results TO helper(the substring of sub_expr from position zero TO position i MINUS one)  \n                    SET right_results TO helper(the substring of sub_expr from position i PLUS one TO the last position)  \n                    FOR each result IN compute(left_results, right_results, the element at position i of sub_expr)  \n                        APPEND result TO results  \n                    END FOR  \n                END IF  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        RETURN helper(expression)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "h-index", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "perfect-squares", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-product-of-word-lengths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters of word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the intersection of element at position i of word_sets AND element at position j of word_sets EQUALS empty set  \n                    SET product TO the LENGTH OF element at position i of words MULTIPLIED BY the LENGTH OF element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "bulb-switcher", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        RETURN the integer part of the square root of n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "coin-change", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "self-crossing", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isSelfCrossing(distance)  \n        SET n TO the LENGTH OF distance  \n        IF n LESS THAN four  \n            RETURN False  \n        END IF  \n        FOR i FROM three TO n MINUS one  \n            IF element at position i of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance AND element at position i MINUS one of distance LESS THAN OR EQUAL TO element at position i MINUS three of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO four AND element at position i MINUS one of distance EQUALS element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO five AND element at position i MINUS two of distance GREATER THAN OR EQUAL TO element at position i MINUS four of distance AND element at position i MINUS three of distance GREATER THAN OR EQUAL TO element at position i MINUS one of distance AND element at position i MINUS one of distance PLUS element at position i MINUS five of distance GREATER THAN OR EQUAL TO element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-numbers-with-unique-digits", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n INCLUSIVE  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            SET available_digits TO available_digits MINUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "perfect-rectangle", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sentence-screen-fitting", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        SET s TO the concatenation of all elements of sentence with a single space between each followed by a single space character  \n        SET total_length TO the LENGTH OF s  \n        SET position TO zero  \n        \n        FOR each iteration IN the range from one TO rows  \n            INCREMENT position BY cols  \n            \n            IF the element at position MODULO total_length of s EQUALS a space character  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position GREATER THAN zero AND the element at position MINUS one MODULO total_length of s NOT EQUALS a space character  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN position DIVIDED BY total_length  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reconstruct-original-digits-from-english", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "ones-and-zeroes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        SET dp TO a two dimensional list with the dimensions of m plus one by n plus one where each element is zero  \n        FOR each string s IN strs  \n            SET count_0 TO the number of elements EQUALS to zero in the string s  \n            SET count_1 TO the number of elements EQUALS to one in the string s  \n            FOR variable i FROM m DOWN TO count_0  \n                FOR variable j FROM n DOWN TO count_1  \n                    SET dp at position i and position j TO the maximum value between dp at position i and position j AND the value of dp at position i MINUS count_0 and position j MINUS count_1 PLUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp at position m and position n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-time-difference", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET split_result TO the list of elements obtained by splitting time at the position of the colon character  \n            SET hours TO the integer conversion of the element at position zero of split_result  \n            SET minutes TO the integer conversion of the element at position one of split_result  \n            RETURN the result of multiplication of hours by the number of minutes in one hour PLUS minutes  \n        END FUNCTION  \n        \n        SET minutes_list TO the list obtained by applying the function to_minutes to each element in timePoints  \n        SORT minutes_list in ascending order  \n        SET min_diff TO positive infinity  \n        FOR index FROM one TO the length of minutes_list MINUS one  \n            SET current_difference TO the element at position index of minutes_list MINUS the element at position index MINUS one of minutes_list  \n            IF current_difference LESS THAN min_diff  \n                SET min_diff TO current_difference  \n            END IF  \n        END FOR  \n        SET circular_difference TO the result of subtracting the element at the last position of minutes_list FROM the number of minutes in a full day PLUS the element at the first position of minutes_list  \n        IF circular_difference LESS THAN min_diff  \n            SET min_diff TO circular_difference  \n        END IF  \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "output-contest-matches", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        SET teams TO an empty list  \n        FOR number FROM one TO n  \n            APPEND the string representation of number TO teams  \n        END FOR  \n        WHILE n GREATER THAN one  \n            FOR i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO the concatenation of an open parenthesis concatenated with the element at position i of teams concatenated with a comma concatenated with the element at position n MINUS one MINUS i of teams concatenated with a close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN the element at position zero of teams  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-closest-palindrome", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO integer VALUE OF n  \n            RETURN string REPRESENTATION OF numeric_value MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        SET power_length TO TEN RAISED TO THE power OF length  \n        SET power_length_minus_one TO TEN RAISED TO THE power OF length MINUS one  \n        \n        ADD the VALUE OF power_length PLUS one TO candidates  \n        ADD the VALUE OF power_length_minus_one MINUS one TO candidates  \n        \n        SET prefix TO integer VALUE OF substring FROM position one TO position (length PLUS one) DIVIDED BY two of n  \n        \n        FOR i FROM negative one TO positive one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO string REPRESENTATION OF new_prefix_numeric  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSED STRING OF new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH reversed_part  \n            ELSE  \n                SET substring_reversed TO the REVERSED STRING OF substring FROM position one TO LENGTH OF new_prefix MINUS one of new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH substring_reversed  \n            END IF  \n            \n            SET candidate_numeric TO integer VALUE OF candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO integer VALUE OF n  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO NULL  \n        SET smallest_distance TO INFINITY  \n        FOR each number IN candidates  \n            SET current_distance TO the ABSOLUTE VALUE OF number MINUS original_number  \n            IF current_distance LESS THAN smallest_distance OR (current_distance EQUALS smallest_distance AND number LESS THAN closest)  \n                SET closest TO number  \n                SET smallest_distance TO current_distance  \n            END IF  \n        END FOR  \n        \n        RETURN string REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "k-inverse-pairs-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kInversePairs(n, k)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a two dimensional list of zeros with dimension n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp  \n                IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                IF j GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of element at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                SET element at position j of element at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "course-schedule-iii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION scheduleCourse(courses)  \n        SORT courses BY the second element of each course representing the last day of the course  \n        SET max_heap TO an empty list  \n        SET current_end_day TO zero  \n        FOR each course IN courses  \n            SET duration TO the first element of course representing the duration of the course  \n            SET last_day TO the second element of course representing the last day of the course  \n            IF current_end_day PLUS duration LESS THAN OR EQUAL TO last_day THEN  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n                INCREMENT current_end_day BY duration  \n            ELSE IF max_heap IS NOT empty AND the negation of the first element of max_heap GREATER THAN duration THEN  \n                INCREMENT current_end_day BY duration PLUS the heap pop operation result from max_heap  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n            END IF  \n        END FOR  \n        RETURN the length of max_heap  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-square-numbers", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET left TO zero  \n        SET right TO integer VALUE OF the SQUARE ROOT OF c  \n        WHILE left LESS THAN OR EQUAL TO right holds  \n            SET current_sum TO left MULTIPLIED BY left PLUS right MULTIPLIED BY right  \n            IF current_sum EQUALS c THEN  \n                RETURN true  \n            ELSE IF current_sum LESS THAN c THEN  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "solve-the-equation", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION solveEquation(equation)  \n        FUNCTION parse_side(side)  \n            SET tokens TO the result of replacing plus signs in side with delimiter plus sign and replacing minus signs in side with delimiter minus sign and splitting the resulting string by the delimiter  \n            SET x_count TO zero  \n            SET num_sum TO zero  \n            FOR each token IN tokens  \n                IF token is an empty string THEN  \n                    CONTINUE to the next token  \n                END IF  \n                IF the character x exists in token THEN  \n                    IF token is equal to x OR token is equal to plus sign followed by x THEN  \n                        INCREMENT x_count BY one  \n                    ELSE IF token is equal to minus sign followed by x THEN  \n                        DECREMENT x_count BY one  \n                    ELSE  \n                        INCREMENT x_count BY the integer value of token with character x removed  \n                    END IF  \n                ELSE  \n                    INCREMENT num_sum BY the integer value of token  \n                END IF  \n            END FOR  \n            RETURN x_count and num_sum  \n        END FUNCTION  \n\n        SET left_side and right_side TO the parts of equation separated by the equal sign  \n        SET left_x and left_num TO the result of calling parse_side with left_side  \n        SET right_x and right_num TO the result of calling parse_side with right_side  \n\n        SET total_x TO left_x MINUS right_x  \n        SET total_num TO right_num MINUS left_num  \n\n        IF total_x EQUALS zero THEN  \n            IF total_num EQUALS zero THEN  \n                RETURN the string Infinite solutions  \n            ELSE  \n                RETURN the string No solution  \n            END IF  \n        ELSE  \n            RETURN the string formed by the character x equals the integer result of total_num DIVIDED BY total_x  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "dota2-senate", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        ASSIGN reference TO new double-ended queue named radiant  \n        ASSIGN reference TO new double-ended queue named dire  \n\n        FOR each index i AND character s IN senate  \n            IF character s EQUALS the character representing Radiant party  \n                APPEND index i TO radiant  \n            ELSE  \n                APPEND index i TO dire  \n            END IF  \n        END FOR  \n\n        WHILE radiant is not empty AND dire is not empty  \n            REMOVE and ASSIGN the first element from radiant TO r_index  \n            REMOVE and ASSIGN the first element from dire TO d_index  \n\n            IF r_index LESS THAN d_index  \n                APPEND r_index PLUS the length of senate TO radiant  \n            ELSE  \n                APPEND d_index PLUS the length of senate TO dire  \n            END IF  \n        END WHILE  \n\n        IF radiant is not empty  \n            RETURN the word Radiant  \n        ELSE  \n            RETURN the word Dire  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "non-decreasing-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "repeated-string-match", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        SET minimum repetitions TO the smallest integer greater than or equal to the LENGTH OF b DIVIDED BY the LENGTH OF a  \n        IF string b IS a substring of string a repeated minimum repetitions times  \n            RETURN minimum repetitions  \n        END IF  \n        IF string b IS a substring of string a repeated minimum repetitions PLUS one times  \n            RETURN minimum repetitions PLUS one  \n        END IF  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "longest-word-in-dictionary", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN LEXICOGRAPHICAL ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO an empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from position one TO position LENGTH OF word MINUS one IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "pour-water", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN zero AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            INCREMENT element at position k of heights BY one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "swap-adjacent-in-lr-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reaching-points", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "valid-tic-tac-toe-state", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "bus-routes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from keys to empty lists  \n        FOR each bus WITH index bus_index AND route IN routes  \n            FOR each stop IN route  \n                APPEND bus_index TO the list corresponding to stop IN stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at the source stop FROM stop_to_buses  \n            APPEND the tuple consisting of bus AND one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element FROM bus_queue AND ASSIGN the elements TO current_bus AND bus_count  \n\n            FOR each stop IN the route at position current_bus OF routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop NOT IN visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop FROM stop_to_buses  \n                        IF next_bus NOT IN visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the tuple consisting of next_bus AND bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "card-flipping-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "binary-trees-with-factors", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "split-array-into-fibonacci-sequence", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS the character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE TO the next iteration of the loop  \n                END IF  \n                SET next_num TO the integer value of the substring of num from position start TO position end MINUS one  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at the position LENGTH OF path MINUS one of path PLUS the element at the position LENGTH OF path MINUS two of path  \n                    SET result TO the call of backtrack WITH parameters end AND the concatenation of path AND the list containing next_num  \n                    IF result IS NOT an empty list  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        RETURN the call of backtrack WITH parameters zero AND an empty list  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "shortest-path-visiting-all-nodes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathLength(graph)  \n        IF graph EQUALS empty collection THEN  \n            RETURN zero  \n        END IF  \n      \n        SET n TO the LENGTH OF graph  \n        SET queue TO a new double-ended queue containing pairs of each node in the range from zero TO n MINUS one together with a value obtained by ONE SHIFTED LEFT BY node  \n        SET visited TO a new set containing the same pairs as in queue  \n      \n        SET steps TO zero  \n        SET all_nodes_visited TO ONE SHIFTED LEFT BY n MINUS one  \n      \n        WHILE queue is not empty  \n            SET current_level_size TO the LENGTH OF queue  \n            FOR iteration FROM one TO current_level_size  \n                REMOVE the leftmost element from queue and DESCTRUCTURE INTO current_node and visited_nodes  \n              \n                IF visited_nodes EQUALS all_nodes_visited THEN  \n                    RETURN steps  \n                END IF  \n              \n                FOR each neighbor IN the element at position current_node of graph  \n                    SET next_visited_nodes TO visited_nodes OR ONE SHIFTED LEFT BY neighbor  \n                    SET next_state TO pair of neighbor and next_visited_nodes  \n                  \n                    IF next_state NOT IN visited THEN  \n                        ADD next_state TO visited  \n                        APPEND next_state TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n          \n            INCREMENT steps BY one  \n        END WHILE  \n      \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "loud-and-rich", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION loudAndRich(richer, quiet)  \n        SET graph TO a new default dictionary with list as the default value type  \n        FOR each pair of elements named a and b IN the collection richer  \n            APPEND element a TO the list associated with key b in graph  \n        END FOR  \n        \n        SET n TO the length of the collection quiet  \n        SET answer TO a list of length n filled with minus one values  \n        \n        FUNCTION dfs(person)  \n            IF the element at position person of answer EQUALS minus one THEN  \n                SET the element at position person of answer TO person  \n                FOR each element neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs with argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position of answer at person of quiet THEN  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        \n        FOR index i FROM zero TO n MINUS one  \n            CALL dfs with argument i  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-subsequence-widths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MOD TO one billion PLUS seven  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list of length n FILLED WITH one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO element at position i MINUS one of power MULTIPLIED BY two MODULO MOD  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS element at position i of nums MULTIPLIED BY element at position i of power MINUS element at position n MINUS i MINUS one of power  \n            SET total_sum TO total_sum MODULO MOD  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "stamping-the-sequence", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION movesToStamp(stamp string, target string) RETURNS list of integers  \n        SET m TO the LENGTH OF stamp  \n        SET n TO the LENGTH OF target  \n        SET indeg TO a list of size n MINUS m PLUS one where each element is m  \n        SET q TO an empty double ended queue  \n        SET g TO a list of size n where each element is an empty list  \n        FOR i FROM zero TO n MINUS m  \n            FOR j FROM zero TO m MINUS one  \n                SET c TO element at position j of stamp  \n                IF element at position i PLUS j of target EQUALS c THEN  \n                    DECREMENT element at position i of indeg BY one  \n                    IF element at position i of indeg EQUALS zero THEN  \n                        APPEND i TO q  \n                    END IF  \n                ELSE  \n                    APPEND i TO element at position i PLUS j of g  \n                END IF  \n            END FOR  \n        END FOR  \n        SET ans TO an empty list  \n        SET vis TO a list of size n where each element is False  \n        WHILE q is not empty  \n            SET i TO the element removed from the left of q  \n            APPEND i TO ans  \n            FOR j FROM zero TO m MINUS one  \n                IF element at position i PLUS j of vis EQUALS False THEN  \n                    SET element at position i PLUS j of vis TO True  \n                    FOR each k IN element at position i PLUS j of g  \n                        DECREMENT element at position k of indeg BY one  \n                        IF element at position k of indeg EQUALS zero THEN  \n                            APPEND k TO q  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n        IF all elements of vis are True THEN  \n            RETURN ans in reverse order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "distinct-subsequences-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        SET MOD TO ten POWER nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        SET dp TO a list OF zeroes WITH LENGTH n PLUS one  \n        SET the element at position zero of dp TO one  \n        SET last TO an empty mapping  \n        FOR i FROM one TO n  \n            SET char TO the element at position i MINUS one of s  \n            SET the element at position i of dp TO the element at position i MINUS one of dp MULTIPLIED BY two  \n            SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            IF char EXISTS IN the keys OF last  \n                SET the element at position i of dp TO the element at position i of dp MINUS the element at position last at char MINUS one of dp PLUS MOD  \n                SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            END IF  \n            ASSIGN last at char TO i  \n        END FOR  \n        RETURN the element at position n of dp MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "triples-with-bitwise-and-equal-to-zero", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        SET pair_and_count TO a new default dictionary of integers  \n        FOR each element i IN nums  \n            FOR each element j IN nums  \n                SET current_key TO the bitwise AND of i AND j  \n                INCREMENT the value at current_key in pair_and_count BY one  \n            END FOR  \n        END FOR  \n        SET triplet_count TO zero  \n        FOR each element k IN nums  \n            FOR each key pair_and and associated count IN pair_and_count items  \n                IF the bitwise AND of pair_and AND k EQUALS zero THEN  \n                    INCREMENT triplet_count BY count  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN triplet_count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "string-transforms-into-another-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO an empty mapping from characters to characters  \n        FOR each pair of characters char1 and char2 FROM str1 AND str2 in order  \n            IF char1 IS IN conversion_map  \n                IF the value mapped from char1 in conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET the value mapped from char1 in conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the number of unique characters IN str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "last-substring-in-lexicographical-order", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-vowels-permutation", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each index FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder when a_next is DIVIDED BY MOD  \n            SET e TO the remainder when e_next is DIVIDED BY MOD  \n            SET i TO the remainder when i_next is DIVIDED BY MOD  \n            SET o TO the remainder when o_next is DIVIDED BY MOD  \n            SET u TO the remainder when u_next is DIVIDED BY MOD  \n        END FOR  \n        SET total_count TO the sum of a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO the remainder when total_count is DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-difficulty-of-a-job-schedule", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minDifficulty(jobDifficulty, d)  \n        SET n TO the LENGTH OF jobDifficulty  \n        \n        IF n LESS THAN d  \n            RETURN negative one  \n        END IF  \n        \n        FUNCTION dp(i, d)  \n            IF d EQUALS one  \n                RETURN the MAXIMUM value IN the SUBLIST of jobDifficulty from position i TO the END  \n            END IF  \n            \n            SET min_difficulty TO positive infinity  \n            SET current_max TO zero  \n            \n            FOR each j FROM i TO n MINUS d  \n                SET current_max TO the GREATER BETWEEN current_max AND element at position j OF jobDifficulty  \n                SET candidate TO current_max PLUS dp(j PLUS one, d MINUS one)  \n                IF candidate LESS THAN min_difficulty  \n                    SET min_difficulty TO candidate  \n                END IF  \n            END FOR  \n            \n            RETURN min_difficulty  \n        END FUNCTION  \n        \n        RETURN dp(zero, d)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "construct-target-array-with-multiple-sums", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isPossible(target)  \n        SET max_heap TO an empty list  \n        FOR each num IN target  \n            APPEND the NEGATION of num TO max_heap  \n        END FOR  \n        TRANSFORM max_heap INTO a heap structure  \n        \n        SET total_sum TO the sum of elements in target  \n        \n        WHILE the element at position zero of max_heap LESS THAN NEGATION of one holds  \n            SET largest TO the NEGATION of the element extracted from max_heap  \n            SET rest_sum TO total_sum MINUS largest  \n            \n            IF largest LESS THAN OR EQUAL TO rest_sum OR rest_sum EQUALS zero THEN  \n                RETURN False  \n            END IF  \n            \n            SET new_value TO the remainder of largest DIVIDED BY rest_sum  \n            \n            IF new_value EQUALS zero AND rest_sum NOT EQUALS one THEN  \n                RETURN False  \n            END IF  \n            \n            SET total_sum TO rest_sum PLUS new_value  \n            INSERT the NEGATION of new_value INTO max_heap maintaining heap order  \n        END WHILE  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "restore-the-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF the element at position zero of mat  \n        SET initial_sum TO zero  \n        FOR each row IN mat  \n            INCREMENT initial_sum BY the element at position zero of row  \n        END FOR  \n        SET initial_indices TO a tuple of zero repeated m times  \n        SET min_heap TO a list containing a tuple of initial_sum and initial_indices  \n        SET visited TO a set containing initial_indices  \n        \n        WHILE k GREATER THAN zero  \n            EXTRACT the tuple containing current_sum and indices by removing the smallest element from min_heap  \n            DECREMENT k BY one  \n            \n            IF k EQUALS zero  \n                RETURN current_sum  \n            END IF  \n            \n            FOR i FROM zero TO m MINUS one  \n                IF the element at position i of indices PLUS one LESS THAN n  \n                    SET new_indices_list TO a list converted from indices  \n                    INCREMENT the element at position i of new_indices_list BY one  \n                    SET new_indices_tuple TO a tuple converted from new_indices_list  \n                    SET new_sum TO current_sum MINUS the element at position i of mat AT the element at position i of indices PLUS the element at position i of mat AT the element at position i of new_indices_tuple  \n                    \n                    IF new_indices_tuple NOT IN visited  \n                        ADD new_indices_tuple TO visited  \n                        ADD the tuple containing new_sum and new_indices_tuple TO min_heap  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "max-dot-product-of-two-subsequences", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxDotProduct(nums1 PARAMETER, nums2 PARAMETER)  \n        SET m TO the LENGTH OF nums1  \n        SET n TO the LENGTH OF nums2  \n        SET dp TO a new list of lists where each inner list has n PLUS one elements each set TO negative infinity and the outer list has m PLUS one such inner lists  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                SET current_product TO the element at position i MINUS one of nums1 MULTIPLIED BY the element at position j MINUS one of nums2  \n                SET dp element at position i element at position j TO the maximum of the following four values  \n                    current_product  \n                    dp element at position i MINUS one element at position j  \n                    dp element at position i element at position j MINUS one  \n                    dp element at position i MINUS one element at position j MINUS one PLUS current_product  \n            END FOR  \n        END FOR  \n        RETURN dp element at position m element at position n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-initial-energy-to-finish-tasks", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumEffort(tasks)  \n        SORT tasks IN ORDER WHERE the element representing the difference between the second element MINUS the first element of each task IS IN DESCENDING ORDER  \n        SET current_energy TO zero  \n        SET required_initial_energy TO zero  \n        FOR each element IN tasks  \n            ASSIGN actual TO the first element of element  \n            ASSIGN minimum TO the second element of element  \n            IF current_energy LESS THAN minimum THEN  \n                INCREMENT required_initial_energy BY minimum MINUS current_energy  \n                SET current_energy TO minimum  \n            END IF  \n            DECREMENT current_energy BY actual  \n        END FOR  \n        RETURN required_initial_energy  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-incompatibility", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        CREATE counter_object AS a COUNT of each element IN nums  \n        IF any count IN the VALUES OF counter_object is GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        CREATE empty dictionary subset_incompatibility  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask  \n            IF bit_count EQUALS subset_size THEN  \n                CREATE empty list elements  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BITWISE AND OF mask AND TWO RAISED TO THE POWER OF i is NOT EQUAL TO zero THEN  \n                        APPEND element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the NUMBER OF UNIQUE ELEMENTS IN elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM ELEMENT IN elements MINUS the MINIMUM ELEMENT IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT key mask  \n                END IF  \n            END IF  \n        END FOR  \n        CREATE list dp WITH LENGTH TWO RAISED TO THE POWER OF n FILLED WITH infinity  \n        SET dp AT position zero TO zero  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            IF the REMAINDER OF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask DIVIDED BY subset_size IS NOT EQUAL TO zero THEN  \n                CONTINUE TO the NEXT iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND OF mask AND subset_mask EQUALS subset_mask THEN  \n                    SET candidate_value TO dp AT position mask MINUS subset_mask PLUS subset_incompatibility AT subset_mask  \n                    IF candidate_value IS LESS THAN dp AT position mask THEN  \n                        SET dp AT position mask TO candidate_value  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET full_mask TO TWO RAISED TO THE POWER OF n MINUS one  \n        IF dp AT position full_mask IS NOT EQUAL TO infinity THEN  \n            RETURN dp AT position full_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-good-people-based-on-statements", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "escape-the-spreading-fire", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO the LIST of elements each being a PAIR consisting of one and zero MINUS one and zero zero and one zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two-dimensional list of size m by n each element set TO infinity  \n            SET queue TO an empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one  \n                        APPEND the TRIPLE consisting of i j and zero TO queue  \n                        SET element at position i and j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx and ny of grid EQUALS zero AND element at position nx and ny of fire_times EQUALS infinity  \n                        SET element at position nx and ny of fire_times TO t PLUS one  \n                        APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a double-ended queue containing a single TRIPLE consisting of zero zero and wait  \n            SET visited TO a set containing the PAIR zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the PAIR nx ny NOT IN visited AND element at position nx and ny of grid EQUALS zero  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one  \n                            IF element at position nx and ny of fire_times GREATER THAN OR EQUAL TO t PLUS one  \n                                RETURN true  \n                            ELSE  \n                                RETURN false  \n                            END IF  \n                        END IF  \n                        IF element at position nx and ny of fire_times GREATER THAN t PLUS one  \n                            ADD the PAIR nx ny TO visited  \n                            APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two rounded down to the nearest integer  \n            IF can_escape(mid)  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result NOT EQUALS m MULTIPLIED BY n  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "total-appeal-of-a-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION appealSum(s)  \n        SET last TO a list of length twenty six with each element set to minus one  \n        SET total_appeal TO zero  \n        SET current_appeal TO zero  \n        FOR each position i AND character char IN the enumeration of s  \n            SET index TO the numeric code of character char MINUS the numeric code of character a  \n            INCREMENT current_appeal BY position i MINUS element at position index of last  \n            INCREMENT total_appeal BY current_appeal  \n            SET element at position index of last TO position i  \n        END FOR  \n        RETURN total_appeal  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sentence-similarity-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION areSentencesSimilarTwo(sentence1 sentence1 TO sentence1 OF TYPE list OF strings sentence2 sentence2 TO sentence2 OF TYPE list OF strings similarPairs similarPairs TO similarPairs OF TYPE list OF list OF strings) RETURNS boolean  \n        IF the LENGTH OF sentence1 NOT EQUALS the LENGTH OF sentence2  \n            RETURN false  \n        END IF  \n\n        SET parent TO empty dictionary  \n\n        FUNCTION find(x x TO x) RETURNS x  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO find(element at position x of parent)  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n\n        FUNCTION union(x x TO x y y TO y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootY of parent TO rootX  \n            END IF  \n        END FUNCTION  \n\n        FOR each pair IN similarPairs  \n            FOR each word IN pair  \n                IF word NOT IN parent  \n                    SET element at position word of parent TO word  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each x y IN similarPairs  \n            union(x y)  \n        END FOR  \n\n        FOR each w1 w2 IN sentence1 sentence2  \n            IF w1 NOT IN parent  \n                SET element at position w1 of parent TO w1  \n            END IF  \n            IF w2 NOT IN parent  \n                SET element at position w2 of parent TO w2  \n            END IF  \n            IF find(w1) NOT EQUALS find(w2)  \n                RETURN false  \n            END IF  \n        END FOR  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "number-of-distinct-islands-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO LENGTH OF element at position zero of grid OR element at position x of grid at position y EQUALS zero  \n                RETURN  \n            END IF  \n            SET element at position x of grid at position y TO zero  \n            APPEND tuple of x and y TO island  \n            CALL dfs WITH x PLUS one AND y AND island  \n            CALL dfs WITH x MINUS one AND y AND island  \n            CALL dfs WITH x AND y PLUS one AND island  \n            CALL dfs WITH x AND y MINUS one AND island  \n        END FUNCTION  \n\n        FUNCTION normalize(island)  \n            SET shapes TO empty list  \n            FOR each pair dx and dy IN list of pairs of one and one PLUS one and minus one PLUS minus one and one PLUS minus one and minus one  \n                SET new_island TO empty list  \n                FOR each pair x and y IN island  \n                    APPEND tuple of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island  \n                END FOR  \n                SORT new_island in ascending order  \n                SET min_x TO the minimum x among all pairs in new_island  \n                SET min_y TO the minimum y among all pairs in new_island  \n                APPEND tuple of pairs where each x MINUS min_x AND each y MINUS min_y from new_island TO shapes  \n            END FOR  \n            SET original_length TO LENGTH OF shapes  \n            FOR index FROM zero TO original_length MINUS one  \n                APPEND tuple of pairs where y AND negative x from shape at position index TO shapes  \n            END FOR  \n            RETURN the minimal element in shapes according to lexicographical order  \n        END FUNCTION  \n\n        SET islands TO empty set  \n        FOR i FROM zero TO LENGTH OF grid MINUS one  \n            FOR j FROM zero TO LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET island TO empty list  \n                    CALL dfs WITH i AND j AND island  \n                    ADD normalize of island TO islands  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN LENGTH OF islands  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-derangement-of-an-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findDerangement(n)  \n        SET MODULO TO ten RAISED TO THE POWER OF nine PLUS seven  \n        \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        IF n EQUALS two  \n            RETURN one  \n        END IF  \n        \n        SET previous_twice TO one  \n        SET previous_once TO zero  \n        \n        FOR integer i FROM three TO n  \n            SET current_value TO integer i MINUS one MULTIPLIED BY the SUM OF previous_once AND previous_twice  \n            SET current_value TO current_value MODULO MODULO  \n            SET previous_twice TO previous_once  \n            SET previous_once TO current_value  \n        END FOR  \n        \n        RETURN previous_once  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
