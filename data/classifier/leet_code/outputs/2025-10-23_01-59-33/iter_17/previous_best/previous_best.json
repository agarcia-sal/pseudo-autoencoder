{
  "prompt": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *fully reproducible* \u2014 meaning it can be directly and unambiguously implemented as correct, complete, and deterministic executable code that will pass *all* valid unit tests unconditionally for the implied problem domain; otherwise output **`0`**. Do not output any whitespace, explanation, or extra characters.\n\nBase your decision *solely* on a thorough, integrated analysis of the entire pseudocode by rigorously applying the following enhanced criteria:\n\n1. **Explicit and Complete Definitions**  \n\u2003- All inputs, outputs, variables, constants, data structures, and subroutines are explicitly defined within the pseudocode or can be reliably and uniquely inferred from it without external assumptions.  \n\u2003- Data types, sizes, initializations, and effects of every variable and data structure are unambiguously described or logically deducible.  \n\u2003- All referenced methods, functions, or procedures have their complete algorithms or clearly specified behavior included.  \n\n2. **Comprehensive and Correct Logic over the Entire Input Domain**  \n\u2003- The pseudocode logically and correctly handles every possible valid input instance, including edge cases, boundary conditions, empty or extreme inputs, and all special scenarios relevant to the problem domain.  \n\u2003- The control flow is fully defined with no infinite loops, dead code, or ambiguous branching.  \n\u2003- Conditions and iterations terminate correctly and deterministically for all possible inputs.\n\n3. **Deterministic and Unambiguous Semantics**  \n\u2003- Each statement and operation performs exactly one well-defined effect; there is no vagueness, ambiguity, or informal phrasing that could lead to conflicting interpretations or nondeterminism.  \n\u2003- The overall behavior results in exactly one deterministic output for every valid input.\n\n4. **Self-Containment Without External or Implicit Dependencies**  \n\u2003- The pseudocode does not rely on any implicit context, external state, environment, or undocumented assumptions.  \n\u2003- All necessary computations, data manipulations, and condition checks are internally defined and complete.\n\n5. **Guaranteed Test-Passing Implementation**  \n\u2003- If implemented exactly as given, the pseudocode will necessarily produce correct results and never cause runtime failures, exceptions, or incorrect outputs for *all* tests that validate the intended functionality.  \n\u2003- Any unclear, partial, inconsistent, or underspecified aspects that might prevent an implementation from passing some valid tests mandate output **`0`**.\n\n---\n\n**Important instructions:**  \n- Assess the entire pseudocode block holistically; fragmented or isolated lines cannot invalidate or confirm reproducibility alone.  \n- Ignore formatting, comments, example usages, or any external problem descriptions \u2014 rely strictly on the pseudocode content provided.  \n- If *any* uncertainty, implicitness, incomplete definition, or logical flaw exists that could prevent fully passing all tests without modification, output **`0`**.  \n- Only output **`1`** when *all* criteria above are unequivocally met and the pseudocode is reproducible as defined.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "response": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *fully reproducible* \u2014 meaning it can be directly and unambiguously implemented as correct, complete, and deterministic executable code that will pass *all* valid unit tests unconditionally for the implied problem domain; otherwise output **`0`**. Do not output any whitespace, explanation, or extra characters.\n\nBase your decision *solely* on a thorough, integrated analysis of the entire pseudocode by rigorously applying the following enhanced criteria:\n\n1. **Explicit and Complete Definitions**  \n\u2003- All inputs, outputs, variables, constants, data structures, and subroutines are explicitly defined within the pseudocode or can be reliably and uniquely inferred from it without external assumptions.  \n\u2003- Data types, sizes, initializations, and effects of every variable and data structure are unambiguously described or logically deducible.  \n\u2003- All referenced methods, functions, or procedures have their complete algorithms or clearly specified behavior included.  \n\n2. **Comprehensive and Correct Logic over the Entire Input Domain**  \n\u2003- The pseudocode logically and correctly handles every possible valid input instance, including edge cases, boundary conditions, empty or extreme inputs, and all special scenarios relevant to the problem domain.  \n\u2003- The control flow is fully defined with no infinite loops, dead code, or ambiguous branching.  \n\u2003- Conditions and iterations terminate correctly and deterministically for all possible inputs.\n\n3. **Deterministic and Unambiguous Semantics**  \n\u2003- Each statement and operation performs exactly one well-defined effect; there is no vagueness, ambiguity, or informal phrasing that could lead to conflicting interpretations or nondeterminism.  \n\u2003- The overall behavior results in exactly one deterministic output for every valid input.\n\n4. **Self-Containment Without External or Implicit Dependencies**  \n\u2003- The pseudocode does not rely on any implicit context, external state, environment, or undocumented assumptions.  \n\u2003- All necessary computations, data manipulations, and condition checks are internally defined and complete.\n\n5. **Guaranteed Test-Passing Implementation**  \n\u2003- If implemented exactly as given, the pseudocode will necessarily produce correct results and never cause runtime failures, exceptions, or incorrect outputs for *all* tests that validate the intended functionality.  \n\u2003- Any unclear, partial, inconsistent, or underspecified aspects that might prevent an implementation from passing some valid tests mandate output **`0`**.\n\n---\n\n**Important instructions:**  \n- Assess the entire pseudocode block holistically; fragmented or isolated lines cannot invalidate or confirm reproducibility alone.  \n- Ignore formatting, comments, example usages, or any external problem descriptions \u2014 rely strictly on the pseudocode content provided.  \n- If *any* uncertainty, implicitness, incomplete definition, or logical flaw exists that could prevent fully passing all tests without modification, output **`0`**.  \n- Only output **`1`** when *all* criteria above are unequivocally met and the pseudocode is reproducible as defined.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "score": 0.6266666666666667,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION reverseWords(s)  \n        SET words TO list of words obtained by splitting s by spaces where multiple spaces are handled automatically  \n        REVERSE the order of elements in words  \n        RETURN single string obtained by joining elements of words with single spaces between them  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\nCLASS Solution\n    FUNCTION isMatch(string_s, string_p)\n        SET dp TO a two dimensional list of BOOLEAN false VALUES with the number of rows EQUAL TO the LENGTH OF string_s PLUS one AND the number of columns EQUAL TO the LENGTH OF string_p PLUS one\n\n        SET the element at row zero AND column zero OF dp TO true\n\n        FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n            IF the element at position index_j MINUS one OF string_p EQUALS character star\n                SET the element at row zero AND column index_j OF dp TO the element at row zero AND column index_j MINUS one OF dp\n            END IF\n        END FOR\n        \n        FOR index_i FROM one TO the LENGTH OF string_s INCLUSIVE\n            FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n                IF the element at position index_j MINUS one OF string_p EQUALS character star\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j OF dp OR the element at row index_i AND column index_j MINUS one OF dp\n                ELSE IF the element at position index_j MINUS one OF string_p EQUALS character question MARK OR the element at position index_i MINUS one OF string_s EQUALS the element at position index_j MINUS one OF string_p\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j MINUS one OF dp\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the element at row the LENGTH OF string_s AND column the LENGTH OF string_p OF dp\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n```\nfunction fractionToDecimal(n, d):\n    sign \u2190 \"-\" if (n < 0) xor (d < 0) else \"\"\n    n, d \u2190 abs(n), abs(d)\n    q, r \u2190 divmod(n, d)\n    int_part \u2190 str(q)\n    if r = 0: return sign + int_part\n    seen \u2190 map remainder \u2192 index\n    frac \u2190 []\n    while r \u2260 0:\n        if r in seen:\n            i \u2190 seen[r]\n            return sign + int_part + \".\" + join(frac[:i]) + \"(\" + join(frac[i:]) + \")\"\n        seen[r] \u2190 length(frac)\n        r \u2190 r * 10\n        q, r \u2190 divmod(r, d)\n        append str(q) to frac\n    return sign + int_part + \".\" + join(frac)\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS\n```\ndiffWaysToCompute(expr):\n  compute(L, R, op):\n    res = []\n    for l in L:\n      for r in R:\n        res.append(l + r) if op=='+' else res.append(l - r) if op=='-' else res.append(l * r)\n    return res\n\n  helper(sub):\n    if sub.isdigit(): return [int(sub)]\n    res = []\n    for i in range(len(sub)):\n      if sub[i] in \"+-*\":\n        L = helper(sub[:i])\n        R = helper(sub[i+1:])\n        res.extend(compute(L, R, sub[i]))\n    return res\n\n  return helper(expr)\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION diffWaysToCompute(expression)  \n        FUNCTION compute(left, right, operator)  \n            SET results TO an empty list  \n            FOR each l IN left  \n                FOR each r IN right  \n                    IF operator EQUALS the plus symbol  \n                        APPEND l PLUS r TO results  \n                    ELSE IF operator EQUALS the minus symbol  \n                        APPEND l MINUS r TO results  \n                    ELSE IF operator EQUALS the multiplication symbol  \n                        APPEND l MULTIPLIED BY r TO results  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        FUNCTION helper(sub_expr)  \n            IF the entirety of sub_expr CONSISTS OF DIGITS  \n                RETURN a list containing the integer value of sub_expr  \n            END IF  \n          \n            SET results TO an empty list  \n            FOR index i FROM zero TO the LENGTH OF sub_expr MINUS one  \n                IF the element at position i of sub_expr EQUALS any of the plus symbol OR the minus symbol OR the multiplication symbol  \n                    SET left_results TO helper(the substring of sub_expr from position zero TO position i MINUS one)  \n                    SET right_results TO helper(the substring of sub_expr from position i PLUS one TO the last position)  \n                    FOR each result IN compute(left_results, right_results, the element at position i of sub_expr)  \n                        APPEND result TO results  \n                    END FOR  \n                END IF  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        RETURN helper(expression)  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6266666666666667",
  "iter": 15
}