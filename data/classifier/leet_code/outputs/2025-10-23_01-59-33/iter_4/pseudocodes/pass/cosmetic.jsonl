{"task_id": "longest-palindromic-substring", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestPalindrome(s)\n        SET length AS THE COUNT OF s\n        SET truth_matrix AS AN ARRAY (length) OF ARRAYS (length) FILLED WITH TRUE\n        SET start_index AS 0\n        SET max_length AS 1\n        \n        SET outer_index AS length MINUS 2\n        WHILE outer_index IS GREATER THAN OR EQUAL TO 0 DO\n            SET inner_index AS outer_index PLUS 1\n            WHILE inner_index IS LESS THAN length DO\n                SET truth_matrix[outer_index][inner_index] AS FALSE\n                \n                IF NOT (s[outer_index] NOT EQUAL TO s[inner_index]) THEN\n                    SET truth_matrix[outer_index][inner_index] AS truth_matrix[outer_index PLUS 1][inner_index MINUS 1]\n                    \n                    IF truth_matrix[outer_index][inner_index] IS TRUE THEN\n                        IF (max_length LESS THAN (inner_index MINUS outer_index PLUS 1)) THEN\n                            SET start_index AS outer_index\n                            SET max_length AS (inner_index MINUS outer_index PLUS 1)\n                        END IF\n                    END IF\n                END IF\n                INCREMENT inner_index BY 1\n            END WHILE\n            DECREMENT outer_index BY 1\n        END WHILE\n        \n        RETURN s SUBSTRING FROM start_index TO (start_index PLUS max_length MINUS 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "multiply-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF NOT (num1 NOT EQUALS string zero AND num2 NOT EQUALS string zero) THEN  \n            RETURN string zero  \n        END IF  \n\n        SET intermediateList TO new list  \n        SET lengthLimit TO (LENGTH OF num1) PLUS (LENGTH OF num2)  \n        FOR counter FROM zero UPTO lengthLimit MINUS one  \n            APPEND zero TO intermediateList  \n        END FOR   \n\n        SET reversedNum1 TO empty string  \n        SET indexA TO LENGTH OF num1 MINUS one  \n        WHILE indexA GREATER OR EQUAL TO zero DO  \n            SET reversedNum1 TO reversedNum1 PLUS CHARACTER AT indexA OF num1  \n            DECREMENT indexA BY one  \n        END WHILE  \n        SET num1 TO reversedNum1  \n\n        SET reversedNum2 TO empty string  \n        SET indexB TO LENGTH OF num2 MINUS one  \n        WHILE indexB GREATER OR EQUAL TO zero DO  \n            SET reversedNum2 TO reversedNum2 PLUS CHARACTER AT indexB OF num2  \n            DECREMENT indexB BY one  \n        END WHILE  \n        SET num2 TO reversedNum2  \n\n        SET posI TO zero  \n        WHILE posI LESS THAN LENGTH OF num1 DO  \n            SET posJ TO zero  \n            WHILE posJ LESS THAN LENGTH OF num2 DO  \n                SET codeA TO (CHARACTER CODE OF CHARACTER AT posI OF num1) MINUS (CHARACTER CODE OF string zero)  \n                SET codeB TO (CHARACTER CODE OF CHARACTER AT posJ OF num2) MINUS (CHARACTER CODE OF string zero)  \n                SET productVal TO codeA TIMES codeB  \n\n                SET positionOne TO posI PLUS posJ  \n                SET positionTwo TO positionOne PLUS one  \n\n                SET combinedSum TO productVal PLUS ELEMENT AT positionOne OF intermediateList  \n\n                SET ELEMENT AT positionOne OF intermediateList TO combinedSum MODULO ten  \n                SET ELEMENT AT positionTwo OF intermediateList TO ELEMENT AT positionTwo OF intermediateList PLUS (combinedSum DIVIDED BY ten)  \n                INCREMENT posJ BY one  \n            END WHILE  \n            INCREMENT posI BY one  \n        END WHILE  \n\n        SET reversedResultStr TO empty string  \n        SET revIndex TO LENGTH OF intermediateList MINUS one  \n        WHILE revIndex GREATER OR EQUAL TO zero DO  \n            SET reversedResultStr TO reversedResultStr PLUS STRING OF ELEMENT AT revIndex OF intermediateList  \n            DECREMENT revIndex BY one  \n        END WHILE  \n\n        SET startIndex TO zero  \n        WHILE startIndex LESS THAN LENGTH OF reversedResultStr AND CHARACTER AT startIndex OF reversedResultStr EQUALS string zero DO  \n            INCREMENT startIndex BY one  \n        END WHILE  \n\n        IF startIndex EQUALS LENGTH OF reversedResultStr THEN  \n            RETURN string zero  \n        END IF  \n\n        RETURN SUBSTRING OF reversedResultStr FROM startIndex TO LENGTH OF reversedResultStr MINUS one  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canJump(nums)\n        ASSIGN 0 TO positionIndex\n        ASSIGN 0 TO maximumReach\n\n        WHILE positionIndex LESS THAN LENGTH(nums)\n            IF NOT(positionIndex LESS THAN OR EQUAL TO maximumReach)\n                OUTPUT false\n                EXIT FUNCTION\n            END IF\n\n            ASSIGN (positionIndex PLUS nums[positionIndex]) TO candidateReach\n            IF candidateReach GREATER THAN maximumReach\n                ASSIGN candidateReach TO maximumReach\n            END IF\n\n            INCREMENT positionIndex BY 1\n        END WHILE\n\n        IF maximumReach GREATER THAN OR EQUAL TO (LENGTH(nums) MINUS 1)\n            OUTPUT true\n            EXIT FUNCTION\n        END IF\n\n        OUTPUT false\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET matrix AS a list containing m elements, each being a list of length n filled with 1  \n        SET rowIndex TO 1  \n        WHILE rowIndex < m DO  \n            SET columnIndex TO 1  \n            WHILE columnIndex < n DO  \n                SET currentRow TO matrix[rowIndex]  \n                SET currentRow[columnIndex] TO matrix[rowIndex - 1][columnIndex] + currentRow[columnIndex - 1]  \n                SET columnIndex TO columnIndex + 1  \n            END WHILE  \n            SET rowIndex TO rowIndex + 1  \n        END WHILE  \n        RETURN matrix[m - 1][n - 1]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combinations", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION combine(n, k)\n        FUNCTION backtrack(begin, sequence)\n            IF NOT (LENGTH(sequence) NOT EQUAL TO k)\n                result COLLECT COPY(sequence)\n                RETURN\n            END IF\n            SET index TO begin\n            WHILE index < n + 1\n                sequence ADD index\n                backtrack(index + 1, sequence)\n                sequence REMOVE LAST\n                index INCREASE BY 1\n            END WHILE\n        END FUNCTION\n        result ASSIGN LIST()\n        backtrack(1, LIST())\n        RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicates-from-sorted-array-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF NOT (LENGTH OF nums > 0) THEN  \n            RETURN 0  \n        END IF  \n        \n        SET ptr AS 0  \n        \n        SET idx AS 0  \n        WHILE idx <= (2 MINUS 1) AND idx <= (LENGTH OF nums MINUS 1)  \n            ASSIGN nums[ptr] AS nums[idx]  \n            SET ptr AS ptr + 1  \n            SET idx AS idx + 1  \n        END WHILE  \n        \n        SET cursor AS 2  \n        WHILE cursor <= (LENGTH OF nums MINUS 1)  \n            IF nums[cursor] = nums[(ptr MINUS 2)] THEN  \n                # do nothing, skip increment  \n            ELSE  \n                ASSIGN nums[ptr] AS nums[cursor]  \n                SET ptr AS ptr PLUS 1  \n            END IF  \n            SET cursor AS cursor + 1  \n        END WHILE  \n        \n        RETURN ptr  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gray-code", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        DECLARE result AS list OF integers  \n        DECLARE temp AS list OF integers  \n        DECLARE bitmask AS integer  \n        DECLARE index AS integer  \n        \n        IF NOT (n NOT EQUALS 0) THEN  \n            RETURN [0]  \n        END IF  \n        \n        SET temp AS grayCode(n - 1)  \n        SET bitmask AS 1 << (n - 1)  \n        \n        SET result AS temp  \n        SET index TO LENGTH(temp) - 1  \n        \n        WHILE index GREATER OR EQUAL TO 0 DO  \n            APPEND (temp[index] BITWISE_OR bitmask) TO result  \n            DECREMENT index BY 1  \n        END WHILE  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET length_s AS the LENGTH OF s  \n        \n        IF NOT (length_s GREATER THAN one)  \n            RETURN zero  \n        END IF  \n        \n        SET palindrome_flag TO a list of length_s elements each containing a list of length_s elements initialized to FALSE  \n        \n        SET idx TO zero  \n        WHILE idx LESS THAN length_s  \n            SET palindrome_flag[idx][idx] AS TRUE  \n            INCREMENT idx BY one  \n        END WHILE  \n        \n        SET substr_len TO two  \n        WHILE substr_len LESS THAN OR EQUAL TO length_s  \n            SET start_pos TO zero  \n            WHILE start_pos LESS THAN OR EQUAL TO length_s MINUS substr_len  \n                SET end_pos TO start_pos PLUS substr_len MINUS one  \n                \n                IF substr_len EQUALS two THEN  \n                    SET palindrome_flag[start_pos][end_pos] AS (s[start_pos] EQUALS s[end_pos])  \n                ELSE  \n                    SET chars_match AS (s[start_pos] EQUALS s[end_pos])  \n                    SET inner_palindrome AS palindrome_flag[start_pos PLUS one][end_pos MINUS one]  \n                    SET palindrome_flag[start_pos][end_pos] AS (chars_match AND inner_palindrome)  \n                END IF  \n                \n                INCREMENT start_pos BY one  \n            END WHILE  \n            INCREMENT substr_len BY one  \n        END WHILE  \n        \n        SET min_cut_counts TO a list of length_s elements initialized as zero  \n        \n        SET i TO zero  \n        WHILE i LESS THAN length_s  \n            IF palindrome_flag[zero][i] THEN  \n                SET min_cut_counts[i] AS zero  \n            ELSE  \n                SET min_cut_counts[i] AS positive infinity  \n                SET j TO one  \n                WHILE j LESS THAN OR EQUAL TO i  \n                    IF palindrome_flag[j][i] AND ((min_cut_counts[j MINUS one] PLUS one) LESS THAN min_cut_counts[i]) THEN  \n                        SET min_cut_counts[i] AS (min_cut_counts[j MINUS one] PLUS one)  \n                    END IF  \n                    INCREMENT j BY one  \n                END WHILE  \n            END IF  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        RETURN min_cut_counts[length_s MINUS one]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-words-in-a-string", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        DECLARE wordCollection AS list ← s split by spaces ignoring repeated spaces  \n        DECLARE reversedList AS list ← empty list  \n        DECLARE indexer AS integer ← LENGTH(wordCollection) - 1  \n        WHILE indexer >= 0  \n            ADD wordCollection[indexer] TO reversedList  \n            DECREMENT indexer BY 1  \n        END WHILE  \n        DECLARE resultString AS string ← reversedList elements concatenated with \" \" as delimiter  \n        RETURN resultString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        SET words TO list of words obtained by splitting s by spaces where multiple spaces are handled automatically  \n        REVERSE the order of elements in words  \n        RETURN single string obtained by joining elements of words with single spaces between them  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "fraction-to-recurring-decimal", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        DECLARE polarity AS string  \n        IF (numerator < 0 AND denominator >= 0) OR (numerator >= 0 AND denominator < 0) THEN  \n            polarity ← \"-\"  \n        ELSE  \n            polarity ← \"\"  \n        ENDIF  \n  \n        numerator ← ABS(numerator)  \n        denominator ← ABS(denominator)  \n  \n        DECLARE integralQuotient AS integer ← numerator DIV denominator  \n        DECLARE modValue AS integer ← numerator MOD denominator  \n        DECLARE integerString AS string ← TO_STRING(integralQuotient)  \n  \n        IF modValue = 0 THEN  \n            RETURN CONCAT(polarity, integerString)  \n        ENDIF  \n  \n        DECLARE remainderPositions AS MAP FROM integer TO integer ← EMPTY MAP  \n        DECLARE digits AS LIST OF string ← EMPTY LIST  \n  \n        DECLARE currentRemainder AS integer ← modValue  \n        WHILE currentRemainder ≠ 0 DO  \n            IF remainderPositions CONTAINS currentRemainder THEN  \n                DECLARE cycleStart AS integer ← remainderPositions[currentRemainder]  \n                DECLARE prefix AS string ← \"\"  \n                DECLARE suffix AS string ← \"\"  \n                FOR idx FROM 0 TO cycleStart - 1 DO  \n                    prefix ← CONCAT(prefix, digits[idx])  \n                ENDFOR  \n                FOR idx FROM cycleStart TO LENGTH(digits) - 1 DO  \n                    suffix ← CONCAT(suffix, digits[idx])  \n                ENDFOR  \n                RETURN CONCAT(polarity, integerString, \".\", prefix, \"(\", suffix, \")\")  \n            ENDIF  \n  \n            remainderPositions[currentRemainder] ← LENGTH(digits)  \n  \n            currentRemainder ← currentRemainder * 10  \n            DECLARE digitValue AS integer ← currentRemainder DIV denominator  \n            currentRemainder ← currentRemainder MOD denominator  \n            APPEND TO digits: TO_STRING(digitValue)  \n        ENDWHILE  \n  \n        RETURN CONCAT(polarity, integerString, \".\", JOIN(digits))  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "majority-element-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        ASSIGN countA AS 0  \n        ASSIGN countB AS 0  \n        ASSIGN candidateA AS 0  \n        ASSIGN candidateB AS 1  \n        SET index AS 0  \n        WHILE index LESS THAN LENGTH OF nums  \n            LET currentItem BE nums AT index  \n            IF currentItem IS candidateA THEN  \n                countA ← countA + 1  \n            ELSE IF currentItem IS candidateB THEN  \n                countB ← countB + 1  \n            ELSE IF countA IS 0 THEN  \n                candidateA ← currentItem  \n                countA ← 1  \n            ELSE IF countB IS 0 THEN  \n                candidateB ← currentItem  \n                countB ← 1  \n            ELSE  \n                countA ← countA - 1  \n                countB ← countB - 1  \n            END IF  \n            index ← index + 1  \n        END WHILE  \n        LET resultElements BE [candidateA, candidateB]  \n        LET threshold BE LENGTH OF nums DIV 3  \n        LET outputList BE EMPTY LIST  \n        FOR EACH element IN resultElements  \n            LET frequency BE 0  \n            FOR EACH val IN nums  \n                IF val EQUALS element THEN  \n                    frequency ← frequency + 1  \n                END IF  \n            END FOR  \n            IF frequency GREATER THAN threshold THEN  \n                APPEND element TO outputList  \n            END IF  \n        END FOR  \n        RETURN outputList  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each element m IN nums  \n            IF element m EQUALS value m1  \n                INCREMENT n1 BY one  \n            ELSE IF element m EQUALS value m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO element m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO element m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE the count of element m IN nums IS GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "different-ways-to-add-parentheses", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION diffWaysToCompute(expression)\n        FUNCTION compute(left, right, operator)\n            ASSIGN [] TO outcomes\n            SET l_index TO 0\n            WHILE l_index < LENGTH of left\n                SET r_pos TO 0\n                WHILE r_pos < LENGTH of right\n                    SET current_left TO left[l_index]\n                    SET current_right TO right[r_pos]\n                    IF NOT (operator != \"+\") THEN\n                        outcomes := outcomes + [current_left + current_right]\n                    ELSE IF NOT (operator != \"-\") THEN\n                        outcomes := outcomes + [current_left - current_right]\n                    ELSE IF NOT (operator != \"*\") THEN\n                        outcomes := outcomes + [current_left * current_right]\n                    END IF\n                    r_pos = r_pos + 1\n                END WHILE\n                l_index = l_index + 1\n            END WHILE\n            RETURN outcomes\n        END FUNCTION\n\n        FUNCTION helper(sub_expr)\n            IF sub_expr CONTAINS ONLY digits THEN\n                RETURN [TO_INTEGER(sub_expr)]\n            END IF\n\n            SET collected TO []\n            SET pointer TO 0\n            WHILE pointer < LENGTH(sub_expr)\n                SET ch TO sub_expr[pointer]\n                IF ch EQUALS \"+\" OR ch EQUALS \"-\" OR ch EQUALS \"*\" THEN\n                    ASSIGN helper(SUBSTRING(sub_expr, 0, pointer)) TO left_group\n                    ASSIGN helper(SUBSTRING(sub_expr, pointer+1, LENGTH(sub_expr)-1)) TO right_group\n                    FOR each val IN compute(left_group, right_group, ch)\n                        collected := collected + [val]\n                    END FOR\n                END IF\n                POINTER_INCREMENT pointer BY 1\n            END WHILE\n            RETURN collected\n        END FUNCTION\n\n        RETURN helper(expression)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION diffWaysToCompute(expression)  \n        FUNCTION compute(left, right, operator)  \n            SET results TO an empty list  \n            FOR each l IN left  \n                FOR each r IN right  \n                    IF operator EQUALS the plus symbol  \n                        APPEND l PLUS r TO results  \n                    ELSE IF operator EQUALS the minus symbol  \n                        APPEND l MINUS r TO results  \n                    ELSE IF operator EQUALS the multiplication symbol  \n                        APPEND l MULTIPLIED BY r TO results  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        FUNCTION helper(sub_expr)  \n            IF the entirety of sub_expr CONSISTS OF DIGITS  \n                RETURN a list containing the integer value of sub_expr  \n            END IF  \n          \n            SET results TO an empty list  \n            FOR index i FROM zero TO the LENGTH OF sub_expr MINUS one  \n                IF the element at position i of sub_expr EQUALS any of the plus symbol OR the minus symbol OR the multiplication symbol  \n                    SET left_results TO helper(the substring of sub_expr from position zero TO position i MINUS one)  \n                    SET right_results TO helper(the substring of sub_expr from position i PLUS one TO the last position)  \n                    FOR each result IN compute(left_results, right_results, the element at position i of sub_expr)  \n                        APPEND result TO results  \n                    END FOR  \n                END IF  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        RETURN helper(expression)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-iii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION strobogrammaticInRange(low  \n                                    high)\n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)\n            SWITCH n\n                CASE 0:\n                    RETURN [\"\"]\n\n                CASE 1:\n                    RETURN [\"0\", \"1\", \"8\"]\n            END SWITCH\n\n            SET innerStrings AS generate_strobogrammatic(final_length - 2, final_length)\n            SET collection AS []\n\n            SET idx TO 0\n            WHILE idx < LENGTH(innerStrings)\n                SET segment TO innerStrings[idx]\n\n                IF n IS DIFFERENT FROM final_length THEN\n                    INSERT \"0\" + segment + \"0\" INTO collection AT END\n                END IF\n\n                INSERT \"1\" + segment + \"1\" INTO collection AT END\n                INSERT \"6\" + segment + \"9\" INTO collection AT END\n                INSERT \"8\" + segment + \"8\" INTO collection AT END\n                INSERT \"9\" + segment + \"6\" INTO collection AT END\n\n                idx ← idx + 1\n            END WHILE\n\n            RETURN collection\n        END FUNCTION\n\n        FUNCTION count_strobogrammatic(low  \n                                       high)\n            SET total AS 0\n            SET lenLow TO LENGTH(low)\n            SET lenHigh TO LENGTH(high)\n\n            SET currentLen TO lenLow\n            WHILE currentLen <= lenHigh\n                SET generatedList AS generate_strobogrammatic(currentLen, currentLen)\n                SET pointer TO 0\n\n                WHILE pointer < LENGTH(generatedList)\n                    SET numberStr TO generatedList[pointer]\n\n                    IF NOT ((currentLen = lenLow AND numberStr < low) OR (currentLen = lenHigh AND numberStr > high)) THEN\n                        total ← total + 1\n                    END IF\n\n                    pointer ← pointer + 1\n                END WHILE\n\n                currentLen ← currentLen + 1\n            END WHILE\n\n            RETURN total\n        END FUNCTION\n\n        RETURN count_strobogrammatic(low, high)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            \n            IF n EQUALS one  \n                RETURN a list containing the string zero once the string one once the string eight  \n            END IF  \n            \n            SET middles TO the result of calling generate_strobogrammatic with arguments n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero PLUS middle PLUS zero TO result  \n                END IF  \n                APPEND the string one PLUS middle PLUS one TO result  \n                APPEND the string six PLUS middle PLUS nine TO result  \n                APPEND the string eight PLUS middle PLUS eight TO result  \n                APPEND the string nine PLUS middle PLUS six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN the result of calling generate_strobogrammatic with arguments length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of calling count_strobogrammatic with arguments low and high  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "h-index", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        DECLARE sortedList ← SORT citations IN DESCENDING ORDER  \n        DECLARE pointer ← 0  \n        WHILE pointer < LENGTH OF sortedList DO  \n            DECLARE currentCitation ← sortedList[pointer]  \n            IF NOT (currentCitation ≥ pointer + 1) THEN  \n                RETURN pointer  \n            END IF  \n            SET pointer ← pointer + 1  \n        END WHILE  \n        RETURN LENGTH OF sortedList  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-squares", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        INITIALIZE dp AS a list WITH (n + 1) elements EACH SET TO infinity_value  \n        ASSIGN dp[0] ← 0  \n        INITIALIZE squares AS an empty list  \n        ASSIGN counter ← 1  \n        LOOP  \n            IF (counter * counter) > n THEN EXIT LOOP  \n            ADD (counter * counter) TO squares  \n            SET counter ← counter + 1  \n        END LOOP  \n        ASSIGN index ← 1  \n        WHILE index ≤ n DO  \n            FOR EACH current_square IN squares DO  \n                IF current_square > index THEN  \n                    EXIT FOR  \n                ELSE  \n                    TEMP ← dp[index - current_square] + 1  \n                    IF TEMP < dp[index] THEN  \n                        SET dp[index] ← TEMP  \n                    END IF  \n                END IF  \n            END FOR  \n            SET index ← index + 1  \n        END WHILE  \n        RETURN dp[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flip-game-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canWin(currentState)\n        DECLARE cache AS an empty map\n\n        FUNCTION can_win_helper(state)\n            IF NOT (state NOT IN cache) THEN\n                RETURN cache[state]\n            END IF\n\n            DECLARE iterator AS 0\n            WHILE iterator <= LENGTH(state) - 2 DO\n                IF (state[iterator] = '+') AND (state[iterator + 1] = '+') THEN\n                    DECLARE before_segment AS SUBSTRING(state, 0, iterator)\n                    DECLARE after_segment AS SUBSTRING(state, iterator + 2, LENGTH(state))\n                    DECLARE candidate_state AS CONCATENATE(before_segment, '--', after_segment)\n\n                    IF FALSE = can_win_helper(candidate_state) THEN\n                        ASSIGN TRUE TO cache[state]\n                        RETURN TRUE\n                    END IF\n                END IF\n                ASSIGN iterator + 1 TO iterator\n            END WHILE\n\n            ASSIGN FALSE TO cache[state]\n            RETURN FALSE\n        END FUNCTION\n\n        RETURN can_win_helper(currentState)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-word-lengths", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maxProduct(words)\n        DECLARE char_sets AS empty list\n        DECLARE idx1 AS 0\n        WHILE idx1 < LENGTH(words)\n            DECLARE temp_set AS empty set\n            DECLARE pos AS 0\n            WHILE pos < LENGTH(words[idx1])\n                SET temp_set TO temp_set UNION { words[idx1][pos] }\n                SET pos TO pos + 1\n            END WHILE\n            APPEND temp_set TO char_sets\n            SET idx1 TO idx1 + 1\n        END WHILE\n\n        SET highest_product TO 0\n\n        DECLARE first_pointer AS 0\n        WHILE first_pointer < LENGTH(words) - 1\n            DECLARE second_pointer AS first_pointer + 1\n            WHILE second_pointer < LENGTH(words)\n                DECLARE intersection_check AS char_sets[first_pointer] INTERSECT char_sets[second_pointer]\n                IF LENGTH(intersection_check) = 0 THEN\n                    DECLARE candidate_product AS (LENGTH(words[first_pointer]) * LENGTH(words[second_pointer]))\n                    IF candidate_product > highest_product THEN\n                        SET highest_product TO candidate_product\n                    END IF\n                END IF\n                SET second_pointer TO second_pointer + 1\n            END WHILE\n            SET first_pointer TO first_pointer + 1\n        END WHILE\n\n        RETURN highest_product\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters of word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the intersection of element at position i of word_sets AND element at position j of word_sets EQUALS empty set  \n                    SET product TO the LENGTH OF element at position i of words MULTIPLIED BY the LENGTH OF element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulb-switcher", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        DECLARE result AS INTEGER  \n        SET result TO 0  \n        WHILE (result + 1) * (result + 1) <= n DO  \n            INCREMENT result BY 1  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        RETURN the integer part of the square root of n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET cache AS a list containing (amount + 1) copies of (amount + 1)  \n        ASSIGN 0 TO cache[0]  \n\n        SET counter TO 1  \n        WHILE counter ≤ amount  \n            SET currentMin TO cache[counter]  \n            FOR each denomination IN coins  \n                SET remainder TO counter - denomination  \n                IF remainder ≥ 0 THEN  \n                    SET candidate TO cache[remainder] + 1  \n                    IF candidate < currentMin THEN  \n                        ASSIGN candidate TO currentMin  \n                    END IF  \n                END IF  \n            END FOR  \n            ASSIGN currentMin TO cache[counter]  \n            INCREMENT counter BY 1  \n        END WHILE  \n\n        IF cache[amount] ≠ (amount + 1) THEN  \n            RETURN cache[amount]  \n        ELSE  \n            RETURN -1  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "self-crossing", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION isSelfCrossing(distance)\n        ASSIGN lengthValue ← SIZE(distance)\n        IF NOT (lengthValue ≥ 4) THEN\n            RETURN False\n        END IF\n\n        SET index ← 3\n        WHILE index ≤ lengthValue - 1 DO\n            ASSIGN current ← distance[index]\n            ASSIGN prev2 ← distance[index - 2]\n            ASSIGN prev1 ← distance[index - 1]\n            ASSIGN prev3 ← distance[index - 3]\n\n            IF (current ≥ prev2) AND (prev1 ≤ prev3) THEN\n                RETURN True\n            END IF\n\n            IF (index ≥ 4) THEN\n                ASSIGN prev3Check ← distance[index - 3]\n                ASSIGN prev4Check ← distance[index - 4]\n                IF (prev1 = prev3Check) AND ((current + prev4Check) ≥ prev2) THEN\n                    RETURN True\n                END IF\n            END IF\n\n            IF (index ≥ 5) THEN\n                ASSIGN prev2Check ← distance[index - 2]\n                ASSIGN prev4Check ← distance[index - 4]\n                ASSIGN prev3Check ← distance[index - 3]\n                ASSIGN prev1Check ← distance[index - 1]\n                ASSIGN prev5Check ← distance[index - 5]\n\n                IF (prev2Check ≥ prev4Check) AND (prev3Check ≥ prev1Check) AND ((prev1Check + prev5Check) ≥ prev3Check) AND ((current + prev4Check) ≥ prev2Check) THEN\n                    RETURN True\n                END IF\n            END IF\n\n            INCREMENT index BY 1\n        END WHILE\n\n        RETURN False\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isSelfCrossing(distance)  \n        SET n TO the LENGTH OF distance  \n        IF n LESS THAN four  \n            RETURN False  \n        END IF  \n        FOR i FROM three TO n MINUS one  \n            IF element at position i of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance AND element at position i MINUS one of distance LESS THAN OR EQUAL TO element at position i MINUS three of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO four AND element at position i MINUS one of distance EQUALS element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO five AND element at position i MINUS two of distance GREATER THAN OR EQUAL TO element at position i MINUS four of distance AND element at position i MINUS three of distance GREATER THAN OR EQUAL TO element at position i MINUS one of distance AND element at position i MINUS one of distance PLUS element at position i MINUS five of distance GREATER THAN OR EQUAL TO element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-break", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dpList AS an array of zeros sized n PLUS 1  \n        SET dpList[1] AS 1  \n        SET outerCounter TO 2  \n        WHILE outerCounter IS LESS THAN OR EQUAL TO n DO  \n            SET currentMax TO 0  \n            SET innerCounter TO 1  \n            WHILE innerCounter IS LESS THAN outerCounter DO  \n                SET firstProduct TO innerCounter TIMES dpList[outerCounter MINUS innerCounter]  \n                SET secondProduct TO innerCounter TIMES (outerCounter MINUS innerCounter)  \n                SWITCH TRUE  \n                    CASE currentMax < firstProduct AND currentMax < secondProduct:  \n                        IF firstProduct > secondProduct THEN  \n                            SET currentMax TO firstProduct  \n                        ELSE  \n                            SET currentMax TO secondProduct  \n                        END IF  \n                    CASE currentMax < firstProduct:  \n                        SET currentMax TO firstProduct  \n                    CASE currentMax < secondProduct:  \n                        SET currentMax TO secondProduct  \n                END SWITCH  \n                INCREMENT innerCounter BY 1  \n            END WHILE  \n            SET dpList[outerCounter] TO currentMax  \n            INCREMENT outerCounter BY 1  \n        END WHILE  \n        RETURN dpList[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dp TO a list of zeros with the length of n PLUS one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            SET max_product TO zero  \n            FOR j FROM one TO i MINUS one  \n                SET product_one TO j MULTIPLIED BY element at position i MINUS j of dp  \n                SET product_two TO j MULTIPLIED BY i MINUS j  \n                IF max_product LESS THAN product_one AND max_product LESS THAN product_two  \n                    SET max_product TO the larger value BETWEEN product_one AND product_two  \n                ELSE IF max_product LESS THAN product_one  \n                    SET max_product TO product_one  \n                ELSE IF max_product LESS THAN product_two  \n                    SET max_product TO product_two  \n                END IF  \n            END FOR  \n            SET element at position i of dp TO max_product  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-numbers-with-unique-digits", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        SWITCH n  \n            CASE 0:  \n                RETURN 1  \n            CASE 1:  \n                RETURN 10  \n        END SWITCH  \n  \n        SET total_sum AS 10  \n        SET digits_left AS 9  \n        SET product AS 9  \n        SET index AS 2  \n        WHILE index <= n DO  \n            SET product AS product * digits_left  \n            SET total_sum AS total_sum + product  \n            SET digits_left AS digits_left - 1  \n            SET index AS index + 1  \n        END WHILE  \n  \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n INCLUSIVE  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            SET available_digits TO available_digits MINUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-jump", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canCross(stones)\n        IF stones IS EMPTY OR NOT (LENGTH stones >= 2)\n            OUTPUT False\n        END IF\n        LET pebbleBank BE A HASH MAP(initialized empty)\n        LET cache BE A HASH MAP(empty)\n\n        FUNCTION can_jump_to(loc, step)\n            IF loc = stones[LENGTH stones - 1]\n                OUTPUT True\n            END IF\n            IF (loc, step) EXISTS IN cache\n                OUTPUT cache[(loc, step)]\n            END IF\n            LET delta BE -1\n            WHILE delta <= 1\n                LET candidateStep BE step + delta\n                IF candidateStep > 0 AND (loc + candidateStep) IN pebbleBank\n                    IF can_jump_to(loc + candidateStep, candidateStep)\n                        SET cache[(loc, step)] AS True\n                        OUTPUT True\n                    END IF\n                END IF\n                INCREMENT delta BY 1\n            END WHILE\n            SET cache[(loc, step)] AS False\n            OUTPUT False\n        END FUNCTION\n\n        FOR peb IN stones\n            SET pebbleBank[peb] AS True\n        END FOR\n\n        OUTPUT can_jump_to(stones[0], 0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS empty OR the LENGTH OF stones LESS THAN two  \n            RETURN False  \n        END IF  \n        SET stone_set TO the SET of all elements in stones  \n        SET memo TO an EMPTY DICTIONARY  \n\n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the element at the last position of stones  \n                RETURN True  \n            END IF  \n            IF the TUPLE of position AND jump IS IN memo  \n                RETURN the VALUE associated with the TUPLE of position AND jump in memo  \n            END IF  \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the SUM of position AND next_jump IS IN stone_set  \n                    IF can_jump_to(the SUM of position AND next_jump, next_jump)  \n                        SET memo at key TUPLE of position AND jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            SET memo at key TUPLE of position AND jump TO False  \n            RETURN False  \n        END FUNCTION  \n\n        RETURN can_jump_to(the element at the first position of stones, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sentence-screen-fitting", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        ASSIGN concatenated_string TO EMPTY STRING  \n        INITIALIZE index_counter TO 0  \n        \n        WHILE index_counter LESS THAN LENGTH OF sentence  \n            CONCATENATE concatenated_string WITH sentence[index_counter]  \n            CONCATENATE concatenated_string WITH \" \"  \n            INCREMENT index_counter BY 1  \n        END WHILE  \n        \n        ASSIGN length_total TO LENGTH OF concatenated_string  \n        SET pointer TO 0  \n        ASSIGN row_iter TO 1  \n        \n        WHILE row_iter LESS THAN OR EQUAL TO rows  \n            ADD cols TO pointer  \n            IF concatenated_string[pointer MOD length_total] IS \" \" THEN  \n                INCREMENT pointer BY 1  \n            ELSE  \n                WHILE (pointer GREATER THAN 0) AND (concatenated_string[(pointer - 1) MOD length_total] IS NOT \" \")  \n                    DECREASE pointer BY 1  \n                END WHILE  \n            END IF  \n            INCREMENT row_iter BY 1  \n        END WHILE  \n        \n        RETURN INTEGER_DIVISION OF pointer BY length_total  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        SET s TO the concatenation of all elements of sentence with a single space between each followed by a single space character  \n        SET total_length TO the LENGTH OF s  \n        SET position TO zero  \n        \n        FOR each iteration IN the range from one TO rows  \n            INCREMENT position BY cols  \n            \n            IF the element at position MODULO total_length of s EQUALS a space character  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position GREATER THAN zero AND the element at position MINUS one MODULO total_length of s NOT EQUALS a space character  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN position DIVIDED BY total_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strong-password-checker", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION strongPasswordChecker(password)\n        SET length_password AS LENGTH OF password\n        SET lower_found AS EXISTS character IN password WHERE character IS lowercase letter\n        SET upper_found AS EXISTS character IN password WHERE character IS uppercase letter\n        SET digit_found AS EXISTS character IN password WHERE character IS digit\n\n        SET missing_char_types AS 3 MINUS (lower_found PLUS upper_found PLUS digit_found)\n\n        SET replacements_needed TO 0\n        SET count_mod0 TO 0\n        SET count_mod1 TO 0\n        SET index_counter TO 2\n\n        WHILE index_counter < length_password\n            IF (password[index_counter] EQUALS password[index_counter - 1]) AND (password[index_counter] EQUALS password[index_counter - 2])\n                SET streak_length TO 2\n                WHILE (index_counter < length_password) AND (password[index_counter] EQUALS password[index_counter - 1])\n                    SET streak_length TO (streak_length PLUS 1)\n                    SET index_counter TO (index_counter PLUS 1)\n                END WHILE\n\n                SET replacements_needed TO replacements_needed PLUS (streak_length DIV 3)\n\n                IF (streak_length MOD 3) EQUALS 0\n                    SET count_mod0 TO count_mod0 PLUS 1\n                ELSE IF (streak_length MOD 3) EQUALS 1\n                    SET count_mod1 TO count_mod1 PLUS 1\n                END IF\n            ELSE\n                SET index_counter TO (index_counter PLUS 1)\n            END IF\n        END WHILE\n\n        IF length_password < 6\n            RETURN MAXIMUM OF missing_char_types AND (6 MINUS length_password)\n        ELSE IF length_password <= 20\n            RETURN MAXIMUM OF missing_char_types AND replacements_needed\n        ELSE\n            SET excess_length TO length_password MINUS 20\n\n            SET min_del0 AS MINIMUM OF excess_length AND count_mod0\n            SET replacements_needed TO replacements_needed MINUS min_del0\n\n            SET remaining_after_del0 TO MAXIMUM OF (excess_length MINUS min_del0) AND 0\n            SET min_del1 AS MINIMUM OF remaining_after_del0 AND (count_mod1 TIMES 2)\n            SET replacements_needed TO replacements_needed MINUS (min_del1 DIV 2)\n\n            SET remaining_after_del1 TO MAXIMUM OF (remaining_after_del0 MINUS min_del1) AND 0\n            SET replacements_needed TO replacements_needed MINUS (remaining_after_del1 DIV 3)\n\n            RETURN excess_length PLUS MAXIMUM OF missing_char_types AND replacements_needed\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION strongPasswordChecker(password)  \n        SET n TO the LENGTH OF password  \n        \n        SET has_lower TO BOOLEAN VALUE OF WHETHER any character IN password is a lowercase letter  \n        SET has_upper TO BOOLEAN VALUE OF WHETHER any character IN password is an uppercase letter  \n        SET has_digit TO BOOLEAN VALUE OF WHETHER any character IN password is a digit  \n        \n        SET missing_types TO three MINUS the SUM OF has_lower PLUS has_upper PLUS has_digit  \n        \n        SET replace TO zero  \n        SET one TO zero  \n        SET two TO zero  \n        SET i TO two  \n        WHILE i LESS THAN n  \n            IF the character at position i of password EQUALS the character at position i MINUS one of password AND the character at position i of password EQUALS the character at position i MINUS two of password  \n                SET length TO two  \n                WHILE i LESS THAN n AND the character at position i of password EQUALS the character at position i MINUS one of password  \n                    INCREMENT length BY one  \n                    INCREMENT i BY one  \n                END WHILE  \n                INCREMENT replace BY the INTEGER DIVISION of length BY three  \n                IF the MODULO of length BY three EQUALS zero  \n                    INCREMENT one BY one  \n                ELSE IF the MODULO of length BY three EQUALS one  \n                    INCREMENT two BY one  \n                END IF  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        \n        IF n LESS THAN six  \n            RETURN the GREATER VALUE BETWEEN missing_types AND six MINUS n  \n        ELSE IF n LESS THAN OR EQUAL TO twenty  \n            RETURN the GREATER VALUE BETWEEN missing_types AND replace  \n        ELSE  \n            SET delete TO n MINUS twenty  \n            \n            SET replace TO replace MINUS the SMALLER VALUE BETWEEN delete AND one  \n            SET replace TO replace MINUS the INTEGER DIVISION BY two OF the SMALLER VALUE BETWEEN the GREATER VALUE BETWEEN delete MINUS one AND zero AND two MULTIPLIED BY two  \n            SET replace TO replace MINUS the INTEGER DIVISION BY three OF the GREATER VALUE BETWEEN delete MINUS one MINUS two MULTIPLIED BY two AND zero  \n            \n            RETURN delete PLUS the GREATER VALUE BETWEEN missing_types AND replace  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET freqMap AS map of character counts in s  \n        SET digitCounts AS list WITH TEN elements INITIATED TO 0  \n        \n        SET digitCounts[0] AS freqMap['z']  \n        SET digitCounts[2] AS freqMap['w']  \n        SET digitCounts[4] AS freqMap['u']  \n        SET digitCounts[6] AS freqMap['x']  \n        SET digitCounts[8] AS freqMap['g']  \n        \n        SET digitCounts[3] AS freqMap['h'] - digitCounts[8]  \n        SET digitCounts[5] AS freqMap['f'] - digitCounts[4]  \n        SET digitCounts[7] AS freqMap['s'] - digitCounts[6]  \n        \n        SET tempI AS freqMap['i']  \n        SET digitCounts[9] AS tempI - digitCounts[5] - digitCounts[6] - digitCounts[8]  \n        \n        SET tempO AS freqMap['o']  \n        SET digitCounts[1] AS tempO - digitCounts[0] - digitCounts[2] - digitCounts[4]  \n        \n        SET collectionOfChars AS empty list  \n        \n        SET numberIdx AS 0  \n        WHILE numberIdx LESS THAN 10  \n            SET countRepeat AS digitCounts[numberIdx]  \n            WHILE countRepeat GREATER THAN 0  \n                APPEND STRING(numberIdx) TO collectionOfChars  \n                ASSIGN countRepeat ← countRepeat - 1  \n            END WHILE  \n            ASSIGN numberIdx ← numberIdx + 1  \n        END WHILE  \n        \n        SET outputString AS CONCATENATE elements of collectionOfChars SEQUENTIALLY  \n        RETURN outputString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-characters-by-frequency", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION frequencySort WITH PARAMETER s  \n        DECLARE freqMap AS mapping from character to integer  \n        FOR index FROM 0 TO LENGTH(s) - 1 DO  \n            SET currentChar TO s[index]  \n            IF freqMap DOES NOT CONTAIN currentChar THEN  \n                SET freqMap[currentChar] AS 1  \n            ELSE  \n                SET freqMap[currentChar] TO freqMap[currentChar] + 1  \n            END IF  \n        END FOR  \n\n        DECLARE charList AS list of characters  \n        SET charList TO KEYS OF freqMap  \n\n        DECLARE descSortedChars AS list of characters  \n        SET descSortedChars TO SORT charList BY (a, b) → (freqMap[b] - freqMap[a])  \n\n        SET outputString TO EMPTY STRING  \n        DECLARE iterator AS integer ← 0  \n        WHILE iterator < LENGTH(descSortedChars) DO  \n            DECLARE ch AS character ← descSortedChars[iterator]  \n            DECLARE count AS integer ← freqMap[ch]  \n            DECLARE tempString AS string ← EMPTY STRING  \n            FOR repeatIndex FROM 1 TO count DO  \n                SET tempString ← tempString + ch  \n            END FOR  \n            SET outputString ← outputString + tempString  \n            SET iterator ← iterator + 1  \n        END WHILE  \n\n        RETURN outputString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION frequencySort WITH PARAMETER s  \n        SET frequency TO the character frequency mapping of s  \n        SET sorted_characters TO the list of characters in frequency arranged in descending order according to their frequency values  \n        SET result TO an empty string  \n        FOR each character IN sorted_characters  \n            APPEND the character repeated the number of times equal to the frequency of the character TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-difference", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET components TO EMPTY LIST  \n            SET pos TO 0  \n            WHILE pos LESS THAN length of time  \n                IF time[pos] EQUALS \":\"  \n                    EXIT WHILE  \n                ELSE  \n                    ADD time[pos] TO components  \n                    SET pos TO pos + 1  \n                END IF  \n            END WHILE  \n            SET colon_index TO pos  \n            \n            SET hrs_str TO SUBSTRING of time FROM 0 TO colon_index  \n            SET mins_str TO SUBSTRING of time FROM colon_index + 1 TO length of time  \n            \n            SET hrs_num TO INTEGER parsed from hrs_str  \n            SET mins_num TO INTEGER parsed from mins_str  \n            RETURN hrs_num * 60 + mins_num  \n        END FUNCTION  \n        \n        SET minute_values TO EMPTY LIST  \n        SET idx TO 0  \n        WHILE idx LESS THAN length of timePoints  \n            ADD to_minutes(timePoints[idx]) TO minute_values  \n            SET idx TO idx + 1  \n        END WHILE\n        \n        CALL sort ON minute_values IN ASCENDING ORDER  \n        \n        SET shortest_gap TO INFINITY  \n        SET pointer TO 1  \n        WHILE pointer LESS THAN length of minute_values  \n            SET gap TO minute_values[pointer] - minute_values[pointer - 1]  \n            IF gap < shortest_gap THEN  \n                SET shortest_gap TO gap  \n            END IF  \n            SET pointer TO pointer + 1  \n        END WHILE  \n        \n        SET wrap_gap TO 1440 - minute_values[length of minute_values - 1] + minute_values[0]  \n        IF wrap_gap < shortest_gap THEN  \n            SET shortest_gap TO wrap_gap  \n        END IF  \n        \n        RETURN shortest_gap  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET split_result TO the list of elements obtained by splitting time at the position of the colon character  \n            SET hours TO the integer conversion of the element at position zero of split_result  \n            SET minutes TO the integer conversion of the element at position one of split_result  \n            RETURN the result of multiplication of hours by the number of minutes in one hour PLUS minutes  \n        END FUNCTION  \n        \n        SET minutes_list TO the list obtained by applying the function to_minutes to each element in timePoints  \n        SORT minutes_list in ascending order  \n        SET min_diff TO positive infinity  \n        FOR index FROM one TO the length of minutes_list MINUS one  \n            SET current_difference TO the element at position index of minutes_list MINUS the element at position index MINUS one of minutes_list  \n            IF current_difference LESS THAN min_diff  \n                SET min_diff TO current_difference  \n            END IF  \n        END FOR  \n        SET circular_difference TO the result of subtracting the element at the last position of minutes_list FROM the number of minutes in a full day PLUS the element at the first position of minutes_list  \n        IF circular_difference LESS THAN min_diff  \n            SET min_diff TO circular_difference  \n        END IF  \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "output-contest-matches", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        DECLARE bracketStrings AS empty list  \n        DECLARE count AS 1  \n        WHILE count LESS THAN OR EQUAL TO n  \n            INSERT TO bracketStrings THE STRING OF count  \n            INCREMENT count BY 1  \n        END WHILE  \n        WHILE n NOT EQUAL TO 1  \n            DECLARE index AS 0  \n            DECLARE limit AS n DIV 2  \n            WHILE index LESS THAN limit  \n                DECLARE leftSide AS bracketStrings AT index  \n                DECLARE rightSide AS bracketStrings AT (n - 1 - index)  \n                ASSIGN bracketStrings AT index TO \"(\" + leftSide + \",\" + rightSide + \")\"  \n                INCREMENT index BY 1  \n            END WHILE  \n            SET n AS n DIV 2  \n        END WHILE  \n        RETURN bracketStrings AT 0  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        SET teams TO an empty list  \n        FOR number FROM one TO n  \n            APPEND the string representation of number TO teams  \n        END FOR  \n        WHILE n GREATER THAN one  \n            FOR i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO the concatenation of an open parenthesis concatenated with the element at position i of teams concatenated with a comma concatenated with the element at position n MINUS one MINUS i of teams concatenated with a close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN the element at position zero of teams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-closest-palindrome", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET lenCount AS LENGTH OF n  \n        IF lenCount EQUALS 1  \n            SET valNum AS integer VALUE OF n  \n            RETURN string FORM valNum MINUS 1  \n        END IF  \n        \n        SET candSet AS AN EMPTY SET  \n        \n        SET powLen AS 10 TO THE POWER OF lenCount  \n        SET powLenMinusOne AS 10 TO THE POWER OF (lenCount MINUS 1)  \n        \n        ADD (powLen PLUS 1) TO candSet  \n        ADD (powLenMinusOne MINUS 1) TO candSet  \n        \n        SET prefVal AS integer VALUE OF SUBSTRING OF n FROM 1 TO ((lenCount PLUS 1) DIVIDED BY 2)  \n        \n        SET idx AS -1  \n        WHILE idx LESS THAN OR EQUAL TO 1  \n            SET newPrefNum AS prefVal PLUS idx  \n            SET newPrefStr AS string FORM newPrefNum  \n            \n            IF (lenCount MOD 2) EQUALS 0 THEN\n                SET revPart AS REVERSE OF newPrefStr  \n                SET candStr AS newPrefStr CONCATENATED WITH revPart  \n            ELSE  \n                SET subRev AS REVERSE OF SUBSTRING OF newPrefStr FROM 1 TO (LENGTH OF newPrefStr MINUS 1)  \n                SET candStr AS newPrefStr CONCATENATED WITH subRev  \n            END IF  \n            \n            SET candNum AS integer VALUE OF candStr  \n            ADD candNum TO candSet  \n            \n            SET idx AS idx PLUS 1  \n        END WHILE  \n        \n        SET origNum AS integer VALUE OF n  \n        IF candSet CONTAINS origNum THEN\n            REMOVE origNum FROM candSet  \n        END IF  \n        \n        SET bestCandidate AS NULL  \n        SET minDist AS POSITIVE_INFINITY  \n        \n        FOR EACH num IN candSet  \n            SET dist AS ABSOLUTE VALUE OF (num MINUS origNum)  \n            IF (dist LESS THAN minDist) OR (dist EQUALS minDist AND num LESS THAN bestCandidate) THEN\n                SET bestCandidate AS num  \n                SET minDist AS dist  \n            END IF  \n        END FOR  \n        \n        RETURN string FORM bestCandidate  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO integer VALUE OF n  \n            RETURN string REPRESENTATION OF numeric_value MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        SET power_length TO TEN RAISED TO THE power OF length  \n        SET power_length_minus_one TO TEN RAISED TO THE power OF length MINUS one  \n        \n        ADD the VALUE OF power_length PLUS one TO candidates  \n        ADD the VALUE OF power_length_minus_one MINUS one TO candidates  \n        \n        SET prefix TO integer VALUE OF substring FROM position one TO position (length PLUS one) DIVIDED BY two of n  \n        \n        FOR i FROM negative one TO positive one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO string REPRESENTATION OF new_prefix_numeric  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSED STRING OF new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH reversed_part  \n            ELSE  \n                SET substring_reversed TO the REVERSED STRING OF substring FROM position one TO LENGTH OF new_prefix MINUS one of new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH substring_reversed  \n            END IF  \n            \n            SET candidate_numeric TO integer VALUE OF candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO integer VALUE OF n  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO NULL  \n        SET smallest_distance TO INFINITY  \n        FOR each number IN candidates  \n            SET current_distance TO the ABSOLUTE VALUE OF number MINUS original_number  \n            IF current_distance LESS THAN smallest_distance OR (current_distance EQUALS smallest_distance AND number LESS THAN closest)  \n                SET closest TO number  \n                SET smallest_distance TO current_distance  \n            END IF  \n        END FOR  \n        \n        RETURN string REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-negative-integers-without-consecutive-ones", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findIntegers(n)  \n        ASSIGN binaryString ← \"\"  \n        ASSIGN tempNumber ← n  \n        WHILE tempNumber > 0  \n            SET binaryString ← ( (tempNumber MOD 2) AS STRING ) + binaryString  \n            SET tempNumber ← tempNumber DIV 2  \n        END WHILE\n\n        SET totalLength ← LENGTH OF binaryString  \n        CREATE dp ARRAY WITH SIZE totalLength + 1 FILLED WITH 0  \n        SET dp[0] ← 1  \n        SET dp[1] ← 2  \n\n        SET counter ← 2  \n        WHILE counter ≤ totalLength  \n            SET dp[counter] ← dp[counter - 1] + dp[counter - 2]  \n            INCREMENT counter BY 1  \n        END WHILE\n\n        SET accumulatedResult ← 0  \n        SET lastBit ← 0  \n        SET position ← 0  \n\n        WHILE position < totalLength  \n            SWITCH binaryString[position]  \n                CASE '1':  \n                    SET accumulatedResult ← accumulatedResult + dp[totalLength - position - 1]  \n                    IF lastBit = 1 THEN  \n                        SET accumulatedResult ← accumulatedResult - 1  \n                        BREAK OUT OF LOOP  \n                    END IF  \n                    SET lastBit ← 1  \n                DEFAULT:  \n                    SET lastBit ← 0  \n            END SWITCH  \n            SET position ← position + 1  \n        END WHILE\n\n        RETURN accumulatedResult + 1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findIntegers(n)  \n        SET binary_representation TO convert the number n to its binary representation as a string of characters representing digits in base two from left to right  \n        SET length TO the number of characters in binary_representation  \n        CREATE a list dp of length plus one initialized with zeroes  \n        SET the element at position zero in dp TO one  \n        SET the element at position one in dp TO two  \n        FOR index i FROM two TO length  \n            SET the element at position i in dp TO the element at position i minus one in dp PLUS the element at position i minus two in dp  \n        END FOR  \n        SET result TO zero  \n        SET previous_bit TO zero  \n        FOR index i FROM zero TO length minus one  \n            IF element at position i in binary_representation EQUALS character representing one  \n                INCREMENT result BY the element at position length minus i minus one in dp  \n                IF previous_bit EQUALS one  \n                    DECREMENT result BY one  \n                    BREAK the loop  \n                END IF  \n            END IF  \n            SET previous_bit TO one IF element at position i in binary_representation EQUALS character representing one ELSE zero  \n        END FOR  \n        RETURN result PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-distance-in-arrays", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maxDistance(arrays)  \n        SET baseline_min TO arrays[0][0]  \n        SET baseline_max TO arrays[0][ LENGTH(arrays[0]) - 1 ]  \n        SET greatest_gap TO 0  \n\n        SET cursor TO 1  \n        WHILE cursor < LENGTH(arrays)  \n            SET segment TO arrays[cursor]  \n            SET segment_minimum TO segment[0]  \n            SET segment_maximum TO segment[ LENGTH(segment) - 1 ]  \n\n            SET candidate_one TO ABSOLUTE_VALUE(segment_maximum - baseline_min)  \n            SET candidate_two TO ABSOLUTE_VALUE(baseline_max - segment_minimum)  \n            IF candidate_one > candidate_two THEN  \n                SET better_candidate TO candidate_one  \n            ELSE  \n                SET better_candidate TO candidate_two  \n            END IF  \n\n            IF greatest_gap < better_candidate THEN  \n                SET greatest_gap TO better_candidate  \n            END IF  \n\n            IF baseline_min > segment_minimum THEN  \n                SET baseline_min TO segment_minimum  \n            END IF  \n\n            IF baseline_max < segment_maximum THEN  \n                SET baseline_max TO segment_maximum  \n            END IF  \n\n            SET cursor TO cursor + 1  \n        END WHILE  \n        RETURN greatest_gap  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxDistance(arrays)  \n        SET min_val TO element at position zero of element at position zero of arrays  \n        SET max_val TO element at position negative one of element at position zero of arrays  \n        SET max_distance TO zero  \n        FOR i FROM one TO the LENGTH OF arrays MINUS one  \n            SET current_array TO element at position i of arrays  \n            SET current_min TO element at position zero of current_array  \n            SET current_max TO element at position negative one of current_array  \n            SET max_distance TO the maximum of max_distance AND the absolute value of current_max MINUS min_val AND the absolute value of max_val MINUS current_min  \n            SET min_val TO the minimum of min_val AND current_min  \n            SET max_val TO the maximum of max_val AND current_max  \n        END FOR  \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule-iii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION scheduleCourse(courses)\n        SORT courses BY course[1] IN ascending order\n        INITIALIZE priority_queue AS an empty list\n        SET accumulated_days TO 0\n        \n        INDEX idx = 0\n        WHILE idx < LENGTH(courses) DO\n            SET curr_course TO courses[idx]\n            SET curr_duration TO curr_course[0]\n            SET deadline TO curr_course[1]\n\n            IF accumulated_days + curr_duration <= deadline THEN\n                ADD -curr_duration INTO priority_queue USING heap push\n                accumulated_days ← accumulated_days + curr_duration\n            ELSE\n                IF NOT (LENGTH(priority_queue) = 0) AND (-priority_queue[0]) > curr_duration THEN\n                    accumulated_days ← accumulated_days + curr_duration + heap pop FROM priority_queue\n                    ADD -curr_duration INTO priority_queue USING heap push\n                END IF\n            END IF\n\n            idx ← idx + 1\n        END WHILE\n\n        RETURN LENGTH(priority_queue)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION scheduleCourse(courses)  \n        SORT courses BY the second element of each course representing the last day of the course  \n        SET max_heap TO an empty list  \n        SET current_end_day TO zero  \n        FOR each course IN courses  \n            SET duration TO the first element of course representing the duration of the course  \n            SET last_day TO the second element of course representing the last day of the course  \n            IF current_end_day PLUS duration LESS THAN OR EQUAL TO last_day THEN  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n                INCREMENT current_end_day BY duration  \n            ELSE IF max_heap IS NOT empty AND the negation of the first element of max_heap GREATER THAN duration THEN  \n                INCREMENT current_end_day BY duration PLUS the heap pop operation result from max_heap  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n            END IF  \n        END FOR  \n        RETURN the length of max_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-square-numbers", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET upperBound AS INTEGER PART OF THE SQUARE ROOT OF c  \n        SET lowerBound AS 0  \n        LOOP FOREVER  \n            IF lowerBound GREATER THAN upperBound THEN  \n                RETURN false  \n            END IF  \n            SET total AS (upperBound * upperBound) + (lowerBound * lowerBound)  \n            SWITCH total COMPARED TO c  \n                CASE EQUAL:  \n                    RETURN true  \n                CASE LESS:  \n                    SET lowerBound TO lowerBound + 1  \n                CASE GREATER:  \n                    SET upperBound TO upperBound - 1  \n            END SWITCH  \n        END LOOP  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET left TO zero  \n        SET right TO integer VALUE OF the SQUARE ROOT OF c  \n        WHILE left LESS THAN OR EQUAL TO right holds  \n            SET current_sum TO left MULTIPLIED BY left PLUS right MULTIPLIED BY right  \n            IF current_sum EQUALS c THEN  \n                RETURN true  \n            ELSE IF current_sum LESS THAN c THEN  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "solve-the-equation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION solveEquation(equation)\n        FUNCTION parse_side(side)\n            SET delimiter TO '#'\n            SET modified_side TO side\n            SET modified_side TO REPLACE all occurrences of '+' in modified_side WITH delimiter concatenated with '+'\n            SET modified_side TO REPLACE all occurrences of '-' in modified_side WITH delimiter concatenated with '-'\n            SET tokens_list TO SPLIT modified_side BY delimiter\n\n            SET coefficient_x TO 0\n            SET total_number TO 0\n\n            SET position TO 0\n            WHILE position < LENGTH(tokens_list)\n                SET element TO tokens_list[position]\n                IF element = '' THEN\n                    SET position TO position + 1\n                    CONTINUE\n                END IF\n\n                SET contains_x TO FALSE\n                SET char_index TO 0\n                WHILE char_index < LENGTH(element)\n                    IF element[char_index] = 'x' THEN\n                        SET contains_x TO TRUE\n                        BREAK\n                    END IF\n                    SET char_index TO char_index + 1\n                END WHILE\n\n                IF contains_x THEN\n                    SWITCH element\n                        CASE 'x':\n                            SET coefficient_x TO coefficient_x + 1\n                        CASE '+x':\n                            SET coefficient_x TO coefficient_x + 1\n                        CASE '-x':\n                            SET coefficient_x TO coefficient_x - 1\n                        DEFAULT:\n                            SET extracted_number TO SUBSTRING(element, 0, LENGTH(element) - 1)\n                            SET coefficient_x TO coefficient_x + TO_INTEGER(extracted_number)\n                    END SWITCH\n                ELSE\n                    SET total_number TO total_number + TO_INTEGER(element)\n                END IF\n\n                SET position TO position + 1\n            END WHILE\n\n            RETURN coefficient_x, total_number\n        END FUNCTION\n\n        SET parts TO SPLIT(equation, '=')\n        SET left_part TO parts[0]\n        SET right_part TO parts[1]\n\n        SET left_coefficient, left_sum TO parse_side(left_part)\n        SET right_coefficient, right_sum TO parse_side(right_part)\n\n        SET net_coefficient TO left_coefficient - right_coefficient\n        SET net_sum TO right_sum - left_sum\n\n        IF NOT (net_coefficient <> 0) THEN\n            IF NOT (net_sum <> 0) THEN\n                RETURN \"Infinite solutions\"\n            ELSE\n                RETURN \"No solution\"\n            END IF\n        ELSE\n            RETURN CONCAT(\"x=\", TO_STRING(net_sum DIV net_coefficient))\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION solveEquation(equation)  \n        FUNCTION parse_side(side)  \n            SET tokens TO the result of replacing plus signs in side with delimiter plus sign and replacing minus signs in side with delimiter minus sign and splitting the resulting string by the delimiter  \n            SET x_count TO zero  \n            SET num_sum TO zero  \n            FOR each token IN tokens  \n                IF token is an empty string THEN  \n                    CONTINUE to the next token  \n                END IF  \n                IF the character x exists in token THEN  \n                    IF token is equal to x OR token is equal to plus sign followed by x THEN  \n                        INCREMENT x_count BY one  \n                    ELSE IF token is equal to minus sign followed by x THEN  \n                        DECREMENT x_count BY one  \n                    ELSE  \n                        INCREMENT x_count BY the integer value of token with character x removed  \n                    END IF  \n                ELSE  \n                    INCREMENT num_sum BY the integer value of token  \n                END IF  \n            END FOR  \n            RETURN x_count and num_sum  \n        END FUNCTION  \n\n        SET left_side and right_side TO the parts of equation separated by the equal sign  \n        SET left_x and left_num TO the result of calling parse_side with left_side  \n        SET right_x and right_num TO the result of calling parse_side with right_side  \n\n        SET total_x TO left_x MINUS right_x  \n        SET total_num TO right_num MINUS left_num  \n\n        IF total_x EQUALS zero THEN  \n            IF total_num EQUALS zero THEN  \n                RETURN the string Infinite solutions  \n            ELSE  \n                RETURN the string No solution  \n            END IF  \n        ELSE  \n            RETURN the string formed by the character x equals the integer result of total_num DIVIDED BY total_x  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dota2-senate", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        DECLARE radiantQueue AS an empty double-ended queue  \n        DECLARE direQueue AS an empty double-ended queue  \n\n        INITIALIZE counter TO 0  \n        WHILE counter IS LESS THAN LENGTH of senate  \n            DECLARE partyChar AS senate[counter]  \n            IF NOT (partyChar NOT EQUAL TO 'R')  \n                APPEND counter TO radiantQueue  \n            ELSE  \n                APPEND counter TO direQueue  \n            END IF  \n            INCREMENT counter BY 1  \n        END WHILE  \n\n        DECLARE radiantLen AS LENGTH of senate  \n\n        LOOP INDEFINITELY  \n            IF radiantQueue IS EMPTY OR direQueue IS EMPTY THEN  \n                BREAK  \n            END IF  \n\n            REMOVE FIRST ELEMENT FROM radiantQueue AND ASSIGN TO radiantPos  \n            REMOVE FIRST ELEMENT FROM direQueue AND ASSIGN TO direPos  \n\n            IF radiantPos - direPos < 0 THEN  \n                APPEND radiantPos + radiantLen TO radiantQueue  \n            ELSE  \n                APPEND direPos + radiantLen TO direQueue  \n            END IF  \n        END LOOP  \n\n        IF radiantQueue IS EMPTY IS FALSE THEN  \n            RETURN \"Radiant\"  \n        END IF  \n        RETURN \"Dire\"  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        ASSIGN reference TO new double-ended queue named radiant  \n        ASSIGN reference TO new double-ended queue named dire  \n\n        FOR each index i AND character s IN senate  \n            IF character s EQUALS the character representing Radiant party  \n                APPEND index i TO radiant  \n            ELSE  \n                APPEND index i TO dire  \n            END IF  \n        END FOR  \n\n        WHILE radiant is not empty AND dire is not empty  \n            REMOVE and ASSIGN the first element from radiant TO r_index  \n            REMOVE and ASSIGN the first element from dire TO d_index  \n\n            IF r_index LESS THAN d_index  \n                APPEND r_index PLUS the length of senate TO radiant  \n            ELSE  \n                APPEND d_index PLUS the length of senate TO dire  \n            END IF  \n        END WHILE  \n\n        IF radiant is not empty  \n            RETURN the word Radiant  \n        ELSE  \n            RETURN the word Dire  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION checkPossibility(nums)\n        SET alterationFlag AS false\n        SET pos AS 1\n        WHILE pos < (LENGTH OF nums) DO\n            IF NOT (nums[pos] >= nums[pos - 1]) THEN\n                IF alterationFlag THEN\n                    RETURN false\n                END IF\n                alterationFlag ← true\n                IF (pos < 2) OR (nums[pos] >= nums[pos - 2]) THEN\n                    nums[pos - 1] ← nums[pos]\n                ELSE\n                    nums[pos] ← nums[pos - 1]\n                END IF\n            END IF\n            pos ← pos + 1\n        END WHILE\n        RETURN true\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "repeated-string-match", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        DECLARE minReps INTEGER  \n        ASSIGN minReps TO CEILING(LENGTH(b) / LENGTH(a))  \n        \n        DECLARE candidate STRING  \n        ASSIGN candidate TO a  \n        DECLARE repeatedCandidate STRING  \n        \n        ASSIGN repeatedCandidate TO CONCATENATE(candidate REPEATED minReps TIMES)  \n        IF CONTAINS(repeatedCandidate, b) THEN  \n            RETURN minReps  \n        END IF  \n        \n        ASSIGN repeatedCandidate TO CONCATENATE(candidate REPEATED (minReps + 1) TIMES)  \n        IF CONTAINS(repeatedCandidate, b) THEN  \n            RETURN (minReps + 1)  \n        END IF  \n        \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        SET minimum repetitions TO the smallest integer greater than or equal to the LENGTH OF b DIVIDED BY the LENGTH OF a  \n        IF string b IS a substring of string a repeated minimum repetitions times  \n            RETURN minimum repetitions  \n        END IF  \n        IF string b IS a substring of string a repeated minimum repetitions PLUS one times  \n            RETURN minimum repetitions PLUS one  \n        END IF  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET length_s1 AS LENGTH OF s1  \n        SET length_s2 AS LENGTH OF s2  \n        \n        DECLARE dp AS LIST OF LISTS WITH (length_s1 + 1) ROWS AND (length_s2 + 1) COLUMNS FILLED WITH 0  \n        \n        SET idx_col TO 1  \n        WHILE idx_col <= length_s2  \n            LET previous_value BE dp[0][idx_col - 1]  \n            LET ascii_code BE ASCII OF s2[idx_col - 1]  \n            dp[0][idx_col] ← previous_value + ascii_code  \n            idx_col ← idx_col + 1  \n        END WHILE  \n        \n        SET idx_row TO 1  \n        WHILE idx_row <= length_s1  \n            LET previous_value_row BE dp[idx_row - 1][0]  \n            LET ascii_code_row BE ASCII OF s1[idx_row - 1]  \n            dp[idx_row][0] ← previous_value_row + ascii_code_row  \n            idx_row ← idx_row + 1  \n        END WHILE  \n        \n        SET outer_index TO 1  \n        WHILE outer_index <= length_s1  \n            SET inner_index TO 1  \n            WHILE inner_index <= length_s2  \n                LET char_s1 BE s1[outer_index - 1]  \n                LET char_s2 BE s2[inner_index - 1]  \n                IF char_s1 ≠ char_s2 THEN\n                    LET deletion_s1 COST ← dp[outer_index - 1][inner_index] + ASCII OF char_s1  \n                    LET deletion_s2 COST ← dp[outer_index][inner_index - 1] + ASCII OF char_s2  \n                    LET dp[outer_index][inner_index] BE MINIMUM OF deletion_s1 COST AND deletion_s2 COST  \n                ELSE  \n                    LET dp[outer_index][inner_index] BE dp[outer_index - 1][inner_index - 1]  \n                END IF  \n                inner_index ← inner_index + 1  \n            END WHILE  \n            outer_index ← outer_index + 1  \n        END WHILE  \n        \n        RETURN dp[length_s1][length_s2]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-different-palindromic-subsequences", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences WITH PARAMETER s  \n        DECLARE MOD AS 1000000007  \n        DECLARE length_s AS LENGTH OF s  \n        \n        DECLARE next_occurrence AS LIST CONTAINING 4 ELEMENTS EACH INITIALIZED TO LIST OF length_s ELEMENTS SET TO -1  \n        DECLARE prev_occurrence AS LIST CONTAINING 4 ELEMENTS EACH INITIALIZED TO LIST OF length_s ELEMENTS SET TO -1  \n        \n        SET index_c TO 0  \n        WHILE index_c LESS THAN 4 DO  \n            SET current_char TO CHARACTER AT (ASCII('a') + index_c)  \n            SET last_seen TO -1  \n            \n            SET pos_idx TO 0  \n            WHILE pos_idx LESS THAN length_s DO  \n                IF s ELEMENT AT pos_idx EQUALS current_char THEN  \n                    SET last_seen TO pos_idx  \n                END IF  \n                SET prev_occurrence[index_c][pos_idx] TO last_seen  \n                INCREMENT pos_idx BY 1  \n            END WHILE  \n            \n            SET last_seen TO -1  \n            SET pos_idx TO length_s - 1  \n            WHILE pos_idx GREATER OR EQUAL TO 0 DO  \n                IF s ELEMENT AT pos_idx EQUALS current_char THEN  \n                    SET last_seen TO pos_idx  \n                END IF  \n                SET next_occurrence[index_c][pos_idx] TO last_seen  \n                DECREMENT pos_idx BY 1  \n            END WHILE  \n            \n            INCREMENT index_c BY 1  \n        END WHILE  \n        \n        DECLARE dp AS LIST OF length_s ELEMENTS EACH BEING A LIST OF length_s ELEMENTS SET TO 0  \n        \n        SET diag_idx TO 0  \n        WHILE diag_idx LESS THAN length_s DO  \n            SET dp[diag_idx][diag_idx] TO 1  \n            INCREMENT diag_idx BY 1  \n        END WHILE  \n        \n        SET current_len TO 2  \n        WHILE current_len LESS OR EQUAL TO length_s DO  \n            SET start_pos TO 0  \n            WHILE start_pos + current_len - 1 LESS THAN length_s DO  \n                SET end_pos TO start_pos + current_len - 1  \n                SET color_code TO 0  \n                WHILE color_code LESS THAN 4 DO  \n                    SET current_char TO CHARACTER AT (ASCII('a') + color_code)  \n                    SET left_idx TO next_occurrence[color_code][start_pos]  \n                    SET right_idx TO prev_occurrence[color_code][end_pos]  \n                    \n                    IF left_idx GREATER THAN end_pos OR right_idx LESS THAN start_pos THEN  \n                        # skip this iteration  \n                    ELSE  \n                        IF left_idx EQUALS right_idx THEN  \n                            SET dp[start_pos][end_pos] TO (dp[start_pos][end_pos] + 1) MOD MOD  \n                        ELSE  \n                            DECLARE addition AS dp[left_idx + 1][right_idx - 1]  \n                            dp[start_pos][end_pos] ← (dp[start_pos][end_pos] + addition + 2) MOD MOD  \n                        END IF  \n                    END IF  \n                    \n                    INCREMENT color_code BY 1  \n                END WHILE  \n                INCREMENT start_pos BY 1  \n            END WHILE  \n            INCREMENT current_len BY 1  \n        END WHILE  \n        \n        RETURN dp[0][length_s - 1]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences WITH PARAMETER s  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        \n        SET next_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        SET prev_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        \n        FOR each c FROM zero TO three  \n            SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n            SET last TO negative one  \n            FOR each i FROM zero TO n MINUS one  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of prev_occurrence TO last  \n            END FOR  \n            \n            SET last TO negative one  \n            FOR each i FROM n MINUS one DOWN TO zero  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of next_occurrence TO last  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a two dimensional list of n lists each containing n times zero  \n        \n        FOR each i FROM zero TO n MINUS one  \n            SET element at position i of element at position i of dp TO one  \n        END FOR  \n        \n        FOR each length FROM two TO n  \n            FOR each i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                FOR each c FROM zero TO three  \n                    SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n                    SET left TO element at position i of element at position c of next_occurrence  \n                    SET right TO element at position j of element at position c of prev_occurrence  \n                    \n                    IF left GREATER THAN j OR right LESS THAN i THEN  \n                        CONTINUE TO next iteration of the innermost loop  \n                    ELSE IF left EQUALS right THEN  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS one is divided by MOD  \n                    ELSE  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS element at position left PLUS one of element at position right MINUS one of dp PLUS two is divided by MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero of element at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swap-adjacent-in-lr-string", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        INITIALIZE filteredStart AS empty list  \n        INITIALIZE posCounter TO 0  \n        WHILE posCounter < LENGTH(start parameter) DO  \n            ASSIGN currentChar TO start parameter[posCounter]  \n            IF NOT (currentChar = 'X') THEN  \n                SET filteredStart TO filteredStart CONCATENATED WITH [(currentChar, posCounter)]  \n            END IF  \n            INCREMENT posCounter BY 1  \n        END WHILE  \n\n        INITIALIZE filteredEnd AS empty list  \n        ASSIGN idxCursor TO 0  \n        WHILE idxCursor < LENGTH(end parameter) DO  \n            ASSIGN ch TO end parameter[idxCursor]  \n            IF ch <> 'X' THEN  \n                SET filteredEnd TO filteredEnd + [(ch, idxCursor)]  \n            END IF  \n            ASSIGN idxCursor TO idxCursor + 1  \n        END WHILE  \n\n        IF LENGTH(filteredStart) != LENGTH(filteredEnd) THEN  \n            RETURN false  \n        END IF  \n\n        INITIALIZE pairIndex TO 0  \n        WHILE pairIndex < LENGTH(filteredStart) DO  \n            ASSIGN firstTuple TO filteredStart[pairIndex]  \n            ASSIGN secondTuple TO filteredEnd[pairIndex]  \n\n            ASSIGN charA TO firstTuple[0]  \n            ASSIGN posA TO firstTuple[1]  \n            ASSIGN charB TO secondTuple[0]  \n            ASSIGN posB TO secondTuple[1]  \n\n            IF NOT (charA = charB) THEN  \n                RETURN false  \n            END IF  \n\n            IF charA = 'L' THEN  \n                IF posA < posB THEN  \n                    RETURN false  \n                END IF  \n            ELSE IF charA = 'R' THEN  \n                IF posA > posB THEN  \n                    RETURN false  \n                END IF  \n            END IF  \n\n            SET pairIndex TO pairIndex + 1  \n        END WHILE  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean\n        LOOP_WHILE (tx IS_NOT_LESS_THAN sx) AND (ty IS_NOT_LESS_THAN sy)\n            IF (NOT (tx IS_DIFFERS_FROM sx)) AND (NOT (ty IS_DIFFERS_FROM sy))\n                RETURN True\n            END IF\n\n            IF tx IS_GREATER_THAN ty\n                IF ty IS_GREATER_THAN sy\n                    LET dividend = tx\n                    LET divisor = ty\n                    LET remainder = dividend MINUS (divisor TIMES FLOOR(dividend DIVIDED_BY divisor))\n                    ASSIGN remainder INTO tx\n                ELSE\n                    LET numerator = tx MINUS sx\n                    LET denominator = ty\n                    LET modulusResult = numerator MINUS (denominator TIMES FLOOR(numerator DIVIDED_BY denominator))\n                    IF NOT (modulusResult IS_NOT_EQUAL_ZERO)\n                        RETURN True\n                    ELSE\n                        RETURN False\n                    END IF\n                END IF\n            ELSE\n                IF tx IS_GREATER_THAN sx\n                    LET dividend = ty\n                    LET divisor = tx\n                    LET remainder = dividend MINUS (divisor TIMES FLOOR(dividend DIVIDED_BY divisor))\n                    ASSIGN remainder INTO ty\n                ELSE\n                    LET numerator = ty MINUS sy\n                    LET denominator = tx\n                    LET modulusResult = numerator MINUS (denominator TIMES FLOOR(numerator DIVIDED_BY denominator))\n                    IF NOT (modulusResult IS_NOT_EQUAL_ZERO)\n                        RETURN True\n                    ELSE\n                        RETURN False\n                    END IF\n                END IF\n            END IF\n        END LOOP_WHILE\n        RETURN False\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "is-graph-bipartite", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        ASSIGN size TO LENGTH(graph)  \n        ASSIGN paint TO ARRAY OF size ELEMENTS FILLED WITH 0  \n        \n        FUNCTION dfs(vertex, shade)  \n            paint[vertex] = shade  \n            SET index TO 0  \n            WHILE index < LENGTH(graph[vertex])  \n                ASSIGN adj TO graph[vertex][index]  \n                IF paint[adj] == shade THEN  \n                    RETURN False  \n                ELSE IF paint[adj] == 0 THEN  \n                    IF dfs(adj, -shade) == False THEN  \n                        RETURN False  \n                    END IF  \n                END IF  \n                index = index + 1  \n            END WHILE  \n            RETURN True  \n        END FUNCTION  \n        \n        SET counter TO 0  \n        WHILE counter < size  \n            IF paint[counter] == 0 THEN  \n                IF dfs(counter, 1) == False THEN  \n                    RETURN False  \n                END IF  \n            END IF  \n            counter = counter + 1  \n        END WHILE  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        SET n TO the LENGTH OF graph  \n        SET color TO a list of zeros with LENGTH n  \n        \n        FUNCTION dfs(node c)  \n            SET the element at position node of color TO c  \n            FOR each neighbor IN the element at position node of graph  \n                IF the element at position neighbor of color EQUALS c  \n                    RETURN False  \n                END IF  \n                IF the element at position neighbor of color EQUALS zero  \n                    IF dfs(neighbor the NEGATION OF c) EQUALS False  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of color EQUALS zero  \n                IF dfs(i one) EQUALS False  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-smallest-prime-fraction", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION kthSmallestPrimeFraction(arr, k)\n        LET totalElements BE LENGTH(arr)\n        LET heapElements BE an EMPTY LIST\n\n        LET indexCounter BE 0\n        WHILE indexCounter < totalElements - 1\n            LET fractionValue BE arr[indexCounter] DIVIDED_BY arr[totalElements - 1]\n            INSERT (fractionValue, indexCounter, totalElements - 1) INTO heapElements\n            SET indexCounter TO indexCounter + 1\n        END WHILE\n\n        LET iterationCounter BE 0\n        WHILE iterationCounter < k - 1\n            EXTRACT_MIN FROM heapElements INTO (_, idxA, idxB)\n            IF (idxB - 1) > idxA THEN\n                LET newFraction BE arr[idxA] DIVIDED_BY arr[idxB - 1]\n                INSERT (newFraction, idxA, idxB - 1) INTO heapElements\n            END IF\n            SET iterationCounter TO iterationCounter + 1\n        END WHILE\n\n        EXTRACT_MIN FROM heapElements INTO (_, finalI, finalJ)\n        RETURN [arr[finalI], arr[finalJ]]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallestPrimeFraction(arr, k)  \n        SET n TO the LENGTH OF arr  \n        SET min_heap TO an empty list  \n        FOR i FROM zero TO n MINUS one MINUS one  \n            PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position n MINUS one of arr AND i AND n MINUS one  \n        END FOR  \n        FOR iteration FROM zero TO k MINUS one MINUS one  \n            POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n            IF j MINUS one IS GREATER THAN i THEN  \n                PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position j MINUS one of arr AND i AND j MINUS one  \n            END IF  \n        END FOR  \n        POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n        RETURN a list containing element at position i of arr AND element at position j of arr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD to 1_000_000_007  \n        \n        SET dp AS a list initialized with zeros, size n PLUS 1  \n        SET dp1 AS a list initialized with zeros, size n PLUS 1  \n        \n        ASSIGN 1 TO dp[0]  \n        ASSIGN 1 TO dp[1]  \n        IF n LESS THAN 2 THEN  \n            GOTO after_initialization  \n        ELSE  \n            ASSIGN 2 TO dp[2]  \n            ASSIGN 1 TO dp1[2]  \n        END IF  \n        LABEL after_initialization  \n        \n        SET index TO 3  \n        WHILE index LESS THAN OR EQUAL TO n DO  \n            SET part1 TO (dp[index - 1] + dp[index - 2]) MOD MOD  \n            SET part2 TO (2 * dp1[index - 1]) MOD MOD  \n            ASSIGN (part1 + part2) MOD MOD TO dp[index]  \n            \n            SET dp1[index] TO ((dp[index - 2] + dp1[index - 1]) MOD MOD)  \n            INCREMENT index BY 1  \n        END WHILE  \n        \n        RETURN dp[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO the one billion PLUS seven  \n        \n        SET dp TO a list of zeros with LENGTH n PLUS one  \n        SET dp1 TO a list of zeros with LENGTH n PLUS one  \n        \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder of the sum of element at position i MINUS one of dp PLUS element at position i MINUS two of dp PLUS two MULTIPLIED BY element at position i MINUS one of dp1 when divided by MOD  \n            SET element at position i of dp1 TO the remainder of the sum of element at position i MINUS two of dp PLUS element at position i MINUS one of dp1 when divided by MOD  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-tic-tac-toe-state", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION validTicTacToe(board)\n        SET tallyAlpha TO 0\n        SET lineBuffer TO 0\n\n        WHILE lineBuffer LESS THAN LENGTH(board)\n            SET currentLine TO board[lineBuffer]\n            SET idxChar TO 0\n            WHILE idxChar LESS THAN LENGTH(currentLine)\n                IF currentLine[idxChar] EQUALS 'X'\n                    SET tallyAlpha TO tallyAlpha + 1\n                END IF\n                SET idxChar TO idxChar + 1\n            END WHILE\n            SET lineBuffer TO lineBuffer + 1\n        END WHILE\n\n        SET tallyBeta TO 0\n        SET scanRow TO 0\n\n        WHILE scanRow LESS THAN LENGTH(board)\n            SET currentSequence TO board[scanRow]\n            SET posChar TO 0\n            LOOP\n                IF posChar GREATER THAN OR EQUAL TO LENGTH(currentSequence)\n                    BREAK\n                END IF\n                IF currentSequence[posChar] EQUALS 'O'\n                    SET tallyBeta TO tallyBeta + 1\n                END IF\n                SET posChar TO posChar + 1\n            END LOOP\n            SET scanRow TO scanRow + 1\n        END WHILE\n\n        IF NOT (tallyAlpha GREATER THAN OR EQUAL TO tallyBeta AND tallyAlpha LESS THAN OR EQUAL TO tallyBeta + 1)\n            RETURN False\n        END IF\n\n        FUNCTION check_win(player)\n            SET lineIndex TO 0\n            WHILE lineIndex LESS THAN LENGTH(board)\n                SET candidateRow TO board[lineIndex]\n                IF candidateRow EQUALS player + player + player\n                    RETURN True\n                END IF\n                SET lineIndex TO lineIndex + 1\n            END WHILE\n\n            SET columnIndex TO 0\n            WHILE columnIndex LESS THAN 3\n                IF board[0][columnIndex] EQUALS player\n                   AND board[1][columnIndex] EQUALS player\n                   AND board[2][columnIndex] EQUALS player\n                    RETURN True\n                END IF\n                SET columnIndex TO columnIndex + 1\n            END WHILE\n\n            IF board[0][0] EQUALS player\n               AND board[1][1] EQUALS player\n               AND board[2][2] EQUALS player\n                RETURN True\n            END IF\n\n            IF board[0][2] EQUALS player\n               AND board[1][1] EQUALS player\n               AND board[2][0] EQUALS player\n                RETURN True\n            END IF\n\n            RETURN False\n        END FUNCTION\n\n        SET victoriousX TO check_win('X')\n        SET victoriousO TO check_win('O')\n\n        SELECT\n            CASE victoriousX AND victoriousO\n                RETURN False\n            CASE victoriousX AND (tallyAlpha EQUALS tallyBeta)\n                RETURN False\n            CASE victoriousO AND (tallyAlpha NOT EQUALS tallyBeta)\n                RETURN False\n            DEFAULT\n                RETURN True\n        END SELECT\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "soup-servings", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION soupServings(n)\n        CASE\n            WHEN n <= 4800 THEN\n                SET n AS (n + 24) DIV 25\n            ELSE\n                RETURN 1.0\n        END CASE\n\n        SET cache AS empty dictionary\n\n        FUNCTION dp(a, b)\n            DEPLOY\n                VARIABLE key AS (a, b)\n            RETRIEVE\n                IF key IN cache THEN\n                    RETURN cache[key]\n                END IF\n            STOP\n\n            IF a <= 0 THEN\n                IF b <= 0 THEN\n                    RETURN 0.5\n                ELSE\n                    RETURN 1.0\n                END IF\n            ELSE\n                IF b <= 0 THEN\n                    RETURN 0.0\n                END IF\n            END IF\n\n            VARIABLE p1 AS dp(a - 4, b)\n            VARIABLE p2 AS dp(a - 3, b - 1)\n            VARIABLE p3 AS dp(a - 2, b - 2)\n            VARIABLE p4 AS dp(a - 1, b - 3)\n\n            VARIABLE prob AS 0.25 * (p1 + p2 + p3 + p4)\n            SET cache[key] AS prob\n\n            RETURN prob\n        END FUNCTION\n\n        RETURN dp(n, n)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred THEN  \n            RETURN one point zero  \n        END IF  \n        SET n TO n PLUS twenty four DIVIDED BY twenty five  \n        SET memo TO empty dictionary  \n        FUNCTION dp(a, b)  \n            IF tuple of a AND b EXISTS IN memo THEN  \n                RETURN value of tuple of a AND b IN memo  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point five  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero THEN  \n                RETURN one point zero  \n            END IF  \n            IF b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point zero  \n            END IF  \n            SET prob TO zero point two five MULTIPLIED BY sum of dp of a MINUS four AND b PLUS dp of a MINUS three AND b MINUS one PLUS dp of a MINUS two AND b MINUS two PLUS dp of a MINUS one AND b MINUS three  \n            SET value of tuple of a AND b IN memo TO prob  \n            RETURN prob  \n        END FUNCTION  \n        RETURN dp of n AND n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bus-routes", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF NOT (source NOT EQUAL target)  \n            RETURN 0  \n        END IF  \n\n        INITIALIZE busMap AS a new empty mapping DefaultDict of list  \n        SET i TO 0  \n        WHILE i LESS THAN LENGTH OF routes  \n            SET currentRoute TO routes[i]  \n            SET j TO 0  \n            WHILE j LESS THAN LENGTH OF currentRoute  \n                APPEND i TO busMap[currentRoute[j]]  \n                SET j TO j PLUS 1  \n            END WHILE  \n            SET i TO i PLUS 1  \n        END WHILE  \n\n        INITIALIZE queue AS an empty double ended queue  \n        INITIALIZE visitedBuses AS an empty set  \n        INITIALIZE seenStops AS an empty set  \n\n        FOR each busIndex IN busMap[source]  \n            ENQUEUE (busIndex, 1) INTO queue  \n            INSERT busIndex INTO visitedBuses  \n        END FOR  \n        INSERT source INTO seenStops  \n\n        WHILE queue IS NOT EMPTY  \n            DEQUEUE FROM queue INTO currentBus, currentCount  \n\n            SET k TO 0  \n            WHILE k LESS THAN LENGTH OF routes[currentBus]  \n                SET currStop TO routes[currentBus][k]  \n\n                IF currStop EQUALS target  \n                    RETURN currentCount  \n                END IF  \n\n                IF currStop NOT IN seenStops  \n                    INSERT currStop INTO seenStops  \n\n                    FOR each nextBus IN busMap[currStop]  \n                        IF nextBus NOT IN visitedBuses  \n                            INSERT nextBus INTO visitedBuses  \n                            ENQUEUE (nextBus, currentCount PLUS 1) INTO queue  \n                        END IF  \n                    END FOR  \n                END IF  \n\n                SET k TO k PLUS 1  \n            END WHILE  \n        END WHILE  \n\n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from keys to empty lists  \n        FOR each bus WITH index bus_index AND route IN routes  \n            FOR each stop IN route  \n                APPEND bus_index TO the list corresponding to stop IN stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at the source stop FROM stop_to_buses  \n            APPEND the tuple consisting of bus AND one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element FROM bus_queue AND ASSIGN the elements TO current_bus AND bus_count  \n\n            FOR each stop IN the route at position current_bus OF routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop NOT IN visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop FROM stop_to_buses  \n                        IF next_bus NOT IN visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the tuple consisting of next_bus AND bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "race-car", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION racecar(target)  \n        DECLARE sequence ← new double ended queue containing [(0, 1, 0)]  \n        DECLARE visited ← empty set  \n        INSERT (0, 1) INTO visited  \n        \n        LOOP indefinitely  \n            IF sequence IS empty THEN BREAK  \n            END IF  \n            \n            POP (current_pos, current_spd, current_steps) FROM the front of sequence  \n            \n            SWITCH  \n                CASE current_pos = target:  \n                    RETURN current_steps  \n                DEFAULT:  \n                    CONTINUE  \n            END SWITCH  \n            \n            SET projected_pos TO current_pos + current_spd  \n            SET projected_spd TO current_spd × 2  \n            \n            IF NOT ((projected_pos, projected_spd) IN visited) AND 0 ≤ projected_pos < (2 × target) THEN  \n                INSERT (projected_pos, projected_spd) INTO visited  \n                ENQUEUE (projected_pos, projected_spd, current_steps + 1) TO the rear of sequence  \n            END IF  \n            \n            DECLARE alt_spd  \n            IF current_spd > 0 THEN  \n                alt_spd ← -1  \n            ELSE  \n                alt_spd ← +1  \n            END IF  \n            \n            IF NOT ((current_pos, alt_spd) IN visited) AND 0 ≤ current_pos < (2 × target) THEN  \n                INSERT (current_pos, alt_spd) INTO visited  \n                ENQUEUE (current_pos, alt_spd, current_steps + 1) TO the rear of sequence  \n            END IF  \n        END LOOP  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION racecar(target)  \n        ASSIGN reference TO a new double ended queue containing a single tuple of zero for position one for speed and zero for steps  \n        ASSIGN reference TO a new empty set  \n        ADD a tuple of zero for position and one for speed TO the set  \n        \n        WHILE the queue is not empty  \n            REMOVE and ASSIGN a tuple from the left side of the queue TO position speed and steps  \n            \n            IF position EQUALS target  \n                RETURN steps  \n            END IF  \n            \n            SET next_position TO position PLUS speed  \n            SET next_speed TO speed MULTIPLIED BY two  \n            IF the tuple of next_position and next_speed NOT IN the set AND next_position IS GREATER THAN OR EQUAL TO zero AND next_position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of next_position and next_speed TO the set  \n                APPEND the tuple of next_position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n            \n            IF speed IS GREATER THAN zero  \n                SET next_speed TO negative one  \n            ELSE  \n                SET next_speed TO one  \n            END IF  \n            IF the tuple of position and next_speed NOT IN the set AND position IS GREATER THAN OR EQUAL TO zero AND position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of position and next_speed TO the set  \n                APPEND the tuple of position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "card-flipping-game", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET repeating TO empty set  \n        DEFINE index AS 0  \n        WHILE index LESS THAN the LENGTH OF fronts  \n            SET front_val TO fronts[index]  \n            SET back_val TO backs[index]  \n            IF front_val EQUAL back_val THEN  \n                ADD front_val TO repeating  \n            END IF  \n            INCREMENT index BY 1  \n        END WHILE  \n\n        SET combined_values TO empty set  \n        FOR EACH val IN fronts DO  \n            ADD val TO combined_values  \n        END FOR  \n\n        FOR EACH val IN backs DO  \n            ADD val TO combined_values  \n        END FOR  \n\n        SET candidates TO empty set  \n        FOR EACH val IN combined_values DO  \n            IF NOT (val IN repeating) THEN  \n                ADD val TO candidates  \n            END IF  \n        END FOR  \n\n        IF LENGTH OF candidates IS NOT EQUAL TO 0 THEN  \n            SET result TO NULL  \n            SET iterator TO candidates.iterator()  \n            SET result TO iterator.next()  \n            WHILE iterator.hasNext() DO  \n                SET current_val TO iterator.next()  \n                IF current_val LESS THAN result THEN  \n                    SET result TO current_val  \n                END IF  \n            END WHILE  \n            RETURN result  \n        ELSE  \n            RETURN 0  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-trees-with-factors", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        ASSIGN MODULO_CONST ← (10 ^ 9) + 7  \n        SORT arr BY ascending order  \n        \n        INITIALIZE factorsCount AS empty mapping  \n        FOR each element IN arr DO  \n            SET factorsCount[element] ← 1  \n        END FOR  \n        \n        SET outerIdx ← 0  \n        WHILE outerIdx < LENGTH(arr) DO  \n            SET currentVal ← arr[outerIdx]  \n            SET innerIdx ← 0  \n            WHILE innerIdx < outerIdx DO  \n                SET divisorCandidate ← arr[innerIdx]  \n                IF (currentVal − (currentVal DIV divisorCandidate) * divisorCandidate) = 0 THEN  \n                    SET pairedFactor ← currentVal DIV divisorCandidate  \n                    IF pairedFactor IN factorsCount THEN  \n                        SET product ← factorsCount[divisorCandidate] * factorsCount[pairedFactor]  \n                        SET factorsCount[currentVal] ← (factorsCount[currentVal] + product) MODULO MODULO_CONST  \n                    END IF  \n                END IF  \n                INCREMENT innerIdx BY 1  \n            END WHILE  \n            INCREMENT outerIdx BY 1  \n        END WHILE  \n        \n        ASSIGN accumulation ← 0  \n        FOR each countValue IN factorsCount DO  \n            SET accumulation ← accumulation + countValue  \n        END FOR  \n        \n        RETURN accumulation MODULO MODULO_CONST  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-into-fibonacci-sequence", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION splitIntoFibonacci(num)\n        FUNCTION backtrack(start, path)\n            ASSIGN sizeNum TO LENGTH(num)\n            ASSIGN sizePath TO LENGTH(path)\n            IF NOT (start NOT EQUAL sizeNum OR sizePath LESS THAN 3)\n                RETURN path\n            END IF\n            ASSIGN idx TO start + 1\n            WHILE idx <= sizeNum\n                IF NOT ((num[start] = '0') AND (idx > start + 1))\n                    ASSIGN substrVal TO SUBSTRING(num, start, idx)\n                    ASSIGN nextVal TO TO_INTEGER(substrVal)\n                    IF nextVal < 2 ^ 31\n                        IF (sizePath < 2) OR (nextVal = path[sizePath - 1] + path[sizePath - 2])\n                            ASSIGN attempt TO backtrack(idx, CONCAT(path, [nextVal]))\n                            IF attempt != []\n                                RETURN attempt\n                            END IF\n                        END IF\n                    ELSE\n                        BREAK\n                    END IF\n                END IF\n                idx = idx + 1\n            END WHILE\n            RETURN []\n        END FUNCTION\n        RETURN backtrack(0, [])\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS the character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE TO the next iteration of the loop  \n                END IF  \n                SET next_num TO the integer value of the substring of num from position start TO position end MINUS one  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at the position LENGTH OF path MINUS one of path PLUS the element at the position LENGTH OF path MINUS two of path  \n                    SET result TO the call of backtrack WITH parameters end AND the concatenation of path AND the list containing next_num  \n                    IF result IS NOT an empty list  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        RETURN the call of backtrack WITH parameters zero AND an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-mountain-in-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestMountain(arr)\n        SET length_arr AS LENGTH OF arr\n        SET maximum_length TO 0\n        SET index_counter TO 1\n        LOOP\n            IF NOT (index_counter < length_arr - 1) THEN\n                BREAK\n            END IF\n\n            IF (arr[index_counter - 1] < arr[index_counter]) AND (arr[index_counter] > arr[index_counter + 1]) THEN\n                SET left_marker AS index_counter - 1\n                SET right_marker AS index_counter + 1\n\n                WHILE (left_marker > 0) AND (arr[left_marker - 1] < arr[left_marker])\n                    left_marker ← left_marker - 1\n                END WHILE\n\n                WHILE (right_marker < length_arr - 1) AND (arr[right_marker] > arr[right_marker + 1])\n                    right_marker ← right_marker + 1\n                END WHILE\n\n                SET current_mountain_length AS right_marker - left_marker + 1\n                IF maximum_length < current_mountain_length THEN\n                    maximum_length ← current_mountain_length\n                END IF\n\n                index_counter ← right_marker\n            ELSE\n                index_counter ← index_counter + 1\n            END IF\n        END LOOP\n        RETURN maximum_length\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestMountain(arr)  \n        SET n TO the LENGTH OF arr  \n        SET longest TO zero  \n        SET i TO one  \n        WHILE i LESS THAN n MINUS one  \n            IF element at position i MINUS one of arr LESS THAN element at position i of arr AND element at position i of arr GREATER THAN element at position i PLUS one of arr  \n                SET left TO i MINUS one  \n                SET right TO i PLUS one  \n                WHILE left GREATER THAN zero AND element at position left MINUS one of arr LESS THAN element at position left of arr  \n                    DECREMENT left BY one  \n                END WHILE  \n                WHILE right LESS THAN n MINUS one AND element at position right of arr GREATER THAN element at position right PLUS one of arr  \n                    INCREMENT right BY one  \n                END WHILE  \n                IF longest LESS THAN right MINUS left PLUS one  \n                    SET longest TO right MINUS left PLUS one  \n                END IF  \n                SET i TO right  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        RETURN longest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-visiting-all-nodes", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION shortestPathLength(graph)\n        IF NOT (graph == empty collection) THEN\n            SET nodeCount AS LENGTH OF graph\n            SET dequeContainer AS new double-ended queue\n            SET index AS zero\n            WHILE index LESS THAN nodeCount\n                SET item AS pair(index, ONE SHIFTED LEFT BY index)\n                APPEND item TO dequeContainer\n                INCREMENT index BY one\n            END WHILE\n\n            SET visitedStates AS new set dequeContainer\n\n            SET distance AS zero\n            SET fullMask AS (ONE SHIFTED LEFT BY nodeCount) MINUS one\n\n            WHILE NOT (dequeContainer IS EMPTY)\n                SET levelSize AS LENGTH OF dequeContainer\n                SET stepCounter AS zero\n                WHILE stepCounter LESS THAN levelSize\n                    REMOVE leftmost element FROM dequeContainer INTO currentPair\n                    SET currentNode AS currentPair's first element\n                    SET visitedMask AS currentPair's second element\n\n                    IF visitedMask == fullMask THEN\n                        RETURN distance\n                    END IF\n\n                    FOR each adjacent IN graph AT index currentNode\n                        SET updatedMask AS visitedMask OR (ONE SHIFTED LEFT BY adjacent)\n                        SET nextPair AS pair(adjacent, updatedMask)\n\n                        IF NOT (nextPair IN visitedStates) THEN\n                            ADD nextPair TO visitedStates\n                            APPEND nextPair TO dequeContainer\n                        END IF\n                    END FOR\n                    INCREMENT stepCounter BY one\n                END WHILE\n                SET distance AS distance + 1\n            END WHILE\n\n            RETURN minus one\n        ELSE\n            RETURN zero\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION shortestPathLength(graph)  \n        IF graph EQUALS empty collection THEN  \n            RETURN zero  \n        END IF  \n      \n        SET n TO the LENGTH OF graph  \n        SET queue TO a new double-ended queue containing pairs of each node in the range from zero TO n MINUS one together with a value obtained by ONE SHIFTED LEFT BY node  \n        SET visited TO a new set containing the same pairs as in queue  \n      \n        SET steps TO zero  \n        SET all_nodes_visited TO ONE SHIFTED LEFT BY n MINUS one  \n      \n        WHILE queue is not empty  \n            SET current_level_size TO the LENGTH OF queue  \n            FOR iteration FROM one TO current_level_size  \n                REMOVE the leftmost element from queue and DESCTRUCTURE INTO current_node and visited_nodes  \n              \n                IF visited_nodes EQUALS all_nodes_visited THEN  \n                    RETURN steps  \n                END IF  \n              \n                FOR each neighbor IN the element at position current_node of graph  \n                    SET next_visited_nodes TO visited_nodes OR ONE SHIFTED LEFT BY neighbor  \n                    SET next_state TO pair of neighbor and next_visited_nodes  \n                  \n                    IF next_state NOT IN visited THEN  \n                        ADD next_state TO visited  \n                        APPEND next_state TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n          \n            INCREMENT steps BY one  \n        END WHILE  \n      \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "loud-and-rich", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION loudAndRich(richer, quiet)\n        graph ← default dictionary with list as default value\n        iterator ← 0\n        WHILE iterator < LENGTH(richer)\n            pair ← richer[iterator]\n            graph[pair[1]] APPEND pair[0]\n            iterator ← iterator + 1\n        END WHILE\n\n        n ← LENGTH(quiet)\n        answer ← new list of size n FILLED WITH -1\n\n        FUNCTION dfs(person)\n            IF NOT (answer[person] ≠ -1) THEN\n                answer[person] ← person\n                index ← 0\n                WHILE index < LENGTH(graph[person])\n                    neighbor ← graph[person][index]\n                    candidate ← dfs(neighbor)\n                    IF quiet[candidate] < quiet[answer[person]] THEN\n                        answer[person] ← candidate\n                    END IF\n                    index ← index + 1\n                END WHILE\n            END IF\n            RETURN answer[person]\n        END FUNCTION\n\n        counter ← 0\n        WHILE counter < n\n            dfs(counter)\n            counter ← counter + 1\n        END WHILE\n\n        RETURN answer\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION loudAndRich(richer, quiet)  \n        SET graph TO a new default dictionary with list as the default value type  \n        FOR each pair of elements named a and b IN the collection richer  \n            APPEND element a TO the list associated with key b in graph  \n        END FOR  \n        \n        SET n TO the length of the collection quiet  \n        SET answer TO a list of length n filled with minus one values  \n        \n        FUNCTION dfs(person)  \n            IF the element at position person of answer EQUALS minus one THEN  \n                SET the element at position person of answer TO person  \n                FOR each element neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs with argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position of answer at person of quiet THEN  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        \n        FOR index i FROM zero TO n MINUS one  \n            CALL dfs with argument i  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "car-fleet", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION carFleet(target, position, speed)  \n        SET combinedPairs AS EMPTY LIST  \n        SET idx TO 0  \n        WHILE idx LESS THAN LENGTH OF position  \n            APPEND (position[idx], speed[idx]) TO combinedPairs  \n            INCREMENT idx BY 1  \n        END WHILE  \n\n        SORT combinedPairs BY FIRST ELEMENT DESCENDING  \n\n        SET arrivalTimes AS EMPTY LIST  \n        SET pairIndex TO 0  \n        WHILE pairIndex LESS THAN LENGTH OF combinedPairs  \n            LET loc BE combinedPairs[pairIndex][0]  \n            LET vel BE combinedPairs[pairIndex][1]  \n            LET timeVal BE (target MINUS loc) DIVIDED BY vel  \n            APPEND timeVal TO arrivalTimes  \n            INCREMENT pairIndex BY 1  \n        END WHILE  \n\n        SET fleetCount TO 0  \n        SET maxObservedTime TO 0  \n\n        SET timeIdx TO 0  \n        WHILE timeIdx LESS THAN LENGTH OF arrivalTimes  \n            LET currentTime BE arrivalTimes[timeIdx]  \n            IF NOT (currentTime LESS OR EQUAL maxObservedTime) THEN  \n                SET maxObservedTime TO currentTime  \n                SET fleetCount TO fleetCount PLUS 1  \n            END IF  \n            INCREMENT timeIdx BY 1  \n        END WHILE  \n\n        RETURN fleetCount  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION carFleet(target position speed)  \n        SET paired_list TO the list of elements obtained by pairing each element at each position in position WITH the element at the corresponding position in speed  \n        SORT paired_list in order from the greatest element of the first component to the smallest element of the first component  \n\n        SET time_to_target TO an empty list  \n        FOR each pair IN paired_list  \n            SET p TO the first component of pair  \n            SET s TO the second component of pair  \n            SET time TO target MINUS p DIVIDED BY s  \n            APPEND time TO time_to_target  \n        END FOR  \n\n        SET fleets TO zero  \n        SET current_max_time TO zero  \n\n        FOR each time IN time_to_target  \n            IF time GREATER THAN current_max_time  \n                INCREMENT fleets BY one  \n                SET current_max_time TO time  \n            END IF  \n        END FOR  \n\n        RETURN fleets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-to-get-all-keys", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET vectors AS the collection of pairs [(1,0), (-1,0), (0,1), (0,-1)]  \n        SET height AS LENGTH OF grid  \n        SET width AS LENGTH OF grid AT INDEX zero  \n        SET origin WITH NO INITIAL VALUE  \n        SET total_keys AS 0  \n        SET row_idx AS 0  \n        WHILE row_idx < height  \n            SET col_idx AS 0  \n            WHILE col_idx < width  \n                IF grid AT row_idx AND col_idx IS '@' THEN  \n                    SET origin TO (row_idx, col_idx)  \n                ELSE IF 'a' <= grid AT row_idx AND col_idx AND grid AT row_idx AND col_idx <= 'z' THEN  \n                    SET total_keys TO total_keys + 1  \n                END IF  \n                SET col_idx TO col_idx + 1  \n            END WHILE  \n            SET row_idx TO row_idx + 1  \n        END WHILE  \n        SET frontier AS A new deque INITIALIZED WITH [(origin AT INDEX zero, origin AT INDEX one, 0, 0)]  \n        SET encountered AS A set WITH {(origin AT INDEX zero, origin AT INDEX one, 0)}  \n        \n        WHILE NOT EMPTY frontier  \n            SET curr_x, curr_y, acquired_keys, step_count TO POP LEFT frontier  \n            FOR EACH vector_x, vector_y IN vectors  \n                SET next_x TO curr_x + vector_x  \n                SET next_y TO curr_y + vector_y  \n                \n                IF 0 <= next_x AND next_x < height AND 0 <= next_y AND next_y < width THEN  \n                    SET cell_value TO grid AT next_x AND next_y  \n                    IF cell_value = '#' THEN  \n                        CONTINUE TO NEXT ITERATION  \n                    END IF  \n                    IF 'A' <= cell_value AND cell_value <= 'Z' THEN  \n                        SET lock_bit TO 1 << (ORD(LOWERCASE cell_value) - ORD('a'))  \n                        IF (acquired_keys & lock_bit) = 0 THEN  \n                            CONTINUE TO NEXT ITERATION  \n                        END IF  \n                    END IF  \n                    IF 'a' <= cell_value AND cell_value <= 'z' THEN  \n                        SET updated_keys TO (acquired_keys | 1 << (ORD cell_value - ORD 'a'))  \n                        IF updated_keys = (1 << total_keys) - 1 THEN  \n                            RETURN step_count + 1  \n                        END IF  \n                    ELSE  \n                        SET updated_keys TO acquired_keys  \n                    END IF  \n                    \n                    IF (next_x, next_y, updated_keys) NOT IN encountered THEN  \n                        ADD (next_x, next_y, updated_keys) TO encountered  \n                        APPEND (next_x, next_y, updated_keys, step_count + 1) TO frontier  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO the list of pairs representing movement right one step left one step down one step and up one step  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO no value assigned  \n        SET num_keys TO zero  \n        FOR i FROM zero TO the value m MINUS one  \n            FOR j FROM zero TO the value n MINUS one  \n                IF element at position i of grid at position j EQUALS the character at sign at symbol  \n                    SET start TO the pair of values i and j  \n                ELSE IF element at position i of grid at position j IS a lowercase letter  \n                    INCREMENT num_keys BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET queue TO a new double ended queue containing the single element of the tuple of value at position zero of start value at position one of start zero zero  \n        SET visited TO a new set containing the single element of the tuple of value at position zero of start value at position one of start zero  \n        WHILE queue is not empty  \n            SET x y keys steps TO the tuple removed from the front of queue  \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid at position ny  \n                    IF cell EQUALS the hash symbol  \n                        CONTINUE to next iteration of FOR loop  \n                    END IF  \n                    IF cell IS an uppercase letter  \n                        SET key_needed TO one SHIFTED LEFT BY the Unicode code point of the lowercase form of cell MINUS the Unicode code point of letter a  \n                        IF the result of keys AND key_needed EQUALS zero  \n                            CONTINUE to next iteration of FOR loop  \n                        END IF  \n                    END IF  \n                    IF cell IS a lowercase letter  \n                        SET new_keys TO the result of keys OR one SHIFTED LEFT BY the Unicode code point of cell MINUS the Unicode code point of letter a  \n                        IF new_keys EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                    IF the tuple nx ny new_keys IS NOT in visited  \n                        ADD the tuple nx ny new_keys TO visited  \n                        APPEND the tuple nx ny new_keys steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-egg-drop", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        LET tests BE 0  \n        LET attempts BE a list initialized with zeros whose size equals k + 1  \n        REPEAT  \n            tests ← tests + 1  \n            LET eggIndex BE k  \n            WHILE eggIndex GREATER THAN 0  \n                attempts[eggIndex] ← 1 + attempts[eggIndex - 1] + attempts[eggIndex]  \n                eggIndex ← eggIndex - 1  \n            END WHILE  \n        UNTIL attempts[k] GREATER THAN OR EQUAL TO n  \n        RETURN tests  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        SET dp TO a list of zeros with length k PLUS one  \n        SET moves TO zero  \n        WHILE element at position k of dp LESS THAN n holds  \n            INCREMENT moves BY one  \n            FOR eggs FROM k DOWN TO one  \n                SET element at position eggs of dp TO one PLUS element at position eggs MINUS one of dp PLUS element at position eggs of dp  \n            END FOR  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stamping-the-sequence", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION movesToStamp(stamp string, target string) RETURNS list of integers  \n        DEFINE totalStampLen AS LENGTH(stamp)  \n        DEFINE totalTargetLen AS LENGTH(target)  \n        DEFINE incomingEdges AS ARRAY OF SIZE (totalTargetLen - totalStampLen + 1) FILLED WITH totalStampLen  \n        DEFINE processingQueue AS NEW double ended queue (empty)  \n        DEFINE adjacencyList AS ARRAY OF SIZE totalTargetLen EACH CONTAINING EMPTY LIST  \n\n        DEFINE outerIndex AS 0  \n        WHILE outerIndex LESS THAN (totalTargetLen - totalStampLen + 1)  \n            DEFINE innerIndex AS 0  \n            REPEAT  \n                IF innerIndex EQUALS totalStampLen THEN  \n                    BREAK  \n                END IF  \n                DEFINE currentStampChar AS stamp[innerIndex]  \n                IF target[outerIndex + innerIndex] EQUALS currentStampChar THEN  \n                    incomingEdges[outerIndex] ← incomingEdges[outerIndex] - 1  \n                    IF incomingEdges[outerIndex] EQUALS 0 THEN  \n                        processingQueue.APPEND(outerIndex)  \n                    END IF  \n                ELSE  \n                    adjacencyList[outerIndex + innerIndex].APPEND(outerIndex)  \n                END IF  \n                SET innerIndex TO innerIndex + 1  \n            END REPEAT  \n            SET outerIndex TO outerIndex + 1  \n        END WHILE  \n\n        DEFINE result AS EMPTY LIST  \n        DEFINE visited AS ARRAY OF SIZE totalTargetLen FILLED WITH False  \n\n        FUNCTION processQueue() RETURNS VOID  \n            IF processingQueue.IS_EMPTY() THEN RETURN END IF  \n            DEFINE currentIndex AS processingQueue.POP_LEFT()  \n            result.APPEND(currentIndex)  \n            DEFINE idx AS 0  \n            WHILE idx LESS THAN totalStampLen  \n                DEFINE pos AS currentIndex + idx  \n                IF visited[pos] EQUALS False THEN  \n                    visited[pos] ← True  \n                    FOR EACH sourceIndex IN adjacencyList[pos]  \n                        incomingEdges[sourceIndex] ← incomingEdges[sourceIndex] - 1  \n                        IF incomingEdges[sourceIndex] EQUALS 0 THEN  \n                            processingQueue.APPEND(sourceIndex)  \n                        END IF  \n                    END FOR  \n                END IF  \n                SET idx TO idx + 1  \n            END WHILE  \n            processQueue()  \n        END FUNCTION  \n\n        processQueue()  \n\n        FOR marker IN visited  \n            IF marker EQUALS False THEN  \n                RETURN EMPTY LIST  \n            END IF  \n        END FOR\n\n        RETURN REVERSE(result)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION movesToStamp(stamp string, target string) RETURNS list of integers  \n        SET m TO the LENGTH OF stamp  \n        SET n TO the LENGTH OF target  \n        SET indeg TO a list of size n MINUS m PLUS one where each element is m  \n        SET q TO an empty double ended queue  \n        SET g TO a list of size n where each element is an empty list  \n        FOR i FROM zero TO n MINUS m  \n            FOR j FROM zero TO m MINUS one  \n                SET c TO element at position j of stamp  \n                IF element at position i PLUS j of target EQUALS c THEN  \n                    DECREMENT element at position i of indeg BY one  \n                    IF element at position i of indeg EQUALS zero THEN  \n                        APPEND i TO q  \n                    END IF  \n                ELSE  \n                    APPEND i TO element at position i PLUS j of g  \n                END IF  \n            END FOR  \n        END FOR  \n        SET ans TO an empty list  \n        SET vis TO a list of size n where each element is False  \n        WHILE q is not empty  \n            SET i TO the element removed from the left of q  \n            APPEND i TO ans  \n            FOR j FROM zero TO m MINUS one  \n                IF element at position i PLUS j of vis EQUALS False THEN  \n                    SET element at position i PLUS j of vis TO True  \n                    FOR each k IN element at position i PLUS j of g  \n                        DECREMENT element at position k of indeg BY one  \n                        IF element at position k of indeg EQUALS zero THEN  \n                            APPEND k TO q  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n        IF all elements of vis are True THEN  \n            RETURN ans in reverse order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "triples-with-bitwise-and-equal-to-zero", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        INITIALIZE pairCountMap AS a default dictionary mapping integer keys to integers  \n        SET indexA TO 0  \n        WHILE indexA < LENGTH(nums)  \n            SET elementA TO nums[indexA]  \n            INITIALIZE indexB TO 0  \n            WHILE indexB < LENGTH(nums)  \n                SET elementB TO nums[indexB]  \n                SET bitwiseKey TO elementB BITWISE_AND elementA  \n                SET existingValue TO 0  \n                IF pairCountMap CONTAINS bitwiseKey THEN  \n                    existingValue ← pairCountMap[bitwiseKey]  \n                END IF  \n                pairCountMap[bitwiseKey] ← existingValue + 1  \n                indexB ← indexB + 1  \n            END WHILE  \n            indexA ← indexA + 1  \n        END WHILE  \n\n        SET accumulatedTriplets TO 0  \n        SET idxC TO 0  \n        WHILE idxC < LENGTH(nums)  \n            SET currentElement TO nums[idxC]  \n            FOR pairKey WITH occurrence IN pairCountMap ITEMS  \n                IF NOT ((pairKey BITWISE_AND currentElement) != 0) THEN  \n                    accumulatedTriplets ← accumulatedTriplets + occurrence  \n                END IF  \n            END FOR  \n            idxC ← idxC + 1  \n        END WHILE  \n\n        RETURN accumulatedTriplets  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        SET pair_and_count TO a new default dictionary of integers  \n        FOR each element i IN nums  \n            FOR each element j IN nums  \n                SET current_key TO the bitwise AND of i AND j  \n                INCREMENT the value at current_key in pair_and_count BY one  \n            END FOR  \n        END FOR  \n        SET triplet_count TO zero  \n        FOR each element k IN nums  \n            FOR each key pair_and and associated count IN pair_and_count items  \n                IF the bitwise AND of pair_and AND k EQUALS zero THEN  \n                    INCREMENT triplet_count BY count  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN triplet_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "grid-illumination", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION gridIllumination(n, lamps, queries)  \n        INITIALIZE freqRows AS a dictionary defaulting to 0  \n        INITIALIZE freqCols AS a dictionary defaulting to 0  \n        INITIALIZE freqDiags AS a dictionary defaulting to 0  \n        INITIALIZE freqAntiDiags AS a dictionary defaulting to 0  \n        INITIALIZE activeLamps AS an empty set  \n        \n        SET idx TO 0  \n        WHILE idx < LENGTH(lamps)  \n            LET x TO lamps[idx][0]  \n            LET y TO lamps[idx][1]  \n            IF NOT (x, y) IN activeLamps  \n                INSERT (x, y) INTO activeLamps  \n                freqRows[x] ← freqRows[x] + 1  \n                freqCols[y] ← freqCols[y] + 1  \n                LET dKey TO x - y  \n                LET adKey TO x + y  \n                freqDiags[dKey] ← freqDiags[dKey] + 1  \n                freqAntiDiags[adKey] ← freqAntiDiags[adKey] + 1  \n            END IF  \n            idx ← idx + 1  \n        END WHILE  \n        \n        DECLARE neighbors AS a list containing (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 0), (0, 1), (1, -1), (1, 0), (1, 1)  \n        \n        DEFINE results AS an empty list  \n        \n        SET qIndex TO 0  \n        WHILE qIndex < LENGTH(queries)  \n            LET currRow TO queries[qIndex][0]  \n            LET currCol TO queries[qIndex][1]  \n            \n            IF freqRows[currRow] > 0 OR freqCols[currCol] > 0 OR freqDiags[currRow - currCol] > 0 OR freqAntiDiags[currRow + currCol] > 0 THEN  \n                APPEND 1 TO results  \n            ELSE  \n                APPEND 0 TO results  \n            END IF  \n            \n            DECLARE nIndex AS 0  \n            WHILE nIndex < LENGTH(neighbors)  \n                LET deltaRow TO neighbors[nIndex][0]  \n                LET deltaCol TO neighbors[nIndex][1]  \n                LET newRow TO currRow + deltaRow  \n                LET newCol TO currCol + deltaCol  \n                \n                IF (newRow, newCol) IN activeLamps THEN  \n                    DELETE (newRow, newCol) FROM activeLamps  \n                    freqRows[newRow] ← freqRows[newRow] - 1  \n                    freqCols[newCol] ← freqCols[newCol] - 1  \n                    freqDiags[newRow - newCol] ← freqDiags[newRow - newCol] - 1  \n                    freqAntiDiags[newRow + newCol] ← freqAntiDiags[newRow + newCol] - 1  \n                END IF  \n                nIndex ← nIndex + 1  \n            END WHILE  \n            qIndex ← qIndex + 1  \n        END WHILE  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION gridIllumination(n, lamps, queries)  \n        SET row_count TO an empty dictionary with default integer zero  \n        SET col_count TO an empty dictionary with default integer zero  \n        SET diag_count TO an empty dictionary with default integer zero  \n        SET anti_diag_count TO an empty dictionary with default integer zero  \n        SET lamp_positions TO an empty set  \n        \n        FOR each pair r c IN the elements of lamps  \n            IF the tuple of r and c is not in lamp_positions  \n                ADD the tuple of r and c TO lamp_positions  \n                INCREMENT the value at key r in row_count BY one  \n                INCREMENT the value at key c in col_count BY one  \n                INCREMENT the value at key the subtraction of c from r in diag_count BY one  \n                INCREMENT the value at key the sum of r and c in anti_diag_count BY one  \n            END IF  \n        END FOR  \n        \n        SET directions TO the list of pairs negative one negative one negative one zero negative one one zero negative one zero zero zero zero one one negative one one zero one one one  \n        \n        SET result TO an empty list  \n        \n        FOR each pair r c IN the elements of queries  \n            IF the value at key r in row_count is greater than zero OR the value at key c in col_count is greater than zero OR the value at key the subtraction of c from r in diag_count is greater than zero OR the value at key the sum of r and c in anti_diag_count is greater than zero  \n                APPEND one TO result  \n            ELSE  \n                APPEND zero TO result  \n            END IF  \n            \n            FOR each pair dr dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF the tuple of nr and nc is in lamp_positions  \n                    REMOVE the tuple of nr and nc FROM lamp_positions  \n                    DECREMENT the value at key nr in row_count BY one  \n                    DECREMENT the value at key nc in col_count BY one  \n                    DECREMENT the value at key the subtraction of nc from nr in diag_count BY one  \n                    DECREMENT the value at key the sum of nr and nc in anti_diag_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parsing-a-boolean-expression", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        INITIALIZE container AS empty list  \n        SET pointer TO 0  \n        WHILE pointer LESS THAN length of expression  \n            LET symbol BE element at position pointer in expression  \n            \n            SWITCH symbol  \n                CASE 't', 'f', '!', '&', '|'  \n                    ADD symbol TO container  \n                    INCREMENT pointer BY 1  \n                    CONTINUE  \n                CASE ')'  \n                    DECLARE tally_true AS 0  \n                    DECLARE tally_false AS 0  \n                    \n                    WHILE container[last element] IS 't' OR container[last element] IS 'f'  \n                        LET current_char BE container[last element]  \n                        \n                        IF current_char IS 't'  \n                            SET tally_true TO tally_true + 1  \n                        END IF  \n                        IF current_char IS 'f'  \n                            SET tally_false TO tally_false + 1  \n                        END IF  \n                        REMOVE last element FROM container  \n                    END WHILE  \n                    \n                    LET operator_char BE container[last element]  \n                    REMOVE last element FROM container  \n                    \n                    IF operator_char IS '!'  \n                        IF tally_false NOT EQUAL TO 0  \n                            SET symbol TO 't'  \n                        ELSE  \n                            SET symbol TO 'f'  \n                        END IF  \n                    ELSE IF operator_char IS '&'  \n                        IF tally_false NOT EQUAL TO 0  \n                            SET symbol TO 'f'  \n                        ELSE  \n                            SET symbol TO 't'  \n                        END IF  \n                    ELSE IF operator_char IS '|'  \n                        IF tally_true NOT EQUAL TO 0  \n                            SET symbol TO 't'  \n                        ELSE  \n                            SET symbol TO 'f'  \n                        END IF  \n                    END IF  \n                    ADD symbol TO container  \n                    INCREMENT pointer BY 1  \n                DEFAULT  \n                    INCREMENT pointer BY 1  \n            END SWITCH  \n        END WHILE  \n        \n        RETURN (container[0] IS 't')  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each c IN expression  \n            IF c EQUALS character representing true OR c EQUALS character representing false OR c EQUALS character representing not OR c EQUALS character representing and OR c EQUALS character representing or  \n                APPEND c TO stk  \n            ELSE IF c EQUALS character representing closing parenthesis  \n                SET count_true TO zero  \n                SET count_false TO zero  \n                WHILE the element at the last position of stk EQUALS character representing true OR the element at the last position of stk EQUALS character representing false  \n                    IF the element at the last position of stk EQUALS character representing true  \n                        INCREMENT count_true BY one  \n                    END IF  \n                    IF the element at the last position of stk EQUALS character representing false  \n                        INCREMENT count_false BY one  \n                    END IF  \n                    REMOVE the element at the last position FROM stk  \n                END WHILE  \n                SET op TO the element at the last position of stk  \n                REMOVE the element at the last position FROM stk  \n                IF op EQUALS character representing not  \n                    IF count_false GREATER THAN zero  \n                        SET c TO character representing true  \n                    ELSE  \n                        SET c TO character representing false  \n                    END IF  \n                ELSE IF op EQUALS character representing and  \n                    IF count_false GREATER THAN zero  \n                        SET c TO character representing false  \n                    ELSE  \n                        SET c TO character representing true  \n                    END IF  \n                ELSE IF op EQUALS character representing or  \n                    IF count_true GREATER THAN zero  \n                        SET c TO character representing true  \n                    ELSE  \n                        SET c TO character representing false  \n                    END IF  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stk EQUALS character representing true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "last-substring-in-lexicographical-order", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        LET lengthVar BE LENGTH OF s  \n        LET highestChar BE MAXIMUM CHARACTER IN s  \n        LET positions BE AN EMPTY LIST  \n        LET index COUNTER TO 0  \n        WHILE index < lengthVar DO  \n            IF s[index] = highestChar THEN  \n                APPEND index TO positions  \n            END IF  \n            SET index TO index + 1  \n        END WHILE  \n\n        LET candidateSubstring BE \"\"  \n        LET posIndex POINTER TO 0  \n        WHILE posIndex < LENGTH OF positions DO  \n            LET substringStart BE positions[posIndex]  \n            LET tempSubstring BE SLICE OF s FROM substringStart TO (LENGTH OF s)  \n            IF NOT (candidateSubstring >= tempSubstring) THEN  \n                SET candidateSubstring TO tempSubstring  \n            END IF  \n            SET posIndex TO posIndex + 1  \n        END WHILE  \n        RETURN candidateSubstring  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-vowels-permutation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION countVowelPermutation(n)\n        DEFINE DIVISOR AS 1_000_000_007\n        INITIALIZE alpha AS 1\n        INITIALIZE beta AS 1\n        INITIALIZE gamma AS 1\n        INITIALIZE delta AS 1\n        INITIALIZE epsilon AS 1\n\n        SET counter TO 2\n        WHILE counter ≤ n DO\n            DEFINE next_alpha AS beta + gamma + epsilon\n            DEFINE next_beta AS alpha + gamma\n            DEFINE next_gamma AS beta + delta\n            DEFINE next_delta AS gamma\n            DEFINE next_epsilon AS gamma + delta\n\n            alpha ← next_alpha MODULO DIVISOR\n            beta ← next_beta MODULO DIVISOR\n            gamma ← next_gamma MODULO DIVISOR\n            delta ← next_delta MODULO DIVISOR\n            epsilon ← next_epsilon MODULO DIVISOR\n\n            INCREMENT counter BY 1\n        END WHILE\n\n        COMPUTE aggregate_total = alpha + beta + gamma + delta + epsilon\n        ASSIGN final_result AS aggregate_total MODULO DIVISOR\n        RETURN final_result\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each index FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder when a_next is DIVIDED BY MOD  \n            SET e TO the remainder when e_next is DIVIDED BY MOD  \n            SET i TO the remainder when i_next is DIVIDED BY MOD  \n            SET o TO the remainder when o_next is DIVIDED BY MOD  \n            SET u TO the remainder when u_next is DIVIDED BY MOD  \n        END FOR  \n        SET total_count TO the sum of a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO the remainder when total_count is DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dice-roll-simulation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION dieSimulator(n, rollMax)\n        SET MOD TO 1000000007\n\n        SET dp TO list of size (n + 1), EACH element a list of size 6, EACH element a list of zeros of size (max element in rollMax + 1)\n\n        SET idx TO 0\n        WHILE idx LESS_THAN 6\n            SET temp_list TO dp[1][idx]\n            temp_list[1] ← 1\n            idx ← idx + 1\n        END WHILE\n\n        SET i TO 2\n        WHILE i LESS_THAN_OR_EQUAL n\n            SET j TO 0\n            WHILE j LESS_THAN 6\n                SET k TO 1\n                WHILE k LESS_THAN_OR_EQUAL rollMax[j]\n                    IF k LESS_THAN 2\n                        SET acc TO 0\n                        SET x TO 0\n                        WHILE x LESS_THAN 6\n                            IF x NOT_EQUALS j THEN\n                                SET y TO 1\n                                WHILE y LESS_THAN_OR_EQUAL rollMax[x]\n                                    acc ← acc + dp[i - 1][x][y]\n                                    y ← y + 1\n                                END WHILE\n                            END IF\n                            x ← x + 1\n                        END WHILE\n                        dp[i][j][k] ← acc MOD MOD\n                    ELSE\n                        dp[i][j][k] ← dp[i - 1][j][k - 1]\n                    END IF\n                    k ← k + 1\n                END WHILE\n                j ← j + 1\n            END WHILE\n            i ← i + 1\n        END WHILE\n\n        SET final_result TO 0  \n        FOR INDEX j FROM 0 TO 5\n            SET subIdx TO 1\n            WHILE subIdx LESS_THAN_OR_EQUAL rollMax[j]\n                ADD dp[n][j][subIdx] TO final_result\n                subIdx ← subIdx + 1\n            END WHILE  \n        END FOR\n\n        RETURN final_result MOD MOD\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution\n    FUNCTION dieSimulator(n, rollMax)\n        SET MOD TO one billion PLUS seven\n\n        SET dp TO a three dimensional list of zeros with dimensions of n PLUS one BY six BY maximum value in rollMax PLUS one\n\n        FOR j FROM zero TO five\n            SET element at position one of list at position j of list at position one of dp TO one\n        END FOR\n\n        FOR i FROM two TO n\n            FOR j FROM zero TO five\n                FOR k FROM one TO element at position j of rollMax\n                    IF k GREATER THAN one\n                        SET element at position k of list at position j of list at position i of dp TO element at position k MINUS one of list at position j of list at position i MINUS one of dp\n                    ELSE\n                        SET total_sum TO zero\n                        FOR x FROM zero TO five\n                            IF x NOT EQUALS j\n                                FOR y FROM one TO element at position x of rollMax\n                                    INCREMENT total_sum BY element at position y of list at position x of list at position i MINUS one of dp\n                                END FOR\n                            END IF\n                        END FOR\n                        SET element at position k of list at position j of list at position i of dp TO total_sum MODULO MOD\n                    END IF\n                END FOR\n            END FOR\n        END FOR\n\n        SET result TO zero\n        FOR j FROM zero TO five\n            FOR k FROM one TO element at position j of rollMax\n                INCREMENT result BY element at position k of list at position j of list at position n of dp\n            END FOR\n        END FOR\n\n        RETURN result MODULO MOD\n    END FUNCTION\nEND CLASS"}
{"task_id": "reverse-subarray-to-maximize-array-value", "label": "cosmetic", "pseudocode": "```\nCLASS Solution\n    FUNCTION maxValueAfterReverse(nums)\n        ASSIGN SIZE OF nums TO lengthCounter\n        IF NOT (lengthCounter GREATER THAN 2) THEN\n            ASSIGN ABS(nums[0] - nums[1]) TO resultVal\n            RETURN resultVal\n        END IF\n\n        ASSIGN 0 TO sumAbsDiff\n        ASSIGN 1 TO idx\n        WHILE idx LESS THAN lengthCounter\n            ASSIGN sumAbsDiff + ABS(nums[idx] - nums[idx - 1]) TO sumAbsDiff\n            ASSIGN idx + 1 TO idx\n        END WHILE\n\n        ASSIGN 0 TO edgeMaxGain\n        ASSIGN 1 TO pointerA\n        WHILE pointerA LESS THAN lengthCounter\n            ASSIGN ABS(nums[0] - nums[pointerA]) - ABS(nums[pointerA] - nums[pointerA - 1]) TO candidateGainA\n            IF candidateGainA GREATER THAN edgeMaxGain THEN\n                ASSIGN candidateGainA TO edgeMaxGain\n            END IF\n            ASSIGN pointerA + 1 TO pointerA\n        END WHILE\n\n        ASSIGN 0 TO pointerB\n        WHILE pointerB LESS THAN lengthCounter - 1\n            ASSIGN ABS(nums[lengthCounter - 1] - nums[pointerB]) - ABS(nums[pointerB + 1] - nums[pointerB]) TO candidateGainB\n            IF candidateGainB GREATER THAN edgeMaxGain THEN\n                ASSIGN candidateGainB TO edgeMaxGain\n            END IF\n            ASSIGN pointerB + 1 TO pointerB\n        END WHILE\n\n        ASSIGN +Infinity TO minMaxPair\n        ASSIGN -Infinity TO maxMinPair\n        ASSIGN 0 TO iteratorC\n        WHILE iteratorC LESS THAN lengthCounter - 1\n            ASSIGN MAX(nums[iteratorC], nums[iteratorC + 1]) TO currentMaxVal\n            IF currentMaxVal LESS THAN minMaxPair THEN\n                ASSIGN currentMaxVal TO minMaxPair\n            END IF\n\n            ASSIGN MIN(nums[iteratorC], nums[iteratorC + 1]) TO currentMinVal\n            IF currentMinVal GREATER THAN maxMinPair THEN\n                ASSIGN currentMinVal TO maxMinPair\n            END IF\n            ASSIGN iteratorC + 1 TO iteratorC\n        END WHILE\n\n        ASSIGN MAX(0, 2 * (maxMinPair - minMaxPair)) TO generalMaxGain\n\n        RETURN sumAbsDiff + MAX(edgeMaxGain, generalMaxGain)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxValueAfterReverse(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS two  \n            RETURN the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position one of nums  \n        END IF  \n        \n        SET initial_value TO zero  \n        FOR i FROM one TO n MINUS one  \n            INCREMENT initial_value BY the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n        END FOR  \n        \n        SET max_edge_gain TO zero  \n        FOR i FROM one TO n MINUS one  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position n MINUS one of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i PLUS one of nums MINUS element at position i of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        SET min_pair TO the MINIMUM VALUE among for each i FROM zero TO n MINUS two the MAXIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        SET max_pair TO the MAXIMUM VALUE among for each i FROM zero TO n MINUS two the MINIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        \n        SET general_gain TO the MAXIMUM VALUE between zero AND two MULTIPLIED BY the DIFFERENCE between max_pair AND min_pair  \n        \n        RETURN initial_value PLUS the MAXIMUM VALUE between max_edge_gain AND general_gain  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-multiple-of-three", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET freq_map AS a mapping from digits to their counts in digits  \n        SET summation TO 0  \n        FOR index FROM 0 TO LENGTH OF digits MINUS 1  \n            summation ← summation PLUS digits[index]  \n        END FOR  \n        SET mod_val AS summation MODULO 3  \n        \n        SWITCH mod_val  \n            CASE 1:  \n                DEFINE singles AS [1, 4, 7]  \n                SET changed_flag AS false  \n                SET pointer AS 0  \n                WHILE pointer < LENGTH OF singles AND changed_flag EQUALS false  \n                    IF freq_map CONTAINS singles[pointer] AND freq_map[singles[pointer]] > 0 THEN  \n                        freq_map[singles[pointer]] ← freq_map[singles[pointer]] MINUS 1  \n                        changed_flag ← true  \n                    END IF  \n                    pointer ← pointer PLUS 1  \n                END WHILE  \n                IF changed_flag EQUALS false THEN  \n                    DEFINE doubles AS [2, 5, 8]  \n                    SET idx AS 0  \n                    WHILE idx < LENGTH OF doubles AND changed_flag EQUALS false  \n                        IF freq_map CONTAINS doubles[idx] AND freq_map[doubles[idx]] > 1 THEN  \n                            freq_map[doubles[idx]] ← freq_map[doubles[idx]] MINUS 2  \n                            changed_flag ← true  \n                        END IF  \n                        idx ← idx PLUS 1  \n                    END WHILE  \n                END IF  \n                BREAK  \n            \n            CASE 2:  \n                DEFINE singles_arr AS [2, 5, 8]  \n                SET done AS false  \n                SET position AS 0  \n                WHILE position < LENGTH OF singles_arr AND done EQUALS false  \n                    IF freq_map CONTAINS singles_arr[position] AND freq_map[singles_arr[position]] > 0 THEN  \n                        freq_map[singles_arr[position]] ← freq_map[singles_arr[position]] MINUS 1  \n                        done ← true  \n                    END IF  \n                    position ← position PLUS 1  \n                END WHILE  \n                IF done EQUALS false THEN  \n                    DEFINE doubles_arr AS [1, 4, 7]  \n                    SET pos AS 0  \n                    WHILE pos < LENGTH OF doubles_arr AND done EQUALS false  \n                        IF freq_map CONTAINS doubles_arr[pos] AND freq_map[doubles_arr[pos]] > 1 THEN  \n                            freq_map[doubles_arr[pos]] ← freq_map[doubles_arr[pos]] MINUS 2  \n                            done ← true  \n                        END IF  \n                        pos ← pos PLUS 1  \n                    END WHILE  \n                END IF  \n                BREAK  \n            DEFAULT:  \n                // no action needed  \n                BREAK  \n        END SWITCH  \n        \n        SET output_segments AS an empty list  \n        SET digit_val AS 9  \n        WHILE digit_val >= 0  \n            IF freq_map CONTAINS digit_val THEN  \n                SET count_value AS freq_map[digit_val]  \n                SET part_str AS empty string  \n                SET iter_num AS 0  \n                WHILE iter_num < count_value  \n                    part_str ← part_str CONCATENATED WITH STRING OF digit_val  \n                    iter_num ← iter_num PLUS 1  \n                END WHILE  \n                IF LENGTH OF part_str > 0 THEN  \n                    output_segments APPEND part_str  \n                END IF  \n            END IF  \n            digit_val ← digit_val MINUS 1  \n        END WHILE  \n        \n        SET assembled_str AS empty string  \n        FOR each segment IN output_segments  \n            assembled_str ← assembled_str CONCATENATED WITH segment  \n        END FOR  \n        \n        IF LENGTH OF assembled_str > 0 THEN  \n            IF assembled_str[0] EQUALS \"0\" THEN  \n                RETURN \"0\"  \n            END IF  \n        ELSE  \n            RETURN \"\"  \n        END IF  \n        \n        RETURN assembled_str  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO the frequency counter of digits  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder after dividing total_sum BY three  \n        IF remainder EQUALS one  \n            FOR each digit d IN the list consisting of one four seven  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of two five eight  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit d IN the list consisting of two five eight  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of one four seven  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        SET result TO an empty list  \n        FOR each digit d FROM nine DOWN TO zero  \n            APPEND the string representation of digit d REPEATED frequency count of digit d times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF the length of final_number IS GREATER THAN zero AND the element at position zero of final_number EQUALS zero  \n            RETURN the string zero  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-the-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer\n        SET MOD TO 1000000000 PLUS 7\n        SET length_s TO LENGTH OF s\n        INITIALIZE dp AS an array containing (length_s PLUS 1) zeros\n        SET dp[0] AS 1\n\n        SET outer_index TO 1\n        WHILE outer_index LESS THAN OR EQUAL TO length_s DO\n            SET inner_idx TO 0\n            WHILE inner_idx LESS THAN outer_index DO\n                SET current_char TO s[inner_idx]\n                IF NOT (current_char EQUALS '0') THEN\n                    SET substring_str TO EXTRACT s FROM inner_idx TO (outer_index MINUS 1)\n                    SET num_value TO CONVERT substring_str TO integer\n                    IF (num_value GREATER THAN OR EQUAL TO 1) AND (num_value LESS THAN OR EQUAL TO k) THEN\n                        SET dp[outer_index] TO (dp[outer_index] PLUS dp[inner_idx]) MODULO MOD\n                    END IF\n                END IF\n                INCREMENT inner_idx BY 1\n            END WHILE\n            INCREMENT outer_index BY 1\n        END WHILE\n\n        RETURN dp[length_s]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        LET rowCount BE LENGTH OF mat  \n        LET colCount BE LENGTH OF FIRST ELEMENT IN mat  \n        LET baseSum BE 0  \n        LET accumulator BE 0  \n        WHILE accumulator < rowCount  \n            baseSum ← baseSum + mat[accumulator][0]  \n            accumulator ← accumulator + 1  \n        END WHILE  \n        \n        LET startIndices BE A TUPLE WITH rowCount COPIES OF 0  \n        LET heapList BE A LIST CONTAINING (baseSum, startIndices)  \n        LET seenIndices BE A SET CONTAINING startIndices  \n        \n        LOOP UNTIL k IS 0  \n            EXTRACT (currentSum, currentIndices) FROM heapList BY REMOVING SMALLEST ELEMENT  \n            k ← k - 1  \n            \n            IF k = 0 THEN RETURN currentSum END IF  \n            \n            LET position BE 0  \n            WHILE position < rowCount DO  \n                LET currentIndexValue BE currentIndices[position]  \n                IF currentIndexValue + 1 < colCount THEN  \n                    LET tempIndices BE CONVERT_TO_LIST(currentIndices)  \n                    LET tempIndexValue BE tempIndices[position] + 1  \n                    tempIndices[position] ← tempIndexValue  \n                    LET nextIndices BE CONVERT_TO_TUPLE(tempIndices)  \n                    \n                    LET replacedSumPart BE mat[position][currentIndexValue]  \n                    LET newSumPart BE mat[position][tempIndexValue]  \n                    LET updatedSum BE currentSum - replacedSumPart + newSumPart  \n                    \n                    IF nextIndices NOT IN seenIndices THEN  \n                        ADD nextIndices TO seenIndices  \n                        ADD (updatedSum, nextIndices) TO heapList  \n                    END IF  \n                END IF  \n                position ← position + 1  \n            END WHILE  \n        END LOOP  \n        \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF the element at position zero of mat  \n        SET initial_sum TO zero  \n        FOR each row IN mat  \n            INCREMENT initial_sum BY the element at position zero of row  \n        END FOR  \n        SET initial_indices TO a tuple of zero repeated m times  \n        SET min_heap TO a list containing a tuple of initial_sum and initial_indices  \n        SET visited TO a set containing initial_indices  \n        \n        WHILE k GREATER THAN zero  \n            EXTRACT the tuple containing current_sum and indices by removing the smallest element from min_heap  \n            DECREMENT k BY one  \n            \n            IF k EQUALS zero  \n                RETURN current_sum  \n            END IF  \n            \n            FOR i FROM zero TO m MINUS one  \n                IF the element at position i of indices PLUS one LESS THAN n  \n                    SET new_indices_list TO a list converted from indices  \n                    INCREMENT the element at position i of new_indices_list BY one  \n                    SET new_indices_tuple TO a tuple converted from new_indices_list  \n                    SET new_sum TO current_sum MINUS the element at position i of mat AT the element at position i of indices PLUS the element at position i of mat AT the element at position i of new_indices_tuple  \n                    \n                    IF new_indices_tuple NOT IN visited  \n                        ADD new_indices_tuple TO visited  \n                        ADD the tuple containing new_sum and new_indices_tuple TO min_heap  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-dot-product-of-two-subsequences", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maxDotProduct(nums1 PARAMETER, nums2 PARAMETER)  \n        SET length1 AS LENGTH OF nums1  \n        SET length2 AS LENGTH OF nums2  \n        CREATE dp AS LIST OF LISTS  \n        FOR index1 FROM 0 TO length1  \n            CREATE row AS LIST  \n            FOR index2 FROM 0 TO length2  \n                APPEND NEGATIVE_INFINITY TO row  \n            END FOR  \n            APPEND row TO dp  \n        END FOR  \n\n        SET outerCounter TO 1  \n        WHILE outerCounter <= length1  \n            SET innerCounter TO 1  \n            WHILE innerCounter <= length2  \n                SET productCurrent TO (nums1[outerCounter - 1]) * (nums2[innerCounter - 1])  \n                SET choice1 TO productCurrent  \n                SET choice2 TO dp[outerCounter - 1][innerCounter]  \n                SET choice3 TO dp[outerCounter][innerCounter - 1]  \n                SET choice4 TO dp[outerCounter - 1][innerCounter - 1] + productCurrent  \n                \n                SET dp[outerCounter][innerCounter] TO choice1  \n                IF choice2 > dp[outerCounter][innerCounter]  \n                    SET dp[outerCounter][innerCounter] TO choice2  \n                END IF  \n                IF choice3 > dp[outerCounter][innerCounter]  \n                    SET dp[outerCounter][innerCounter] TO choice3  \n                END IF  \n                IF choice4 > dp[outerCounter][innerCounter]  \n                    SET dp[outerCounter][innerCounter] TO choice4  \n                END IF  \n                \n                INCREMENT innerCounter BY 1  \n            END WHILE  \n            INCREMENT outerCounter BY 1  \n        END WHILE  \n\n        RETURN dp[length1][length2]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxDotProduct(nums1 PARAMETER, nums2 PARAMETER)  \n        SET m TO the LENGTH OF nums1  \n        SET n TO the LENGTH OF nums2  \n        SET dp TO a new list of lists where each inner list has n PLUS one elements each set TO negative infinity and the outer list has m PLUS one such inner lists  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                SET current_product TO the element at position i MINUS one of nums1 MULTIPLIED BY the element at position j MINUS one of nums2  \n                SET dp element at position i element at position j TO the maximum of the following four values  \n                    current_product  \n                    dp element at position i MINUS one element at position j  \n                    dp element at position i element at position j MINUS one  \n                    dp element at position i MINUS one element at position j MINUS one PLUS current_product  \n            END FOR  \n        END FOR  \n        RETURN dp element at position m element at position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parallel-courses-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minNumberOfSemesters(n k relations)\n        INITIALIZE graph AS a mapping with default empty list for unseen keys\n        INITIALIZE in_degree AS a list containing (n + 1) zeros\n        \n        SET edgeIndex TO 0\n        WHILE edgeIndex < LENGTH(relations)\n            SET fromNode TO relations[edgeIndex][0]\n            SET toNode TO relations[edgeIndex][1]\n            ADD toNode TO graph[fromNode]\n            SET in_degree[toNode] TO in_degree[toNode] + 1\n            INCREMENT edgeIndex BY 1\n        END WHILE\n        \n        INITIALIZE pendingCourses AS empty deque\n        SET courseID TO 1\n        LOOP\n            IF courseID > n THEN BREAK\n            IF in_degree[courseID] = 0 THEN\n                APPEND courseID TO pendingCourses\n            END IF\n            INCREMENT courseID BY 1\n        END LOOP\n        \n        SET semesterCount TO 0\n        \n        WHILE LENGTH(pendingCourses) > 0\n            SET maxCoursesThisRound TO k\n            IF maxCoursesThisRound > LENGTH(pendingCourses) THEN\n                SET maxCoursesThisRound TO LENGTH(pendingCourses)\n            END IF\n            \n            SET counter TO 0\n            RECURSIVE_PROCESS:\n                IF counter >= maxCoursesThisRound THEN\n                    GOTO FINISH_PROCESS\n                END IF\n                \n                SET currentCourse TO REMOVE_LEFT(pendingCourses)\n                FOR every adjacentCourse IN graph[currentCourse]\n                    SET in_degree[adjacentCourse] TO in_degree[adjacentCourse] - 1\n                    IF in_degree[adjacentCourse] = 0 THEN\n                        APPEND adjacentCourse TO pendingCourses\n                    END IF\n                END FOR\n                \n                SET counter TO counter + 1\n                GOTO RECURSIVE_PROCESS\n            FINISH_PROCESS:\n            \n            SET semesterCount TO semesterCount + 1\n        END WHILE\n        \n        RETURN semesterCount\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minNumberOfSemesters(n k relations)  \n        SET graph TO a new mapping with default empty list for each key  \n        SET in_degree TO a list of zeros with length equal to n PLUS one  \n        \n        FOR each pair prevCourse AND nextCourse IN relations  \n            APPEND nextCourse TO the list associated with prevCourse in graph  \n            INCREMENT the element at position nextCourse of in_degree BY one  \n        END FOR  \n        \n        SET queue TO an empty double-ended queue  \n        FOR course FROM one TO n  \n            IF the element at position course of in_degree EQUALS zero  \n                APPEND course TO queue  \n            END IF  \n        END FOR  \n        \n        SET semesters TO zero  \n        \n        WHILE queue holds any elements  \n            SET numberOfCoursesThisSemester TO the smaller of k AND the length of queue  \n            FOR index FROM one TO numberOfCoursesThisSemester  \n                REMOVE the element from the left end of queue AND ASSIGN to current_course  \n                FOR each next_course IN the list associated with current_course in graph  \n                    DECREMENT the element at position next_course of in_degree BY one  \n                    IF the element at position next_course of in_degree EQUALS zero  \n                        APPEND next_course TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT semesters BY one  \n        END WHILE  \n        \n        RETURN semesters  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-connect-two-groups-of-points", "label": "cosmetic", "pseudocode": "```\nCLASS Solution\n    FUNCTION connectTwoGroups(cost)\n        SET lengthA AS LENGTH OF cost\n        SET lengthB AS LENGTH OF cost[0]\n\n        SET dp AS LIST OF LISTS WITH (lengthA + 1) ROWS AND (2 ^ lengthB) COLUMNS FILLED WITH INFINITY\n        dp[0][0] ← 0\n\n        SET outerIndex TO 0\n        WHILE outerIndex < lengthA\n            SET maskIndex TO 0\n            WHILE maskIndex < (2 ^ lengthB)\n                SET innerIndex TO 0\n                WHILE innerIndex < lengthB\n                    dp[outerIndex + 1][maskIndex BITWISE_OR (1 << innerIndex)] ←\n                        MINIMUM(\n                            dp[outerIndex + 1][maskIndex BITWISE_OR (1 << innerIndex)],\n                            dp[outerIndex][maskIndex] + cost[outerIndex][innerIndex]\n                        )\n                    innerIndex ← innerIndex + 1\n                END WHILE\n\n                SET checkIndex TO 0\n                WHILE checkIndex < lengthB\n                    IF (maskIndex BITWISE_AND (1 << checkIndex)) ≠ 0 THEN\n                        dp[outerIndex + 1][maskIndex] ←\n                            MINIMUM(\n                                dp[outerIndex + 1][maskIndex],\n                                dp[outerIndex + 1][maskIndex BITWISE_XOR (1 << checkIndex)] + cost[outerIndex][checkIndex]\n                            )\n                    ENDIF\n                    checkIndex ← checkIndex + 1\n                END WHILE\n\n                maskIndex ← maskIndex + 1\n            END WHILE\n            outerIndex ← outerIndex + 1\n        END WHILE\n\n        RETURN dp[lengthA][(2 ^ lengthB) - 1]\n    END FUNCTION\nEND CLASS\n```", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION connectTwoGroups(cost)  \n        SET size1 TO the LENGTH OF cost  \n        SET size2 TO the LENGTH OF element at position zero of cost  \n        SET dp TO a two dimensional list with size1 PLUS one rows and two TO THE power OF size2 columns FILLED WITH infinity VALUE  \n        SET element at position zero at position zero of dp TO zero  \n        \n        FOR i FROM zero TO size1 MINUS one  \n            FOR mask FROM zero TO two TO THE power OF size2 MINUS one  \n                FOR j FROM zero TO size2 MINUS one  \n                    SET element at position i PLUS one at position mask ORED WITH two TO THE power OF j of dp TO the MINIMUM VALUE BETWEEN element at position i PLUS one at position mask ORED WITH two TO THE power OF j of dp AND the SUM OF element at position i at position mask of dp PLUS element at position i at position j of cost  \n                END FOR  \n                FOR j FROM zero TO size2 MINUS one  \n                    IF the BITWISE AND OF mask AND two TO THE power OF j IS NOT EQUAL TO zero  \n                        SET element at position i PLUS one at position mask of dp TO the MINIMUM VALUE BETWEEN element at position i PLUS one at position mask of dp AND the SUM OF element at position i PLUS one at position mask XORED WITH two TO THE power OF j of dp PLUS element at position i at position j of cost  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position size1 at position two TO THE power OF size2 MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "create-sorted-array-through-instructions", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        ASSIGN MOD ← 1 + (10 ^ 9)  \n        ASSIGN MAX ← 1 + MAX_VALUE(instructions)  \n        ASSIGN bit ← LIST_OF_ZEROS_WITH_LENGTH(MAX)  \n\n        FUNCTION update(idx val)  \n            LOOP  \n                IF NOT (idx < MAX) THEN BREAK  \n                bit[idx] ← bit[idx] + val  \n                idx ← idx + (idx AND (-idx))  \n            END LOOP  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            ASSIGN acc ← 0  \n            REPEAT WHILE idx > 0  \n                acc ← acc + bit[idx]  \n                idx ← idx - (idx AND (-idx))  \n            END REPEAT  \n            RETURN acc  \n        END FUNCTION  \n\n        ASSIGN total_cost ← 0  \n        SET enumerator ← ENUMERATE(instructions)  \n        FOR EACH i_num IN enumerator  \n            LET i ← i_num[0]  \n            LET num ← i_num[1]  \n            ASSIGN less_than ← query(num - 1)  \n            ASSIGN greater_than ← i - query(num)  \n            IF less_than <= greater_than THEN  \n                ASSIGN cost ← less_than  \n            ELSE  \n                ASSIGN cost ← greater_than  \n            END IF  \n            total_cost ← (total_cost + cost) MOD MOD  \n            CALL update(num, 1)  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET MAX TO the maximum element of instructions PLUS one  \n        SET bit TO a list of zeros with length MAX  \n\n        FUNCTION update(idx val)  \n            WHILE idx LESS THAN MAX holds  \n                INCREMENT element at position idx of bit BY val  \n                INCREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            SET total TO zero  \n            WHILE idx GREATER THAN zero holds  \n                INCREMENT total BY element at position idx of bit  \n                DECREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n            RETURN total  \n        END FUNCTION  \n\n        SET total_cost TO zero  \n        FOR each pair of i num IN the enumeration of instructions  \n            SET less_than TO the result of query with argument num MINUS one  \n            SET greater_than TO i MINUS the result of query with argument num  \n            IF less_than LESS THAN OR EQUAL TO greater_than holds  \n                SET cost TO less_than  \n            ELSE  \n                SET cost TO greater_than  \n            END IF  \n            SET total_cost TO the remainder of total_cost PLUS cost DIVIDED BY MOD  \n            CALL update with arguments num and one  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-incompatibility", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        LET totalElements ← LENGTH nums  \n        LET sizePerSubset ← totalElements DIV k  \n        LET elementCounts ← COUNT ELEMENTS IN nums  \n        \n        FOR countValue IN elementCounts.VALUES  \n            IF countValue > k THEN RETURN -1  \n        END FOR  \n        \n        LET incompatibilityMap ← EMPTY DICTIONARY  \n        LET maxMask ← (2 POWER totalElements) - 1  \n        LET currentMask ← 0  \n        \n        WHILE currentMask <= maxMask DO  \n            LET bitsSet ← COUNT OF BITS SET IN currentMask  \n            \n            IF bitsSet = sizePerSubset THEN  \n                LET collected ← EMPTY LIST  \n                LET index ← 0  \n                \n                WHILE index < totalElements DO  \n                    IF (currentMask BITWISE-AND (2 POWER index)) ≠ 0 THEN  \n                        collected.APPEND(nums[index])  \n                    END IF  \n                    index ← index + 1  \n                END WHILE  \n                \n                LET uniqueElements ← SET OF collected  \n                IF LENGTH uniqueElements = sizePerSubset THEN  \n                    LET maxVal ← MAX OF collected  \n                    LET minVal ← MIN OF collected  \n                    LET diff ← maxVal - minVal  \n                    incompatibilityMap[currentMask] ← diff  \n                END IF  \n            END IF  \n            \n            currentMask ← currentMask + 1  \n        END WHILE  \n        \n        LET dpArray ← ARRAY OF SIZE (2 POWER totalElements) FILLED WITH INFINITY  \n        dpArray[0] ← 0  \n        \n        FOR maskValue FROM 0 TO maxMask DO  \n            IF (COUNT OF BITS SET IN maskValue) MOD sizePerSubset ≠ 0 THEN CONTINUE  \n            \n            FOR each candidateSubset IN incompatibilityMap.KEYS DO  \n                IF (maskValue BITWISE-AND candidateSubset) = candidateSubset THEN  \n                    LET attempt ← dpArray[maskValue - candidateSubset] + incompatibilityMap[candidateSubset]  \n                    IF attempt < dpArray[maskValue] THEN  \n                        dpArray[maskValue] ← attempt  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        LET fullSetMask ← maxMask  \n        IF dpArray[fullSetMask] ≠ INFINITY THEN  \n            RETURN dpArray[fullSetMask]  \n        ELSE  \n            RETURN -1  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        CREATE counter_object AS a COUNT of each element IN nums  \n        IF any count IN the VALUES OF counter_object is GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        CREATE empty dictionary subset_incompatibility  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask  \n            IF bit_count EQUALS subset_size THEN  \n                CREATE empty list elements  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BITWISE AND OF mask AND TWO RAISED TO THE POWER OF i is NOT EQUAL TO zero THEN  \n                        APPEND element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the NUMBER OF UNIQUE ELEMENTS IN elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM ELEMENT IN elements MINUS the MINIMUM ELEMENT IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT key mask  \n                END IF  \n            END IF  \n        END FOR  \n        CREATE list dp WITH LENGTH TWO RAISED TO THE POWER OF n FILLED WITH infinity  \n        SET dp AT position zero TO zero  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            IF the REMAINDER OF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask DIVIDED BY subset_size IS NOT EQUAL TO zero THEN  \n                CONTINUE TO the NEXT iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND OF mask AND subset_mask EQUALS subset_mask THEN  \n                    SET candidate_value TO dp AT position mask MINUS subset_mask PLUS subset_incompatibility AT subset_mask  \n                    IF candidate_value IS LESS THAN dp AT position mask THEN  \n                        SET dp AT position mask TO candidate_value  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET full_mask TO TWO RAISED TO THE POWER OF n MINUS one  \n        IF dp AT position full_mask IS NOT EQUAL TO infinity THEN  \n            RETURN dp AT position full_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-xor-with-an-element-from-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximizeXor(nums PARAMETER, queries PARAMETER)\n        CALL sort on nums to arrange numbers in ascending order\n\n        SET indexed_queries TO list created by enumerating queries\n        CALL sort on indexed_queries with sorting key as the second element of each query sublist\n        ASSIGN sorted_queries TO indexed_queries\n\n        ASSIGN answers TO list of length equal to length of queries, each element set to -1\n\n        INITIALIZE root AS empty dictionary\n\n        ASSIGN pointer TO 0\n\n        ASSIGN idx TO 0\n        WHILE idx LESS THAN length of sorted_queries\n            ASSIGN q_index, (val_x, val_m) TO sorted_queries[idx]\n\n            WHILE pointer LESS THAN length of nums AND nums[pointer] LESS THAN OR EQUAL TO val_m\n                ASSIGN current_num TO nums[pointer]\n                ASSIGN current_node TO root\n\n                ASSIGN bit_pos TO 31\n                WHILE bit_pos GREATER THAN OR EQUAL TO 0\n                    ASSIGN bit_val TO (current_num DIVIDE BY (2 TO THE POWER bit_pos)) MODULO 2\n                    IF NOT bit_val IS A KEY IN current_node\n                        ASSIGN current_node[bit_val] TO empty dictionary\n                    END IF\n                    ASSIGN current_node TO current_node[bit_val]\n                    DECREASE bit_pos BY 1\n                END WHILE\n\n                INCREMENT pointer BY 1\n            END WHILE\n\n            IF root IS EMPTY\n                INCREMENT idx BY 1\n                CONTINUE\n            END IF\n\n            ASSIGN current_node TO root\n            ASSIGN xor_max TO 0\n            ASSIGN bit_pos TO 31\n\n            WHILE bit_pos GREATER THAN OR EQUAL TO 0\n                ASSIGN bit_val TO (val_x DIVIDE BY (2 TO THE POWER bit_pos)) MODULO 2\n                ASSIGN flipped_bit TO (1 - bit_val)\n\n                IF flipped_bit IS A KEY IN current_node\n                    SET xor_max TO xor_max PLUS (2 TO THE POWER bit_pos)\n                    ASSIGN current_node TO current_node[flipped_bit]\n                ELSE\n                    ASSIGN current_node TO current_node[bit_val]\n                END IF\n                DECREASE bit_pos BY 1\n            END WHILE\n\n            ASSIGN answers[q_index] TO xor_max\n            INCREMENT idx BY 1\n        END WHILE\n\n        RETURN answers\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximizeXor(nums PARAMETER, queries PARAMETER)  \n        CALL sort on nums to arrange numbers in ascending order  \n        \n        CALL sorted on enumeration of queries with sorting key as the second element of query sublist to arrange queries in ascending order by the maximum value parameter  \n        ASSIGN sorted_queries TO this sorted result  \n        \n        INITIALIZE result as a list with the length equal to the length of queries filled with negative one  \n        \n        INITIALIZE an empty dictionary named trie  \n        \n        SET num_index TO zero  \n        \n        FOR each query_index and a tuple of two elements xi and mi IN sorted_queries  \n            WHILE num_index is less than the length of nums AND the element at position num_index of nums is LESS THAN OR EQUAL TO mi  \n                SET num TO element at position num_index of nums  \n                ASSIGN reference TO trie in variable named node  \n                \n                FOR i FROM thirty-one DOWN TO zero  \n                    SET bit TO the integer value of num DIVIDED BY two RAISED TO power i THEN TAKE the remainder after division by two  \n                    IF bit NOT IN keys of node  \n                        SET element at key bit of node TO an empty dictionary  \n                    END IF  \n                    ASSIGN reference TO element at key bit of node  \n                END FOR  \n                \n                INCREMENT num_index BY one  \n            END WHILE  \n            \n            IF trie IS empty  \n                CONTINUE to next iteration of FOR loop  \n            END IF  \n            \n            ASSIGN reference TO trie in variable named node  \n            SET max_xor TO zero  \n            \n            FOR i FROM thirty-one DOWN TO zero  \n                SET bit TO the integer value of xi DIVIDED BY two RAISED TO power i THEN TAKE the remainder after division by two  \n                SET toggle_bit TO one MINUS bit  \n                \n                IF toggle_bit IN keys of node  \n                    SET max_xor TO max_xor PLUS two RAISED TO power i  \n                    ASSIGN reference TO element at key toggle_bit of node  \n                ELSE  \n                    ASSIGN reference TO element at key bit of node  \n                END IF  \n            END FOR  \n            \n            SET element at position query_index of result TO max_xor  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-different-subsequences-gcds", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET upper_bound AS the largest element found in nums  \n        SET elements_map AS a mapping of all items in nums to true  \n        SET total_count AS 0  \n        SET g_index AS 1  \n        WHILE g_index <= upper_bound DO  \n            SET current_gcd AS 0  \n            SET multiplier AS 1  \n            LOOP   \n                SET candidate_num AS g_index * multiplier  \n                IF candidate_num > upper_bound THEN  \n                    EXIT LOOP  \n                END IF  \n                IF elements_map HAS candidate_num THEN  \n                    SET current_gcd AS gcd(current_gcd, candidate_num)  \n                    IF current_gcd = g_index THEN  \n                        total_count ← total_count + 1  \n                        EXIT LOOP  \n                    END IF  \n                END IF  \n                SET multiplier ← multiplier + 1  \n            END LOOP  \n            SET g_index ← g_index + 1  \n        END WHILE  \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET max_num TO the maximum value in nums  \n        SET num_set TO the set of elements in nums  \n        SET count TO zero  \n        FOR g FROM one TO max_num INCLUSIVE  \n            SET gcd_val TO zero  \n            FOR m FROM g TO max_num INCLUSIVE IN STEPS OF g  \n                IF element at position m of num_set IS PRESENT  \n                    SET gcd_val TO the greatest common divisor of gcd_val AND m  \n                    IF gcd_val EQUALS g  \n                        INCREMENT count BY one  \n                        BREAK out of inner loop  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter of list of integers k parameter of integer) RETURNS integer  \n        SET sum_total AS 0  \n        SET length_nums AS 0  \n        \n        SET iterator_index AS 0  \n        WHILE iterator_index LESS THAN length of nums  \n            SET sum_total AS sum_total PLUS element at position iterator_index of nums  \n            SET iterator_index AS iterator_index PLUS 1  \n        END WHILE  \n        \n        SET length_nums AS length of nums  \n        \n        CREATE diff_counts_left AS a dictionary defaulting to 0  \n        CREATE diff_counts_right AS a dictionary defaulting to 0  \n        \n        SET prefix_sum AS 0  \n        SET counter AS 0  \n        REPEAT  \n            EXIT WHEN counter GREATER OR EQUAL TO (length_nums MINUS 1)  \n            SET prefix_sum AS prefix_sum PLUS element at position counter of nums  \n            SET difference_val AS sum_total MINUS (2 MULTIPLIED BY prefix_sum)  \n            SET diff_counts_right[difference_val] AS diff_counts_right[difference_val] PLUS 1  \n            SET counter AS counter PLUS 1  \n        END REPEAT  \n        \n        SET maximum_ways AS diff_counts_right[0]  \n        \n        SET prefix_sum AS 0  \n        SET index_iter AS 0  \n        FROM WHILE index_iter LESS THAN length_nums DO  \n            SET prefix_sum AS prefix_sum PLUS element at position index_iter of nums  \n            \n            SET delta_diff AS k MINUS element at position index_iter of nums  \n            \n            SET ways_new AS diff_counts_left[NEGATIVE delta_diff] PLUS diff_counts_right[delta_diff]  \n            \n            IF maximum_ways LESS THAN ways_new THEN  \n                SET maximum_ways AS ways_new  \n            END IF  \n            \n            SET current_diff AS sum_total MINUS (2 MULTIPLIED BY prefix_sum)  \n            \n            SET diff_counts_right[current_diff] AS diff_counts_right[current_diff] MINUS 1  \n            SET diff_counts_left[current_diff] AS diff_counts_left[current_diff] PLUS 1  \n            \n            SET index_iter AS index_iter PLUS 1  \n        END FROM  \n        \n        RETURN maximum_ways  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter of list of integers k parameter of integer) RETURNS integer  \n        SET total_sum TO the sum of all elements of nums  \n        SET n TO the length of nums  \n        \n        CREATE left_diff as a dictionary with default integer zero  \n        CREATE right_diff as a dictionary with default integer zero  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value associated with diff in right_diff BY one  \n        END FOR  \n        \n        SET max_ways TO the value associated with zero in right_diff  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            \n            SET diff_change TO k MINUS the element at position i of nums  \n            \n            SET new_ways TO the value associated with negative diff_change in left_diff PLUS the value associated with diff_change in right_diff  \n            \n            IF new_ways GREATER THAN max_ways  \n                SET max_ways TO new_ways  \n            END IF  \n            \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value associated with diff in right_diff BY one  \n            INCREMENT the value associated with diff in left_diff BY one  \n        END FOR  \n        \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-array-into-two-arrays-to-minimize-sum-difference", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minimumDifference(nums)\n        ASSIGN (LENGTH OF nums) DIV 2 TO half_length\n        ASSIGN ADD ALL ELEMENTS IN nums TO sum_total\n        ASSIGN sum_total DIV 2 TO half_target\n        ASSIGN positive infinity TO minimal_difference\n\n        ASSIGN SUBARRAY OF nums FROM INDEX 0 TO half_length EXCLUSIVE TO left_segment\n        ASSIGN SUBARRAY OF nums FROM INDEX half_length TO END TO right_segment\n\n        ASSIGN A LIST OF (half_length + 1) EMPTY MAPS TO sums_left\n        ASSIGN A LIST OF (half_length + 1) EMPTY MAPS TO sums_right\n\n        ASSIGN 0 TO idx_i\n        WHILE idx_i <= half_length\n            FOR EACH grouping IN COMBINATIONS(left_segment, idx_i) DO\n                ASSIGN SUM OF grouping TO curr_sum\n                IF curr_sum NOT IN sums_left[idx_i] THEN\n                    ASSIGN 0 TO sums_left[idx_i][curr_sum]\n                END IF\n                ASSIGN sums_left[idx_i][curr_sum] + 1 TO sums_left[idx_i][curr_sum]\n            END FOR\n\n            FOR EACH grouping IN COMBINATIONS(right_segment, idx_i) DO\n                ASSIGN SUM OF grouping TO curr_sum\n                IF curr_sum NOT IN sums_right[idx_i] THEN\n                    ASSIGN 0 TO sums_right[idx_i][curr_sum]\n                END IF\n                ASSIGN sums_right[idx_i][curr_sum] + 1 TO sums_right[idx_i][curr_sum]\n            END FOR\n            ASSIGN idx_i + 1 TO idx_i\n        END WHILE\n\n        ASSIGN 0 TO idx_i\n        WHILE idx_i <= half_length\n            ASSIGN SORTED KEYS OF sums_left[idx_i] TO left_keys_sorted\n            ASSIGN SORTED KEYS OF sums_right[half_length - idx_i] TO right_keys_sorted\n\n            ASSIGN 0 TO ptr_left\n            ASSIGN LENGTH OF right_keys_sorted - 1 TO ptr_right\n\n            WHILE ptr_left < LENGTH OF left_keys_sorted AND ptr_right >= 0\n                ASSIGN left_keys_sorted[ptr_left] + right_keys_sorted[ptr_right] TO combined_sum\n                ASSIGN sum_total - 2 * combined_sum TO candidate_diff\n\n                IF candidate_diff < 0 THEN\n                    ASSIGN -candidate_diff TO candidate_diff\n                END IF\n\n                IF candidate_diff < minimal_difference THEN\n                    ASSIGN candidate_diff TO minimal_difference\n                END IF\n\n                IF combined_sum < half_target THEN\n                    INCREMENT ptr_left BY 1\n                ELSE IF combined_sum > half_target THEN\n                    DECREMENT ptr_right BY 1\n                ELSE\n                    RETURN 0\n                END IF\n            END WHILE\n            INCREMENT idx_i BY 1\n        END WHILE\n\n        RETURN minimal_difference\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumDifference(nums)  \n        SET n TO the LENGTH OF nums DIVIDED BY two  \n        SET total_sum TO the SUM OF nums  \n        SET target TO total_sum DIVIDED BY two  \n        SET min_diff TO positive infinity  \n        \n        SET left_half TO the first n elements of nums  \n        SET right_half TO the elements of nums from position n plus one TO the end  \n        \n        SET left_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        SET right_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        \n        FOR i FROM zero TO n  \n            FOR each combination of i elements IN left_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN left_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN left_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN left_sums at position i BY one  \n            END FOR  \n            \n            FOR each combination of i elements IN right_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN right_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN right_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN right_sums at position i BY one  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO n  \n            SET left_values TO the keys of left_sums at position i SORTED in ascending order  \n            SET right_values TO the keys of right_sums at position n MINUS i SORTED in ascending order  \n            \n            SET j TO zero  \n            SET k TO the LENGTH OF right_values MINUS one  \n            \n            WHILE j LESS THAN the LENGTH OF left_values AND k GREATER THAN OR EQUAL TO zero  \n                SET current_sum TO the element at position j of left_values PLUS the element at position k of right_values  \n                SET diff_candidate TO total_sum MINUS two MULTIPLIED BY current_sum  \n                IF diff_candidate IS LESS THAN zero  \n                    SET diff_candidate TO the NEGATIVE of diff_candidate  \n                END IF  \n                IF diff_candidate LESS THAN min_diff  \n                    SET min_diff TO diff_candidate  \n                END IF  \n                \n                IF current_sum LESS THAN target  \n                    INCREMENT j BY one  \n                ELSE IF current_sum GREATER THAN target  \n                    DECREMENT k BY one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits AS list of list of integers, startPos AS integer, k AS integer) RETURNS integer  \n        SET resultMax TO 0  \n        SET currSum TO 0  \n        SET windowStart TO 0  \n        \n        SET rightPtr TO 0  \n        WHILE rightPtr < LENGTH(fruits)  \n            SET currPos TO fruits[rightPtr][0]  \n            SET currCount TO fruits[rightPtr][1]  \n            SET currSum TO currSum + currCount  \n            \n            WHILE windowStart <= rightPtr  \n                SET leftPos TO fruits[windowStart][0]  \n                SET rightPos TO fruits[rightPtr][0]  \n                SET leftCondInclusive TO (startPos - k)  \n                SET rightCondInclusive TO (startPos + k)  \n                SET distLeft TO ABS(leftPos - startPos)  \n                SET distRight TO ABS(rightPos - startPos)  \n                SET minDist TO IF distLeft < distRight THEN distLeft ELSE distRight  \n                SET rangeSpan TO rightPos - leftPos  \n                SET condition1 TO (leftCondInclusive <= leftPos) AND (leftPos <= rightCondInclusive)  \n                SET condition2 TO (leftCondInclusive <= rightPos) AND (rightPos <= rightCondInclusive)  \n                SET condition3 TO ((minDist + rangeSpan) <= k)  \n                IF NOT (condition1 AND condition2 AND condition3) THEN  \n                    SET currSum TO currSum - fruits[windowStart][1]  \n                    SET windowStart TO windowStart + 1  \n                ELSE  \n                    BREAK  \n                END IF  \n            END WHILE  \n            \n            IF resultMax < currSum  \n                SET resultMax TO currSum  \n            END IF  \n            SET rightPtr TO rightPtr + 1  \n        END WHILE  \n        \n        RETURN resultMax  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits AS list of list of integers, startPos AS integer, k AS integer) RETURNS integer  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        \n        FOR right FROM zero TO the length of fruits MINUS one  \n            SET position TO the element at position zero of the element at position right of fruits  \n            SET amount TO the element at position one of the element at position right of fruits  \n            INCREMENT total_fruits BY amount  \n            \n            WHILE left LESS THAN OR EQUAL TO right AND NOT  \n                (startPos MINUS k LESS THAN OR EQUAL TO the element at position zero of the element at position left of fruits AND  \n                the element at position zero of the element at position left of fruits LESS THAN OR EQUAL TO startPos PLUS k AND  \n                startPos MINUS k LESS THAN OR EQUAL TO the element at position zero of the element at position right of fruits AND  \n                the element at position zero of the element at position right of fruits LESS THAN OR EQUAL TO startPos PLUS k AND  \n                the minimum value of the absolute value of the element at position zero of the element at position right of fruits MINUS startPos AND the absolute value of the element at position zero of the element at position left of fruits MINUS startPos PLUS the element at position zero of the element at position right of fruits MINUS the element at position zero of the element at position left of fruits) LESS THAN OR EQUAL TO k  \n            DO  \n                DECREMENT total_fruits BY the element at position one of the element at position left of fruits  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            IF max_fruits LESS THAN total_fruits  \n                SET max_fruits TO total_fruits  \n            END IF  \n        END FOR  \n        \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-good-people-based-on-statements", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumGood(statements)\n        ASSIGN n AS LENGTH(statements)\n        LET maximumCount BE 0\n        LET mask BE 0\n        WHILE mask < (1 << n)\n            DECLARE truthful AS ARRAY OF n ELEMENTS FILLED WITH FALSE\n            DECLARE deceitful AS ARRAY OF n ELEMENTS FILLED WITH FALSE\n            LET position BE 0\n            REPEAT UNTIL position = n\n                LET bitmask BE (1 << position)\n                IF (mask & bitmask) = bitmask THEN\n                    truthful[position] ← TRUE\n                ELSE\n                    deceitful[position] ← TRUE\n                END IF\n                position ← position + 1\n            END REPEAT\n            LET isConsistent BE TRUE\n            LET idx BE 0\n            WHILE idx < n AND isConsistent\n                IF truthful[idx] = TRUE THEN\n                    LET innerIdx BE 0\n                    REPEAT UNTIL innerIdx = n OR NOT isConsistent\n                        LET statementValue BE statements[idx][innerIdx]\n                        IF (statementValue = 0 AND truthful[innerIdx] = TRUE) OR (statementValue = 1 AND deceitful[innerIdx] = TRUE) THEN\n                            isConsistent ← FALSE\n                        END IF\n                        innerIdx ← innerIdx + 1\n                    END REPEAT\n                END IF\n                idx ← idx + 1\n            END WHILE\n            IF isConsistent THEN\n                LET countTruthful BE 0\n                FOR countIdx FROM 0 TO n - 1\n                    IF truthful[countIdx] = TRUE THEN\n                        countTruthful ← countTruthful + 1\n                    END IF\n                END FOR\n                IF countTruthful > maximumCount THEN\n                    maximumCount ← countTruthful\n                END IF\n            END IF\n            mask ← mask + 1\n        END WHILE\n        RETURN maximumCount\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-substring-with-given-hash-value", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION subStrHash(s string power integer modulo integer k integer hashValue integer) RETURNS string  \n        FUNCTION val(c character) RETURNS integer  \n            RETURN (UNICODE(c) - UNICODE('a')) + 1  \n        END FUNCTION  \n\n        SET length_s AS LENGTH(s)  \n        SET rolling_hash TO 0  \n        SET multiplier TO 1  \n\n        SET idx TO length_s - k  \n        WHILE idx < length_s  \n            SET char_val TO val(s[idx])  \n            SET rolling_hash TO (rolling_hash + (char_val * multiplier) MOD modulo) MOD modulo  \n            IF idx < length_s - 1 THEN  \n                SET multiplier TO (multiplier * power) MOD modulo  \n            END IF  \n            SET idx TO idx + 1  \n        END WHILE  \n\n        SET substring_start TO length_s - k  \n        IF rolling_hash = hashValue THEN  \n            RETURN SUBSTRING(s, substring_start, length_s - 1)  \n        END IF  \n\n        SET highest_power TO multiplier  \n\n        SET j TO length_s - k - 1  \n        WHILE j >= 0  \n            SET removed_char_val TO val(s[j + k])  \n            SET rolling_hash TO rolling_hash - (removed_char_val * highest_power)  \n            SET rolling_hash TO rolling_hash MOD modulo  \n            IF rolling_hash < 0 THEN  \n                SET rolling_hash TO rolling_hash + modulo  \n            END IF  \n            SET rolling_hash TO ((rolling_hash * power) + val(s[j])) MOD modulo  \n\n            IF rolling_hash = hashValue THEN  \n                SET substring_start TO j  \n            END IF  \n            SET j TO j - 1  \n        END WHILE  \n\n        RETURN SUBSTRING(s, substring_start, substring_start + k - 1)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION subStrHash(s string power integer modulo integer k integer hashValue integer) RETURNS string  \n        FUNCTION val(c character) RETURNS integer  \n            RETURN the unicode code of character c MINUS the unicode code of character a PLUS one  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF string s  \n        SET current_hash TO zero  \n        SET p_pow TO one  \n\n        FOR i FROM n MINUS k TO n MINUS one  \n            SET current_hash TO current_hash PLUS val(the element at position i of s) MULTIPLIED BY p_pow MODULO modulo  \n            IF i LESS THAN n MINUS one  \n                SET p_pow TO p_pow MULTIPLIED BY power MODULO modulo  \n            END IF  \n        END FOR  \n\n        SET start_index TO n MINUS k  \n        IF current_hash EQUALS hashValue  \n            RETURN the substring from position start_index TO the position one LESS THAN n of s  \n        END IF  \n\n        SET p_pow_k_minus_1 TO p_pow  \n\n        FOR i FROM n MINUS k MINUS one DOWN TO zero  \n            SET current_hash TO current_hash MINUS val(the element at position i PLUS k of s) MULTIPLIED BY p_pow_k_minus_1 MODULO modulo  \n            SET current_hash TO current_hash MULTIPLIED BY power PLUS val(the element at position i of s) MODULO modulo  \n\n            IF current_hash EQUALS hashValue  \n                SET start_index TO i  \n            END IF  \n        END FOR  \n\n        RETURN the substring from position start_index TO the position start_index PLUS k MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-array-pairs-divisible-by-k", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET divisorFrequency AS a new counter collection  \n        \n        SET indexA TO 0  \n        WHILE indexA < LENGTH(nums)  \n            SET currentNum TO nums[indexA]  \n            SET divisorKey TO gcd(currentNum, k)  \n            INCREMENT divisorFrequency AT divisorKey BY 1  \n            SET indexA TO indexA + 1  \n        END WHILE  \n        \n        SET pairSum TO 0  \n        \n        SET divisorList TO KEYS(divisorFrequency)  \n        SET totalDivisors TO LENGTH(divisorList)  \n        \n        SET outerIdx TO 0  \n        WHILE outerIdx < totalDivisors  \n            SET innerIdx TO outerIdx  \n            WHILE innerIdx < totalDivisors  \n                SET firstDivisor TO divisorList[outerIdx]  \n                SET secondDivisor TO divisorList[innerIdx]  \n                \n                IF (firstDivisor * secondDivisor) MOD k = 0 THEN  \n                    IF outerIdx = innerIdx THEN  \n                        SET freqVal TO divisorFrequency[firstDivisor]  \n                        SET pairSum TO pairSum + (freqVal * (freqVal - 1)) / 2  \n                    ELSE  \n                        SET pairSum TO pairSum + (divisorFrequency[firstDivisor] * divisorFrequency[secondDivisor])  \n                    END IF  \n                END IF  \n                \n                SET innerIdx TO innerIdx + 1  \n            END WHILE  \n            SET outerIdx TO outerIdx + 1  \n        END WHILE  \n        \n        RETURN pairSum  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET gcd_count TO a new counter collection  \n        \n        FOR each num IN nums  \n            INCREMENT the count in gcd_count for the gcd of num AND k BY one  \n        END FOR  \n        \n        SET total_pairs TO zero  \n        \n        SET gcd_values TO the list of keys of gcd_count  \n        SET n TO the length of gcd_values  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET gcd1 TO the element at position i of gcd_values  \n                SET gcd2 TO the element at position j of gcd_values  \n                \n                IF the remainder of gcd1 MULTIPLIED BY gcd2 DIVIDED BY k EQUALS zero THEN  \n                    IF i EQUALS j THEN  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd1 in gcd_count MINUS one DIVIDED BY two  \n                    ELSE  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd2 in gcd_count  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-finish-the-race", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minimumFinishTime(tires, changeTime, numLaps)\n        LET minimal_times BE an array of length 15 WHERE each element IS assigned +∞\n        FOR EACH (initial_value, multiplier) IN tires DO\n            LET accumulated_time BE 0\n            LET lap_counter BE 0\n            WHILE lap_counter < 15 DO\n                LET current_lap_duration BE initial_value * (multiplier ^ lap_counter)\n                IF NOT (current_lap_duration ≤ changeTime + initial_value) THEN\n                    EXIT WHILE\n                END IF\n                accumulated_time ← accumulated_time + current_lap_duration\n                IF accumulated_time < minimal_times[lap_counter] THEN\n                    minimal_times[lap_counter] ← accumulated_time\n                END IF\n                lap_counter ← lap_counter + 1\n            END WHILE\n        END FOR\n\n        LET dp_table BE a list of size (numLaps + 1) FILLED WITH +∞\n        SET dp_table[0] TO 0\n\n        LET outer_index BE 1\n        WHILE outer_index ≤ numLaps DO\n            LET inner_index BE 0\n            WHILE inner_index ≤ MIN(outer_index - 1, 14) DO\n                LET proposed_time BE dp_table[outer_index - inner_index - 1] + minimal_times[inner_index] + changeTime\n                IF proposed_time < dp_table[outer_index] THEN\n                    dp_table[outer_index] ← proposed_time\n                END IF\n                inner_index ← inner_index + 1\n            END WHILE\n            outer_index ← outer_index + 1\n        END WHILE\n\n        RETURN dp_table[numLaps] - changeTime\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution\n    FUNCTION minimumFinishTime(tires, changeTime, numLaps)\n        SET min_times TO a list of length FIFTEEN with all elements set to positive infinity\n        FOR each pair of first_variable AND ratio IN tires\n            SET total_time TO zero\n            FOR index FROM zero TO FOURTEEN\n                SET lap_time TO first_variable MULTIPLIED BY ratio RAISED TO the power of index\n                IF lap_time IS GREATER THAN changeTime PLUS first_variable\n                    BREAK the current loop\n                END IF\n                SET total_time TO total_time PLUS lap_time\n                IF total_time IS LESS THAN element at position index of min_times\n                    SET element at position index of min_times TO total_time\n                END IF\n            END FOR\n        END FOR\n\n        SET dp TO a list of length numLaps PLUS one with all elements set to positive infinity\n        SET element at position zero of dp TO zero\n\n        FOR i FROM one TO numLaps\n            FOR j FROM zero TO THE LESSER OF i MINUS one AND FOURTEEN\n                SET candidate_time TO element at position i MINUS j MINUS one of dp PLUS element at position j of min_times PLUS changeTime\n                IF candidate_time IS LESS THAN element at position i of dp\n                    SET element at position i of dp TO candidate_time\n                END IF\n            END FOR\n        END FOR\n\n        RETURN element at position numLaps of dp MINUS changeTime\n    END FUNCTION\nEND CLASS"}
{"task_id": "maximum-total-beauty-of-the-gardens", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET length_of_flowers TO the LENGTH OF flowers  \n        SET highest_beauty TO 0  \n        DEFINE prefix_accumulation AS A LIST WITH length_of_flowers PLUS one ELEMENTS INITIALIZED TO 0  \n        \n        SET idx TO 0  \n        WHILE idx < length_of_flowers  \n            SET prefix_accumulation[idx + 1] AS prefix_accumulation[idx] + flowers[idx]  \n            SET idx TO idx + 1  \n        END WHILE  \n        \n        SET count_full_gardens TO 0  \n        SET pointer TO length_of_flowers - 1  \n        LOOP  \n            IF pointer < 0 THEN  \n                BREAK  \n            ENDIF  \n            \n            IF flowers[pointer] >= target THEN  \n                SET count_full_gardens AS count_full_gardens + 1  \n                SET pointer AS pointer - 1  \n            ELSE  \n                BREAK  \n            ENDIF  \n        END LOOP  \n        \n        SET flowers_left TO newFlowers  \n        SET incomplete_max_flowers TO 0  \n        \n        SET current_index TO count_full_gardens  \n        WHILE current_index <= length_of_flowers  \n            \n            IF current_index > 0 THEN  \n                SET flowers_left AS flowers_left - (target - flowers[length_of_flowers - current_index])  \n                IF NOT (flowers_left >= 0) THEN  \n                    BREAK  \n                ENDIF  \n            ENDIF  \n            \n            SET low_bound TO 0  \n            SET high_bound TO length_of_flowers - current_index - 1  \n            \n            WHILE low_bound <= high_bound  \n                SET midpoint TO (low_bound + high_bound) DIVIDED BY 2 USING INTEGER DIVISION  \n                \n                SET required_flowers TO (flowers[midpoint] * (midpoint+1)) - (prefix_accumulation[midpoint + 1])  \n                \n                IF required_flowers > flowers_left THEN  \n                    SET high_bound TO midpoint - 1  \n                ELSE  \n                    SET low_bound TO midpoint + 1  \n                ENDIF  \n            END WHILE  \n            \n            IF high_bound >= 0 THEN  \n                SET numerator TO flowers_left - ((flowers[high_bound] * (high_bound + 1)) - prefix_accumulation[high_bound + 1])  \n                SET incomplete_max_flowers AS flowers[high_bound] + (numerator DIVIDED BY (high_bound + 1) USING INTEGER DIVISION)  \n            ELSE  \n                SET incomplete_max_flowers TO 0  \n            ENDIF  \n            \n            SET candidate_beauty TO (current_index * full) + (MIN(incomplete_max_flowers, target - 1) * partial)  \n            IF candidate_beauty > highest_beauty THEN  \n                SET highest_beauty AS candidate_beauty  \n            ENDIF  \n            \n            SET current_index TO current_index + 1  \n        END WHILE  \n        \n        RETURN highest_beauty  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET n TO the LENGTH OF flowers  \n        SET max_beauty TO zero  \n        SET prefix_sum TO A LIST OF ZEROS WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at POSITION i PLUS one OF prefix_sum TO element at POSITION i OF prefix_sum PLUS element at POSITION i OF flowers  \n        END FOR  \n        SET complete_gardens TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at POSITION i OF flowers GREATER THAN OR EQUAL TO target THEN  \n                INCREMENT complete_gardens BY one  \n            ELSE  \n                BREAK  \n            END IF  \n        END FOR  \n        SET remaining_flowers TO newFlowers  \n        SET max_incomplete_flowers TO zero  \n        FOR i FROM complete_gardens TO n  \n            IF i GREATER THAN zero THEN  \n                DECREMENT remaining_flowers BY target MINUS element at POSITION n MINUS i OF flowers  \n                IF remaining_flowers LESS THAN zero THEN  \n                    BREAK  \n                END IF  \n            END IF  \n            SET left TO zero  \n            SET right TO n MINUS i MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n                SET cost TO element at POSITION mid OF flowers MULTIPLIED BY mid PLUS one MINUS element at POSITION mid PLUS one OF prefix_sum  \n                IF cost GREATER THAN remaining_flowers THEN  \n                    DECREMENT right BY one PLUS mid MINUS right  \n                ELSE  \n                    INCREMENT left BY one PLUS mid MINUS left  \n                END IF  \n            END WHILE  \n            IF right GREATER THAN OR EQUAL TO zero THEN  \n                SET max_incomplete_flowers TO element at POSITION right OF flowers PLUS remaining_flowers MINUS element at POSITION right OF flowers MULTIPLIED BY right PLUS one PLUS NEGATION OF element at POSITION right PLUS one OF prefix_sum DIVIDED BY right PLUS one USING INTEGER DIVISION  \n            ELSE  \n                SET max_incomplete_flowers TO zero  \n            END IF  \n            SET total_beauty TO i MULTIPLIED BY full PLUS THE MINIMUM OF max_incomplete_flowers AND target MINUS one MULTIPLIED BY partial  \n            IF total_beauty GREATER THAN max_beauty THEN  \n                SET max_beauty TO total_beauty  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-of-a-node-sequence", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(scores, edges)  \n        CREATE neighbors AS empty default mapping where each key maps to an empty list  \n        SET indexA TO 0  \n        WHILE indexA < LENGTH(edges)  \n            LET edgePair BE edges[indexA]  \n            LET firstNode TO edgePair[0]  \n            LET secondNode TO edgePair[1]  \n            LET scoreSecond TO scores[secondNode]  \n            LET scoreFirst TO scores[firstNode]  \n            ADD (scoreSecond, secondNode) TO neighbors[firstNode]  \n            ADD (scoreFirst, firstNode) TO neighbors[secondNode]  \n            INCREMENT indexA BY 1  \n        END WHILE  \n\n        LET nodeIterKeys BE KEYS(neighbors)  \n        LET indexB TO 0  \n        WHILE indexB < LENGTH(nodeIterKeys)  \n            LET currNode TO nodeIterKeys[indexB]  \n            LET currList TO neighbors[currNode]  \n            SORT currList DESCENDING BY first ELEMENT OF PAIRS  \n            SET neighbors[currNode] TO SUBLIST(currList, 0, MIN(3, LENGTH(currList)))  \n            INCREMENT indexB BY 1  \n        END WHILE  \n\n        SET highestScore TO -1  \n        LET idxEdge TO 0  \n        WHILE idxEdge < LENGTH(edges)  \n            LET currentEdge TO edges[idxEdge]  \n            LET nodeU TO currentEdge[0]  \n            LET nodeV TO currentEdge[1]  \n            LET listU TO neighbors[nodeU]  \n            LET listV TO neighbors[nodeV]  \n            LET idxU TO 0  \n            WHILE idxU < LENGTH(listU)  \n                LET pairU TO listU[idxU]  \n                LET scr1 TO pairU[0]  \n                LET xNode TO pairU[1]  \n                LET idxV TO 0  \n                WHILE idxV < LENGTH(listV)  \n                    LET pairV TO listV[idxV]  \n                    LET scr2 TO pairV[0]  \n                    LET yNode TO pairV[1]  \n                    IF (xNode ≠ yNode) AND (xNode ≠ nodeU) AND (xNode ≠ nodeV) AND (yNode ≠ nodeU) AND (yNode ≠ nodeV) AND (nodeU ≠ nodeV) THEN  \n                        LET tempSum TO scr1 + scr2 + scores[nodeU] + scores[nodeV]  \n                        IF tempSum > highestScore THEN  \n                            SET highestScore TO tempSum  \n                        END IF  \n                    END IF  \n                    INCREMENT idxV BY 1  \n                END WHILE  \n                INCREMENT idxU BY 1  \n            END WHILE  \n            INCREMENT idxEdge BY 1  \n        END WHILE  \n\n        RETURN highestScore  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumScore(scores, edges)  \n        CREATE graph AS a new default mapping from elements to empty lists  \n        FOR each element u AND element v IN edges  \n            APPEND a pair consisting of the element at position v of scores AND element v TO the list associated with element u in graph  \n            APPEND a pair consisting of the element at position u of scores AND element u TO the list associated with element v in graph  \n        END FOR  \n        FOR each element node IN graph  \n            SET the list associated with element node in graph TO the three highest scoring pairs from the list associated with element node in graph  \n        END FOR  \n        SET max_score TO negative one  \n        FOR each element u AND element v IN edges  \n            FOR each pair consisting of score1 AND x IN the list associated with element u in graph  \n                FOR each pair consisting of score2 AND y IN the list associated with element v in graph  \n                    IF the set containing x AND y AND u AND v HAS size EQUALS four  \n                        SET max_score TO the greater value between max_score AND the sum of score1 PLUS score2 PLUS the element at position u of scores PLUS the element at position v of scores  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN max_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-the-spreading-fire", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumMinutes(grid)\n        SET rowCount AS LENGTH OF grid\n        SET colCount AS LENGTH OF element AT 0 OF grid\n        SET moves AS LIST OF PAIRS: (1, 0), (-1, 0), (0, 1), (0, -1)\n\n        FUNCTION can_escape(wait)\n            SET fireArrival TO a 2D LIST sized rowCount BY colCount FILLED WITH infinity\n            CREATE deque AS empty double-ended queue\n\n            SET iCounter TO 0\n            WHILE iCounter < rowCount\n                SET jCounter TO 0\n                WHILE jCounter < colCount\n                    IF element AT iCounter OF grid = 1 THEN\n                        PUSH (iCounter, jCounter, 0) TO deque\n                        ASSIGN fireArrival[iCounter][jCounter] ← 0\n                    END IF\n                    INCREMENT jCounter BY 1\n                END WHILE\n                INCREMENT iCounter BY 1\n            END WHILE\n\n            WHILE deque IS NOT empty\n                POP_LEFT (currX, currY, currTime) FROM deque\n                FOR EACH (dx, dy) IN moves DO\n                    SET nextX TO currX + dx\n                    SET nextY TO currY + dy\n                    IF (nextX ≥ 0) AND (nextX < rowCount) AND (nextY ≥ 0) AND (nextY < colCount) AND (grid[nextX][nextY] = 0) AND (fireArrival[nextX][nextY] = infinity) THEN\n                        ASSIGN fireArrival[nextX][nextY] ← currTime + 1\n                        PUSH (nextX, nextY, currTime + 1) TO deque\n                    END IF\n                END FOR\n            END WHILE\n\n            SET explorerQueue TO new double-ended queue WITH ELEMENT (0, 0, wait)\n            SET visitedSet TO SET CONTAINING PAIR (0, 0)\n\n            WHILE explorerQueue IS NOT empty\n                POP_LEFT (posX, posY, timePassed) FROM explorerQueue\n                FOR EACH (offsetX, offsetY) IN moves DO\n                    SET candidateX TO posX + offsetX\n                    SET candidateY TO posY + offsetY\n                    IF (candidateX ≥ 0) AND (candidateX < rowCount) AND (candidateY ≥ 0) AND (candidateY < colCount) AND NOT ((candidateX, candidateY) IN visitedSet) AND (grid[candidateX][candidateY] = 0) THEN\n                        IF (candidateX = rowCount - 1) AND (candidateY = colCount - 1) THEN\n                            IF fireArrival[candidateX][candidateY] ≥ timePassed + 1 THEN\n                                RETURN true\n                            ELSE\n                                RETURN false\n                            END IF\n                        END IF\n                        IF fireArrival[candidateX][candidateY] > timePassed + 1 THEN\n                            ADD (candidateX, candidateY) TO visitedSet\n                            PUSH (candidateX, candidateY, timePassed + 1) TO explorerQueue\n                        END IF\n                    END IF\n                END FOR\n            END WHILE\n\n            RETURN false\n        END FUNCTION\n\n        SET startPos TO 0\n        SET endPos TO rowCount * colCount\n        SET answer TO -1\n\n        WHILE startPos ≤ endPos\n            SET middle TO startPos + FLOOR((endPos - startPos) / 2)\n            IF can_escape(middle) THEN\n                ASSIGN answer ← middle\n                ASSIGN startPos ← middle + 1\n            ELSE\n                ASSIGN endPos ← middle - 1\n            END IF\n        END WHILE\n\n        IF answer ≠ rowCount * colCount THEN\n            RETURN answer\n        ELSE\n            RETURN 1000000000\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO the LIST of elements each being a PAIR consisting of one and zero MINUS one and zero zero and one zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two-dimensional list of size m by n each element set TO infinity  \n            SET queue TO an empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one  \n                        APPEND the TRIPLE consisting of i j and zero TO queue  \n                        SET element at position i and j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx and ny of grid EQUALS zero AND element at position nx and ny of fire_times EQUALS infinity  \n                        SET element at position nx and ny of fire_times TO t PLUS one  \n                        APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a double-ended queue containing a single TRIPLE consisting of zero zero and wait  \n            SET visited TO a set containing the PAIR zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the PAIR nx ny NOT IN visited AND element at position nx and ny of grid EQUALS zero  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one  \n                            IF element at position nx and ny of fire_times GREATER THAN OR EQUAL TO t PLUS one  \n                                RETURN true  \n                            ELSE  \n                                RETURN false  \n                            END IF  \n                        END IF  \n                        IF element at position nx and ny of fire_times GREATER THAN t PLUS one  \n                            ADD the PAIR nx ny TO visited  \n                            APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two rounded down to the nearest integer  \n            IF can_escape(mid)  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result NOT EQUALS m MULTIPLIED BY n  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "total-appeal-of-a-string", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION appealSum(s)\n        DECLARE lastIndices AS list WITH size 26 INITIALIZED BY -1 REPEATEDLY\n        DECLARE sumOfAppeals AS 0\n        DECLARE currentValue AS 0\n        DECLARE pos AS 0\n        WHILE pos < LENGTH(s)\n            DECLARE character AS s[pos]\n            DECLARE letterIndex AS (ORD(character) - ORD('a'))\n            DECLARE contribution AS (pos - lastIndices[letterIndex])\n            currentValue ← currentValue + contribution\n            sumOfAppeals ← sumOfAppeals + currentValue\n            lastIndices[letterIndex] ← pos\n            pos ← pos + 1\n        END WHILE\n        RETURN sumOfAppeals\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION appealSum(s)  \n        SET last TO a list of length twenty six with each element set to minus one  \n        SET total_appeal TO zero  \n        SET current_appeal TO zero  \n        FOR each position i AND character char IN the enumeration of s  \n            SET index TO the numeric code of character char MINUS the numeric code of character a  \n            INCREMENT current_appeal BY position i MINUS element at position index of last  \n            INCREMENT total_appeal BY current_appeal  \n            SET element at position index of last TO position i  \n        END FOR  \n        RETURN total_appeal  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "substring-with-largest-variance", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION largestVariance(s)  \n        FUNCTION calculate_variance(substring, char_a, char_b)  \n            SET peak_variance ← 0  \n            SET tally_a ← 0  \n            SET tally_b ← 0  \n            SET observed_b ← false  \n            SET encountered_first_b ← false  \n            \n            SET iterator ← 0  \n            WHILE iterator < LENGTH(substring)  \n                SET current_char ← substring[iterator]  \n                IF current_char = char_a THEN  \n                    tally_a ← tally_a + 1  \n                ELSE  \n                    IF current_char = char_b THEN  \n                        tally_b ← tally_b + 1  \n                        observed_b ← true  \n                    END IF  \n                END IF  \n                \n                IF NOT (tally_b ≤ 0) THEN  \n                    IF peak_variance < (tally_a - tally_b) THEN  \n                        peak_variance ← tally_a - tally_b  \n                    END IF  \n                ELSE  \n                    IF (tally_b = 0) AND encountered_first_b THEN  \n                        IF peak_variance < (tally_a - 1) THEN  \n                            peak_variance ← tally_a - 1  \n                        END IF  \n                    END IF  \n                END IF  \n                \n                IF tally_b > tally_a THEN  \n                    SET tally_a ← 0  \n                    SET tally_b ← 0  \n                    SET encountered_first_b ← observed_b  \n                END IF  \n                \n                iterator ← iterator + 1  \n            END WHILE  \n            \n            RETURN peak_variance  \n        END FUNCTION  \n        \n        SET overall_max ← 0  \n        SET character_pool ← EMPTY SET  \n        SET index ← 0  \n        WHILE index < LENGTH(s)  \n            character_pool ← character_pool UNION { s[index] }  \n            index ← index + 1  \n        END WHILE  \n        \n        SET unique_list ← LIST(character_pool)  \n        SET n ← LENGTH(unique_list)  \n        SET outer_index ← 0  \n        WHILE outer_index < n  \n            SET inner_index ← 0  \n            WHILE inner_index < n  \n                IF outer_index ≠ inner_index THEN  \n                    SET candidate_a ← unique_list[outer_index]  \n                    SET candidate_b ← unique_list[inner_index]  \n                    SET probe_variance ← calculate_variance(s, candidate_a, candidate_b)  \n                    IF probe_variance > overall_max THEN  \n                        overall_max ← probe_variance  \n                    END IF  \n                END IF  \n                inner_index ← inner_index + 1  \n            END WHILE  \n            outer_index ← outer_index + 1  \n        END WHILE  \n        \n        RETURN overall_max  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION largestVariance(s)  \n        FUNCTION calculate_variance(substring, char_a, char_b)  \n            SET max_variance TO zero  \n            SET count_a TO zero  \n            SET count_b TO zero  \n            SET has_b TO false  \n            SET first_b TO false  \n            \n            FOR each char IN substring  \n                IF char EQUALS char_a  \n                    INCREMENT count_a BY one  \n                ELSE IF char EQUALS char_b  \n                    INCREMENT count_b BY one  \n                    SET has_b TO true  \n                END IF  \n                \n                IF count_b GREATER THAN zero  \n                    SET max_variance TO the greater value BETWEEN max_variance AND count_a MINUS count_b  \n                ELSE IF count_b EQUALS zero AND first_b EQUALS true  \n                    SET max_variance TO the greater value BETWEEN max_variance AND count_a MINUS one  \n                END IF  \n                \n                IF count_b GREATER THAN count_a  \n                    SET count_a TO zero  \n                    SET count_b TO zero  \n                    SET first_b TO has_b  \n                END IF  \n            END FOR  \n            \n            RETURN max_variance  \n        END FUNCTION  \n        \n        SET max_variance TO zero  \n        SET unique_chars TO the set of all different characters in s  \n        \n        FOR each ordered pair of distinct characters char_a AND char_b IN all permutations of unique_chars taking two at a time  \n            IF char_a EQUALS char_b  \n                CONTINUE to the next iteration  \n            END IF  \n            SET max_variance TO the greater value BETWEEN max_variance AND calculate_variance with arguments s char_a char_b  \n        END FOR  \n        \n        RETURN max_variance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shopping-offers", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION shoppingOffers(price, special, needs)\n        SET filtered_special TO empty collection\n        SET idx TO 0\n        WHILE idx < LENGTH(special)\n            SET bundle TO special[idx]\n            SET sum_items TO 0\n            SET total_value TO 0\n            SET pos TO 0\n            WHILE pos < LENGTH(bundle) - 1\n                SET sum_items TO sum_items + bundle[pos]\n                SET total_value TO total_value + bundle[pos] * price[pos]\n                INCREMENT pos BY 1\n            END WHILE\n            IF sum_items > 0 AND bundle[LENGTH(bundle) - 1] < total_value THEN\n                APPEND bundle TO filtered_special\n            END IF\n            INCREMENT idx BY 1\n        END WHILE\n        \n        FUNCTION dfs(current_needs)\n            SET minimal_cost TO 0\n            DECLARE counter AS 0\n            WHILE counter < LENGTH(price)\n                SET minimal_cost TO minimal_cost + price[counter] * current_needs[counter]\n                INCREMENT counter BY 1\n            END WHILE\n            \n            SET offer_index TO 0\n            WHILE offer_index < LENGTH(filtered_special)\n                SET offer_bundle TO filtered_special[offer_index]\n                SET updated_needs TO empty collection\n                FOR position IN 0 TO LENGTH(current_needs) - 1\n                    APPEND current_needs[position] - offer_bundle[position] TO updated_needs\n                END FOR\n                \n                SET eligible TO TRUE\n                FOR demand IN updated_needs\n                    IF demand < 0 THEN\n                        SET eligible TO FALSE\n                        EXIT FOR\n                    END IF\n                END FOR\n                \n                IF eligible THEN\n                    SET cost_if_used TO offer_bundle[LENGTH(offer_bundle) - 1] + dfs(CONVERT_TO_TUPLE(updated_needs))\n                    IF cost_if_used < minimal_cost THEN\n                        SET minimal_cost TO cost_if_used\n                    END IF\n                END IF\n                \n                INCREMENT offer_index BY 1\n            END WHILE\n            \n            RETURN minimal_cost\n        END FUNCTION\n        \n        RETURN dfs(CONVERT_TO_TUPLE(needs))\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION shoppingOffers(price, special, needs)  \n        SET special TO an empty list  \n        FOR each offer IN the original special list  \n            IF the sum of elements at all positions except the last in offer IS GREATER THAN zero AND  \n               the last element of offer IS LESS THAN the sum of the product of corresponding elements of price and offer except the last element  \n                APPEND offer TO special  \n            END IF  \n        END FOR  \n        \n        FUNCTION dfs(needs)  \n            SET min_cost TO zero  \n            FOR each element at position index FROM zero TO the length of price MINUS one  \n                INCREMENT min_cost BY the element at position index of price MULTIPLIED BY the element at position index of needs  \n            END FOR  \n            \n            FOR each offer IN special  \n                SET new_needs TO an empty list  \n                FOR each index FROM zero TO the length of needs MINUS one  \n                    APPEND to new_needs the element at position index of needs MINUS the element at position index of offer  \n                END FOR  \n                \n                SET can_use_offer TO true  \n                FOR each element n IN new_needs  \n                    IF n IS LESS THAN zero  \n                        SET can_use_offer TO false  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n                \n                IF can_use_offer EQUALS true  \n                    SET possible_cost TO the last element of offer PLUS dfs(the tuple version of new_needs)  \n                    IF possible_cost IS LESS THAN min_cost  \n                        SET min_cost TO possible_cost  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dfs(the tuple version of needs)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sentence-similarity-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION areSentencesSimilarTwo(sentence1 sentence1 TO sentence1 OF TYPE list OF strings sentence2 sentence2 TO sentence2 OF TYPE list OF strings similarPairs similarPairs TO similarPairs OF TYPE list OF list OF strings) RETURNS boolean\n        IF LENGTH sentence1 == LENGTH sentence2 THEN\n        ELSE\n            RETURN false\n        END IF\n\n        DECLARE registry AS dictionary = {}\n\n        FUNCTION find(element element TO element) RETURNS element\n            DECLARE stack AS list = []\n            DECLARE current AS element = element\n            WHILE current != registry[current] DO\n                PUSH current INTO stack\n                SET current = registry[current]\n            END WHILE\n            FOR each node IN stack DO\n                SET registry[node] = current\n            END FOR\n            RETURN current\n        END FUNCTION\n\n        FUNCTION union(first first TO first second second TO second)\n            DECLARE rootFirst AS first = find(first)\n            DECLARE rootSecond AS second = find(second)\n            IF rootFirst != rootSecond THEN\n                SET registry[rootSecond] = rootFirst\n            END IF\n        END FUNCTION\n\n        DECLARE index1 AS int = 0\n        WHILE index1 < LENGTH similarPairs DO\n            DECLARE couple AS list = similarPairs[index1]\n            DECLARE idxWord AS int = 0\n            WHILE idxWord < LENGTH couple DO\n                DECLARE token AS string = couple[idxWord]\n                IF NOT token IN registry THEN\n                    SET registry[token] = token\n                END IF\n                SET idxWord = idxWord + 1\n            END WHILE\n            SET index1 = index1 + 1\n        END WHILE\n\n        DECLARE idxPair AS int = 0\n        WHILE idxPair < LENGTH similarPairs DO\n            DECLARE a AS string = similarPairs[idxPair][0]\n            DECLARE b AS string = similarPairs[idxPair][1]\n            CALL union(a b)\n            SET idxPair = idxPair + 1\n        END WHILE\n\n        DECLARE pos AS int = 0\n        WHILE pos < LENGTH sentence1 DO\n            DECLARE firstWord AS string = sentence1[pos]\n            DECLARE secondWord AS string = sentence2[pos]\n            IF NOT firstWord IN registry THEN\n                SET registry[firstWord] = firstWord\n            END IF\n            IF NOT secondWord IN registry THEN\n                SET registry[secondWord] = secondWord\n            END IF\n\n            IF find(firstWord) != find(secondWord) THEN\n                RETURN false\n            END IF\n            SET pos = pos + 1\n        END WHILE\n\n        RETURN true\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION areSentencesSimilarTwo(sentence1 sentence1 TO sentence1 OF TYPE list OF strings sentence2 sentence2 TO sentence2 OF TYPE list OF strings similarPairs similarPairs TO similarPairs OF TYPE list OF list OF strings) RETURNS boolean  \n        IF the LENGTH OF sentence1 NOT EQUALS the LENGTH OF sentence2  \n            RETURN false  \n        END IF  \n\n        SET parent TO empty dictionary  \n\n        FUNCTION find(x x TO x) RETURNS x  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO find(element at position x of parent)  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n\n        FUNCTION union(x x TO x y y TO y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootY of parent TO rootX  \n            END IF  \n        END FUNCTION  \n\n        FOR each pair IN similarPairs  \n            FOR each word IN pair  \n                IF word NOT IN parent  \n                    SET element at position word of parent TO word  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each x y IN similarPairs  \n            union(x y)  \n        END FOR  \n\n        FOR each w1 w2 IN sentence1 sentence2  \n            IF w1 NOT IN parent  \n                SET element at position w1 of parent TO w1  \n            END IF  \n            IF w2 NOT IN parent  \n                SET element at position w2 of parent TO w2  \n            END IF  \n            IF find(w1) NOT EQUALS find(w2)  \n                RETURN false  \n            END IF  \n        END FOR  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "friends-of-appropriate-ages", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numFriendRequests(ages)\n        FUNCTION request_will_be_sent(age_x age_y)\n            IF age_y <= (age_x / 2 + 7) THEN\n                RETURN false\n            ELSE IF age_y > age_x THEN\n                RETURN false\n            ELSE IF (age_y > 100) AND (age_x < 100) THEN\n                RETURN false\n            ELSE\n                RETURN true\n            END IF\n        END FUNCTION\n\n        SET tally TO dictionary()\n        SET idx TO 0\n        WHILE idx < LENGTH(ages)\n            IF ages[idx] IN tally THEN\n                tally[ages[idx]] = tally[ages[idx]] + 1\n            ELSE\n                tally[ages[idx]] = 1\n            END IF\n            idx = idx + 1\n        END WHILE\n\n        SET accumulated TO 0\n        SET p_age_x TO 1\n        WHILE p_age_x <= 120\n            SET p_age_y TO 1\n            WHILE p_age_y <= 120\n                IF request_will_be_sent(p_age_x, p_age_y) THEN\n                    IF p_age_x = p_age_y THEN\n                        accumulated = accumulated + (tally.get(p_age_x, 0) * (tally.get(p_age_y, 0) - 1))\n                    ELSE\n                        accumulated = accumulated + (tally.get(p_age_x, 0) * tally.get(p_age_y, 0))\n                    END IF\n                END IF\n                p_age_y = p_age_y + 1\n            END WHILE\n            p_age_x = p_age_x + 1\n        END WHILE\n\n        RETURN accumulated\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numFriendRequests(ages)  \n        FUNCTION request_will_be_sent(age_x age_y)  \n            RETURN NOT (age_y IS LESS THAN OR EQUAL TO age_x MULTIPLIED BY one half PLUS seven OR age_y IS GREATER THAN age_x OR age_y IS GREATER THAN one hundred AND age_x IS LESS THAN one hundred)  \n        END FUNCTION  \n\n        SET count TO list of zero repeated one hundred and twenty one times  \n        FOR each age IN ages  \n            INCREMENT element at position age of count BY one  \n        END FOR  \n\n        SET total_requests TO zero  \n        FOR age_x FROM one TO one hundred and twenty  \n            FOR age_y FROM one TO one hundred and twenty  \n                IF request_will_be_sent(age_x age_y)  \n                    INCREMENT total_requests BY element at position age_x of count MULTIPLIED BY element at position age_y of count MINUS one IF age_x EQUALS age_y ELSE element at position age_y of count  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN total_requests  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pacific-atlantic-water-flow", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION pacificAtlantic WITH PARAMETER heights\n        FUNCTION bfs WITH PARAMETERS q AND vis\n            ASSIGN m TO LENGTH OF heights\n            ASSIGN n TO LENGTH OF heights[0]\n            DEFINE directions AS LIST OF PAIRS: (-1, 0), (1, 0), (0, 1), (0, -1)\n            \n            WHILE LENGTH OF q IS GREATER THAN 0\n                ASSIGN count TO LENGTH OF q\n                ASSIGN idx TO 0\n                WHILE idx IS LESS THAN count\n                    REMOVE THE LEFTMOST ELEMENT FROM q AND ASSIGN IT TO pos\n                    ASSIGN i TO pos[0]\n                    ASSIGN j TO pos[1]\n                    \n                    ASSIGN d_idx TO 0\n                    WHILE d_idx IS LESS THAN LENGTH OF directions\n                        ASSIGN delta TO directions[d_idx]\n                        ASSIGN x TO i + delta[0]\n                        ASSIGN y TO j + delta[1]\n                        \n                        IF x >= 0 AND x < m AND y >= 0 AND y < n AND NOT (x, y) IN vis AND heights[x][y] >= heights[i][j]\n                            ADD (x, y) TO vis\n                            ADD (x, y) TO RIGHT OF q\n                        ENDIF\n                        \n                        INCREMENT d_idx BY 1\n                    END WHILE\n                    \n                    INCREMENT idx BY 1\n                END WHILE\n            END WHILE\n        END FUNCTION\n        \n        ASSIGN m TO LENGTH OF heights\n        ASSIGN n TO LENGTH OF heights[0]\n        INITIALIZE vis1 TO AN EMPTY SET\n        INITIALIZE vis2 TO AN EMPTY SET\n        INITIALIZE q1 TO AN EMPTY DEQUE\n        INITIALIZE q2 TO AN EMPTY DEQUE\n        \n        ASSIGN row TO 0\n        WHILE row < m\n            ASSIGN col TO 0\n            WHILE col < n\n                IF row = 0 OR col = 0\n                    ADD (row, col) TO vis1\n                    ADD (row, col) TO RIGHT OF q1\n                ENDIF\n                \n                IF row = m - 1 OR col = n - 1\n                    ADD (row, col) TO vis2\n                    ADD (row, col) TO RIGHT OF q2\n                ENDIF\n                \n                INCREMENT col BY 1\n            END WHILE\n            INCREMENT row BY 1\n        END WHILE\n        \n        CALL bfs WITH q1 AND vis1\n        CALL bfs WITH q2 AND vis2\n        \n        INITIALIZE result TO AN EMPTY LIST\n        \n        ASSIGN r_idx TO 0\n        WHILE r_idx < m\n            ASSIGN c_idx TO 0\n            WHILE c_idx < n\n                ASSIGN pos TO (r_idx, c_idx)\n                IF pos IN vis1 AND pos IN vis2\n                    ADD pos TO result\n                ENDIF\n                INCREMENT c_idx BY 1\n            END WHILE\n            INCREMENT r_idx BY 1\n        END WHILE\n        \n        RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION pacificAtlantic WITH PARAMETER heights  \n        FUNCTION bfs WITH PARAMETERS q AND vis  \n            WHILE the LENGTH OF q is greater than zero  \n                FOR each element from zero TO the LENGTH OF q MINUS one  \n                    SET i TO the first element of the element at position zero of q removed from the front  \n                    SET j TO the second element of the element at position zero of q removed from the front  \n                    FOR each pair a and b IN the list of pairs where the pairs are zero and MINUS one, zero and one, one and zero, MINUS one and zero  \n                        SET x TO i PLUS a  \n                        SET y TO j PLUS b  \n                        IF x GREATER THAN OR EQUAL TO zero AND x LESS THAN m AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n AND the tuple consisting of x and y is NOT IN vis AND the element at position x of heights AT position y OF heights GREATER THAN OR EQUAL TO the element at position i of heights AT position j OF heights  \n                            ADD the tuple consisting of x and y TO vis  \n                            APPEND the tuple consisting of x and y TO the end of q  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END WHILE  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF heights  \n        SET n TO the LENGTH OF the element at position zero of heights  \n        SET vis1 TO an empty set  \n        SET vis2 TO an empty set  \n        SET q1 TO an empty double ended queue  \n        SET q2 TO an empty double ended queue  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF i EQUALS zero OR j EQUALS zero  \n                    ADD the tuple consisting of i and j TO vis1  \n                    APPEND the tuple consisting of i and j TO the end of q1  \n                END IF  \n                IF i EQUALS m MINUS one OR j EQUALS n MINUS one  \n                    ADD the tuple consisting of i and j TO vis2  \n                    APPEND the tuple consisting of i and j TO the end of q2  \n                END IF  \n            END FOR  \n        END FOR  \n        CALL bfs WITH q1 AND vis1  \n        CALL bfs WITH q2 AND vis2  \n        SET result TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the tuple consisting of i and j IS IN vis1 AND the tuple consisting of i and j IS IN vis2  \n                    APPEND the tuple consisting of i and j TO result  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF NOT (0 <= x AND x < LENGTH of grid AND 0 <= y AND y < LENGTH of grid at 0) OR grid at x, y EQUALS 0 THEN  \n                EXIT FUNCTION  \n            END IF  \n            ASSIGN 0 TO grid at x, y  \n            INSERT (x, y) INTO island  \n            CALL dfs(x + 1, y, island)  \n            CALL dfs(x - 1, y, island)  \n            CALL dfs(x, y + 1, island)  \n            CALL dfs(x, y - 1, island)  \n        END FUNCTION  \n\n        FUNCTION normalize(island)  \n            ASSIGN empty array TO shapes  \n            DEFINE transforms AS [(1, 1), (1, -1), (-1, 1), (-1, -1)]  \n            SET idx TO 0  \n            WHILE idx < LENGTH of transforms DO  \n                ASSIGN empty array TO temp_island  \n                LET dx, dy BE transforms at idx  \n                LET v TO 0  \n                WHILE v < LENGTH of island DO  \n                    LET px, py BE island at v  \n                    INSERT (px * dx, py * dy) INTO temp_island  \n                    INCREMENT v BY 1  \n                END WHILE  \n                SORT temp_island by ascending order  \n                LET min_x BE temp_island at 0, 0  \n                LET min_y BE temp_island at 0, 1  \n                LET k BE 1  \n                WHILE k < LENGTH of temp_island DO  \n                    IF temp_island at k, 0 < min_x THEN  \n                        ASSIGN temp_island at k, 0 TO min_x  \n                    END IF  \n                    IF temp_island at k, 1 < min_y THEN  \n                        ASSIGN temp_island at k, 1 TO min_y  \n                    END IF  \n                    INCREMENT k BY 1  \n                END WHILE  \n                LET normalized_shape BE empty list  \n                LET m TO 0  \n                WHILE m < LENGTH of temp_island DO  \n                    LET cx, cy BE temp_island at m  \n                    INSERT (cx - min_x, cy - min_y) INTO normalized_shape  \n                    INCREMENT m BY 1  \n                END WHILE  \n                INSERT TUPLE OF normalized_shape INTO shapes  \n                INCREMENT idx BY 1  \n            END WHILE  \n\n            LET original_cnt BE LENGTH of shapes  \n            LET r TO 0  \n            WHILE r < original_cnt DO  \n                LET shape BE shapes at r  \n                LET rotated_shape BE empty list  \n                LET s TO 0  \n                WHILE s < LENGTH of shape DO  \n                    LET ox, oy BE shape at s  \n                    INSERT (oy, -ox) INTO rotated_shape  \n                    INCREMENT s BY 1  \n                END WHILE  \n                INSERT TUPLE OF rotated_shape INTO shapes  \n                INCREMENT r BY 1  \n            END WHILE  \n\n            RETURN MINIMUM element IN shapes by lex order  \n        END FUNCTION  \n\n        ASSIGN empty set TO islands  \n        LET i_iter BE 0  \n        WHILE i_iter < LENGTH of grid DO  \n            LET j_iter BE 0  \n            WHILE j_iter < LENGTH of grid at 0 DO  \n                IF grid at i_iter, j_iter EQUALS 1 THEN  \n                    ASSIGN empty array TO island  \n                    CALL dfs(i_iter, j_iter, island)  \n                    ADD normalize(island) TO islands  \n                END IF  \n                INCREMENT j_iter BY 1  \n            END WHILE  \n            INCREMENT i_iter BY 1  \n        END WHILE  \n\n        RETURN LENGTH of islands  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO LENGTH OF element at position zero of grid OR element at position x of grid at position y EQUALS zero  \n                RETURN  \n            END IF  \n            SET element at position x of grid at position y TO zero  \n            APPEND tuple of x and y TO island  \n            CALL dfs WITH x PLUS one AND y AND island  \n            CALL dfs WITH x MINUS one AND y AND island  \n            CALL dfs WITH x AND y PLUS one AND island  \n            CALL dfs WITH x AND y MINUS one AND island  \n        END FUNCTION  \n\n        FUNCTION normalize(island)  \n            SET shapes TO empty list  \n            FOR each pair dx and dy IN list of pairs of one and one PLUS one and minus one PLUS minus one and one PLUS minus one and minus one  \n                SET new_island TO empty list  \n                FOR each pair x and y IN island  \n                    APPEND tuple of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island  \n                END FOR  \n                SORT new_island in ascending order  \n                SET min_x TO the minimum x among all pairs in new_island  \n                SET min_y TO the minimum y among all pairs in new_island  \n                APPEND tuple of pairs where each x MINUS min_x AND each y MINUS min_y from new_island TO shapes  \n            END FOR  \n            SET original_length TO LENGTH OF shapes  \n            FOR index FROM zero TO original_length MINUS one  \n                APPEND tuple of pairs where y AND negative x from shape at position index TO shapes  \n            END FOR  \n            RETURN the minimal element in shapes according to lexicographical order  \n        END FUNCTION  \n\n        SET islands TO empty set  \n        FOR i FROM zero TO LENGTH OF grid MINUS one  \n            FOR j FROM zero TO LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET island TO empty list  \n                    CALL dfs WITH i AND j AND island  \n                    ADD normalize of island TO islands  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN LENGTH OF islands  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-and-replace-in-string", "label": "cosmetic", "pseudocode": "CLASS Solution\n  FUNCTION findReplaceString(s parameter, indices parameter, sources parameter, targets parameter)\n    SET combined TO empty queue\n    FOR counter FROM 0 TO LENGTH OF indices parameter MINUS 1 DO\n      ENQUEUE TO combined THE tuple (indices parameter[counter], sources parameter[counter], targets parameter[counter])\n    END FOR\n    CONVERT combined TO list AND SORT BY first element OF each tuple ASCENDING\n    \n    SET output TO empty list\n    SET last_pos TO 0\n    \n    FOR EACH element IN combined DO\n      DESTRUCTURE element INTO start_pos, src_str, tgt_str\n      \n      IF last_pos >= start_pos THEN\n        CONTINUE TO NEXT iteration\n      END IF\n      \n      APPEND substring OF s parameter FROM last_pos TO start_pos MINUS 1 TO output\n      \n      SET expected_segment TO substring OF s parameter FROM start_pos TO start_pos PLUS LENGTH OF src_str MINUS 1\n      \n      IF expected_segment NOT EQUAL TO src_str THEN\n        APPEND expected_segment TO output\n      ELSE\n        APPEND tgt_str TO output\n      END IF\n      \n      SET last_pos TO start_pos PLUS LENGTH OF src_str\n    END FOR\n    \n    APPEND substring OF s parameter FROM last_pos TO END TO output\n    \n    SET final_string TO empty string\n    FOR EACH piece IN output DO\n      final_string = final_string + piece\n    END FOR\n    \n    RETURN final_string\n  END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findReplaceString(s parameter, indices parameter, sources parameter, targets parameter)  \n        SET replacements TO list of tuples made of element at same position of indices parameter AND sources parameter AND targets parameter sorted by the first element of each tuple  \n        SET result TO empty list  \n        SET prev_end TO zero  \n        FOR each tuple composed of index variable AND source variable AND target variable IN replacements  \n            APPEND substring of s parameter from position prev_end TO position index MINUS one to result  \n            IF substring of s parameter from position index TO position index PLUS the LENGTH OF source variable MINUS one EQUALS source variable  \n                APPEND target variable TO result  \n            ELSE  \n                APPEND substring of s parameter from position index TO position index PLUS the LENGTH OF source variable MINUS one TO result  \n            END IF  \n            SET prev_end TO index PLUS the LENGTH OF source variable  \n        END FOR  \n        APPEND substring of s parameter from position prev_end TO the end TO result  \n        RETURN concatenation of all elements IN result  \n    END FUNCTION  \nEND CLASS"}
