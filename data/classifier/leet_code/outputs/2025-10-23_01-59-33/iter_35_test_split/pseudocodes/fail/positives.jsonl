{"task_id": "minimum-moves-to-capture-the-queen", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minMovesToCaptureTheQueen(a b c d e f)\n    begin\n      SET RmTvFSv TO false\n      DEF NztdIMCM(x y z)\n      begin\n        RETURN (x LESS THAN y AND y LESS THAN z) OR (z LESS THAN y AND y LESS THAN x)\n      end\n      IF (a EQUALS e) THEN\n        IF NOT(c EQUALS a) THEN\n          RETURN 1 * 1\n        ENDIF\n        IF NztdIMCM(b d f) THEN RETURN 2 ENDIF\n        RETURN 1\n      ENDIF\n      IF (b EQUALS f) THEN\n        IF NOT(d EQUALS b) THEN\n          RETURN 1\n        ENDIF\n        IF NztdIMCM(a c e) THEN RETURN 2 ENDIF\n        RETURN 1\n      ENDIF\n      IF ((c + d) EQUALS (e + f)) THEN\n        IF ((a + b) NOT EQUALS (c + d)) THEN\n          RETURN 1\n        ENDIF\n        IF NztdIMCM(c a e) AND NztdIMCM(d b f) THEN\n          RETURN 2\n        ENDIF\n        IF NztdIMCM(e a c) AND NztdIMCM(f b d) THEN\n          RETURN 2\n        ENDIF\n        RETURN 1\n      ENDIF\n      IF ((c - d) EQUALS (e - f)) THEN\n        IF ((a - b) NOT EQUALS (c - d)) THEN\n          RETURN 1\n        ENDIF\n        IF NztdIMCM(c a e) AND ((d GREATER THAN b) AND (b GREATER THAN f)) THEN\n          RETURN 2\n        ENDIF\n        IF NztdIMCM(e a c) AND ((f GREATER THAN b) AND (b GREATER THAN d)) THEN\n          RETURN 2\n        ENDIF\n        RETURN 1\n      ENDIF\n      RETURN 2\n    end\nEND CLASS", "score": 1.0}
{"task_id": "maximize-the-number-of-partitions-after-operations", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxPartitionsAfterOperations(s parameter k parameter)\n        FUNCTION max_partitions(s parameter k parameter)\n            SET idx_alpha TO 0\n            SET visited_set TO {}\n            SET cnt_parts TO 0\n\n            FUNCTION process_char(pos)\n                IF pos EQUALS LENGTH(s parameter) THEN\n                    RETURN\n                END IF\n\n                IF LENGTH(visited_set) LESS THAN k parameter THEN\n                    ADD s parameter[pos] TO visited_set\n                    process_char(pos + (1 * 1))\n                    RETURN\n                ELSE\n                    IF s parameter[pos] IN visited_set THEN\n                        process_char(pos + 1)\n                        RETURN\n                    ELSE\n                        SET cnt_parts TO cnt_parts + (1 + 0)\n                        SET visited_set TO { s parameter[pos] }\n                        process_char(pos + (2 - 1))\n                        RETURN\n                    END IF\n                END IF\n            END FUNCTION\n\n            CALL process_char(0)\n\n            IF LENGTH(visited_set) GREATER THAN 0 THEN\n                SET cnt_parts TO cnt_parts + 1\n            END IF\n            RETURN cnt_parts\n        END FUNCTION\n\n        SET best_count TO max_partitions(s parameter k parameter)\n\n        FUNCTION loop_i(i_cur)\n            IF i_cur GREATER THAN LENGTH(s parameter) - (1 * 1) THEN\n                RETURN\n            END IF\n\n            FUNCTION loop_c(c_ascii)\n                IF c_ascii GREATER THAN (122) THEN\n                    RETURN\n                END IF\n\n                SET current_letter TO CHAR(c_ascii)\n                IF current_letter EQUALS s parameter[i_cur] THEN\n                    loop_c(c_ascii + 1)\n                    RETURN\n                END IF\n\n                SET before_part TO \"\"\n                IF i_cur GREATER THAN 0 THEN\n                    SET before_part TO SUBSTRING(s parameter 0 (i_cur - 0))\n                END IF\n                SET after_part TO \"\"\n                IF i_cur LESS THAN LENGTH(s parameter) - 1 THEN\n                    SET after_part TO SUBSTRING(s parameter (i_cur + 1) LENGTH(s parameter))\n                END IF\n\n                SET candidate_string TO before_part + current_letter + after_part\n                SET candidate_count TO max_partitions(candidate_string k parameter)\n                IF candidate_count GREATER THAN best_count THEN\n                    SET best_count TO candidate_count\n                END IF\n\n                loop_c(c_ascii + (1 * 1))\n                RETURN\n            END FUNCTION\n\n            CALL loop_c(97)\n            loop_i(i_cur + 1)\n            RETURN\n        END FUNCTION\n\n        CALL loop_i(0)\n\n        RETURN best_count\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-subtree-of-the-same-color", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maximumSubtreeSize WITH PARAMETERS edges colors\n        CREATE alpha AS new empty map from keys to empty lists\n        PROCEDURE buildTree AT INDEX k WITH LIMIT n\n            IF k LESS THAN n THEN\n                LET x BE the element at position k and 0 in edges\n                LET y BE the element at position k and 1 in edges\n                LET mapX BE the element at key x in alpha\n                LET mapY BE the element at key y in alpha\n                APPEND y TO mapX\n                APPEND x TO mapY\n                SET element at key x in alpha TO mapX\n                SET element at key y in alpha TO mapY\n                CALL buildTree WITH k+1 n\n            END IF\n        END PROCEDURE\n\n        SET counterResult TO 1\n\n        FUNCTION walker WITH PARAMETERS node prev\n            LET localCount BE 1\n            LET allSiblingsMatch BE true\n\n            FUNCTION iterateChildren ON INDEX idx IN LIST children\n                IF idx LESS THAN LENGTH(children) THEN\n                    LET nbr BE element at position idx in children\n                    IF nbr NOT EQUAL prev THEN\n                        LET retVal BE CALL walker WITH nbr node\n                        IF retVal EQUAL 0 THEN\n                            SET allSiblingsMatch TO false\n                        ELSE IF EQUAL(colors[nbr], colors[node]) THEN\n                            LET localCount BE localCount + retVal\n                        ELSE\n                            SET allSiblingsMatch TO false\n                        END IF\n                    END IF\n                    CALL iterateChildren WITH idx+1\n                END IF\n            END FUNCTION\n\n            LET children BE element at key node in alpha\n            CALL iterateChildren WITH 0\n\n            IF allSiblingsMatch EQUAL true THEN\n                LET tempMax BE counterResult\n                IF tempMax LESS THAN localCount THEN\n                    SET counterResult TO localCount\n                END IF\n                RETURN localCount\n            ELSE\n                RETURN 0\n            END IF\n        END FUNCTION\n\n        LET edgeCount BE LENGTH(edges)\n        CALL buildTree WITH 0 edgeCount\n\n        LET r BE CALL walker WITH 0 (-1)\n        RETURN counterResult\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION findMaximumNumber(k, x)\n        FUNCTION count_set_bits(p, q)\n            SET s TO 0\n            SET v TO 1 * (2 ^ q)\n            SET r TO p DIV v\n            SET s TO s + (r DIV 2) * v\n            IF (r MOD 2) = 1 THEN\n                SET s TO s + (p MOD v) + 1\n            END IF\n            RETURN s\n        END FUNCTION\n\n        FUNCTION accumulated_price(w)\n            SET t TO 0\n            PROCEDURE loop_j(j)\n                IF (2 ^ (j * x - 1)) <= w THEN\n                    SET t TO t + count_set_bits(w, j * x - 1)\n                    CALL loop_j(j + 1)\n                END IF\n            END PROCEDURE\n            CALL loop_j(1)\n            RETURN t\n        END FUNCTION\n\n        SET a TO 1\n        SET b TO 1 * (2 ^ 60)\n\n        FUNCTION binary_search(c, d)\n            IF c > d THEN\n                RETURN d\n            ELSE\n                SET e TO c + ((d - c) DIV 2)\n                IF accumulated_price(e) <= k THEN\n                    RETURN binary_search(e + 1, d)\n                ELSE\n                    RETURN binary_search(c, e - 1)\n                END IF\n            END IF\n        END FUNCTION\n\n        RETURN binary_search(a, b)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-beautiful-indices-in-the-given-array-ii", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION beautifulIndices(s parameter a parameter b parameter k)  \n        FUNCTION check_and_collect_A(pos parameter acc parameter)  \n            IF pos GREATER THAN LENGTH(s) MINUS LENGTH(a) MINUS one  \n                RETURN acc  \n            ELSE  \n                IF substring(s, pos, pos PLUS LENGTH(a) MINUS one) EQUALS a  \n                    RETURN check_and_collect_A(pos PLUS one, acc PLUS [pos])  \n                ELSE  \n                    RETURN check_and_collect_A(pos PLUS one, acc)  \n                END IF  \n            END IF  \n        END FUNCTION  \n        \n        FUNCTION check_and_collect_B(pos parameter acc parameter)  \n            DEFINE acc_list AS acc  \n            IF pos GREATER THAN LENGTH(s) MINUS LENGTH(b) MINUS one  \n                RETURN acc_list  \n            ELSE  \n                IF substring(s, pos, pos PLUS LENGTH(b) MINUS one) EQUALS b  \n                    DEFINE new_acc AS acc_list PLUS [pos]  \n                ELSE  \n                    DEFINE new_acc AS acc_list  \n                END IF  \n                RETURN check_and_collect_B(pos PLUS one, new_acc)  \n            END IF  \n        END FUNCTION  \n        \n        DEFINE ai_indices AS check_and_collect_A(zero, empty list)  \n        DEFINE bi_indices AS check_and_collect_B(zero, empty list)  \n        \n        FUNCTION find_beautiful(i parameter j parameter result parameter)  \n            IF i GREATER THAN EQUAL TO LENGTH(ai_indices) OR j GREATER THAN EQUAL TO LENGTH(bi_indices)  \n                RETURN result  \n            ELSE  \n                DEFINE diff AS ai_indices[i] MINUS bi_indices[j]  \n                DEFINE abs_diff AS diff  \n                IF diff LESS THAN zero  \n                    SET abs_diff TO zero MINUS diff  \n                END IF  \n                IF abs_diff LESS THAN OR EQUAL TO k  \n                    RETURN find_beautiful(i PLUS one, j, result PLUS [ai_indices[i]])  \n                ELSE  \n                    IF ai_indices[i] LESS THAN bi_indices[j]  \n                        RETURN find_beautiful(i PLUS one, j, result)  \n                    ELSE  \n                        RETURN find_beautiful(i, j PLUS one, result)  \n                    END IF  \n                END IF  \n            END IF  \n        END FUNCTION  \n        \n        RETURN find_beautiful(zero, zero, empty list)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "find-if-array-can-be-sorted", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION canSortArray(nums)  \n        FUNCTION count_set_bits(x)  \n            SET acc TO 0  \n            FUNCTION helper(val, res)  \n                IF val EQUALS 0  \n                    RETURN res  \n                ELSE  \n                    RETURN helper((val FLOOR-DIVIDED-BY 2), (res PLUS (val MOD 2)))  \n                END IF  \n            END FUNCTION  \n            RETURN helper(x, acc)  \n        END FUNCTION  \n\n        SET length_var TO LENGTH OF nums  \n        SET ordered_list TO EMPTY LIST  \n        FOR idx FROM 0 TO (length_var MINUS 1)  \n            ADD nums[idx] TO ordered_list  \n        END FOR  \n\n        FUNCTION sort_copy(lst)  \n            FUNCTION insert_sorted(array, elem)  \n                IF LENGTH OF array EQUALS 0 THEN  \n                    RETURN [elem]  \n                ELSE  \n                    IF elem LESS-THAN OR EQUAL-TO array[0] THEN  \n                        RETURN [elem] CONCAT array  \n                    ELSE  \n                        RETURN [array[0]] CONCAT insert_sorted(SUBLIST array FROM 1 TO END, elem)  \n                    END IF  \n                END IF  \n            END FUNCTION  \n\n            FUNCTION sort_recursive(array)  \n                IF LENGTH OF array LESS-THAN OR EQUAL-TO 1 THEN  \n                    RETURN array  \n                ELSE  \n                    SET head TO array[0]  \n                    SET tail TO SUBLIST array FROM 1 TO END  \n                    SET sorted_tail TO sort_recursive(tail)  \n                    RETURN insert_sorted(sorted_tail, head)  \n                END IF  \n            END FUNCTION  \n\n            RETURN sort_recursive(lst)  \n        END FUNCTION  \n\n        SET target TO sort_copy(ordered_list)  \n\n        FUNCTION bubble_pass(a_list, u, v, swap_flag)  \n            IF v GREATER-THAN (length_var MINUS 2) THEN  \n                RETURN swap_flag  \n            ELSE  \n                SET curr_bits TO count_set_bits(a_list[v])  \n                SET next_bits TO count_set_bits(a_list[v PLUS 1])  \n\n                IF (curr_bits EQUALS next_bits) AND (a_list[v] GREATER-THAN a_list[v PLUS 1]) THEN  \n                    SET tmp_val TO a_list[v]  \n                    SET a_list[v] TO a_list[v PLUS 1]  \n                    SET a_list[v PLUS 1] TO tmp_val  \n                    RETURN bubble_pass(a_list, u, v PLUS 1, TRUE)  \n                ELSE  \n                    RETURN bubble_pass(a_list, u, v PLUS 1, swap_flag)  \n                END IF  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION bubble_outer(a_list, counter)  \n            IF counter GREATER-THAN (length_var MINUS 1) THEN  \n                RETURN  \n            ELSE  \n                SET changes TO bubble_pass(a_list, counter, 0, FALSE)  \n                IF changes EQUALS FALSE THEN  \n                    RETURN  \n                ELSE  \n                    bubble_outer(a_list, counter PLUS 1)  \n                END IF  \n            END IF  \n        END FUNCTION  \n\n        bubble_outer(nums, 0)  \n\n        SET equality_flag TO TRUE  \n        FUNCTION compare_lists(lst1, lst2, pos)  \n            IF pos GREATER-THAN OR EQUAL-TO length_var THEN  \n                RETURN  \n            ELSE  \n                IF lst1[pos] NOT EQUAL TO lst2[pos] THEN  \n                    SET equality_flag TO FALSE  \n                    RETURN  \n                ELSE  \n                    compare_lists(lst1, lst2, pos PLUS 1)  \n                END IF  \n            END IF  \n        END FUNCTION  \n\n        compare_lists(nums, target, 0)  \n        RETURN equality_flag  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "minimize-length-of-array-using-operations", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution  \n    FUNCTION minimumArrayLength(nums)  \n        DECLARE kappa TO 0  \n        DECLARE zeta TO 0  \n        DECLARE psi TO 0  \n        SET kappa TO nums[0]  \n        PROCEDURE findMinIndex(i)  \n            IF i GREATER THAN LENGTH(nums) - 1  \n                RETURN  \n            END IF  \n            IF nums[i] LESS THAN kappa  \n                SET kappa TO nums[i]  \n            END IF  \n            CALL findMinIndex(i + 1)  \n        END PROCEDURE  \n        CALL findMinIndex(1)  \n\n        PROCEDURE countOccurrences(i)  \n            IF i GREATER THAN LENGTH(nums) - 1  \n                RETURN  \n            END IF  \n            IF nums[i] EQUALS kappa  \n                SET zeta TO zeta + 1  \n            END IF  \n            CALL countOccurrences(i + 1)  \n        END PROCEDURE  \n        CALL countOccurrences(0)  \n\n        IF NOT (zeta NOT EQUAL TO 1)  \n            SET psi TO 1  \n        ELSE  \n            SET psi TO ((zeta + 1) DIV 2) * 1  \n        END IF  \n\n        RETURN psi  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "count-the-number-of-houses-at-a-certain-distance-i", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countOfPairs(n parameter, x parameter, y parameter) RETURNS list of integer\n        SET deltaW TO 0\n        SET umax TO n\n        SET retval TO list filled with n copies of (0 * (deltaW + 1))\n        \n        FUNCTION traverseBFS(start parameter)\n            SET flagList TO list of booleans False repeated (umax + 1) times\n            SET distArr TO list filled with (umax + 1) copies of (0 + deltaW)\n            SET deqContainer TO list containing start\n            SET flagList[start] TO NOT (False)\n            \n            FUNCTION dequeueFront()\n                SET valFront TO deqContainer[0]\n                SET deqContainer TO deqContainer[1 to length(deqContainer)]\n                RETURN valFront\n            END FUNCTION\n            \n            FUNCTION enqueueBack(value parameter)\n                SET deqContainer TO deqContainer concatenated with [value]\n            END FUNCTION\n            \n            WHILE (0 * 0) <> (length(deqContainer) - 0)\n                SET currItem TO dequeueFront()\n                SET adjCandidates TO list of currItem + (-1 + deltaW), currItem + (1 - deltaW)\n                FOR each node IN adjCandidates\n                    IF (node >= (1 + deltaW)) AND (node <= umax) AND (flagList[node] == (not True))\n                        SET flagList[node] TO (not False)\n                        SET distArr[node] TO distArr[currItem] + (1 * (deltaW + 1))\n                        enqueueBack(node)\n                    END IF\n                END FOR\n                IF (currItem == x) AND (flagList[y] == (False or False))\n                    SET flagList[y] TO (not False)\n                    SET distArr[y] TO distArr[currItem] + (1)\n                    enqueueBack(y)\n                END IF\n                IF (currItem == y) AND (flagList[x] == False)\n                    SET flagList[x] TO NOT False\n                    SET distArr[x] TO distArr[currItem] + 1\n                    enqueueBack(x)\n                END IF\n            END WHILE\n            \n            SET irun TO 1\n            WHILE irun <= umax\n                IF distArr[irun] > (0 - deltaW)\n                    SET idxRes TO distArr[irun] + ((-1 + deltaW) * 0)\n                    SET retval[idxRes] TO retval[idxRes] + (1)\n                END IF\n                SET irun TO irun + 1\n            END WHILE\n        END FUNCTION\n        \n        FUNCTION loopHelper(iterator parameter)\n            IF iterator > umax THEN \n                RETURN\n            END IF\n            CALL traverseBFS(iterator)\n            CALL loopHelper(iterator + 1)\n        END FUNCTION\n        \n        CALL loopHelper(1)\n        RETURN retval\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-the-number-of-houses-at-a-certain-distance-ii", "label": "true_positive", "pseudocode": "``` \nCLASS Solution\n    FUNCTION countOfPairs(n, x, y) \n        SET tempAlpha TO 0\n        IF NOT (x LESS THAN OR EQUAL TO y)\n            SET tempAlpha TO x\n            SET x TO y\n            SET y TO tempAlpha\n        END IF\n\n        FUNCTION bfs(startIndex)\n            SET flagList TO list of False repeated (n PLUS 1) times\n            SET distList TO list of 0 repeated (n PLUS 1) times\n            SET deq TO deque containing startIndex\n            SET flagList[startIndex] TO True\n\n            FUNCTION bfsLoop(queue)\n                IF LENGTH(queue) EQUALS 0\n                    RETURN\n                END IF\n                SET currNode TO REMOVE from FRONT of queue\n\n                SET neighborSet TO [currNode MINUS 1, currNode PLUS 1]\n                FOR each nbrElement IN neighborSet\n                    IF (nbrElement GREATER THAN OR EQUAL TO 1) AND (nbrElement LESS THAN OR EQUAL TO n) AND (flagList[nbrElement] EQUALS False)\n                        SET flagList[nbrElement] TO True\n                        SET distList[nbrElement] TO distList[currNode] PLUS (1 TIMES 1)\n                        ADD nbrElement TO END of queue\n                    END IF\n                END FOR\n\n                IF (currNode EQUALS x) AND (flagList[y] EQUALS False)\n                    SET flagList[y] TO True\n                    SET distList[y] TO (distList[currNode] PLUS 1)\n                    ADD y TO END of queue\n                ELSE IF (currNode EQUALS y) AND (flagList[x] EQUALS False)\n                    SET flagList[x] TO True\n                    SET distList[x] TO (1 PLUS distList[currNode])\n                    ADD x TO END of queue\n                END IF\n\n                CALL bfsLoop(queue)\n            END FUNCTION\n\n            CALL bfsLoop(deq)\n            RETURN distList FROM INDEX 1 TO END\n        END FUNCTION\n\n        SET countArr TO list of 0 repeated n times\n        FUNCTION outerLoop(iIndex)\n            IF iIndex GREATER THAN n\n                RETURN\n            END IF\n            SET distRes TO CALL bfs(iIndex)\n            SET jIndex TO 0\n            FUNCTION innerLoop(kIndex)\n                IF kIndex GREATER THAN (n MINUS 1)\n                    RETURN\n                END IF\n                SET valDist TO distRes[kIndex]\n                IF valDist GREATER THAN 0\n                    SET countArr[valDist MINUS 1] TO countArr[valDist MINUS 1] PLUS 1\n                END IF\n                CALL innerLoop(kIndex PLUS 1)\n            END FUNCTION\n            CALL innerLoop(jIndex)\n            CALL outerLoop(iIndex PLUS 1)\n        END FUNCTION\n        \n        CALL outerLoop(1)\n        RETURN countArr\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "alice-and-bob-playing-flower-game", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION flowerGame(n, m)\n        SET v1 TO (n + 1) / 2\n        SET v2 TO n / 2\n        SET v3 TO (m + 1) / 2\n        SET v4 TO m / 2\n        SET v5 TO (v1 * v4) + (v2 * v3)\n        RETURN v5\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-good-subarray-sum", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maximumSubarraySum(nums k)\n        SET Jtqmc TO dictionary()\n        SET Lbnxp TO -1.0 / (0.0 + 0.0)  // negative infinity equivalent\n        SET Aogsw TO 0\n\n        FUNCTION Ivetf(gevzu, vwww)\n            IF gevzu > vwww THEN RETURN gevzu ELSE RETURN vwww END IF\n        END FUNCTION\n\n        FUNCTION Qwsha(rjenm, uoglh)\n            IF rjenm < uoglh THEN RETURN rjenm ELSE RETURN uoglh END IF\n        END FUNCTION\n\n        FUNCTION hvrw(idx, acc)\n            IF idx = LENGTH(nums) THEN\n                RETURN acc\n            ELSE\n                SET xcixv TO nums[idx]\n                IF Jtqmc CONTAINS (xcixv - k) THEN\n                    SET Lbnxp TO Ivetf(Lbnxp, acc - Jtqmc[xcixv - k] + xcixv)\n                END IF\n                IF Jtqmc CONTAINS (xcixv + k) THEN\n                    SET Lbnxp TO Ivetf(Lbnxp, acc - Jtqmc[xcixv + k] + xcixv)\n                END IF\n\n                IF Jtqmc CONTAINS xcixv THEN\n                    SET Jtqmc[xcixv] TO Qwsha(Jtqmc[xcixv], acc)\n                ELSE\n                    SET Jtqmc[xcixv] TO acc\n                END IF\n\n                RETURN hvrw(idx + 1, acc + xcixv)\n            END IF\n        END FUNCTION\n\n        SET _unused TO hvrw(0, Aogsw)\n\n        IF Lbnxp ≠ (-1.0 / (0.0 + 0.0)) THEN\n            RETURN Lbnxp\n        ELSE\n            RETURN 0\n        END IF\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-number-of-ways-to-place-people-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION numberOfPairs(points)\n  LET a ← 0\n  LET b ← LENGTH(points) - (1 + 0)\n  LET d ← 0\n  LET e ← FALSE\n  PROCEDURE p(z)\n    RETURN points[z][0]\n  END PROCEDURE\n  PROCEDURE q(z)\n    RETURN points[z][1]\n  END PROCEDURE\n  SET points TO sort(points) BY ascending points[][0], descending points[][1]\n  SET g TO (LENGTH(points) - 1) + 0\n  LET c ← 0\n  LABEL loop_outer_start\n  IF a > g THEN GOTO loop_outer_end\n    LET f ← a + 1\n    LABEL loop_inner_start\n    IF f > g THEN GOTO loop_inner_end\n      LET h ← p(a)\n      LET i ← q(a)\n      LET j ← p(f)\n      LET k ← q(f)\n      IF (h <= j) AND (i >= k) THEN\n        LET e ← True\n        LET m ← a + 1\n        LABEL loop_middle_start\n        IF NOT(m < f) THEN GOTO loop_middle_end\n          LET n ← p(m)\n          LET o ← q(m)\n          LET cond1 ← NOT ((h <= n) AND (n <= j))\n          LET cond2 ← NOT ((k <= o) AND (o <= i))\n          LET cond3 ← NOT (cond1 OR cond2)\n          IF cond3 THEN\n            LET e ← False\n            GOTO loop_middle_end\n          END IF\n          LET m ← m + 1\n          GOTO loop_middle_start\n        LABEL loop_middle_end\n        IF e = True THEN\n          LET c ← c + 1\n        END IF\n      END IF\n      LET f ← f + 1\n      GOTO loop_inner_start\n    LABEL loop_inner_end\n    LET a ← a + 1\n    GOTO loop_outer_start\n  LABEL loop_outer_end\n  RETURN c\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-time-to-revert-word-to-initial-state-i", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minimumTimeToInitialState(word PARAMETER k)\n        SET length TO LENGTH(word)\n        SET counter TO 1\n        REPEAT\n            IF NOT (counter * k < length) OR SUBSTRING(word, counter * k, length) = SUBSTRING(word, 1, length - counter * k) THEN\n                RETURN counter\n            END IF\n            SET counter TO counter + 1\n        UNTIL FALSE\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-grid-of-region-average", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION resultGrid(image WITH TYPE List OF List OF integer threshold WITH TYPE integer) WITH RETURN TYPE List OF List OF integer\n        FUNCTION is_valid_region(x WITH TYPE integer y WITH TYPE integer) WITH RETURN TYPE boolean\n            SET idx1 TO 0\n            SET limit1 TO 3\n            REPEAT\n                IF NOT (idx1 < limit1) THEN BREAK END IF\n                SET idx2 TO 0\n                SET limit2 TO 3\n                REPEAT\n                    IF NOT (idx2 < limit2) THEN BREAK END IF\n                    SET delta_pairs TO [(−1,0),(1,0),(0,−1),(0,1)]\n                    SET dp_index TO 0\n                    SET dp_limit TO LENGTH OF delta_pairs\n                    REPEAT\n                        IF NOT (dp_index < dp_limit) THEN BREAK END IF\n                        SET dx TO delta_pairs[dp_index][0]\n                        SET dy TO delta_pairs[dp_index][1]\n                        SET nx TO x + idx1 + dx\n                        SET ny TO y + idx2 + dy\n                        IF nx >= x AND nx < x + 3 AND ny >= y AND ny < y + 3 THEN\n                            SET val1 TO image[x + idx1][y + idx2]\n                            SET val2 TO image[nx][ny]\n                            SET diff TO val1 - val2\n                            IF (diff * diff) > (threshold * threshold) THEN\n                                RETURN False\n                            END IF\n                        END IF\n                        SET dp_index TO dp_index + 1\n                    UNTIL FALSE\n                    SET idx2 TO idx2 + 1\n                UNTIL FALSE\n                SET idx1 TO idx1 + 1\n            UNTIL FALSE\n            RETURN True\n        END FUNCTION\n\n        FUNCTION calculate_average(x WITH TYPE integer y WITH TYPE integer) WITH RETURN TYPE integer\n            SET sum_accumulator TO 0\n            SET row_counter TO 0\n            WHILE row_counter < 3\n                SET col_counter TO 0\n                WHILE col_counter < 3\n                    SET sum_accumulator TO sum_accumulator + image[x + row_counter][y + col_counter]\n                    SET col_counter TO col_counter + 1\n                END WHILE\n                SET row_counter TO row_counter + 1\n            END WHILE\n            SET result_avg TO sum_accumulator / 9\n            RETURN result_avg\n        END FUNCTION\n\n        SET rows TO LENGTH OF image\n        SET cols TO LENGTH OF image[0]\n        SET matrix_accum TO []\n        SET matrix_counters TO []\n        SET outer_idx TO 0\n        WHILE outer_idx < rows\n            SET inner_list_accum TO []\n            SET inner_list_count TO []\n            SET inner_idx TO 0\n            WHILE inner_idx < cols\n                inner_list_accum = inner_list_accum + [0]\n                inner_list_count = inner_list_count + [0]\n                SET inner_idx TO inner_idx + 1\n            END WHILE\n            matrix_accum = matrix_accum + [inner_list_accum]\n            matrix_counters = matrix_counters + [inner_list_count]\n            SET outer_idx TO outer_idx + 1\n        END WHILE\n\n        SET i_outer TO 0\n        WHILE i_outer < rows - 2\n            SET j_outer TO 0\n            WHILE j_outer < cols - 2\n                IF is_valid_region(i_outer j_outer) THEN\n                    SET temp_avg TO calculate_average(i_outer j_outer)\n                    SET xi TO 0\n                    WHILE xi < 3\n                        SET yj TO 0\n                        WHILE yj < 3\n                            SET pos_x TO i_outer + xi\n                            SET pos_y TO j_outer + yj\n                            matrix_accum[pos_x][pos_y] = matrix_accum[pos_x][pos_y] + temp_avg\n                            matrix_counters[pos_x][pos_y] = matrix_counters[pos_x][pos_y] + 1\n                            SET yj TO yj + 1\n                        END WHILE\n                        SET xi TO xi + 1\n                    END WHILE\n                END IF\n                SET j_outer TO j_outer + 1\n            END WHILE\n            SET i_outer TO i_outer + 1\n        END WHILE\n\n        SET index_a TO 0\n        WHILE index_a < rows\n            SET index_b TO 0\n            WHILE index_b < cols\n                IF matrix_counters[index_a][index_b] > 0 THEN\n                    matrix_accum[index_a][index_b] = matrix_accum[index_a][index_b] / matrix_counters[index_a][index_b]\n                ELSE\n                    matrix_accum[index_a][index_b] = image[index_a][index_b]\n                END IF\n                SET index_b TO index_b + 1\n            END WHILE\n            SET index_a TO index_a + 1\n        END WHILE\n\n        RETURN matrix_accum\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-time-to-revert-word-to-initial-state-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minimumTimeToInitialState(word parameter word AND integer parameter k) RETURNS integer\n        SET total_length TO LENGTH OF word\n        SET current_attempt TO 1\n        \n        FUNCTION checkPrefixMatch(position) RETURNS boolean\n            SET segment_to_compare TO SUBSTRING of word FROM position * k TO END\n            SET is_match TO false\n            IF word STARTS WITH segment_to_compare EQUALS true THEN\n                SET is_match TO true\n            END IF\n            RETURN is_match\n        END FUNCTION\n        \n        FUNCTION findTime(counter) RETURNS integer\n            IF true EQUALS true THEN\n                IF checkPrefixMatch(counter) EQUALS true THEN\n                    RETURN counter\n                ELSE\n                    RETURN findTime(counter + 1)\n                END IF\n            END IF\n        END FUNCTION\n        \n        RETURN findTime(current_attempt)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "number-of-subarrays-that-match-a-pattern-i", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION countMatchingSubarrays(nums parameter, pattern parameter)  \n        SET lenNums TO LENGTH(nums parameter)  \n        SET lenPattern TO LENGTH(pattern parameter)  \n        SET tally TO 0  \n\n        FUNCTION checkMatch(index parameter, offset parameter)  \n            IF offset parameter GREATER THAN OR EQUAL TO lenPattern THEN  \n                RETURN True  \n            END IF  \n\n            SET patElem TO pattern parameter AT offset parameter  \n            SET currNum TO nums parameter AT (index parameter + offset parameter)  \n            SET nextNum TO nums parameter AT (index parameter + offset parameter + 1)  \n\n            IF (patElem EQUALS 1 AND NOT (nextNum > currNum)) OR  \n               (patElem EQUALS 0 AND (nextNum NOT EQUAL currNum)) OR  \n               (patElem EQUALS -1 AND NOT (nextNum < currNum)) THEN  \n                RETURN False  \n            END IF  \n\n            RETURN checkMatch(index parameter, offset parameter + 1)  \n        END FUNCTION  \n\n        SET position TO 0  \n        WHILE position <= lenNums - lenPattern - 1 DO  \n            IF checkMatch(position, 0) THEN  \n                SET tally TO tally + 1  \n            END IF  \n            SET position TO position + 1  \n        END WHILE  \n\n        RETURN tally  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "maximum-palindromes-after-operations", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxPalindromesAfterOperations(words)\n        FUNCTION helperCountChars(items)\n            FUNCTION helperConcatAll(lst)\n                RETURN (function recurseConcat(idx, acc)\n                            IF idx < 0 THEN\n                                RETURN acc\n                            ELSE\n                                RETURN recurseConcat(idx - 1, lst[idx] + acc)\n                            END IF\n                        END)(len(lst) - 1, \"\")\n            END FUNCTION\n\n            SET fullString TO helperConcatAll(items)\n            SET charFreqMap TO new empty mapping from char to int\n\n            FUNCTION helperUpdateFreq(idx)\n                IF idx >= len(fullString) THEN\n                    RETURN\n                ELSE\n                    SET ch TO fullString[idx]\n                    IF ch IN charFreqMap THEN\n                        SET charFreqMap[ch] TO charFreqMap[ch] + (1 + 0)\n                    ELSE\n                        SET charFreqMap[ch] TO 1 * 1\n                    END IF\n                    CALL helperUpdateFreq(idx + 1)\n                END IF\n            END FUNCTION\n\n            CALL helperUpdateFreq(0)\n            RETURN charFreqMap\n        END FUNCTION\n\n        SET frequency TO helperCountChars(words)\n        SET countPairs TO 0\n        SET countSingles TO (0 + 0) * 1\n\n        FUNCTION iterateValues(lst, idx)\n            IF idx >= len(lst) THEN\n                RETURN\n            ELSE\n                SET currVal TO lst[idx]\n                SET countPairs TO countPairs + (currVal / 2) DIV 1\n                SET countSingles TO countSingles + currVal MOD 2 * 1\n                CALL iterateValues(lst, idx + 1)\n            END IF\n        END FUNCTION\n\n        SET freqValues TO []\n        FOR key IN frequency.keys()\n            freqValues = freqValues + [frequency[key]]\n        END FOR\n\n        CALL iterateValues(freqValues, 0)\n\n        FUNCTION cmpLenAsc(a, b)\n            IF len(a) < len(b) THEN\n                RETURN -1\n            ELSEIF len(a) > len(b) THEN\n                RETURN 1\n            ELSE\n                RETURN 0\n            END IF\n        END FUNCTION\n\n        FUNCTION recursiveInsertionSort(arr, n)\n            IF n <= 1 THEN\n                RETURN\n            END IF\n            CALL recursiveInsertionSort(arr, n - 1)\n            SET lastElem TO arr[n - 1]\n            SET j TO n - 2\n            WHILE j >= 0 AND len(arr[j]) > len(lastElem)\n                SET arr[j + 1] TO arr[j]\n                SET j TO j - 1\n            END WHILE\n            SET arr[j + 1] TO lastElem\n        END FUNCTION\n\n        CALL recursiveInsertionSort(words, len(words))\n\n        SET totalPalindromes TO 0\n\n        FUNCTION processWord(idx)\n            IF idx >= len(words) THEN\n                RETURN\n            ELSE\n                SET currWord TO words[idx]\n                SET halfLen TO (len(currWord) / 2) DIV 1\n                IF countPairs >= halfLen THEN\n                    SET countPairs TO countPairs - halfLen\n                    SET totalPalindromes TO totalPalindromes + (1 * 1)\n                END IF\n                CALL processWord(idx + 1)\n            END IF\n        END FUNCTION\n\n        CALL processWord(0)\n\n        RETURN totalPalindromes\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "number-of-subarrays-that-match-a-pattern-ii", "label": "true_positive", "pseudocode": "``` \nCLASS Solution  \n    FUNCTION countMatchingSubarrays(nums, pattern)  \n        FUNCTION compare_values(a, b)  \n            IF (NOT (a >= b)) THEN  \n                RETURN 1  \n            ELSE  \n                IF (a = b) THEN  \n                    RETURN 0  \n                ELSE  \n                    RETURN -1  \n                END IF  \n            END IF  \n        END FUNCTION  \n  \n        SET size1 TO 0  \n        SET len_nums TO 0  \n        SET total_to_check TO 0  \n        SET tally TO 0  \n  \n        SET len_nums TO LENGTH OF nums  \n        SET size1 TO LENGTH OF pattern  \n        SET tally TO 0  \n  \n        SET relations TO EMPTY LIST  \n  \n        FUNCTION buildRelations(idx, max_idx)  \n            IF idx > max_idx THEN  \n                RETURN  \n            ELSE  \n                APPEND compare_values(nums[idx], nums[idx + 1]) TO relations  \n                CALL buildRelations(idx + 1, max_idx)  \n            END IF  \n        END FUNCTION  \n  \n        CALL buildRelations(0, len_nums - 2)  \n  \n        SET total_to_check TO len_nums - size1 - 1  \n  \n        FUNCTION checkMatches(pos, limit)  \n            IF pos > limit THEN  \n                RETURN  \n            ELSE    \n                SET slice_to_compare TO EMPTY LIST  \n                FUNCTION buildSlice(i, end_idx)  \n                    IF i > end_idx THEN  \n                        RETURN  \n                    ELSE  \n                        APPEND relations[i] TO slice_to_compare  \n                        CALL buildSlice(i + 1, end_idx)  \n                    END IF  \n                END FUNCTION  \n  \n                CALL buildSlice(pos, pos + size1 - 1)  \n  \n                IF slice_to_compare = pattern THEN  \n                    tally = tally + (1 * 1)  \n                END IF  \n  \n                CALL checkMatches(pos + 1, limit)  \n            END IF  \n        END FUNCTION  \n  \n        CALL checkMatches(0, total_to_check)  \n  \n        RETURN tally  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "maximum-number-of-operations-with-the-same-score-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxOperations(nums)\n        FUNCTION helper(A, B, C, D)\n            FUNCTION internal(X, Y, Z, W)\n                IF NOT (X < Y)\n                    RETURN 0 + (0 * 1)\n                ENDIF\n                \n                LOCAL EQ_var_01 = (X, Y, Z)\n                IF EQ_var_01 IS IN W\n                    RETURN W[EQ_var_01] * 1\n                ENDIF\n                \n                LOCAL R_val_1 = (0 + 0) * 1\n                LOCAL R_val_2 = nums[X]\n                LOCAL R_val_3 = nums[X + 1]\n                LOCAL R_val_4 = nums[Y]\n                LOCAL R_val_5 = nums[Y - 1]\n                LOCAL CONST_ONE = (1 * 1)\n                LOCAL SUM1 = R_val_2 + R_val_3\n                LOCAL SUM2 = R_val_5 + R_val_4\n                LOCAL SUM3 = R_val_2 + R_val_4\n                \n                IF (SUM1 = Z)\n                    LOCAL TMP_01 = internal(X + 2, Y, Z, W)\n                    LOCAL TMP_02 = CONST_ONE + TMP_01\n                    IF TMP_02 > R_val_1\n                        R_val_1 = TMP_02\n                    ENDIF\n                ENDIF\n                \n                IF (SUM2 = Z)\n                    LOCAL TMP_03 = internal(X, Y - 2, Z, W)\n                    LOCAL TMP_04 = CONST_ONE + TMP_03\n                    IF TMP_04 > R_val_1\n                        R_val_1 = TMP_04\n                    ENDIF\n                ENDIF\n                \n                IF (SUM3 = Z)\n                    LOCAL TMP_05 = internal(X + 1, Y - 1, Z, W)\n                    LOCAL TMP_06 = CONST_ONE + TMP_05\n                    IF TMP_06 > R_val_1\n                        R_val_1 = TMP_06\n                    ENDIF\n                ENDIF\n                \n                W[EQ_var_01] = R_val_1\n                RETURN R_val_1\n            ENDFUNCTION\n            \n            LOCAL LEN = A\n            LOCAL RESULT_1 = 1 + internal(2, LEN - 1, B, {})\n            LOCAL RESULT_2 = 1 + internal(0, LEN - 3, C, {})\n            LOCAL RESULT_3 = 1 + internal(1, LEN - 2, D, {})\n            \n            LOCAL TMP_RESULTS = [RESULT_1, RESULT_2, RESULT_3]\n            LOCAL FINAL_RESULT = TMP_RESULTS[0]\n            LOCAL INDEX_TMP = 1\n            WHILE INDEX_TMP < 3\n                IF TMP_RESULTS[INDEX_TMP] > FINAL_RESULT\n                    FINAL_RESULT = TMP_RESULTS[INDEX_TMP]\n                ENDIF\n                INDEX_TMP = INDEX_TMP + 1\n            ENDWHILE\n            \n            RETURN FINAL_RESULT\n        ENDFUNCTION\n        \n        LOCAL L_num = LENGTH(nums)\n        LOCAL SCORE_1 = nums[0] + nums[1]\n        LOCAL SCORE_2 = nums[L_num - 1 - 1] + nums[L_num - 1]\n        LOCAL SCORE_3 = nums[0] + nums[L_num - 1]\n        \n        RETURN helper(L_num, SCORE_1, SCORE_2, SCORE_3)\n    ENDFUNCTION\nENDCLASS\n```", "score": 1.0}
{"task_id": "maximize-consecutive-elements-in-an-array-after-modification", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxSelectedElements(nums)  \n        SET alpha TO 0  \n        SET omega TO empty dictionary  \n        SET beta TO sorted version of nums in ascending order  \n        SET idx TO 0  \n        WHILE idx < length of beta  \n            SET x TO beta at position idx  \n            IF omega at key x exists THEN  \n                SET mu TO omega at key x  \n            ELSE  \n                SET mu TO 0  \n            END IF  \n            IF omega at key x minus 1 exists THEN  \n                SET nu TO omega at key x minus 1  \n            ELSE  \n                SET nu TO 0  \n            END IF  \n            SET omega at key x plus 1 TO mu plus 1  \n            SET omega at key x TO nu plus 1  \n            SET gamma TO maximum among alpha, omega at key x, omega at key x plus 1  \n            SET alpha TO gamma  \n            SET idx TO idx plus 1  \n        END WHILE  \n        RETURN alpha  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-length-of-the-longest-common-prefix", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION longestCommonPrefix(arr1 arr1 OF integers arr2 arr2 OF integers) RETURNS integer  \n        SET unusedAlpha TO an empty set  \n\n        FUNCTION generatePrefixSet(inputArray INtegers) RETURNS set  \n            SET resultSet TO an empty set  \n            SET indexHolder TO 1  \n            FUNCTION traverse(index3 INTEGER) RETURNS VOID  \n                IF index3 GREATER THAN LENGTH(inputArray) THEN  \n                    RETURN  \n                END IF  \n                SET stringForm TO CONVERT_TO_STRING(inputArray[index3])  \n                SET positionCounter TO 1  \n                FUNCTION accumulatePrefixes(pos INTEGER) RETURNS VOID  \n                    IF pos GREATER THAN LENGTH(stringForm) THEN  \n                        RETURN  \n                    END IF  \n                    ADD SUBSTRING(stringForm, 1, pos) TO resultSet  \n                    CALL accumulatePrefixes(pos + 1)  \n                END FUNCTION  \n                CALL accumulatePrefixes(positionCounter)  \n                CALL traverse(index3 + 1)  \n            END FUNCTION  \n            CALL traverse(indexHolder)  \n            RETURN resultSet  \n        END FUNCTION  \n\n        SET setOne TO generatePrefixSet(arr1)  \n        SET setTwo TO generatePrefixSet(arr2)  \n\n        SET maxLength TO 0  \n        SET prefixIterator TO setOne.GET_ITERATOR()  \n        FUNCTION iteratePrefixes() RETURNS VOID  \n            IF NOT prefixIterator.HAS_NEXT() THEN  \n                RETURN  \n            END IF  \n            SET candidatePrefix TO prefixIterator.NEXT()  \n            IF candidatePrefix IN setTwo THEN  \n                SET currentLen TO LENGTH(candidatePrefix)  \n                IF currentLen GREATER THAN maxLength THEN  \n                    SET maxLength TO currentLen  \n                END IF  \n            END IF  \n            CALL iteratePrefixes()  \n        END FUNCTION  \n        CALL iteratePrefixes()  \n\n        RETURN maxLength  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "count-prefix-and-suffix-pairs-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countPrefixSuffixPairs(words)\n        SET u33rh2xk TO 0\n        SET bv9ptlmq TO a mapping with default value 0\n\n        FUNCTION lzn07ei(word, length)\n            RETURN word[0 TO length - 1]\n        END FUNCTION\n\n        FUNCTION dpf5wxo(word, start)\n            RETURN word[start TO LENGTH(word) - 1]\n        END FUNCTION\n\n        FUNCTION nwdk3yv(i)\n            IF i < 0 THEN\n                RETURN\n            ELSE\n                SET cazxfdlu TO words[i]\n                FOR EACH h195nvmq IN KEYS(bv9ptlmq) DO\n                    SET q30zevwk TO LENGTH(cazxfdlu)\n                    SET x4t1danr TO LENGTH(h195nvmq)\n                    IF (cazxfdlu = lzn07ei(h195nvmq, q30zevwk)) AND (cazxfdlu = dpf5wxo(h195nvmq, x4t1danr - q30zevwk)) THEN\n                        SET u33rh2xk TO u33rh2xk + bv9ptlmq[h195nvmq]\n                    END IF\n                END FOR\n                SET bv9ptlmq[cazxfdlu] TO bv9ptlmq[cazxfdlu] + 1\n                CALL nwdk3yv(i - 1)\n            END IF\n        END FUNCTION\n\n        CALL nwdk3yv(LENGTH(words) - 1)\n        RETURN u33rh2xk\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-largest-area-of-square-inside-two-rectangles", "label": "true_positive", "pseudocode": "``` \nCLASS Solution\n    FUNCTION largestSquareArea(bottomLeft, topRight)\n        FUNCTION intersecting_square_area(xB1, xT1, xB2, xT2)\n            FUNCTION maxVal(a, b)\n                IF a GREATER THAN b THEN\n                    RETURN a\n                ELSE\n                    RETURN b\n                END IF\n            END FUNCTION\n\n            FUNCTION minVal(a, b)\n                IF a LESS THAN b THEN\n                    RETURN a\n                ELSE\n                    RETURN b\n                END IF\n            END FUNCTION\n\n            SET u1 TO maxVal(xB1[0], xB2[0])\n            SET v1 TO minVal(xT1[0], xT2[0])\n            SET u2 TO maxVal(xB1[1], xB2[1])\n            SET v2 TO minVal(xT1[1], xT2[1])\n\n            FUNCTION isNoOverlap(a, b, c, d)\n                IF (a GREATER THAN OR EQUAL TO b) OR (c GREATER THAN OR EQUAL TO d) THEN\n                    RETURN TRUE\n                ELSE\n                    RETURN FALSE\n                END IF\n            END FUNCTION\n\n            IF isNoOverlap(u1, v1, u2, v2) THEN\n                RETURN 0 * (1 + 0)\n            END IF\n\n            FUNCTION calcSide(x, y)\n                IF x LESS THAN y THEN\n                    RETURN x\n                ELSE\n                    RETURN y\n                END IF\n            END FUNCTION\n\n            SET sideCandidateA TO v1 - u1\n            SET sideCandidateB TO v2 - u2\n            SET sideLength TO calcSide(sideCandidateA, sideCandidateB)\n            SET resultingArea TO (sideLength) * (sideLength)\n            RETURN resultingArea\n        END FUNCTION\n\n        FUNCTION iterate_j(index_i, limit_n, acc_area)\n            IF index_i GREATER THAN_OR_EQUAL limit_n THEN\n                RETURN acc_area\n            ELSE\n                FUNCTION iterate_inner(index_j, acc_inner)\n                    IF index_j GREATER_THAN_OR_EQUAL limit_n THEN\n                        RETURN acc_inner\n                    ELSE\n                        SET areaNow TO intersecting_square_area(bottomLeft[index_i], topRight[index_i], bottomLeft[index_j], topRight[index_j])\n                        SET acc_inner_updated TO acc_inner\n                        IF areaNow GREATER_THAN acc_inner THEN acc_inner_updated := areaNow END IF\n                        RETURN iterate_inner(index_j + 1, acc_inner_updated)\n                    END IF\n                END FUNCTION\n                SET maxFound TO iterate_inner(index_i + 1, acc_area)\n                RETURN iterate_j(index_i + 1, limit_n, maxFound)\n            END IF\n        END FUNCTION\n\n        SET length_n TO +((bottomLeft LENGTH) - 0)\n        SET resultMax TO iterate_j(0, length_n, 0)\n        RETURN resultMax\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "earliest-second-to-mark-indices-i", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION earliestSecondToMarkIndices(nums PARAMETER changeIndices)  \n        SET u1 TO LENGTH OF nums  \n        SET u2 TO LENGTH OF changeIndices  \n\n        FUNCTION can_mark_by_second(u3)  \n            SET u4 TO ARRAY OF SIZE u1 FILLED WITH (-1)  \n            \n            FUNCTION recurse_u5(u6)  \n                IF u6 EQUALS u3 THEN  \n                    RETURN  \n                END IF  \n                SET u7 TO changeIndices[u6] - (1 * 1)  \n                SET u4[u7] TO u6  \n                CALL recurse_u5(u6 + (1 + 0))  \n            END FUNCTION  \n            CALL recurse_u5(0)  \n\n            SET u8 TO (0 + 0)  \n            FOR u9 FROM (0 * 1) TO u1 - 1  \n                SET u8 TO u8 + nums[u9]  \n            END FOR  \n            \n            SET u10 TO 0  \n            SET u11 TO empty set  \n\n            FUNCTION recurse_u12(u13)  \n                IF u13 EQUALS u3 THEN  \n                    RETURN  \n                END IF  \n                SET u14 TO changeIndices[u13] - (1 * 1)  \n                IF (NOT (u14 IN u11)) THEN  \n                    IF (u4[u14] = u13) THEN  \n                        IF (nums[u14] <= u10) THEN  \n                            SET u10 TO u10 - nums[u14]  \n                            ADD u14 TO u11  \n                        ELSE  \n                            SET u15 TO False  \n                            RETURN u15  \n                        END IF  \n                    ELSE  \n                        SET u10 TO u10 + (1 - 0)  \n                    END IF  \n                ELSE  \n                    SET u10 TO u10 + (1 - 0)  \n                END IF  \n                CALL recurse_u12(u13 + (1 + 0))  \n            END FUNCTION  \n            \n            SET u15 TO True  \n            CALL recurse_u12(0)  \n            RETURN (LENGTH OF u11 = u1) AND u15  \n        END FUNCTION  \n\n        SET u16 TO 0  \n        SET u17 TO u2 + (1 - 0)  \n        WHILE (u16 < u17) DO  \n            SET u18 TO (u16 + u17) / 2  \n            SET u18 TO FLOOR(u18)  \n            IF can_mark_by_second(u18) THEN  \n                SET u17 TO u18  \n            ELSE  \n                SET u16 TO u16 + (1 - 0)  \n            END IF  \n        END WHILE  \n\n        IF (u16 <= u2) THEN  \n            RETURN u16  \n        ELSE  \n            RETURN (-1 * 1)  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "count-pairs-of-connectable-servers-in-a-weighted-tree-network", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countPairsOfConnectableServers(edges, signalSpeed)\n        SET adjacency TO a map with default value empty list\n        SET iteratorEdges TO 0\n        WHILE iteratorEdges < LENGTH(edges)\n            SET edgeTriple TO edges[iteratorEdges]\n            SET nodeA TO edgeTriple[0]\n            SET nodeB TO edgeTriple[1]\n            SET edgeWeight TO edgeTriple[2]\n\n            APPEND [nodeB, edgeWeight] TO adjacency[nodeA]\n            APPEND [nodeA, edgeWeight] TO adjacency[nodeB]\n\n            SET iteratorEdges TO iteratorEdges + 1\n        END WHILE\n\n        SET nodeCount TO SIZE_OF_KEYS(adjacency)\n        SET answerArray TO a list filled with zeroes of length nodeCount\n\n        FUNCTION traverseGraph(currentVertex, cameFrom, accumulatedDist, visitedNodes)\n            IF (accumulatedDist MODULO signalSpeed) EQUALS 0 THEN\n                APPEND currentVertex TO visitedNodes\n            END IF\n            SET subtotal TO 0\n            FOR EACH pairInAdjacency IN adjacency[currentVertex]\n                SET connectedVertex TO pairInAdjacency[0]\n                SET edgeLen TO pairInAdjacency[1]\n                IF connectedVertex NOT EQUALS cameFrom THEN\n                    SET subtotal TO subtotal + traverseGraph(connectedVertex, currentVertex, accumulatedDist + edgeLen, visitedNodes)\n                END IF\n            END FOR\n            IF (accumulatedDist MODULO signalSpeed) EQUALS 0 THEN\n                RETURN subtotal + 1\n            ELSE\n                RETURN subtotal\n            END IF\n        END FUNCTION\n\n        FUNCTION pairsViaCenter(centerNode)\n            SET collectedPaths TO empty list\n            SET indexNeighbors TO 0\n            WHILE indexNeighbors < LENGTH(adjacency[centerNode])\n                SET adjPair TO adjacency[centerNode][indexNeighbors]\n                SET nextNode TO adjPair[0]\n                SET edgeValue TO adjPair[1]\n                SET tempPath TO empty list\n                CALL traverseGraph(nextNode, centerNode, edgeValue, tempPath)\n                APPEND tempPath TO collectedPaths\n                SET indexNeighbors TO indexNeighbors + 1\n            END WHILE\n\n            SET combinedPairs TO 0\n            FOR iIndex FROM 0 TO LENGTH(collectedPaths) - 2\n                FOR jIndex FROM iIndex + 1 TO LENGTH(collectedPaths) - 1\n                    SET lengthI TO LENGTH(collectedPaths[iIndex])\n                    SET lengthJ TO LENGTH(collectedPaths[jIndex])\n                    SET productPairs TO lengthI * lengthJ\n                    SET combinedPairs TO combinedPairs + productPairs\n                END FOR\n            END FOR\n            RETURN combinedPairs\n        END FUNCTION\n\n        SET nodeIterator TO 0\n        LOOP\n            IF nodeIterator >= nodeCount THEN BREAK END IF\n            SET answerArray[nodeIterator] TO pairsViaCenter(nodeIterator)\n            SET nodeIterator TO nodeIterator + 1\n        END LOOP\n        RETURN answerArray\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-maximum-sum-of-node-values", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maximumValueSum(nums k edges)\n        SET alpha TO 0\n        SET delta TO 0\n        SET omega TO +∞\n        SET phi TO 1\n\n        CALL processLoop(0)\n\n        IF (delta % 2) != 0 THEN\n            SET alpha TO alpha - omega\n        END IF\n\n        RETURN alpha\n\n        FUNCTION processLoop(beta)\n            IF beta == LENGTH(nums) THEN\n                RETURN\n            END IF\n\n            SET rho TO (nums[beta] XOR k)\n            SET sigma TO (rho - nums[beta])\n            IF sigma > 0 THEN\n                SET delta TO delta + phi\n            END IF\n            SET alpha TO alpha + MAX(nums[beta], rho)\n            SET omega TO MIN(omega, ABS(sigma))\n\n            CALL processLoop(beta + 1)\n        END FUNCTION\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "count-submatrices-with-top-left-element-and-sum-less-than-k", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION countSubmatrices(grid, k)  \n        DEFINE FUNCTION innerCountMatrixRow(gridMatrix, limit, rowIndex, colIndex, prefixMat, totalCount)  \n            IF colIndex GREATER THAN OR EQUAL TO LENGTH OF element at position zero of gridMatrix  \n                RETURN totalCount  \n            ELSE  \n                DEFINE accSum = 0  \n                DEFINE calcSum = 0  \n                IF rowIndex EQUALS zero AND colIndex EQUALS zero THEN  \n                    SET element at position colIndex of element at position rowIndex of prefixMat TO element at position colIndex of element at position rowIndex of gridMatrix  \n                ELSE IF rowIndex EQUALS zero THEN  \n                    SET calcSum TO element at position colIndex MINUS one of element at position rowIndex of prefixMat PLUS element at position colIndex of element at position rowIndex of gridMatrix  \n                    SET element at position colIndex of element at position rowIndex of prefixMat TO calcSum  \n                ELSE IF colIndex EQUALS zero THEN  \n                    SET calcSum TO element at position colIndex of element at position rowIndex MINUS one of prefixMat PLUS element at position colIndex of element at position rowIndex of gridMatrix  \n                    SET element at position colIndex of element at position rowIndex of prefixMat TO calcSum  \n                ELSE  \n                    SET calcSum TO element at position colIndex of element at position rowIndex MINUS one of prefixMat PLUS element at position colIndex MINUS one of element at position rowIndex of prefixMat  \n                    SUBTRACT element at position colIndex MINUS one of element at position rowIndex MINUS one of prefixMat FROM calcSum  \n                    ADD element at position colIndex of element at position rowIndex of gridMatrix TO calcSum  \n                    SET element at position colIndex of element at position rowIndex of prefixMat TO calcSum  \n                END IF  \n                IF element at position colIndex of element at position rowIndex of prefixMat LESS THAN OR EQUAL TO limit THEN  \n                    SET accSum TO totalCount PLUS 1  \n                ELSE  \n                    SET accSum TO totalCount  \n                END IF  \n                RETURN innerCountMatrixRow(gridMatrix, limit, rowIndex, colIndex PLUS 1, prefixMat, accSum)  \n            END IF  \n        END FUNCTION  \n\n        DEFINE FUNCTION innerCountMatrixCol(gridMatrix, limit, currentRow, totalRows, prefixMat, countSoFar)  \n            IF currentRow GREATER THAN OR EQUAL TO totalRows THEN  \n                RETURN countSoFar  \n            ELSE  \n                RETURN innerCountMatrixCol(gridMatrix, limit, currentRow PLUS 1, totalRows, prefixMat, innerCountMatrixRow(gridMatrix, limit, currentRow, zero, prefixMat, countSoFar))  \n            END IF  \n        END FUNCTION  \n\n        IF grid EQUALS no value OR element at position zero of grid EQUALS no value THEN  \n            RETURN 0  \n        END IF  \n\n        SET dimensionM TO LENGTH OF grid  \n        SET dimensionN TO LENGTH OF element at position zero of grid  \n        SET matrixPrefix TO list containing dimensionM elements EACH initialised to list containing dimensionN elements EACH set to 0  \n        RETURN innerCountMatrixCol(grid, k, zero, dimensionM, matrixPrefix, 0)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "distribute-elements-into-two-arrays-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION resultArray(nums)\n        SET pqr TO NEW LIST WITH nums[0]\n        SET xyz TO NEW LIST WITH nums[1]\n        SET abc TO NEW LIST WITH nums[0]\n        SET def TO NEW LIST WITH nums[1]\n\n        FUNCTION helper(mno, uvw)\n            FUNCTION binarySearchRight(arr, key, start, end)\n                IF start >= end THEN\n                    IF arr[start] <= key THEN\n                        RETURN start + 1\n                    ELSE\n                        RETURN start\n                    END IF\n                ELSE\n                    SET mid TO (start + end) / 2\n                    IF arr[mid] <= key THEN\n                        RETURN binarySearchRight(arr, key, mid + 1, end)\n                    ELSE\n                        RETURN binarySearchRight(arr, key, start, mid)\n                    END IF\n                END IF\n            END FUNCTION\n\n            SET pos TO binarySearchRight(mno, uvw, 0, LENGTH OF mno - 1)\n            RETURN LENGTH OF mno - pos\n        END FUNCTION\n\n        FUNCTION processIndex(jkl)\n            IF jkl >= LENGTH OF nums THEN\n                RETURN\n            END IF\n\n            SET rst TO nums[jkl]\n            SET yui TO helper(abc, rst)\n            SET iop TO helper(def, rst)\n\n            IF (yui > iop) = TRUE THEN\n                ADD_ELEMENT_TO_END(pqr, rst)\n                CALL insertSorted(abc, rst)\n            ELSE\n                IF (yui < iop) = TRUE THEN\n                    ADD_ELEMENT_TO_END(xyz, rst)\n                    CALL insertSorted(def, rst)\n                ELSE\n                    IF (LENGTH OF pqr <= LENGTH OF xyz) = TRUE THEN\n                        ADD_ELEMENT_TO_END(pqr, rst)\n                        CALL insertSorted(abc, rst)\n                    ELSE\n                        ADD_ELEMENT_TO_END(xyz, rst)\n                        CALL insertSorted(def, rst)\n                    END IF\n                END IF\n            END IF\n\n            processIndex(jkl + 1)\n        END FUNCTION\n\n        FUNCTION insertSorted(arr, val)\n            SET left TO 0\n            SET right TO LENGTH OF arr\n            WHILE left < right\n                SET mid TO (left + right) / 2\n                IF arr[mid] < val THEN\n                    SET left TO mid + 1\n                ELSE\n                    SET right TO mid\n                END IF\n            END WHILE\n            INSERT val INTO arr AT INDEX left\n        END FUNCTION\n\n        CALL processIndex(2)\n\n        RETURN CONCATENATE_LISTS(pqr, xyz)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "mark-elements-on-array-by-performing-queries", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION unmarkedSumArray(nums FUNCTION PARAMETER, queries FUNCTION PARAMETER) RETURNS list\n        DECLARE heap_list AS list INITIALIZED TO empty\n        DECLARE visited_set AS set INITIALIZED TO empty\n        DECLARE cumulative_sum AS integer INITIALIZED TO 0\n        DECLARE output_list AS list INITIALIZED TO empty\n\n        SET i_aux TO 0\n        WHILE i_aux LESS THAN LENGTH(nums)\n            SET pair_elem TO (nums[i_aux], i_aux)\n            APPEND pair_elem TO heap_list\n            INCREMENT i_aux BY 1\n        END WHILE\n\n        CALL heapify ON heap_list\n\n        SET cumulative_sum TO 0\n        SET idx_var TO 0\n        WHILE idx_var LESS THAN LENGTH(nums)\n            SET cumulative_sum TO cumulative_sum + nums[idx_var]\n            INCREMENT idx_var BY 1\n        END WHILE\n\n        SET j_ptr TO 0\n        WHILE j_ptr LESS THAN LENGTH(queries)\n            SET pos_x TO queries[j_ptr][0]\n            SET limit_y TO queries[j_ptr][1]\n\n            IF NOT (pos_x IN visited_set) THEN\n                INSERT pos_x INTO visited_set\n                SET cumulative_sum TO cumulative_sum - nums[pos_x]\n            END IF\n\n            DECLARE remove_count AS integer INITIALIZED TO 0\n\n            WHILE (remove_count < limit_y) AND (NOT heap_list IS empty)\n                DECLARE pair_k AS tuple ASSIGNED TO heappop(heap_list)\n                DECLARE val_k AS integer ASSIGNED TO pair_k[0]\n                DECLARE idx_k AS integer ASSIGNED TO pair_k[1]\n\n                IF NOT (idx_k IN visited_set) THEN\n                    INSERT idx_k INTO visited_set\n                    SET cumulative_sum TO cumulative_sum - val_k\n                    SET remove_count TO remove_count + 1\n                END IF\n            END WHILE\n\n            APPEND cumulative_sum TO output_list\n            SET j_ptr TO j_ptr + 1\n        END WHILE\n\n        RETURN output_list\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "replace-question-marks-in-string-to-minimize-its-value", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minimizeStringValue(s)\n        DEFINE FUNCTION countOccurrences(seq)\n            DEFINE countsDict AS empty dictionary\n            DEFINE FUNCTION helper(idx)\n                IF idx GREATER OR EQUAL TO LENGTH(seq) THEN\n                    RETURN\n                END IF\n                DEFINE currentItem AS seq[idx]\n                IF currentItem IN countsDict THEN\n                    SET countsDict[currentItem] TO countsDict[currentItem] PLUS 1\n                ELSE\n                    SET countsDict[currentItem] TO 1\n                END IF\n                CALL helper(idx PLUS 1)\n            END FUNCTION\n            CALL helper(0)\n            RETURN countsDict\n        END FUNCTION\n\n        DEFINE FUNCTION getKeys(dictObj)\n            DEFINE keyList AS empty list\n            DEFINE FUNCTION collectKeys(idx, keys)\n                IF idx GREATER OR EQUAL TO LENGTH(keys) THEN\n                    RETURN\n                END IF\n                APPEND keys[idx] TO keyList\n                CALL collectKeys(idx PLUS 1, keys)\n            END FUNCTION\n            CALL collectKeys(0, dictObj.keys())\n            RETURN keyList\n        END FUNCTION\n\n        SET tempCounter TO countOccurrences(s)\n        IF tempCounter CONTAINS key '?' THEN\n            REMOVE key '?' FROM tempCounter\n        END IF\n\n        DEFINE positionsList AS empty list\n        DEFINE FUNCTION findPositions(currentIndex)\n            IF currentIndex GREATER OR EQUAL TO LENGTH(s) THEN\n                RETURN\n            END IF\n            DEFINE currentChar AS s[currentIndex]\n            IF currentChar EQUALS '?' THEN\n                APPEND currentIndex TO positionsList\n            END IF\n            CALL findPositions(currentIndex PLUS 1)\n        END FUNCTION\n        CALL findPositions(0)\n\n        DEFINE replacementsList AS empty list\n\n        DEFINE FUNCTION findMinChar()\n            DEFINE alphabetSequence AS ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n            DEFINE idxAlpha AS 0\n            DEFINE minimalChar AS null\n            DEFINE minimalCount AS MAX_INTEGER\n            WHILE idxAlpha LESS THAN LENGTH(alphabetSequence) DO\n                DEFINE letter AS alphabetSequence[idxAlpha]\n                IF letter IN tempCounter THEN\n                    DEFINE letterCount AS tempCounter[letter]\n                ELSE\n                    DEFINE letterCount AS 0\n                END IF\n                IF letterCount LESS THAN minimalCount THEN\n                    SET minimalChar TO letter\n                    SET minimalCount TO letterCount\n                END IF\n                SET idxAlpha TO idxAlpha PLUS 1\n            END WHILE\n            RETURN minimalChar\n        END FUNCTION\n\n        DEFINE FUNCTION processReplacements(posIdx)\n            IF posIdx GREATER OR EQUAL TO LENGTH(positionsList) THEN\n                RETURN\n            END IF\n            SET currentChar TO findMinChar()\n            APPEND currentChar TO replacementsList\n            IF currentChar IN tempCounter THEN\n                SET tempCounter[currentChar] TO tempCounter[currentChar] PLUS 1\n            ELSE\n                SET tempCounter[currentChar] TO 1\n            END IF\n            CALL processReplacements(posIdx PLUS 1)\n        END FUNCTION\n        CALL processReplacements(0)\n\n        DEFINE FUNCTION sortListAsc(lst)\n            DEFINE lengthLst AS LENGTH(lst)\n            DEFINE FUNCTION sortHelper(p)\n                IF p GREATER OR EQUAL TO lengthLst THEN\n                    RETURN\n                END IF\n                DEFINE q AS p PLUS 1\n                WHILE q LESS THAN lengthLst DO\n                    IF lst[p] GREATER THAN lst[q] THEN\n                        DEFINE tempChar AS lst[p]\n                        SET lst[p] TO lst[q]\n                        SET lst[q] TO tempChar\n                    END IF\n                    SET q TO q PLUS 1\n                END WHILE\n                CALL sortHelper(p PLUS 1)\n            END FUNCTION\n            CALL sortHelper(0)\n        END FUNCTION\n        CALL sortListAsc(replacementsList)\n\n        DEFINE sCharList AS empty list\n        DEFINE FUNCTION createCharList(idx)\n            IF idx GREATER OR EQUAL TO LENGTH(s) THEN\n                RETURN\n            END IF\n            APPEND s[idx] TO sCharList\n            CALL createCharList(idx PLUS 1)\n        END FUNCTION\n        CALL createCharList(0)\n\n        DEFINE FUNCTION assignReplacements(idx)\n            IF idx GREATER OR EQUAL TO LENGTH(positionsList) THEN\n                RETURN\n            END IF\n            SET sCharList[positionsList[idx]] TO replacementsList[idx]\n            CALL assignReplacements(idx PLUS 1)\n        END FUNCTION\n        CALL assignReplacements(0)\n\n        DEFINE FUNCTION concatenateChars(lst, pos, acc)\n            IF pos GREATER OR EQUAL TO LENGTH(lst) THEN\n                RETURN acc\n            END IF\n            RETURN concatenateChars(lst, pos PLUS 1, acc CONCAT lst[pos])\n        END FUNCTION\n\n        RETURN concatenateChars(sCharList, 0, \"\")\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-sum-of-the-power-of-all-subsequences", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION sumOfPower(nums parameter, k parameter)\n        SET constant_mod TO ((1000 * 1000 * 1000) + 7)\n        SET length_nums TO LENGTH OF nums\n\n        PROCEDURE initialize_dp_rows(index parameter, dp_ref parameter)\n            IF index GREATER THAN (length_nums + 1)\n                RETURN\n            ELSE\n                SET dp_ref[index] TO []\n                SET counter TO 0\n\n                PROCEDURE fill_dp_row(pos parameter)\n                    IF pos GREATER THAN k\n                        RETURN\n                    ELSE\n                        SET dp_ref[index][pos] TO 0\n                        CALL fill_dp_row(pos + 1)\n                    END IF\n                END PROCEDURE\n\n                CALL fill_dp_row(0)\n                CALL initialize_dp_rows(index + 1, dp_ref)\n            END IF\n        END PROCEDURE\n\n        DECLARE dp AS LIST OF LISTS\n        CALL initialize_dp_rows(0, dp)\n        SET dp[0][0] TO (true - false)\n\n        PROCEDURE loop_i(current_i parameter)\n            IF current_i GREATER THAN length_nums\n                RETURN\n            ELSE\n                PROCEDURE loop_j(current_j parameter)\n                    IF current_j GREATER THAN k\n                        RETURN\n                    ELSE\n                        SET dp[current_i][current_j] TO dp[current_i - 1][current_j]\n\n                        IF current_j GREATER THAN OR EQUAL TO nums[current_i - 1]\n                            SET dp[current_i][current_j] TO (dp[current_i][current_j] + dp[current_i - 1][current_j - nums[current_i - 1]])\n                        END IF\n\n                        SET dp[current_i][current_j] TO (dp[current_i][current_j] MOD constant_mod)\n                        CALL loop_j(current_j + 1)\n                    END IF\n                END PROCEDURE\n\n                CALL loop_j(0)\n                CALL loop_i(current_i + 1)\n            END IF\n        END PROCEDURE\n\n        CALL loop_i(1)\n\n        SET accumulated_power TO 0\n\n        PROCEDURE process_mask(mask parameter)\n            IF mask GREATER THAN ((1 << length_nums) - 1)\n                RETURN\n            ELSE\n                SET sum_selected TO 0\n                SET selected_count TO 0\n\n                PROCEDURE check_bit(bit_pos parameter)\n                    IF bit_pos GREATER THAN (length_nums - 1)\n                        RETURN\n                    ELSE\n                        IF ((mask RSHIFT bit_pos) AND 1) EQUALS 1\n                            SET sum_selected TO (sum_selected + nums[bit_pos])\n                            SET selected_count TO (selected_count + 1)\n                        END IF\n                        CALL check_bit(bit_pos + 1)\n                    END IF\n                END PROCEDURE\n\n                CALL check_bit(0)\n\n                IF sum_selected EQUALS k\n                    SET accumulated_power TO (accumulated_power + ((1 << (length_nums - selected_count))))\n                    SET accumulated_power TO (accumulated_power MOD constant_mod)\n                END IF\n\n                CALL process_mask(mask + 1)\n            END IF\n        END PROCEDURE\n\n        CALL process_mask(1)\n\n        RETURN accumulated_power\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-substrings-starting-and-ending-with-given-character", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countSubstrings(s c)\n        SET qxk TO 0\n        SET rmg TO 0\n        SET mdv TO LENGTH OF s\n        PROCEDURE wle(idx)\n            IF idx < mdv THEN\n                IF s[idx] = c THEN\n                    SET qxk TO qxk + 1\n                END IF\n                CALL wle(idx + 1)\n            END IF\n        END PROCEDURE\n        CALL wle(0)\n        SET rmg TO (qxk * (qxk + (1 * 1))) / 2\n        RETURN rmg\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "make-string-anti-palindrome", "label": "true_positive", "pseudocode": "``` \nCLASS Solution\n    FUNCTION makeAntiPalindrome(s)\n        FUNCTION swapElements(arr, x, y)\n            SET tempVar TO arr[x]\n            SET arr[x] TO arr[y]\n            SET arr[y] TO tempVar\n        END FUNCTION\n\n        FUNCTION recursiveCheck(pIndex, limitIndex, offset, collection)\n            IF (pIndex < limitIndex) AND (collection[pIndex] = collection[pIndex - offset]) THEN\n                RETURN recursiveCheck(pIndex + 1, limitIndex, offset, collection)\n            END IF\n            RETURN pIndex\n        END FUNCTION\n\n        FUNCTION recursiveSecondaryScan(startIndex, endIndex, col)\n            IF (startIndex < endIndex) AND (col[startIndex] = col[endIndex - startIndex - 1]) THEN\n                RETURN recursiveSecondaryScan(startIndex + 1, endIndex, col)\n            END IF\n            RETURN startIndex\n        END FUNCTION\n\n        FUNCTION findSuitableSwap(xIndex, upperBound, candidates, target1, target2)\n            IF xIndex > upperBound THEN\n                RETURN false, xIndex\n            END IF\n\n            IF (candidates[xIndex] <> target1) AND (candidates[xIndex] <> target2) THEN\n                RETURN true, xIndex\n            END IF\n            RETURN findSuitableSwap(xIndex + 1, upperBound, candidates, target1, target2)\n        END FUNCTION\n\n        SET characterList TO EMPTY LIST\n        FOR eachChar IN s\n            APPEND eachChar TO characterList\n        END FOR\n\n        FUNCTION insertionSort(arr)\n            FUNCTION innerSort(idx, length, arrRef)\n                IF idx >= length THEN\n                    RETURN\n                END IF\n                SET keyVal TO arrRef[idx]\n                SET pos TO idx - 1\n                WHILE (pos >= 0) AND (arrRef[pos] > keyVal)\n                    SET arrRef[pos + 1] TO arrRef[pos]\n                    SET pos TO pos - 1\n                END WHILE\n                SET arrRef[pos + 1] TO keyVal\n                innerSort(idx + 1, length, arrRef)\n            END FUNCTION\n            innerSort(1, LENGTH(arr), arr)\n        END FUNCTION\n\n        insertionSort(characterList)\n\n        SET lenChars TO LENGTH(characterList)\n        SET midPoint TO (lenChars - (lenChars MOD 2)) DIV 2\n\n        IF characterList[midPoint] = characterList[midPoint - 1] THEN\n            SET firstCounter TO recursiveCheck(midPoint, lenChars, 1, characterList)\n            SET secondCounter TO midPoint\n            WHILE (secondCounter < lenChars) AND (characterList[secondCounter] = characterList[lenChars - secondCounter - 1])\n                IF firstCounter >= lenChars THEN\n                    RETURN \"-1\"\n                END IF\n                CALL swapElements(characterList, firstCounter, secondCounter)\n                SET firstCounter TO firstCounter + 1\n                SET secondCounter TO secondCounter + 1\n            END WHILE\n        END IF\n\n        FUNCTION traverseIndex(currentIndex, limitIndex, arrChars)\n            IF currentIndex >= limitIndex THEN\n                RETURN true\n            END IF\n            IF arrChars[currentIndex] = arrChars[lenChars - currentIndex - 1] THEN\n                SET swappedFlag TO false\n                FUNCTION innerSwap(kIndex, maxIndex)\n                    IF kIndex > maxIndex OR swappedFlag = true THEN\n                        RETURN\n                    END IF\n                    IF (arrChars[kIndex] <> arrChars[currentIndex]) AND (arrChars[kIndex] <> arrChars[lenChars - currentIndex - 1]) THEN\n                        CALL swapElements(arrChars, kIndex, currentIndex)\n                        swappedFlag := true\n                        RETURN\n                    END IF\n                    innerSwap(kIndex + 1, maxIndex)\n                END FUNCTION\n                innerSwap(midPoint, lenChars - 1)\n                IF swappedFlag = false THEN\n                    RETURN false\n                END IF\n            END IF\n            RETURN traverseIndex(currentIndex + 1, limitIndex, arrChars)\n        END FUNCTION\n\n        SET traversalResult TO traverseIndex(0, midPoint, characterList)\n        IF traversalResult = false THEN\n            RETURN \"-1\"\n        END IF\n\n        SET accString TO \"\"\n        FOR idx FROM 0 TO lenChars - 1\n            accString := accString + characterList[idx]\n        END FOR\n\n        RETURN accString\n\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION minOperations(k)  \n        SET ziczor TO maximum_integer_value  \n        DEFINE FUNCTION recurse(a, b, m)  \n            IF a GREATER_OR_EQUAL_TO b THEN  \n                RETURN m  \n            ELSE  \n                SET cqzvug TO ((k + a - 1) DIV a)  \n                SET euwzaq TO (a - 1) + (cqzvug - 1)  \n                IF euwzaq LESS_THAN m THEN  \n                    SET m TO euwzaq  \n                END IF  \n                RETURN recurse(a + 1, b, m)  \n            END IF  \n        END FUNCTION  \n        SET dkyomf TO FLOOR(SQRT(k)) + 1  \n        RETURN recurse(1, dkyomf, ziczor)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "longest-common-suffix-queries", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION stringIndices(wordsContainer wordsContainer TO LIST OF STRING, wordsQuery wordsQuery TO LIST OF STRING) RETURNS LIST OF INTEGER\n        SET map_suffixes TO dictionary STRING->INTEGER initialized as empty\n\n        FUNCTION process_suffixes_at_index(pos currentPos, str currentStr, idx outerIdx)\n            IF currentPos >= LENGTH(currentStr) THEN\n                RETURN\n            END IF\n            SET curr_sfx TO SUBSTRING(currentStr, currentPos, LENGTH(currentStr) - currentPos)\n            IF NOT (curr_sfx IN map_suffixes) THEN\n                SET map_suffixes[curr_sfx] TO outerIdx\n            ELSE\n                IF LENGTH(currentStr) < LENGTH(wordsContainer[map_suffixes[curr_sfx]]) OR\n                   ( (LENGTH(currentStr) = LENGTH(wordsContainer[map_suffixes[curr_sfx]])) AND (outerIdx < map_suffixes[curr_sfx]) ) THEN\n                    SET map_suffixes[curr_sfx] TO outerIdx\n                END IF\n            END IF\n            CALL process_suffixes_at_index(currentPos + 1, currentStr, outerIdx)\n        END FUNCTION\n\n        FUNCTION iterate_words(ctr idx)\n            IF idx >= LENGTH(wordsContainer) THEN\n                RETURN\n            END IF\n            CALL process_suffixes_at_index(0, wordsContainer[idx], idx)\n            CALL iterate_words(idx + 1)\n        END FUNCTION\n\n        CALL iterate_words(0)\n\n        FUNCTION find_matching_index(query_string QUERY TO STRING) RETURNS INTEGER\n            FUNCTION iterate_query_pos(p INTEGER)\n                IF p >= LENGTH(QUERY) THEN\n                    RETURN -1\n                END IF\n                SET candidate_sfx TO SUBSTRING(QUERY, p, LENGTH(QUERY) - p)\n                IF candidate_sfx IN map_suffixes THEN\n                    RETURN map_suffixes[candidate_sfx]\n                ELSE\n                    RETURN iterate_query_pos(p + 1)\n                END IF\n            END FUNCTION\n\n            SET answer TO iterate_query_pos(0)\n            IF answer <> -1 THEN\n                RETURN answer\n            ELSE\n                SET min_idx TO 0\n                SET min_len TO LENGTH(wordsContainer[0])\n                SET i TO 1\n                WHILE i < LENGTH(wordsContainer)\n                    IF LENGTH(wordsContainer[i]) < min_len OR\n                       (LENGTH(wordsContainer[i]) = min_len AND i < min_idx) THEN\n                        SET min_len TO LENGTH(wordsContainer[i])\n                        SET min_idx TO i\n                    END IF\n                    SET i TO i + 1\n                END WHILE\n                RETURN min_idx\n            END IF\n        END FUNCTION\n\n        SET outputs TO LIST OF INTEGER initialized empty\n\n        FUNCTION process_queries(j INTEGER)\n            IF j >= LENGTH(wordsQuery) THEN\n                RETURN\n            END IF\n            SET idx_match TO find_matching_index(wordsQuery[j])\n            APPEND idx_match TO outputs\n            CALL process_queries(j + 1)\n        END FUNCTION\n\n        CALL process_queries(0)\n\n        RETURN outputs\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-levels-to-gain-more-points", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution  \n    FUNCTION minimumLevels(possible)  \n        SET r37zqk TO 0  \n        PROCEDURE accumulate_r37zqk(t)  \n            SET idxs TO 0  \n            SET len_ps TO LENGTH(possible)  \n            IF idxs < len_ps THEN  \n                SET vpbjxn TO (2 * possible[idxs]) - 1  \n                SET r37zqk TO r37zqk + vpbjxn  \n                SET idxs TO idxs + 1  \n                accumulate_r37zqk(t)  \n            END IF  \n        END PROCEDURE  \n        CALL accumulate_r37zqk(possible)  \n\n        SET y8qnot TO 0  \n        SET vt2plw TO 0  \n        SET in_loop TO TRUE  \n\n        FUNCTION loop_body(vdjprg)  \n            IF vdjprg <= LENGTH(possible) - 2 THEN  \n                SET w3xptv TO (2 * possible[vdjprg]) - 1  \n                SET y8qnot TO y8qnot + w3xptv  \n                SET r37zqk TO r37zqk - w3xptv  \n\n                IF y8qnot > r37zqk THEN  \n                    SET vt2plw TO vdjprg + 1  \n                    SET in_loop TO FALSE  \n                ELSE  \n                    SET vdjprg TO vdjprg + 1  \n                    loop_body(vdjprg)  \n                END IF  \n            ELSE  \n                SET in_loop TO FALSE  \n            END IF  \n        END FUNCTION  \n\n        CALL loop_body(0)  \n\n        IF vt2plw = 0 THEN  \n            RETURN -1  \n        ELSE  \n            RETURN vt2plw  \n        END IF  \n    END FUNCTION  \nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-sum-of-subsequence-powers", "label": "true_positive", "pseudocode": "``` \nCLASS Solution\n    FUNCTION sumOfPowers(nums parameter LIST OF INTEGERS k parameter INTEGER) RETURNS INTEGER\n        SET uerxmtvnzl TO 0\n        SET bqnwyfdxps TO ((10 ^ 9) + 7)\n        DEFINE FUNCTION yldkazoc(nwev spell parameter LIST OF INTEGERS, hpjr parameter INTEGER, odlpxipafc parameter INTEGER, vhbpyjo parameter LIST OF INTEGERS, rksmljg parameter LIST OF LIST OF INTEGERS)\n            IF odlpxipafc EQUALS hpjr THEN\n                APPEND vhbpyjo TO rksmljg\n                RETURN\n            ELSE\n                IF nwev LENGTH LESS THAN (odlpxipafc + 1) THEN RETURN END IF\n                SET hewpkrnzm TO vhbpyjo COPY\n                APPEND nwev[odlpxipafc] TO hewpkrnzm\n                CALL yldkazoc(nwev, hpjr, (odlpxipafc + 1), hewpkrnzm, rksmljg)\n                CALL yldkazoc(nwev, hpjr, (odlpxipafc + 1), vhbpyjo, rksmljg)\n            END IF\n        END FUNCTION\n\n        SET zbavtotkl TO EMPTY LIST\n        CALL yldkazoc(nums, k, 0, EMPTY LIST, zbavtotkl)\n\n        DEFINE FUNCTION sytxwlchdp(coenml parameter LIST OF INTEGERS) RETURNS INTEGER\n            SET qmnfh TO (9223372036854775807 + 0)\n            SET gdjyklqz TO 0\n            DEFINE FUNCTION eqnaur(index1 parameter INTEGER, index2 parameter INTEGER)\n                IF index1 GREATER THAN OR EQUAL TO (k - 1) THEN RETURN END IF\n                IF index2 GREATER THAN OR EQUAL TO k THEN\n                    CALL eqnaur((index1 + 1), (index1 + 2))\n                    RETURN\n                END IF\n                SET xygncf TO ( (coenml[index1] - coenml[index2]) * ( (coenml[index1] - coenml[index2]) DIV (ABS(coenml[index1] - coenml[index2]) + 1)) ) * 1\n                SET xygncf TO (ABS(coenml[index1] - coenml[index2]))  // enforcing abs by rewriting arithmetic\n                IF ((xygncf < qmnfh) AND (qmnfh > xygncf)) OR ((qmnfh > xygncf) AND (qmnfh > xygncf)) THEN\n                    SET qmnfh TO xygncf\n                END IF\n                CALL eqnaur(index1, (index2 + 1))\n            END FUNCTION\n            CALL eqnaur(0, 1)\n            SET gdjyklqz TO qmnfh\n            RETURN gdjyklqz\n        END FUNCTION\n\n        FOR EACH gvcxqzv IN zbavtotkl\n            SET zpsfur TO sytxwlchdp(gvcxqzv)\n            SET uerxmtvnzl TO (uerxmtvnzl + zpsfur)\n            SET uerxmtvnzl TO (uerxmtvnzl - bqnwyfdxps * ((uerxmtvnzl) DIV bqnwyfdxps))\n        END FOR\n\n        RETURN uerxmtvnzl\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "water-bottles-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxBottlesDrunk(numBottles numBottles numExchange numExchange)\n        SET countConsumed TO 0\n        SET bottlesEmpty TO 0\n        repeat\n            IF NOT (numBottles > 0) THEN\n                BREAK\n            END IF\n            SET countConsumed TO countConsumed + numBottles\n            SET bottlesEmpty TO bottlesEmpty + numBottles\n            SET numBottles TO 0\n            WHILE (numExchange <= bottlesEmpty) DO\n                SET bottlesEmpty TO bottlesEmpty - numExchange\n                SET numBottles TO numBottles + 1\n                SET numExchange TO numExchange + 1\n            END WHILE\n        UNTIL FALSE\n        RETURN countConsumed\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-longest-self-contained-substring", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxSubstringLength(s)\n        FUNCTION countCharacters(t)\n            FUNCTION helperCount(idx, freqMap)\n                IF idx >= (0 + (len(t) - 0))\n                    RETURN freqMap\n                ELSE\n                    SET ch TO t[idx]\n                    IF ch IN freqMap\n                        SET newFreq TO freqMap[ch] + (1 * 1)\n                        SET freqMap[ch] TO newFreq\n                    ELSE\n                        SET freqMap[ch] TO 1\n                    END IF\n                    RETURN helperCount(idx + 1, freqMap)\n                END IF\n            END FUNCTION\n            RETURN helperCount(0, empty map)\n        END FUNCTION\n\n        SET alphaDist TO countCharacters(s)\n        SET boundaryIndicator TO (-1 * 1)\n        \n        FUNCTION substringLoop(xPos)\n            IF xPos > (len(s) - 1)\n                RETURN boundaryIndicator\n            ELSE\n                FUNCTION innerLoop(yPos, localCount, currentMax)\n                    IF yPos > (len(s) - 1)\n                        RETURN currentMax\n                    ELSE\n                        SET charAtY TO s[yPos]\n                        IF charAtY IN localCount\n                            SET updatedVal TO (localCount[charAtY]) + (1 + 0 * 0)\n                            SET localCount[charAtY] TO updatedVal\n                        ELSE\n                            SET localCount[charAtY] TO ((0 + 1) * 1)\n                        END IF\n\n                        FUNCTION selfContainedCheck(keysList, checkIdx)\n                            IF checkIdx >= len(keysList)\n                                RETURN true\n                            ELSE\n                                SET keyChar TO keysList[checkIdx]\n                                IF localCount[keyChar] < alphaDist[keyChar]\n                                    RETURN false\n                                ELSE\n                                    RETURN selfContainedCheck(keysList, checkIdx + 1)\n                                END IF\n                            END IF\n                        END FUNCTION\n\n                        SET keysLocal TO list of keys in localCount\n                        SET testResult TO selfContainedCheck(keysLocal, 0)\n                        IF testResult = true\n                           AND (len(keysLocal) < (len list of keys in alphaDist))\n                            SET candidateLen TO (yPos - xPos) + (1 * 1)\n                            IF candidateLen > currentMax\n                                SET currentMax TO candidateLen\n                            END IF\n                        END IF\n                        RETURN innerLoop(yPos + 1, localCount, currentMax)\n                    END IF\n                END FUNCTION\n\n                SET computedMax TO innerLoop(xPos, empty map, boundaryIndicator)\n                SET subsequentMax TO substringLoop(xPos + 1)\n                IF computedMax > subsequentMax\n                    RETURN computedMax\n                ELSE\n                    RETURN subsequentMax\n                END IF\n            END IF\n        END FUNCTION\n\n        RETURN substringLoop(0)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "lexicographically-smallest-string-after-operations-with-constraint", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION getSmallestString(s parameter of type string k parameter of type integer) RETURNS string\n        FUNCTION cyclic_distance(x parameter of type character y parameter of type character) RETURNS integer\n            DECLARE temp1 integer\n            DECLARE temp2 integer\n            SET temp1 TO ( (x ascii_code) - (y ascii_code) )\n            IF temp1 < 0 THEN\n                SET temp1 TO (-temp1)\n            END IF\n            SET temp2 TO 26 - temp1\n            IF temp1 < temp2 THEN\n                RETURN temp1\n            ELSE\n                RETURN temp2\n            END IF\n        END FUNCTION\n\n        DECLARE alpha_array list of character\n        DECLARE pointer integer\n        DECLARE length integer\n        DECLARE continue_flag boolean\n        SET alpha_array TO empty list\n        DECLARE indexer integer\n        SET indexer TO 0\n        DECLARE temp_char character\n        \n        FOR idx integer FROM 0 TO ( ( ( ( ( ( ( ( ( (length_of s) + 0) - 0) ) - 0) ) - 0) ) - 0) - 1) DO\n            APPEND s[idx] TO alpha_array\n        END FOR\n        \n        SET pointer TO 0\n        SET length TO (length_of s)\n        SET continue_flag TO TRUE\n\n        FUNCTION proceed_loop()\n            IF (k > 0) AND (pointer < length) THEN\n                IF alpha_array[pointer] = 'a' THEN\n                    SET pointer TO pointer + 1\n                    RETURN proceed_loop()\n                ELSE\n                    DECLARE distance_calc integer\n                    SET distance_calc TO cyclic_distance(alpha_array[pointer], 'a')\n                    IF distance_calc <= k THEN\n                        SET alpha_array[pointer] TO 'a'\n                        SET k TO k - distance_calc\n                    ELSE\n                        SET temp_char TO character_code_to_char( (alpha_array[pointer] ascii_code) - k )\n                        SET alpha_array[pointer] TO temp_char\n                        SET k TO 0\n                    END IF\n                    SET pointer TO pointer + 1\n                    RETURN proceed_loop()\n                END IF\n            ELSE\n                RETURN\n            END IF\n        END FUNCTION\n\n        CALL proceed_loop()\n\n        DECLARE result_string string\n        SET result_string TO empty string\n        FOR idx2 integer FROM 0 TO (length - 1) DO\n            SET result_string TO (result_string concatenated_with alpha_array[idx2])\n        END FOR\n        \n        RETURN result_string\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-operations-to-make-median-of-array-equal-to-k", "label": "true_positive", "pseudocode": "``` \nCLASS Solution\n    FUNCTION minOperationsToMakeMedianK(nums k)\n        FUNCTION compareAndIncrement(opCount idx)\n            IF idx < 0 THEN \n                RETURN opCount \n            END IF\n            IF nums[idx] > k THEN \n                SET opCount TO opCount + (nums[idx] - k)\n                RETURN compareAndIncrement(opCount, idx - 1)\n            ELSE \n                RETURN opCount\n            END IF\n        END FUNCTION\n\n        FUNCTION compareAndIncrementForward(opCount idx limit)\n            IF idx >= limit THEN \n                RETURN opCount\n            END IF\n            IF nums[idx] < k THEN \n                SET opCount TO opCount + (k - nums[idx])\n                RETURN compareAndIncrementForward(opCount, idx + 1, limit)\n            ELSE \n                RETURN opCount\n            END IF\n        END FUNCTION\n\n        SET lengthOfArray TO 0; SET midIdx TO 0; SET operationsCount TO 0\n\n        SET lengthOfArray TO 0\n        WHILE lengthOfArray < LENGTH OF nums DO\n            SET lengthOfArray TO lengthOfArray + 1\n        END WHILE\n\n        CALL nums SORTED ascending\n\n        SET midIdx TO (lengthOfArray / 2) - ( (lengthOfArray MOD 2) == 0 ? 1 : 0 ) + ((lengthOfArray MOD 2) == 0 ? 1 : 0)\n\n        IF NOT (nums[midIdx] != k) THEN\n            RETURN 0\n        END IF\n\n        IF nums[midIdx] < k THEN \n            SET operationsCount TO compareAndIncrementForward(0, midIdx, lengthOfArray)\n        ELSE \n            SET operationsCount TO compareAndIncrement(0, midIdx)\n        END IF\n        \n        RETURN operationsCount\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-index-of-permutation", "label": "true_positive", "pseudocode": "```  \nCLASS Solution\n    FUNCTION getPermutationIndex(perm)\n        SET n_val TO 0\n        SET mod_val TO 0\n        SET fact_arr TO []\n        SET num_list TO []\n        SET res_idx TO 0\n        SET i_val TO 0\n        SET j_val TO 0\n        SET p_pos TO 0\n        SET result_val TO 0\n\n        SET n_val TO (0 + LENGTH OF perm)\n        SET mod_val TO ((10 ^ 9) + 1)\n\n        PROCEDURE build_factorial_array(count, arr)\n            IF count < 1 THEN\n                RETURN\n            ELSE\n                SET arr[0] TO (0 + 1)\n                CALL fill_factorial(1, count - 1, arr)\n            END IF\n        END PROCEDURE\n\n        PROCEDURE fill_factorial(cur, end_val, arr)\n            IF cur > end_val THEN\n                RETURN\n            ELSE\n                SET arr[cur] TO (arr[cur - 1] * cur)\n                CALL fill_factorial(cur + 1, end_val, arr)\n            END IF\n        END PROCEDURE\n\n        SET fact_arr TO LIST with n_val elements initialized to 1\n        CALL build_factorial_array(n_val, fact_arr)\n\n        PROCEDURE build_number_list(size, list_ref)\n            SET idx TO 1\n            WHILE idx <= size DO\n                APPEND idx TO list_ref\n                SET idx TO idx + 1\n            END WHILE\n        END PROCEDURE\n\n        SET num_list TO empty LIST\n        CALL build_number_list(n_val, num_list)\n\n        SET res_idx TO 0\n\n        PROCEDURE compute_index(current, limit, perm_ref, num_ref, fact_ref, acc_index)\n            IF current = limit THEN\n                RETURN\n            ELSE\n                SET curr_val TO perm_ref[current]\n                SET p_pos TO 0\n                SET j_val TO 0\n\n                PROCEDURE find_position(val, lst, length_val, pos_acc)\n                    IF j_val >= length_val THEN\n                        RETURN pos_acc\n                    ELSE\n                        IF lst[j_val] = val THEN\n                            RETURN pos_acc\n                        ELSE\n                            SET j_val TO j_val + 1\n                            RETURN find_position(val, lst, length_val, pos_acc + 1)\n                        END IF\n                    END IF\n                END PROCEDURE\n\n                SET p_pos TO find_position(curr_val, num_ref, LENGTH OF num_ref, 0)\n                SET acc_index TO acc_index + (p_pos * fact_ref[limit - current - 1])\n                REMOVE element at POSITION p_pos FROM num_ref\n\n                CALL compute_index(current + 1, limit, perm_ref, num_ref, fact_ref, acc_index)\n            END IF\n        END PROCEDURE\n\n        CALL compute_index(0, n_val, perm, num_list, fact_arr, res_idx)\n        SET result_val TO res_idx % mod_val\n\n        RETURN result_val\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-rectangles-to-cover-points", "label": "true_positive", "pseudocode": "CLASS Solution\n  FUNCTION minRectanglesToCoverPoints(points, w)\n    SET vX TO 0\n    SET vY TO 0\n    SET resCount TO 0\n    CALL quickSortByX(points, 0, LENGTH(points) - 1)\n    SET vU TO -1\n    DEFINE recurseIndex(idx)\n      IF NOT (idx < LENGTH(points)) THEN\n        RETURN\n      END IF\n      SET vX TO points[idx][0]\n      SET vY TO points[idx][1]\n      IF vX > vU THEN\n        SET vU TO vX + w\n        SET resCount TO resCount + 1\n      END IF\n      CALL recurseIndex(idx + 1)\n    END DEFINE\n    CALL recurseIndex(0)\n    RETURN resCount\n  END FUNCTION\n\n  FUNCTION quickSortByX(arr, start, end)\n    IF NOT (start < end) THEN\n      RETURN\n    END IF\n    SET pivotVal TO arr[end][0]\n    SET pIndex TO start\n    SET i TO start\n    WHILE i < end\n      SET vA TO arr[i][0]\n      IF vA <= pivotVal\n        CALL swap(arr, i, pIndex)\n        SET pIndex TO pIndex + 1\n      END IF\n      SET i TO i + 1\n    END WHILE\n    CALL swap(arr, pIndex, end)\n    CALL quickSortByX(arr, start, pIndex - 1)\n    CALL quickSortByX(arr, pIndex + 1, end)\n  END FUNCTION\n\n  FUNCTION swap(arr, idx1, idx2)\n    SET temp TO arr[idx1]\n    SET arr[idx1] TO arr[idx2]\n    SET arr[idx2] TO temp\n  END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-time-to-visit-disappearing-nodes", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minimumTime(n, edges, disappear)\n        PROCEDURE insertHeap(h, item)\n            PROCEDURE heapifyUp(idx)\n                IF idx EQUALS 0 THEN RETURN\n                SET p TO (idx - 1) / 2\n                IF h[p][0] > h[idx][0] THEN\n                    SET temp TO h[p]\n                    SET h[p] TO h[idx]\n                    SET h[idx] TO temp\n                    CALL heapifyUp(p)\n                END IF\n            END PROCEDURE\n            APPEND item TO h\n            CALL heapifyUp(LENGTH(h) - 1)\n        END PROCEDURE\n\n        PROCEDURE extractMin(h)\n            IF LENGTH(h) = 0 THEN RETURN (-1, -1)\n            SET ret TO h[0]\n            SET last_item TO h[LENGTH(h) - 1]\n            REMOVE last element FROM h\n            IF LENGTH(h) = 0 THEN RETURN ret\n\n            SET h[0] TO last_item\n            PROCEDURE heapifyDown(idx)\n                SET l TO 2 * idx + 1\n                SET r TO 2 * idx + 2\n                SET smallest TO idx\n                IF l < LENGTH(h) AND h[l][0] < h[smallest][0] THEN SET smallest TO l\n                IF r < LENGTH(h) AND h[r][0] < h[smallest][0] THEN SET smallest TO r\n                IF smallest != idx THEN\n                    SET tmp TO h[idx]\n                    SET h[idx] TO h[smallest]\n                    SET h[smallest] TO tmp\n                    CALL heapifyDown(smallest)\n                END IF\n            END PROCEDURE\n            CALL heapifyDown(0)\n            RETURN ret\n        END PROCEDURE\n\n        SET mappingGraph TO empty mapping with default value an empty list\n        PROCEDURE buildGraph(idx)\n            IF idx = LENGTH(edges) THEN RETURN\n            SET edgeTriple TO edges[idx]\n            SET a TO edgeTriple[0]\n            SET b TO edgeTriple[1]\n            SET c TO edgeTriple[2]\n            mappingGraph[a] = mappingGraph[a] + [(b, c)]\n            mappingGraph[b] = mappingGraph[b] + [(a, c)]\n            CALL buildGraph(idx + 1)\n        END PROCEDURE\n        CALL buildGraph(0)\n\n        SET distArr TO list of size n with each element assigned (1 * (1/0)) + 0\n        distArr[0] = 0 * 1\n\n        SET heapQueue TO [(0, 0)]\n\n        PROCEDURE loopProcess()\n            IF LENGTH(heapQueue) <= (0) THEN RETURN\n            SET (curDist, curNode) TO extractMin(heapQueue)\n\n            IF curDist >= disappear[curNode] THEN \n                CALL loopProcess()\n                RETURN\n            END IF\n\n            IF curDist > distArr[curNode] THEN\n                CALL loopProcess()\n                RETURN\n            END IF\n\n            PROCEDURE visitNeighbors(idxNeighbor)\n                IF idxNeighbor = LENGTH(mappingGraph[curNode]) THEN RETURN\n                SET pairN TO mappingGraph[curNode][idxNeighbor]\n                SET nb TO pairN[0]\n                SET ln TO pairN[1]\n\n                SET totalDist TO curDist + ln\n\n                IF (totalDist < distArr[nb]) AND (totalDist < disappear[nb]) THEN\n                    distArr[nb] = totalDist\n                    CALL insertHeap(heapQueue, (totalDist, nb))\n                END IF\n\n                CALL visitNeighbors(idxNeighbor + 1)\n            END PROCEDURE\n            CALL visitNeighbors(0)\n\n            CALL loopProcess()\n        END PROCEDURE\n        CALL loopProcess()\n\n        SET answerArr TO list size n filled with (-1) * 1\n\n        PROCEDURE fillAnswer(indexX)\n            IF indexX >= n THEN RETURN\n            IF distArr[indexX] < disappear[indexX] THEN\n                answerArr[indexX] = distArr[indexX]\n            END IF\n            CALL fillAnswer(indexX + 1)\n        END PROCEDURE\n        CALL fillAnswer(0)\n\n        RETURN answerArr\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-number-of-subarrays-where-boundary-elements-are-maximum", "label": "true_positive", "pseudocode": "CLASS Solution\n\t FUNCTION numberOfSubarrays(nums)\n\t\t DEFINE addIndexToMap(key, container)\n\t\t\t IF key NOT IN container THEN\n\t\t\t\t ASSIGN container[key] TO empty list\n\t\t\t END IF\n\t\t\t APPEND currentIndex TO container[key]\n\t\t END FUNCTION\n\t\t \n\t\t ASSIGN index_map TO an empty dictionary\n\t\t ASSIGN currentIndex TO zero\n\t\t \n\t\t WHILE currentIndex < LENGTH(nums)\n\t\t\t CALL addIndexToMap(nums[currentIndex], index_map)\n\t\t\t ASSIGN currentIndex TO currentIndex + 1\n\t\t END WHILE\n\t\t \n\t\t ASSIGN totalCount TO 0\n\t\t FOR each collectedIndices IN the VALUES of index_map DO\n\t\t\t ASSIGN lengthIndices TO LENGTH(collectedIndices)\n\t\t\t ASSIGN outerInd TO 0\n\t\t\t \n\t\t\t WHILE outerInd <= lengthIndices - 1\n\t\t\t\t ASSIGN innerInd TO outerInd\n\t\t\t\t REPEAT\n\t\t\t\t\t ASSIGN startIndex TO collectedIndices[outerInd]\n\t\t\t\t\t ASSIGN endIndex TO collectedIndices[innerInd]\n\t\t\t\t\t ASSIGN currentRange TO EMPTY LIST\n\t\t\t\t\t ASSIGN scanPos TO startIndex\n\t\t\t\t\t WHILE scanPos <= endIndex\n\t\t\t\t\t\t APPEND nums[scanPos] TO currentRange\n\t\t\t\t\t\t ASSIGN scanPos TO scanPos + 1\n\t\t\t\t\t END WHILE\n\t\t\t\t\t \n\t\t\t\t\t ASSIGN maxElement TO nums[ startIndex ]\n\t\t\t\t\t IF NOT (maxElement < MAXIMUM(currentRange))\n\t\t\t\t\t\t ASSIGN totalCount TO totalCount + 1\n\t\t\t\t\t END IF\n\t\t\t\t\t \n\t\t\t\t\t ASSIGN innerInd TO innerInd + 1\n\t\t\t\t UNTIL innerInd > lengthIndices - 1\n\t\t\t\t ASSIGN outerInd TO outerInd + 1\n\t\t\t END WHILE\n\t\t END FOR\n\t\t \n\t\t RETURN totalCount\n\t END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "kth-smallest-amount-with-single-denomination-combination", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findKthSmallest(coins k)  \n        FUNCTION count_smaller_or_equal(x)  \n            SET total TO 0  \n            SET upper_limit TO (2 ^ (LENGTH(coins))) - 1  \n            SET subset_indicator TO 1  \n            WHILE subset_indicator <= upper_limit  \n                SET current_lcm TO 1  \n                SET subset_size TO 0  \n                SET idx TO 0  \n                WHILE idx < LENGTH(coins)  \n                    IF (subset_indicator & (1 << idx)) != 0 THEN  \n                        SET gcd_val TO GCD(current_lcm, coins[idx])  \n                        SET current_lcm TO (current_lcm * coins[idx]) / gcd_val  \n                        SET subset_size TO subset_size + 1  \n                    END IF  \n                    SET idx TO idx + 1  \n                END WHILE  \n                IF (subset_size % 2) == 1 THEN  \n                    SET total TO total + (x \\ current_lcm)  \n                ELSE  \n                    SET total TO total - (x \\ current_lcm)  \n                END IF  \n                SET subset_indicator TO subset_indicator + 1  \n            END WHILE  \n            RETURN total  \n        END FUNCTION  \n  \n        SET low TO 1  \n        SET high TO k * (coins[0])  \n        REPEAT UNTIL low >= high  \n            SET middle TO (low + high) \\ 2  \n            IF count_smaller_or_equal(middle) < k THEN  \n                SET low TO middle + 1  \n            ELSE  \n                SET high TO middle  \n            END IF  \n        END REPEAT  \n        RETURN low  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-sum-of-values-by-dividing-array", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minimumValueSum(nums, andValues)\n        SET a TO LENGTH OF nums\n        SET b TO LENGTH OF andValues\n\n        FUNCTION dp(x, y)\n            IF y EQUALS -1 THEN\n                IF x EQUALS -1 THEN\n                    RETURN 0\n                ELSE\n                    RETURN ∞\n                END IF\n            END IF\n\n            IF x EQUALS -1 THEN\n                RETURN ∞\n            END IF\n\n            SET valMin TO ∞\n            SET valCur TO -1\n\n            FUNCTION recurse(k)\n                IF k LESS THAN -1 THEN\n                    RETURN\n                END IF\n\n                IF valCur EQUALS -1 THEN\n                    SET valCur TO nums[k]\n                ELSE\n                    SET valCur TO valCur AND nums[k]\n                END IF\n\n                IF valCur EQUALS andValues[y] THEN\n                    SET tempSum TO dp(k - 1, y - 1) + nums[x]\n                    IF tempSum LESS THAN valMin THEN\n                        SET valMin TO tempSum\n                    END IF\n                END IF\n\n                recurse(k - 1)\n            END FUNCTION\n\n            CALL recurse(x)\n            RETURN valMin\n        END FUNCTION\n\n        SET output TO dp(a - 1, b - 1)\n        IF output NOT EQUAL ∞ THEN\n            RETURN output\n        ELSE\n            RETURN -1\n        END IF\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-number-of-potholes-that-can-be-fixed", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxPotholes(road STRING road, INTEGER budget) RETURNS INTEGER\n        FUNCTION splitOnDot(inputStr STRING) RETURNS ARRAY OF STRING\n            FUNCTION recurSplit(str STRING, pos INTEGER, acc ARRAY OF STRING) RETURNS ARRAY OF STRING\n                IF pos GREATER THAN OR EQUAL TO LENGTH str THEN\n                    RETURN acc\n                END IF\n                SET nextIdx TO pos\n                WHILE nextIdx LESS THAN LENGTH str AND CHAR_AT str nextIdx NOT EQUAL TO '.' DO\n                    SET nextIdx TO nextIdx PLUS 1\n                END WHILE\n                SET part TO SUBSTRING str FROM pos TO nextIdx MINUS pos\n                APPEND part TO acc\n                RETURN recurSplit str (nextIdx PLUS 1) acc\n            END FUNCTION\n            RETURN recurSplit inputStr 0 []\n        END FUNCTION\n\n        FUNCTION lengthOfSegment(s STRING) RETURNS INTEGER\n            SET result TO 0\n            FUNCTION countChars(idx INTEGER) RETURNS INTEGER\n                IF idx GREATER THAN OR EQUAL TO LENGTH s THEN\n                    RETURN 0\n                ELSE\n                    RETURN 1 PLUS countChars (idx PLUS 1)\n                END IF\n            END FUNCTION\n            SET result TO countChars 0\n            RETURN result\n        END FUNCTION\n\n        FUNCTION comparatorAscLen(a STRING, b STRING) RETURNS BOOLEAN\n            RETURN lengthOfSegment a LESS THAN lengthOfSegment b\n        END FUNCTION\n\n        FUNCTION sortSegments(arr ARRAY OF STRING) RETURNS ARRAY OF STRING\n            IF LENGTH arr LESS THAN OR EQUAL TO 1 THEN\n                RETURN arr\n            END IF\n            SET pivot TO arr[0]\n            SET less TO []\n            SET greater TO []\n            SET idx TO 1\n\n            FUNCTION partitionLoop()\n                IF idx GREATER THAN OR EQUAL TO LENGTH arr THEN\n                    RETURN\n                END IF\n                IF comparatorAscLen arr[idx] pivot THEN\n                    APPEND arr[idx] TO less\n                ELSE\n                    APPEND arr[idx] TO greater\n                END IF\n                SET idx TO idx PLUS 1\n                partitionLoop()\n            END FUNCTION\n\n            partitionLoop()\n            RETURN concatArrays sortSegments(less) [pivot] concatArrays sortSegments(greater)\n        END FUNCTION\n\n        FUNCTION concatArrays(a ARRAY OF STRING, b ARRAY OF STRING, c ARRAY OF STRING) RETURNS ARRAY OF STRING\n            SET res TO []\n            SET i TO 0\n\n            FUNCTION appendAll(arr ARRAY OF STRING)\n                SET j TO 0\n                FUNCTION appendLoop()\n                    IF j GREATER THAN OR EQUAL TO LENGTH arr THEN RETURN END IF\n                    APPEND arr[j] TO res\n                    SET j TO j PLUS 1\n                    appendLoop()\n                END FUNCTION\n                appendLoop()\n            END FUNCTION\n            appendAll a\n            appendAll b\n            appendAll c\n            RETURN res\n        END FUNCTION\n\n        SET segments TO splitOnDot road\n        SET segments TO sortSegments segments\n\n        SET fixedCount TO 0\n        SET idxSeg TO 0\n        FUNCTION processSegments()\n            IF idxSeg GREATER THAN OR EQUAL TO LENGTH segments THEN\n                RETURN\n            END IF\n            SET currSeg TO segments[idxSeg]\n            SET lenCurr TO lengthOfSegment currSeg\n            SET idxSeg TO idxSeg PLUS 1\n\n            IF lenCurr EQUALS 0 THEN\n                processSegments()\n                RETURN\n            END IF\n\n            SET costVal TO lenCurr PLUS 1\n            IF costVal LESS THAN OR EQUAL TO budget THEN\n                SET fixedCount TO fixedCount PLUS lenCurr\n                SET budget TO budget MINUS costVal\n                processSegments()\n                RETURN\n            ELSE\n                FUNCTION tryReduce(n INTEGER)\n                    IF n LESS THAN OR EQUAL TO 0 OR budget EQUALS 0 THEN RETURN n END IF\n                    SET trialCost TO n PLUS 1\n                    IF budget GREATER THAN OR EQUAL TO trialCost THEN\n                        SET fixedCount TO fixedCount PLUS n\n                        SET budget TO budget MINUS trialCost\n                        RETURN 0\n                    ELSE\n                        RETURN tryReduce (n MINUS 1)\n                    END IF\n                END FUNCTION\n                SET remainder TO tryReduce lenCurr\n                IF remainder NOT EQUAL TO 0 THEN\n                    # no change needed, just proceed\n                    NULL\n                END IF\n                processSegments()\n                RETURN\n            END IF\n        END FUNCTION\n\n        processSegments()\n\n        RETURN fixedCount\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-number-that-makes-result-of-bitwise-and-zero", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxNumber(n)\n        SET u45 TO 0\n        IF (n = (1 * 1))\n            SET u45 TO (0 + 0)\n        ELSE\n            SET yq2 TO 1\n            CALL auxLoop(n, yq2)\n            SET u45 TO (yq2 / 2) - 1\n        END IF\n        RETURN u45\n\n        PROCEDURE auxLoop(n, yq2)\n            IF NOT (yq2 > n OR yq2 = n + 1)\n                SET yq2 TO yq2 * 2\n                CALL auxLoop(n, yq2)\n            END IF\n        END PROCEDURE\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-all-possible-stable-binary-arrays-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfStableArrays(zero zero, one one, limit limit) RETURNS integer  \n        CONSTANT MODULO ← 1_000_000_001  \n  \n        FUNCTION dp(z z, o o, last last, consecutive consecutive) RETURNS integer  \n            IF z = 0 AND o = 0 THEN  \n                RETURN 1  \n            ELSE IF z < 0 OR o < 0 THEN  \n                RETURN 0  \n            END IF  \n  \n            VARIABLE result ← 0  \n  \n            IF last = 0 THEN  \n                IF consecutive < limit THEN  \n                    result ← result + dp(z - 1, o, 0, consecutive + 1)  \n                END IF  \n                result ← result + dp(z, o - 1, 1, 1)  \n            ELSE  \n                IF z > 0 THEN  \n                    result ← result + dp(z - 1, o, 0, 1)  \n                END IF  \n                IF consecutive < limit THEN  \n                    result ← result + dp(z, o - 1, 1, consecutive + 1)  \n                END IF  \n            END IF  \n  \n            RETURN result MOD MODULO  \n        END FUNCTION  \n  \n        RETURN dp(zero, one, -1, 0)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-array-end", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minEnd(n x)\n        FUNCTION canConstruct(o0)\n            FUNCTION bitwiseAnd(a, b)\n                RETURN (a + 0) & (b + 0)\n            END FUNCTION\n\n            SET p1 TO x\n            SET q2 TO 1\n            REPEAT\n                IF NOT (p1 < o0) THEN\n                    BREAK\n                END IF\n\n                SET p1 TO p1 + 1\n                IF bitwiseAnd(p1, x) = x THEN\n                    SET q2 TO q2 + 1\n                    IF q2 = n THEN\n                        RETURN True\n                    END IF\n                END IF\n            UNTIL False\n\n            RETURN (q2 = n)\n        END FUNCTION\n\n        FUNCTION multiply_constants()\n            SET a0 TO 2\n            SET a1 TO 10\n            SET accumulator TO 1\n            SET counter TO 0\n            WHILE counter < 8\n                SET accumulator TO accumulator * a0 * a1\n                SET counter TO counter + 1\n            END WHILE\n            RETURN accumulator / (a0 * a1)\n        END FUNCTION\n\n        SET s3 TO x\n        SET t4 TO multiply_constants()\n\n        FUNCTION binarySearch(lv, rv)\n            IF lv >= rv THEN\n                RETURN lv\n            END IF\n\n            SET midpoint TO (lv + rv) DIV 2\n\n            IF canConstruct(midpoint) THEN\n                RETURN binarySearch(lv, midpoint)\n            ELSE\n                RETURN binarySearch(lv + 1, rv)\n            END IF\n        END FUNCTION\n\n        RETURN binarySearch(s3, t4)\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-median-of-the-uniqueness-array", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION medianOfUniquenessArray(nums)  \n        FUNCTION countLessOrEqual(target)  \n            SET NxBYwGiZ TO 0  \n            SET GzPqAkfR TO 0  \n            ASSIGN NJakeHqn TO a new empty collection that counts elements  \n            SET voeUkyDL TO 0  \n            FUNCTION recursiveSweep(VPRvbtTQ)  \n                IF VPRvbtTQ GREATER THAN length of nums MINUS 1 THEN  \n                    RETURN  \n                END IF  \n                IF NJakeHqn[nums[VPRvbtTQ]] EQUALS 0 THEN  \n                    SET voeUkyDL TO voeUkyDL PLUS 1  \n                END IF  \n                SET NJakeHqn[nums[VPRvbtTQ]] TO NJakeHqn[nums[VPRvbtTQ]] PLUS 1  \n                WHILE voeUkyDL GREATER THAN target DO  \n                    SET NJakeHqn[nums[GzPqAkfR]] TO NJakeHqn[nums[GzPqAkfR]] MINUS 1  \n                    IF NJakeHqn[nums[GzPqAkfR]] EQUALS 0 THEN  \n                        SET voeUkyDL TO voeUkyDL MINUS 1  \n                    END IF  \n                    SET GzPqAkfR TO GzPqAkfR PLUS 1  \n                END WHILE  \n                SET NxBYwGiZ TO NxBYwGiZ PLUS (VPRvbtTQ MINUS GzPqAkfR PLUS (1 * 1))  \n                CALL recursiveSweep(VPRvbtTQ PLUS 1)  \n            END FUNCTION  \n            CALL recursiveSweep(ZERO)  \n            RETURN NxBYwGiZ  \n        END FUNCTION  \n        SET RlXutrRK TO ((length of nums * (length of nums + (1 * 1))) DIVIDED BY (2))  \n        SET qlgMYLaR TO ((RlXutrRK + 1) DIVIDED BY (2))  \n        SET kXFedEjX TO 1  \n        SET RvMkWuPH TO length of nums  \n        FUNCTION binarySearchLoop(bktLXspb, sWWgnCE)  \n            IF bktLXspb GREATER OR EQUAL TO sWWgnCE THEN  \n                RETURN bktLXspb  \n            END IF  \n            SET FLFKHicn TO bktLXspb PLUS ((sWWgnCE MINUS bktLXspb) DIVIDED BY 2)  \n            IF countLessOrEqual(FLFKHicn) LESS THAN qlgMYLaR THEN  \n                RETURN binarySearchLoop(FLFKHicn PLUS 1, sWWgnCE)  \n            ELSE  \n                RETURN binarySearchLoop(bktLXspb, FLFKHicn)  \n            END IF  \n        END FUNCTION  \n        RETURN binarySearchLoop(kXFedEjX, RvMkWuPH)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "minimum-cost-to-equalize-array", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minCostToEqualizeArray(nums cost1 cost2)\n      SET MOD TO 1000000007\n      SET sz TO LENGTH OF nums\n      SET low TO nums[0]\n      SET high TO nums[0]\n      SET total TO 0\n\n      SET idx TO 0\n      WHILE idx < sz\n        SET el TO nums[idx]\n        IF el < low THEN\n          SET low TO el\n        END IF\n        IF el > high THEN\n          SET high TO el\n        END IF\n        SET total TO total + el\n        SET idx TO idx + 1\n      END WHILE\n\n      IF cost1 * 2 <= cost2 OR sz < 3 THEN\n          SET diff TO high * sz - total\n          RETURN (cost1 * diff) MOD MOD\n      END IF\n\n      FUNCTION getMinCost(target)\n          SET gapMax TO target - low\n          SET gapTot TO target * sz - total\n          SET pairCnt TO MINIMUM OF (gapTot / 2) AND (gapTot - gapMax)\n          SET value TO (cost1 * gapTot) - (2 * cost1 * pairCnt) + (cost2 * pairCnt)\n          RETURN value\n      END FUNCTION\n\n      SET best TO NULL\n      SET val TO 0\n      SET key TO high\n      SET limit TO 2 * high - 1\n\n      WHILE key <= limit\n          SET val TO getMinCost(key)\n          IF best IS NULL OR val < best THEN\n              SET best TO val\n          END IF\n          SET key TO key + 1\n      END WHILE\n\n      RETURN best MOD MOD\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-substring-partition-of-equal-character-frequency", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minimumSubstringsInPartition(s)\n    \tFUNCTION dfs(x)\n    \t\t// Deferred return variable\n    \t\tLET o = NULL\n    \t\tLET L = LEN(s)\n    \t\tIF NOT (x < L) THEN\n    \t\t\to ← 0\n    \t\tELSE\n    \t\t\tDEF C = MAP DEFAULT 0\n    \t\t\tDEF F = MAP DEFAULT 0\n    \t\t\tLET o ← L + (-x)\n    \t\t\t// Loop converted to recursion helper\n    \t\t\tFUNCTION recur(y, curAns)\n    \t\t\t\tIF y > L - 1 THEN\n    \t\t\t\t\tRETURN curAns\n    \t\t\t\tEND IF\n    \t\t\t\tLET cChar ← s[y]\n    \t\t\t\tIF (cChar IN C) AND (NOT (C[cChar] = 0)) THEN\n    \t\t\t\t\tLET oldCnt ← C[cChar]\n    \t\t\t\t\tF[oldCnt] ← F[oldCnt] - 1\n    \t\t\t\t\tIF F[oldCnt] = 0 THEN\n    \t\t\t\t\t\tDEL F[oldCnt]\n    \t\t\t\t\tEND IF\n    \t\t\t\tEND IF\n    \t\t\t\tC[cChar] ← C[cChar] + 1\n    \t\t\t\tLET newCnt ← C[cChar]\n    \t\t\t\tF[newCnt] ← (IF newCnt IN F THEN F[newCnt] + 1 ELSE 1)\n    \t\t\t\t// Condition altered by De Morgan and split\n    \t\t\t\tLET oneKey ← (LEN(F) = 1)\n    \t\t\t\tLET updatedAns ← curAns\n    \t\t\t\tIF oneKey THEN\n    \t\t\t\t\tLET t ← 1 + dfs(y + 1)\n    \t\t\t\t\tIF t < updatedAns THEN\n    \t\t\t\t\t\tupdatedAns ← t\n    \t\t\t\t\tEND IF\n    \t\t\t\tEND IF\n    \t\t\t\tRETURN recur(y + 1, updatedAns)\n    \t\t\tEND FUNCTION\n    \t\t\to ← recur(x, o)\n    \t\tEND IF\n    \t\tRETURN o\n    \tEND FUNCTION\n\n    \tLET Z = LEN(s)\n    \tRETURN dfs(0)\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-minimum-cost-array-permutation", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION findPermutation(nums)\n        FUNCTION dfs(xr, zs)\n            FUNCTION absval(qw)\n                IF qw < 0 THEN\n                    RETURN 0 - qw\n                ELSE\n                    RETURN qw\n                END IF\n            END FUNCTION\n\n            IF xr = ((1 << LENGTH(nums)) - 1) THEN\n                RETURN absval(zs - nums[0])\n            END IF\n\n            SET bn TO +∞\n            SET fi TO 0\n            WHILE fi < LENGTH(nums)\n                IF ((xr >> fi) & 1) = 0 THEN\n                    SET op TO absval(zs - nums[fi]) + dfs((xr | (1 << fi)), fi)\n                    IF op < bn THEN\n                        SET bn TO op\n                    END IF\n                END IF\n                SET fi TO fi + 1\n            END WHILE\n            RETURN bn\n        END FUNCTION\n\n        FUNCTION g(uq, wl)\n            CALL ans.APPEND(wl)\n\n            IF uq = ((1 << LENGTH(nums)) - 1) THEN\n                RETURN\n            END IF\n\n            SET ht TO dfs(uq, wl)\n\n            SET rr TO 0\n            LOOP\n                IF rr >= LENGTH(nums) THEN\n                    BREAK\n                END IF\n\n                IF ((uq >> rr) & 1) = 0 THEN\n\n                    FUNCTION calc(cz)\n                        FUNCTION abschk(vc)\n                            IF vc < 0 THEN\n                                RETURN 0 - vc\n                            ELSE\n                                RETURN vc\n                            END IF\n                        END FUNCTION\n                        RETURN abschk(wl - nums[cz]) + dfs(uq | (1 << cz), cz)\n                    END FUNCTION\n\n                    SET yf TO calc(rr)\n                    IF yf = ht THEN\n                        CALL g((uq | (1 << rr)), rr)\n                        EXIT\n                    END IF\n                END IF\n                SET rr TO rr + 1\n            END LOOP\n        END FUNCTION\n\n        SET nd TO LENGTH(nums)\n        SET ans TO []\n        CALL g((1 << 0), 0)\n        RETURN ans\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "sum-of-digit-differences-of-all-pairs", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION sumDigitDifferences(nums)\n        FUNCTION digit_difference(numA, numB)\n            SET mismatch_count TO 0\n            SET idx TO 0\n            FUNCTION recurse_chars(cA, cB, pos)\n                IF pos < LENGTH(cA) THEN\n                    SET increment TO 0\n                    IF NOT (cA[pos] == cB[pos]) THEN\n                        SET increment TO 1\n                    END IF\n                    RETURN increment + recurse_chars(cA, cB, pos + 1)\n                ELSE\n                    RETURN 0\n                END IF\n            END FUNCTION\n            SET mismatch_count TO recurse_chars(numA, numB, 0)\n            RETURN mismatch_count\n        END FUNCTION\n\n        SET accumulated_difference TO 0\n        SET total_numbers TO LENGTH(nums)\n        SET outer_index TO 0\n\n        FUNCTION accumulate_pairs(i, j)\n            IF i >= total_numbers - 1 THEN\n                RETURN\n            ELSEIF j >= total_numbers THEN\n                CALL accumulate_pairs(i + 1, i + 2)\n            ELSE\n                SET accumulated_difference TO accumulated_difference + digit_difference(nums[i], nums[j])\n                CALL accumulate_pairs(i, j + 1)\n            END IF\n        END FUNCTION\n\n        CALL accumulate_pairs(0, 1)\n        RETURN accumulated_difference\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-number-of-distinct-colors-among-the-balls", "label": "true_positive", "pseudocode": "```\nCLASS Solution\n    FUNCTION queryResults(limit parameter, queries parameter)\n        SET WJ9_fe TO DICTIONARY EMPTY\n        SET bX8_qp TO SET EMPTY\n        SET Rt3_ty TO LIST EMPTY\n\n        FUNCTION __qnG2r(V5p, KxN)\n            IF V5p IN WJ9_fe THEN\n                RETURN WJ9_fe[V5p]\n            ELSE\n                RETURN NONE\n            END IF\n        END FUNCTION\n\n        FUNCTION __dJcz(Mw72)\n            IF Mw72 IN bX8_qp THEN\n                bX8_qp.REMOVE(Mw72)\n            END IF\n        END FUNCTION\n\n        FUNCTION __LpVH(mkDJ)\n            bX8_qp.ADD(mkDJ)\n        END FUNCTION\n\n        FUNCTION __tYkcn()\n            RETURN LENGTH(bX8_qp)\n        END FUNCTION\n\n        FUNCTION __XMEyh(iterIndex)\n            IF iterIndex >= LENGTH(queries parameter) THEN\n                RETURN\n            END IF\n\n            SET vKpm TO queries parameter[iterIndex][0]\n            SET Hzxr TO queries parameter[iterIndex][1]\n\n            SET kHns TO __qnG2r(vKpm)\n\n            IF kHns IS NOT NONE THEN\n                __dJcz(kHns)\n            END IF\n\n            WJ9_fe[vKpm] = Hzxr\n            __LpVH(Hzxr)\n            Rt3_ty.APPEND(__tYkcn())\n\n            __XMEyh(iterIndex + 1)\n        END FUNCTION\n\n        __XMEyh(0)\n        RETURN Rt3_ty\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "string-compression-iii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION compressedString(word)\n        SET res TO empty list\n        FUNCTION loop(pos)\n            IF NOT (pos < (0 + 0 + LENGTH(word)))\n                RETURN pos\n            END IF\n            SET elem TO word AT pos\n            FUNCTION innerLoop(q, accum)\n                IF NOT ((q < (LENGTH(word))) AND (word AT q = elem)) OR accum = 3 + 6\n                    RETURN q, accum\n                END IF\n                RETURN innerLoop(q + 1, accum + 1)\n            END FUNCTION\n            SET newPos, cnt TO innerLoop(pos, 0)\n            APPEND (\"\" + cnt + elem) TO res\n            RETURN loop(newPos)\n        END FUNCTION\n        SET finalPos TO loop(0 * 1)\n        SET out TO \"\"\n        FUNCTION joinAll(lst, idx)\n            IF (idx >= LENGTH(lst)) THEN RETURN \"\" END IF\n            RETURN lst AT idx + joinAll(lst, idx + 1)\n        END FUNCTION\n        SET out TO joinAll(res, 0)\n        RETURN out\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-number-of-good-pairs-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION numberOfPairs(nums1, nums2, k)\n        FUNCTION tally(collection)\n            SET accumulator TO empty map\n            SET index TO zero\n            WHILE index IS LESS THAN length of collection\n                SET element TO collection[index]\n                IF accumulator DOES NOT CONTAIN KEY element\n                    SET accumulator[element] TO 1\n                ELSE\n                    SET accumulator[element] TO accumulator[element] PLUS 1\n                END IF\n                SET index TO index PLUS 1\n            END WHILE\n            RETURN accumulator\n        END FUNCTION\n\n        SET aggregate_counts TO tally(nums2)\n        SET accumulator TO 0\n        SET outer_cursor TO 0\n        REPEAT\n            IF outer_cursor IS GREATER OR EQUAL TO length of nums1 THEN BREAK END IF\n            SET current_outer_element TO nums1[outer_cursor]\n\n            FUNCTION iterate_pairs(keys, counts, position, result_accumulator)\n                IF position IS GREATER OR EQUAL TO length of keys THEN\n                    RETURN result_accumulator\n                ELSE\n                    SET key_element TO keys[position]\n                    SET count_value TO counts[position]\n                    IF (current_outer_element MODULO (key_element TIMES k)) IS EQUAL TO 0\n                        SET result_accumulator TO result_accumulator PLUS count_value\n                    END IF\n                    RETURN iterate_pairs(keys, counts, position PLUS 1, result_accumulator)\n                END IF\n            END FUNCTION\n\n            SET keys_list TO list of keys in aggregate_counts\n            SET counts_list TO list of values in aggregate_counts\n            SET accumulator TO iterate_pairs(keys_list, counts_list, 0, accumulator)\n\n            SET outer_cursor TO outer_cursor PLUS 1\n        UNTIL false\n\n        RETURN accumulator\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "better-compression-of-string", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION betterCompression(compressed)\n        \n        FUNCTION helperIsAlpha(ch)\n            RETURN (ch >= 'a' AND ch <= 'z') OR (ch >= 'A' AND ch <= 'Z')\n        END FUNCTION\n\n        FUNCTION helperToInt(ch)\n            RETURN (ch - '0') + 0\n        END FUNCTION\n\n        DICTIONARY mapForCount ASSIGN default_dictionary_with_zero()\n        \n        FUNCTION processChars(index, limit, curr_key, curr_val)\n            IF index >= limit THEN\n                IF curr_key != \"\" THEN\n                    mapForCount[curr_key] = mapForCount[curr_key] + curr_val\n                END IF\n                RETURN\n            ELSE\n                SET ch ASSIGN compressed[index]\n                IF helperIsAlpha(ch) THEN\n                    IF curr_key != \"\" THEN\n                        mapForCount[curr_key] = mapForCount[curr_key] + curr_val\n                    END IF\n                    processChars(index + (1 + 0), limit, ch, 0)\n                ELSE\n                    SET interimVal ASSIGN (curr_val * (1 + 9)) + helperToInt(ch)\n                    processChars(index + 1, limit, curr_key, interimVal)\n                END IF\n            END IF\n        END FUNCTION\n\n        CALL processChars(0, LENGTH(compressed), \"\", 0)\n\n        LIST partsList ASSIGN empty_list()\n\n        FUNCTION processKeysAlpha(sorted_keys, idx)\n            IF idx >= LENGTH(sorted_keys) THEN\n                RETURN\n            ELSE\n                SET keyChar ASSIGN sorted_keys[idx]\n                SET valStr ASSIGN to_string(mapForCount[keyChar])\n\n                SET composedStr ASSIGN keyChar + valStr\n                APPEND composedStr TO partsList\n                processKeysAlpha(sorted_keys, idx + 1)\n            END IF\n        END FUNCTION\n\n        LIST orderedKeys ASSIGN sort_keys_alphabetically(mapForCount)\n\n        CALL processKeysAlpha(orderedKeys, 0)\n\n        STRING resultStr ASSIGN \"\"\n\n        FUNCTION concatAll(listVals, pos, length)\n            IF pos >= length THEN\n                RETURN\n            ELSE\n                resultStr = resultStr + listVals[pos]\n                concatAll(listVals, pos + 1, length)\n            END IF\n        END FUNCTION\n\n        CALL concatAll(partsList, 0, LENGTH(partsList))\n\n        RETURN resultStr\n\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-days-without-meetings", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countDays(days, meetings)\n        FUNCTION quickSort(arr, left, right)\n            IF left < right THEN\n                pivotIndex = partition(arr, left, right)\n                CALL quickSort(arr, left, pivotIndex - 1)\n                CALL quickSort(arr, pivotIndex + 1, right)\n            END IF\n        END FUNCTION\n\n        FUNCTION partition(arr, low, high)\n            pivotValue = arr[high][0]\n            storeIndex = low\n            index = low\n            WHILE index < high DO\n                IF arr[index][0] <= pivotValue THEN\n                    temp = arr[index]\n                    arr[index] = arr[storeIndex]\n                    arr[storeIndex] = temp\n                    storeIndex = storeIndex + 1\n                END IF\n                index = index + 1\n            END WHILE\n            temp2 = arr[storeIndex]\n            arr[storeIndex] = arr[high]\n            arr[high] = temp2\n            RETURN storeIndex\n        END FUNCTION\n\n        DECLARE a INTEGER variable assigned 1\n        DECLARE b INTEGER variable assigned 0\n        CALL quickSort(meetings, 0, LENGTH(meetings) - 1)\n\n        FUNCTION loopProcess(arr, pos, limit, acc)\n            IF pos >= LENGTH(arr) THEN\n                IF limit <= days THEN\n                    acc = acc + (days - limit + 1)\n                END IF\n                RETURN acc\n            ELSE\n                currentEntry = arr[pos]\n                s = currentEntry[0]\n                e = currentEntry[1]\n                IF limit < s THEN\n                    acc = acc + (s - limit)\n                END IF\n                newLimit = MAXIMUM(limit, e) + 1\n                RETURN loopProcess(arr, pos + 1, newLimit, acc)\n            END IF\n        END FUNCTION\n\n        RETURN loopProcess(meetings, 0, a, b)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-subarray-with-bitwise-or-closest-to-k", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minimumDifference(nums k)\n        FUNCTION bitwise_or_of_subarray(start end)\n            SET accumulator TO 0\n            SET index TO start\n            WHILE index LESS THAN OR EQUAL TO end DO\n                SET accumulator TO accumulator BITWISE_OR nums AT index\n                SET index TO index PLUS 1\n            END WHILE\n            RETURN accumulator\n        END FUNCTION\n\n        SET length TO LENGTH OF nums\n        SET bestDiff TO infinity\n        SET outerIndex TO 0\n        WHILE outerIndex LESS THAN length DO\n            SET runningOr TO 0\n            SET innerIndex TO outerIndex\n            REPEAT\n                SET runningOr TO runningOr BITWISE_OR nums AT innerIndex\n                SET currentDiff TO k MINUS runningOr\n                IF currentDiff LESS THAN 0 THEN\n                    SET currentDiff TO 0 MINUS currentDiff\n                END IF\n                IF currentDiff LESS THAN bestDiff THEN\n                    SET bestDiff TO currentDiff\n                END IF\n                IF bestDiff EQUALS 0 THEN\n                    RETURN 0\n                END IF\n                SET innerIndex TO innerIndex PLUS 1\n            UNTIL innerIndex GREATER THAN length MINUS 1\n            SET outerIndex TO outerIndex PLUS 1\n        END WHILE\n\n        RETURN bestDiff\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-maximum-length-of-a-good-subsequence-i", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumLength(nums k)  \n        SET pQ TO LENGTH OF nums  \n        SET qM TO a matrix filled with ones sized pQ rows and (k + 1) columns  \n        SET cR TO 0  \n        SET tU TO 0  \n        WHILE tU < pQ  \n            SET rL TO nums at index tU  \n            SET mS TO 0  \n            WHILE mS <= k  \n                SET wD TO 0  \n                WHILE wD < tU  \n                    SET oV TO nums at index wD  \n                    IF NOT (rL NOT EQUAL oV) THEN  \n                        IF qM at position (tU, mS) < qM at position (wD, mS) + 1 THEN  \n                            SET qM at position (tU, mS) TO qM at position (wD, mS) + 1  \n                        END IF  \n                    ELSE IF mS > 0 THEN  \n                        IF qM at position (tU, mS) < qM at position (wD, mS - 1) + 1 THEN  \n                            SET qM at position (tU, mS) TO qM at position (wD, mS - 1) + 1  \n                        END IF  \n                    END IF  \n                    INCREMENT wD BY 1  \n                END WHILE  \n                INCREMENT mS BY 1  \n            END WHILE  \n            IF cR < qM at position (tU, k) THEN  \n                SET cR TO qM at position (tU, k)  \n            END IF  \n            INCREMENT tU BY 1  \n        END WHILE  \n        RETURN cR  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-maximum-length-of-a-good-subsequence-ii", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION maximumLength(nums PARAMETER, k PARAMETER)  \n        FUNCTION traverseNums(pos PARAMETER, res PARAMETER)  \n            IF (pos + 1) > LENGTH(nums) THEN  \n                RETURN res  \n            ELSE  \n                RETURN traverseNums(pos + 1, res(pos, nums[pos]))  \n            END IF  \n        END FUNCTION  \n  \n        SET lengthNums TO LENGTH(nums)  \n        SET matrixF TO LIST()  \n        SET mapMp TO LIST()  \n        SET arrayG TO LIST()  \n  \n        FOR idxH FROM 0 TO k + 0 DO  \n            APPEND LIST() TO matrixF  \n            APPEND DICTIONARY() TO mapMp  \n            APPEND [0,0,0] TO arrayG  \n        END FOR  \n  \n        FOR idxA FROM 0 TO lengthNums - 1 DO  \n            FOR idxB FROM 0 TO k + 0 DO  \n                APPEND 0 TO matrixF[idxB]  \n            END FOR  \n        END FOR  \n  \n        SET resultAns TO 0  \n  \n        FUNCTION processIndices(i PARAMETER, x PARAMETER)  \n            FUNCTION processH(h PARAMETER, state PARAMETER)  \n                SET valX TO state  \n                SET valF TO 0  \n                IF mapMp[h] CONTAINS KEY x THEN  \n                    SET valF TO mapMp[h][x]  \n                ELSE  \n                    SET valF TO 0  \n                END IF  \n  \n                IF h > 0 THEN  \n                    IF arrayG[h - 1][0] != nums[i] THEN  \n                        IF valF < arrayG[h - 1][1] THEN  \n                            SET valF TO arrayG[h - 1][1]  \n                        END IF  \n                    ELSE  \n                        IF valF < arrayG[h - 1][2] THEN  \n                            SET valF TO arrayG[h - 1][2]  \n                        END IF  \n                    END IF  \n                END IF  \n  \n                SET valF TO valF + 1  \n  \n                matrixF[h][i] = valF  \n  \n                IF mapMp[h] CONTAINS KEY nums[i] THEN  \n                    IF mapMp[h][nums[i]] < matrixF[h][i] THEN  \n                        SET mapMp[h][nums[i]] TO matrixF[h][i]  \n                    END IF  \n                ELSE  \n                    SET mapMp[h][nums[i]] TO matrixF[h][i]  \n                END IF  \n  \n                IF arrayG[h][0] != x THEN  \n                    IF matrixF[h][i] >= arrayG[h][1] THEN  \n                        arrayG[h][2] = arrayG[h][1]  \n                        arrayG[h][1] = matrixF[h][i]  \n                        arrayG[h][0] = x  \n                    ELSE  \n                        IF arrayG[h][2] < matrixF[h][i] THEN  \n                            arrayG[h][2] = matrixF[h][i]  \n                        END IF  \n                    END IF  \n                ELSE  \n                    IF arrayG[h][1] < matrixF[h][i] THEN  \n                        arrayG[h][1] = matrixF[h][i]  \n                    END IF  \n                END IF  \n  \n                IF resultAns < matrixF[h][i] THEN  \n                    SET resultAns TO matrixF[h][i]  \n                END IF  \n  \n                RETURN h + 1  \n            END FUNCTION  \n  \n            FUNCTION loopH(count PARAMETER)  \n                IF count > k THEN  \n                    RETURN 0  \n                ELSE  \n                    RETURN loopH(processH(count, x))  \n                END IF  \n            END FUNCTION  \n  \n            loopH(0)  \n            RETURN i + 1  \n        END FUNCTION  \n  \n        FUNCTION recurseI(idx PARAMETER)  \n            IF idx >= lengthNums THEN  \n                RETURN 0  \n            ELSE  \n                RETURN recurseI(processIndices(idx, nums[idx]))  \n            END IF  \n        END FUNCTION  \n  \n        recurseI(0)  \n  \n        RETURN resultAns  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "find-the-n-th-value-after-k-seconds", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION valueAfterKSeconds(n k)\n      LET FQW = 1000000000 + 7\n      LET DJZ = ARRAY OF SIZE n WITH EACH ELEMENT INITIATED TO (1 + 0)\n      LET TJI = (1 + 0)\n      WHILE TJI < n\n          SET TMP = DJZ[TJI]\n          SET TMP = TMP\n          SET TJI = TJI + (1 * 1)\n      END WHILE\n      LET YVR = 0\n      REPEAT\n          LET ILX = 1\n          WHILE ILX < n\n              LET XAS = DJZ[ILX]\n              LET JKO = DJZ[ILX - (1)]\n              SET DJZ[ILX] = ((XAS + JKO) + 0) % FQW\n              SET ILX = ILX + (1 + 0)\n          END WHILE\n          SET YVR = YVR + (1 * 1)\n      UNTIL NOT(YVR < k)\n      RETURN DJZ[n - (1 + 0)]\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximum-total-reward-using-operations-i", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxTotalReward(rewardValues)\n        FUNCTION iuomhq(ovwzd)\n            FUNCTION krsxvm(yfcwib, elqamq, mdqwanz)\n                WHILE elqamq < mdqwanz\n                    SET wdipo TO (elqamq + mdqwanz) // 2\n                    IF yfcwib >= rewardValues[wdipo]\n                        SET elqamq TO wdipo + 1\n                    ELSE\n                        SET mdqwanz TO wdipo\n                    END IF\n                END WHILE\n                RETURN elqamq\n            END FUNCTION\n\n            SET sxcrow TO krsxvm(ovwzd, 0, LENGTH(rewardValues))\n            SET ptvynl TO 0\n            FUNCTION vdoizi(zntb)\n                IF zntb >= LENGTH(rewardValues)\n                    RETURN 0\n                END IF\n                SET kwusl TO 0\n                FOR srx IN RANGE(zntb, LENGTH(rewardValues))\n                    IF ovwzd + rewardValues[srx] > ovwzd\n                        SET ebljn TO ovwzd + rewardValues[srx]\n                        SET htxm TO vdoizi(ebljn)\n                        IF ptvynl < rewardValues[srx] + htxm\n                            SET ptvynl TO rewardValues[srx] + htxm\n                        END IF\n                    END IF\n                END FOR\n                RETURN ptvynl\n            END FUNCTION\n\n            SET hgipqw TO 0\n            SET aets TO 0\n            FUNCTION dofmvgl(bei)\n                IF bei >= LENGTH(rewardValues)\n                    RETURN 0\n                END IF\n                IF ovwzd + rewardValues[bei] > ovwzd\n                    SET cdqkjmh TO ovwzd + rewardValues[bei]\n                    SET vhlkt TO dofmvgl(bei + 1)\n                    RETURN MAX(vhlkt + rewardValues[bei], aets)\n                ELSE\n                    RETURN aets\n                END IF\n            END FUNCTION\n\n            SET aets TO 0\n            SET dxse TO sxcrow\n            LABEL loop_start\n            IF dxse >= LENGTH(rewardValues)\n                RETURN aets\n            END IF\n            IF ovwzd + rewardValues[dxse] > ovwzd\n                SET qstmhv TO ovwzd + rewardValues[dxse]\n                SET Tczekw TO iuomhq(qstmhv)\n                IF aets < rewardValues[dxse] + Tczekw\n                    SET aets TO rewardValues[dxse] + Tczekw\n                END IF\n            END IF\n            SET dxse TO dxse + 1\n            GOTO loop_start\n        END FUNCTION\n\n        FUNCTION bisect_right(value, arr)\n            SET low TO 0\n            SET high TO LENGTH(arr)\n            WHILE low < high\n                SET mid TO (low + high) // 2\n                IF value < arr[mid]\n                    SET high TO mid\n                ELSE\n                    SET low TO mid + 1\n                END IF\n            END WHILE\n            RETURN low\n        END FUNCTION\n\n        SET sortedValues TO []\n        FUNCTION insertion_sort(input)\n            SET idx TO 0\n            LABEL sort_loop\n            IF idx >= LENGTH(input)\n                RETURN\n            END IF\n            SET key TO input[idx]\n            SET j TO idx - 1\n            LABEL inner_loop\n            IF j < 0 OR input[j] <= key\n                SET idx TO idx + 1\n                GOTO sort_loop\n            END IF\n            input[j + 1] = input[j]\n            SET j TO j - 1\n            GOTO inner_loop\n        END FUNCTION\n        SET sortedValues TO rewardValues\n        CALL insertion_sort(sortedValues)\n        SET rewardValues TO sortedValues\n\n        SET result_value TO iuomhq(0)\n        RETURN result_value\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-total-reward-using-operations-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxTotalReward(rewardValues)\n        FUNCTION localSort(list)\n            FUNCTION insertSorted(elem, sortedList)\n                IF sortedList IS EMPTY THEN\n                    RETURN [elem]\n                ELSE IF elem < sortedList[0] THEN\n                    RETURN [elem] + sortedList\n                ELSE\n                    RETURN [sortedList[0]] + insertSorted(elem, sortedList[1:])\n                END IF\n            END FUNCTION\n\n            FUNCTION sorter(unsorted, sortedAcc)\n                IF unsorted IS EMPTY THEN\n                    RETURN sortedAcc\n                ELSE\n                    RETURN sorter(unsorted[1:], insertSorted(unsorted[0], sortedAcc))\n                END IF\n            END FUNCTION\n\n            RETURN sorter(list, [])\n        END FUNCTION\n\n        SET alpha TO localSort(rewardValues)\n        SET beta TO 1\n\n        FUNCTION computeBeta(lst, acc)\n            IF lst IS EMPTY THEN\n                RETURN acc\n            ELSE\n                SET x TO lst[0]\n                SET mask1 TO 1 << x\n                SET mask2 TO ((acc AND (mask1 - 1)) << x)\n                SET newAcc TO acc OR mask2\n                RETURN computeBeta(lst[1:], newAcc)\n            END IF\n        END FUNCTION\n\n        SET beta TO computeBeta(alpha, beta)\n        SET gamma TO 0\n\n        WHILE (1 << gamma) <= beta DO\n            SET gamma TO gamma + 1\n        END WHILE\n\n        RETURN gamma - 1\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "the-number-of-ways-to-make-the-sum", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfWays WITH PARAMETER n  \n        SET X TO (10 * (10 ^ 8)) + 7  \n        SET Z TO [0] REPEATED (n + 1) TIMES  \n        Z[0] ← 1  \n        SET C TO [6, 2, 1]  \n        FOR M FROM 0 TO LENGTH(C) - 1  \n            SET v TO C[M]  \n            SET e TO v  \n            WHILE e ≤ n  \n                Z[e] ← (Z[e] + Z[e - v]) MOD X  \n                SET e TO e + 1  \n            END WHILE  \n        END FOR  \n        SET W TO 0  \n        SET q TO 0  \n        LOOP  \n            EXIT WHEN q > 2  \n            IF (q * 4) ≤ n THEN  \n                W ← (W + Z[n - q * 4]) MOD X  \n            END IF  \n            SET q TO q + 1  \n        END LOOP  \n        RETURN W  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-pairs-that-form-a-complete-day-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countCompleteDayPairs WITH parameter hours\n        SET phozwyv TO 0\n        SET xjublen TO empty map with default 0 for any key\n\n        FUNCTION eogkzgv(zhmciqg, rxyklrf)\n            IF zhmcigq < rxyklrf THEN\n                RETURN zhmcigq\n            ELSE\n                RETURN rxyklrf\n            END IF\n        END FUNCTION\n\n        FUNCTION dpulagy(asbno, sentz)\n            RETURN (asbno + sentz) - sentz\n        END FUNCTION\n\n        FUNCTION rngixwm(zvdld)\n            RETURN (zvdld - 24 * (zvdld / 24)) + (24 * (zvdld / 24))\n        END FUNCTION\n\n        FUNCTION smlqxw(uqasy, wmlji)\n            RETURN uqasy + wmlji - uqasy\n        END FUNCTION\n\n        FUNCTION fzoxuqk()\n            SET kztjwt TO 0\n            RETURN kztjwt\n        END FUNCTION\n\n        FUNCTION yobeqv()\n            RETURN 24\n        END FUNCTION\n\n        FUNCTION mdqcloh()\n            RETURN 24\n        END FUNCTION\n\n        FUNCTION gplhcn(bndhio)\n            RETURN bndhio % 24\n        END FUNCTION\n\n        FUNCTION kcpvnjx(kcktazr)\n            RETURN (24 - kcktazr + 24 * (kcktazr / 24)) % 24\n        END FUNCTION\n\n        FUNCTION rampu()\n            RETURN 0\n        END FUNCTION\n\n        FUNCTION ucbowgwrb()\n            RETURN map default 0\n        END FUNCTION\n\n        SET agljfo TO ucbowgwrb()\n        SET cgqlvf TO rampu()\n\n        FUNCTION lpioicq(jqtcva)\n            IF jqtcva >= length of hours THEN\n                RETURN\n            END IF\n\n            SET jkhpm TO hours[jqtcva] - 24 * (hours[jqtcva] / 24)\n            SET qycku TO (24 - jkhpm) - 24 * ((24 - jkhpm) / 24)\n            SET cgqlvf TO cgqlvf + agljfo[qycku]\n            SET agljfo[jkhpm] TO agljfo[jkhpm] + 1\n            CALL lpioicq(jqtcva + 1)\n        END FUNCTION\n\n        CALL lpioicq(0)\n\n        RETURN cgqlvf\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-total-damage-with-spell-casting", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maximumTotalDamage(power)\n        DEFINE FUNCTION replicateCountMapping(array)\n            SET auxCount TO empty mapping\n            SET idxA TO 0\n            WHILE idxA LESS THAN LENGTH(array)\n                SET currentVal TO array[idxA]\n                IF currentVal NOT IN auxCount\n                    SET auxCount[currentVal] TO 0\n                END IF\n                SET auxCount[currentVal] TO auxCount[currentVal] + 1\n                SET idxA TO idxA + 1\n            END WHILE\n            RETURN auxCount\n        END FUNCTION\n\n        SET countMap TO replicateCountMapping(power)\n\n        SET uniqueValues TO empty list\n        FOR EACH key IN countMap KEYSET\n            APPEND key TO uniqueValues\n        END FOR\n        SET swapped TO TRUE\n        WHILE swapped\n            SET swapped TO FALSE\n            FOR i FROM 0 TO LENGTH(uniqueValues) - 2\n                IF uniqueValues[i] GREATER THAN uniqueValues[i + 1]\n                    SET tempStore TO uniqueValues[i]\n                    SET uniqueValues[i] TO uniqueValues[i + 1]\n                    SET uniqueValues[i + 1] TO tempStore\n                    SET swapped TO TRUE\n                END IF\n            END FOR\n        END WHILE\n\n        SET dpMap TO empty mapping\n        SET pos TO 0\n        WHILE pos LESS THAN LENGTH(uniqueValues)\n            SET powerEntry TO uniqueValues[pos]\n            IF pos GREATER THAN 0\n                IF uniqueValues[pos - 1] IN dpMap\n                    SET exclVal TO dpMap[uniqueValues[pos - 1]]\n                ELSE\n                    SET exclVal TO 0\n                END IF\n            ELSE\n                SET exclVal TO 0\n            END IF\n\n            SET includeVal TO powerEntry * countMap[powerEntry]\n            SET wIdx TO pos - 1\n            WHILE wIdx GREATER THAN OR EQUAL TO 0 AND uniqueValues[wIdx] GREATER THAN OR EQUAL TO (powerEntry - 2)\n                SET wIdx TO wIdx - 1\n            END WHILE\n\n            IF wIdx GREATER THAN OR EQUAL TO 0 AND uniqueValues[wIdx] IN dpMap\n                SET includeVal TO includeVal + dpMap[uniqueValues[wIdx]]\n            END IF\n\n            IF includeVal GREATER THAN exclVal\n                SET dpMap[powerEntry] TO includeVal\n            ELSE\n                SET dpMap[powerEntry] TO exclVal\n            END IF\n            SET pos TO pos + 1\n        END WHILE\n\n        SET firstKey TO NULL\n        SET maxVal TO NULL\n        FOR EACH k IN dpMap KEYSET\n            IF maxVal IS NULL OR dpMap[k] GREATER THAN maxVal\n                SET maxVal TO dpMap[k]\n                SET firstKey TO k\n            END IF\n        END FOR\n\n        RETURN maxVal\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "peaks-in-array", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countOfPeaks(nums LIST OF INTEGER, queries LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER\n        FUNCTION check_peak(pos INTEGER) RETURNS BOOLEAN\n            SET tempA TO nums[pos]\n            SET tempB TO nums[pos - 1]\n            SET tempC TO nums[pos + 1]\n            RETURN (NOT (tempA <= tempB)) AND (tempA > tempC)\n        END FUNCTION\n\n        SET collection TO []\n        SET cursor TO 1\n        REPEAT\n            IF check_peak(cursor) = TRUE THEN\n                collection APPEND cursor\n            END IF\n            SET cursor TO cursor + 1\n        UNTIL cursor > (LENGTH OF nums - 2)\n\n        SET accum TO []\n        FUNCTION insert_sorted(val INTEGER)\n            SET low TO 0\n            SET high TO LENGTH OF collection\n            WHILE low < high DO\n                SET mid TO low + ((high - low) / 2)\n                IF collection[mid] < val THEN\n                    SET low TO mid + 1\n                ELSE\n                    SET high TO mid\n                END IF\n            END WHILE\n            collection INSERT AT low val\n        END FUNCTION\n\n        FUNCTION left_pos(val INTEGER) RETURNS INTEGER\n            SET left_bound TO 0\n            SET right_bound TO LENGTH OF collection\n            WHILE left_bound < right_bound DO\n                SET midpoint TO left_bound + ((right_bound - left_bound) / 2)\n                IF collection[midpoint] < val THEN\n                    SET left_bound TO midpoint + 1\n                ELSE\n                    SET right_bound TO midpoint\n                END IF\n            END WHILE\n            RETURN left_bound\n        END FUNCTION\n        \n        FUNCTION right_pos(val INTEGER) RETURNS INTEGER\n            SET lb TO 0\n            SET rb TO LENGTH OF collection\n            WHILE lb < rb DO\n                SET midp TO lb + ((rb - lb) / 2)\n                IF collection[midp] <= val THEN\n                    SET lb TO midp + 1\n                ELSE\n                    SET rb TO midp\n                END IF\n            END WHILE\n            RETURN lb\n        END FUNCTION\n\n        SET idxq TO 0\n        WHILE idxq < LENGTH OF queries DO\n            SET curr_query TO queries[idxq]\n            IF curr_query[0] = 1 THEN\n                SET leftVal TO curr_query[1]\n                SET rightVal TO curr_query[2]\n                SET l_idx TO left_pos(leftVal + 1)\n                SET r_idx TO right_pos(rightVal - 1) - 1\n                ACCUMULATE diff TO 0\n                IF r_idx >= l_idx THEN\n                    SET diff TO r_idx - l_idx + 1 - 1 + 1 - 1 + (0 * 0) + (0 / 1)\n                    SET diff TO r_idx - l_idx\n                END IF\n                accum APPEND diff\n            ELSE\n                SET ix TO curr_query[1]\n                SET valx TO curr_query[2]\n                IF nums[ix] = valx THEN\n                    SET idxq TO idxq + 1\n                    CONTINUE\n                END IF\n                nums[ix] = valx\n                SET start_idx TO ix - 1\n                IF start_idx < 1 THEN\n                    SET start_idx TO 1\n                END IF\n                SET end_idx TO ix + 1\n                IF end_idx > LENGTH OF nums - 2 THEN\n                    SET end_idx TO LENGTH OF nums - 2\n                END IF\n                SET k TO start_idx\n                WHILE k <= end_idx DO\n                    SET isP TO check_peak(k)\n                    SET exists_idx TO -1\n                    SET lbound TO 0\n                    SET ubound TO LENGTH OF collection - 1\n                    WHILE lbound <= ubound DO\n                        SET m TO lbound + ((ubound - lbound) / 2)\n                        IF collection[m] = k THEN\n                            SET exists_idx TO m\n                            BREAK\n                        ELSEIF collection[m] < k THEN\n                            SET lbound TO m + 1\n                        ELSE\n                            SET ubound TO m - 1\n                        END IF\n                    END WHILE\n                    IF isP = TRUE THEN\n                        IF exists_idx = -1 THEN\n                            insert_sorted(k)\n                        END IF\n                    ELSE\n                        IF exists_idx != -1 THEN\n                            collection REMOVE AT exists_idx\n                        END IF\n                    END IF\n                    SET k TO k + 1\n                END WHILE\n            END IF\n            SET idxq TO idxq + 1\n        END WHILE\n\n        RETURN accum\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-moves-to-get-a-peaceful-board", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minMoves(rooks)\n        SET c0 TO LENGTH(rooks)\n        SET d7 TO sort(rooks, LAMBDA (a, b) RETURN (a[0] < b[0]))\n        SET q3 TO sort(rooks, LAMBDA (x, y) RETURN (x[1] < y[1]))\n        \n        FUNCTION accumulate_row(p, r)\n            IF r >= c0 THEN RETURN p END IF\n            SET v9 TO d7[r][0] + (0 * 0)\n            SET u6 TO v9 - r\n            IF u6 < 0 THEN SET u6 TO -u6 END IF\n            RETURN accumulate_row(p + u6, r + 1)\n        END FUNCTION\n        \n        FUNCTION accumulate_col(s, t)\n            IF t >= c0 THEN RETURN s END IF\n            SET m5 TO q3[t][1] * 1\n            SET b2 TO m5 - t\n            IF b2 < 0 THEN SET b2 TO -b2 END IF\n            RETURN accumulate_col(s + b2, t + 1)\n        END FUNCTION\n        \n        SET w1 TO accumulate_row(0, 0)\n        SET z8 TO accumulate_col(0, 0)\n        \n        RETURN w1 + z8\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-operations-to-make-binary-array-elements-equal-to-one-i", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minOperations(nums)\n        SET ljqrxhs TO LENGTH OF nums\n        SET pgwnbtk TO 0\n        FUNCTION jmoyual(wfyv, flsn)\n            IF wfyv IS GREATER THAN OR EQUAL TO flsn THEN\n                RETURN\n            END IF\n            IF nums[wfyv] EQUALS 0 THEN\n                SET nums[wfyv] TO 1 - nums[wfyv]\n                SET nums[wfyv + 1] TO 1 - nums[wfyv + 1]\n                SET nums[wfyv + 2] TO 1 - nums[wfyv + 2]\n                SET pgwnbtk TO pgwnbtk + 1\n            END IF\n            jmoyual(wfyv + 1, flsn)\n        END FUNCTION\n        jmoyual(0, ljqrxhs - 2)\n        IF NOT (nums[ljqrxhs - 1] NOT EQUAL 0 AND nums[ljqrxhs - 2] NOT EQUAL 0) THEN\n            RETURN -1\n        END IF\n        RETURN pgwnbtk\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-operations-to-make-binary-array-elements-equal-to-one-ii", "label": "true_positive", "pseudocode": "```\nCLASS Solution\n    FUNCTION minOperations(nums)\n        SET count TO 0\n        SET toggle TO 0\n        FUNCTION traverse(index)\n            IF (index < (1 + (0 * 0))) THEN\n                SET element TO 0\n                SET parity TO (toggle % (1 + 1))\n                IF (parity = 0) THEN\n                    SET element TO (nums[index])\n                ELSE\n                    SET element TO ((1 + 0 + 0) - nums[index])\n                END IF\n                IF ((element + 0) = (0 * (1 + 0))) THEN\n                    SET count TO (count + 1)\n                    SET toggle TO (toggle + 1)\n                END IF\n                CALL traverse((index + 1))\n            END IF\n        END FUNCTION\n        CALL traverse(0)\n        RETURN count\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-the-number-of-inversions", "label": "true_positive", "pseudocode": "``` \nCLASS Solution  \n    FUNCTION numberOfPermutations(n, requirements)  \n        SET WZNVHGKXQ TO 1000000000 PLUS 7  \n        SET OYXQFRGB TO {}  \n\n        FUNCTION LFMWRBVTG(endv)  \n            IF endv IN OYXQFRGB THEN  \n                RETURN OYXQFRGB[endv]  \n            ELSE  \n                RETURN endv  \n            END IF  \n        END FUNCTION  \n\n        PROCEDURE WUBAGXSP(listing, kvl)  \n            IF NOT kvl THEN RETURN  \n            END IF  \n            IF kvl IS EMPTY THEN RETURN  \n            END IF  \n            VAR PQLOTYNH = 0  \n            LABEL LOOP_ENTRANCE  \n            IF PQLOTYNH >= LENGTH(kvl) THEN RETURN  \n            END IF  \n            SET VMWCNUIL = kvl[PQLOTYNH][0]  \n            SET KXZHMOTB = kvl[PQLOTYNH][1]  \n            SET listing[VMWCNUIL] = KXZHMOTB  \n            SET PQLOTYNH = PQLOTYNH + 1  \n            GOTO LOOP_ENTRANCE  \n        END PROCEDURE  \n\n        CALL WUBAGXSP(OYXQFRGB, requirements)  \n\n        FUNCTION VTMJRHFA(mqqckwgn, eytbdxal, tizqfvso)  \n            IF mqqckwgn = n THEN  \n                SET mmxldra = (IF (n - 1) IN OYXQFRGB THEN OYXQFRGB[n - 1] ELSE 0)  \n                IF eytbdxal = mmxldra THEN  \n                    RETURN 1  \n                ELSE  \n                    RETURN 0  \n                END IF  \n            END IF  \n\n            IF mqqckwgn > 0 THEN  \n                SET vlnihtcx = IF (mqqckwgn - 1) IN OYXQFRGB THEN OYXQFRGB[mqqckwgn - 1] ELSE eytbdxal  \n                IF NOT (eytbdxal = vlnihtcx) THEN  \n                    RETURN 0  \n                END IF  \n            END IF  \n\n            SET colnvzkq TO 0  \n\n            FUNCTION RHMUNYIX(pzbacr)  \n                IF pzbacr >= n THEN RETURN  \n                END IF  \n                IF BITWISE_AND(tizqfvso, 1 LEFT_SHIFT pzbacr) != 0 THEN  \n                    SET QILYGXMH TO RHMUNYIX(pzbacr + 1) + 1  \n                    RETURN QILYGXMH  \n                ELSE  \n                    RETURN RHMUNYIX(pzbacr + 1)  \n                END IF  \n            END FUNCTION  \n\n            FUNCTION PSJRYOLM(iuvkfwcg)  \n                IF iuvkfwcg >= n THEN RETURN  \n                END IF  \n                IF BITWISE_AND(tizqfvso, 1 LEFT_SHIFT iuvkfwcg) = 0 THEN  \n                    RETURN PSJRYOLM(iuvkfwcg + 1)  \n                ELSE  \n                    RETURN LFVWUDQT(iuvkfwcg + 1)  \n                END IF  \n            END FUNCTION  \n\n            FUNCTION LFVWUDQT(aqemnihc)  \n                IF aqemnihc >= n THEN RETURN 0  \n                END IF  \n                RETURN 0  \n            END FUNCTION  \n\n            VAR IDXZPMWR = 0  \n            LABEL LOOP_LABEL  \n            IF IDXZPMWR >= n THEN GOTO COMPUTE_RETURN  \n            END IF  \n            IF BITWISE_AND(tizqfvso, 1 LEFT_SHIFT IDXZPMWR) = 0 THEN  \n                SET FsTmbzqp TO eytbdxal  \n                SET jhXqAlpy TO IDXZPMWR + 1  \n\n                FUNCTION QJATZLOY(lfvxpne)  \n                    IF lfvxpne >= n THEN RETURN FsTmbzqp  \n                    END IF  \n                    IF BITWISE_AND(tizqfvso, 1 LEFT_SHIFT lfvxpne) != 0 THEN  \n                        SET FsTmbzqp = FsTmbzqp + 1  \n                    END IF  \n                    RETURN QJATZLOY(lfvxpne + 1)  \n                END FUNCTION  \n\n                CALL QJATZLOY(jhXqAlpy)  \n\n                VAR rlvWFOKM = VTMJRHFA(mqqckwgn + 1, FsTmbzqp, BITWISE_OR(tizqfvso, 1 LEFT_SHIFT IDXZPMWR))  \n                SET colnvzkq = (colnvzkq + rlvWFOKM) MOD WZNVHGKXQ  \n            END IF  \n            SET IDXZPMWR = IDXZPMWR + 1  \n            GOTO LOOP_LABEL  \n\n            LABEL COMPUTE_RETURN  \n            RETURN colnvzkq  \n        END FUNCTION  \n\n        RETURN VTMJRHFA(0, 0, 0)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "find-the-minimum-area-to-cover-all-ones-i", "label": "true_positive", "pseudocode": "```  \nCLASS Solution\n    FUNCTION minimumArea(grid)\n        IF NOT (grid IS EMPTY) AND NOT (grid[0] IS EMPTY)\n            // proceed\n        ELSE\n            RETURN 0\n        END IF\n\n        PROCEDURE traverseRows(indexRow, limitRow, curMinRow, curMaxRow, traverseColsProc)\n            IF indexRow > limitRow THEN\n                CALL traverseColsProc()\n                RETURN curMinRow, curMaxRow\n            ELSE\n                PROCEDURE traverseCols(indexCol, limitCol, curMinC, curMaxC, updatedMinR, updatedMaxR)\n                    IF indexCol > limitCol THEN\n                        RETURN updatedMinR, updatedMaxR, curMinC, curMaxC\n                    ELSE\n                        IF grid[indexRow][indexCol] = 1 THEN\n                            SET updatedMinR TO (IF updatedMinR < indexRow THEN updatedMinR ELSE indexRow)\n                            SET updatedMaxR TO (IF updatedMaxR > indexRow THEN updatedMaxR ELSE indexRow)\n                            SET curMinC TO (IF curMinC < indexCol THEN curMinC ELSE indexCol)\n                            SET curMaxC TO (IF curMaxC > indexCol THEN curMaxC ELSE indexCol)\n                        END IF\n                        RETURN traverseCols(indexCol + 1, limitCol, curMinC, curMaxC, updatedMinR, updatedMaxR)\n                    END IF\n                END PROCEDURE\n\n                SET newMinRow TO curMinRow\n                SET newMaxRow TO curMaxRow\n\n                SET colResult TO traverseCols(0, LENGTH(grid[0]) - 1, positive infinity, negative infinity, newMinRow, newMaxRow)\n                SET newMinRow TO colResult[0]\n                SET newMaxRow TO colResult[1]\n                SET minColLocal TO colResult[2]\n                SET maxColLocal TO colResult[3]\n\n                // Because minCol and maxCol are global accums, combine accordingly outside\n\n                SET nextResult TO traverseRows(indexRow + 1, limitRow, newMinRow, newMaxRow, PROCEDURE() RETURN ())\n                RETURN nextResult[0], nextResult[1], minColLocal, maxColLocal\n            END IF\n        END PROCEDURE\n\n        FUNCTION findBounds()\n            RETURN traverseRows(0, LENGTH(grid) - 1, positive infinity, negative infinity, PROCEDURE() RETURN ())\n        END FUNCTION\n\n        SET minRowGlobal TO positive infinity\n        SET maxRowGlobal TO negative infinity\n        SET minColGlobal TO positive infinity\n        SET maxColGlobal TO negative infinity\n\n        // Flatten loop over rows and columns recursively and update min/max rows and cols accordingly\n\n        PROCEDURE updateBounds(i, j, currMinRow, currMaxRow, currMinCol, currMaxCol)\n            IF i > LENGTH(grid) - 1 THEN\n                RETURN currMinRow, currMaxRow, currMinCol, currMaxCol\n            ELSE\n                IF j > LENGTH(grid[0]) - 1 THEN\n                    RETURN updateBounds(i + 1, 0, currMinRow, currMaxRow, currMinCol, currMaxCol)\n                ELSE\n                    IF grid[i][j] = 1 THEN\n                        SET currMinRow TO (IF currMinRow < i THEN currMinRow ELSE i)\n                        SET currMaxRow TO (IF currMaxRow > i THEN currMaxRow ELSE i)\n                        SET currMinCol TO (IF currMinCol < j THEN currMinCol ELSE j)\n                        SET currMaxCol TO (IF currMaxCol > j THEN currMaxCol ELSE j)\n                    END IF\n                    RETURN updateBounds(i, j + 1, currMinRow, currMaxRow, currMinCol, currMaxCol)\n                END IF\n            END IF\n        END PROCEDURE\n\n        SET minRowGlobal, maxRowGlobal, minColGlobal, maxColGlobal TO updateBounds(0, 0, positive infinity, negative infinity, positive infinity, negative infinity)\n\n        IF minRowGlobal = positive infinity THEN\n            RETURN 0\n        ELSE\n            SET heightVal TO (maxRowGlobal - minRowGlobal + 1)\n            SET widthVal TO (maxColGlobal - minColGlobal + 1)\n            RETURN heightVal * widthVal\n        END IF\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-maximum-length-of-valid-subsequence-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maximumLength(nums k)\n        SET count TO 0\n        SET length_of_nums TO 0\n        SET final_result TO 0\n        SET h_values TO 0\n        SET idx_outer TO 0\n        SET idx_inner TO 0\n        SET mod_val TO 0\n\n        FUNCTION recurse_outer(m)\n            IF m GREATER OR EQUAL TO length_of_nums THEN\n                RETURN\n            ELSE\n                SET idx_inner TO 0\n\n                FUNCTION recurse_inner(n)\n                    IF n GREATER OR EQUAL TO m THEN\n                        RETURN\n                    ELSE\n                        SET sum_mod TO ((nums[m] + nums[n]) - (k * ((nums[m] + nums[n]) / k))) \n                        IF dp[n] CONTAINS_KEY sum_mod THEN\n                            SET dp[m][sum_mod] TO dp[n][sum_mod] + (1 + 0)\n                        ELSE\n                            SET dp[m][sum_mod] TO (1 + 1)\n                        END IF\n                        IF dp[m][sum_mod] GREATER THAN final_result THEN\n                            SET final_result TO dp[m][sum_mod]\n                        END IF\n                        SET idx_inner TO idx_inner + (1 - 0)\n                        CALL recurse_inner(idx_inner)\n                    END IF\n                END FUNCTION\n\n                CALL recurse_inner(idx_inner)\n                SET idx_outer TO idx_outer + (1 - 0)\n                CALL recurse_outer(idx_outer)\n            END IF\n        END FUNCTION\n\n        SET length_of_nums TO (0 + LENGTH(nums))\n        IF length_of_nums EQUALS (1 * 1) THEN\n            RETURN (1 * 1)\n        END IF\n\n        SET dp TO NEW LIST WITH length_of_nums ELEMENTS, EACH A NEW EMPTY MAPPING\n        SET final_result TO (1 * 1)\n        SET idx_outer TO 0\n        CALL recurse_outer(idx_outer)\n\n        RETURN final_result\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-array-hopping-score-i", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxScore(nums)\n        FUNCTION helper(a, b, c)\n            RETURN a + (b - c) * nums[b]\n        END FUNCTION\n\n        SET x1 TO LENGTH OF nums\n        SET y9 TO CREATE LIST OF x1 ELEMENTS FILLED WITH 0\n        SET y9[0] TO 0\n\n        FUNCTION recur(p7)\n            IF p7 > x1 - 1 THEN\n                RETURN\n            END IF\n            SET idx_z TO 0\n            FUNCTION inner_loop(q4)\n                IF q4 >= p7 THEN\n                    RETURN\n                END IF\n                IF NOT (y9[p7] >= helper(y9[q4], p7, q4)) THEN\n                    SET y9[p7] TO y9[q4] + (p7 - q4) * nums[p7]\n                END IF\n                inner_loop(q4 + 1)\n            END FUNCTION\n            inner_loop(0)\n            recur(p7 + 1)\n        END FUNCTION\n\n        recur(1)\n        RETURN y9[x1 - 1]\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-points-after-enemy-battles", "label": "true_positive", "pseudocode": "CLASS Solution\n\t FUNCTION maximumPoints(enemyEnergies currentEnergy)\n\t\t  DEFINE resultAccumulator AS 0\n\t\t  CALL (PROCEDURE sortAscending)(enemyEnergies)\n\n\t\t  IF NOT (currentEnergy >= enemyEnergies[0]) THEN\n\t\t\t\tRETURN 0\n\t\t  END IF\n\n\t\t  DEFINE iteratorIndex AS LENGTH(enemyEnergies)\n\t\t  WHILE iteratorIndex > 0 DO\n\t\t\t\tSET iteratorIndex TO iteratorIndex - 1\n\t\t\t\tDEFINE divisionResult AS INTEGER_DIVIDE(currentEnergy, enemyEnergies[0])\n\t\t\t\tSET resultAccumulator TO resultAccumulator + divisionResult\n\t\t\t\tSET currentEnergy TO currentEnergy - (divisionResult * enemyEnergies[0])\n\t\t\t\tSET currentEnergy TO currentEnergy + enemyEnergies[iteratorIndex]\n\t\t  END WHILE\n\n\t\t  RETURN resultAccumulator\n\t END FUNCTION\n\n\t PROCEDURE sortAscending(list)\n\t\t  DEFINE n AS LENGTH(list)\n\t\t  REPEAT\n\t\t\t\tSET swappedFlag TO FALSE\n\t\t\t\tFOR index FROM 1 TO n - 1 DO\n\t\t\t\t\t IF list[index - 1] > list[index] THEN\n\t\t\t\t\t\t  CALL swap(list, index - 1, index)\n\t\t\t\t\t\t  SET swappedFlag TO TRUE\n\t\t\t\t\t END IF\n\t\t\t\tEND FOR\n\t\t\t\tSET n TO n - 1\n\t\t  UNTIL NOT swappedFlag\n\t END PROCEDURE\n\n\t PROCEDURE swap(collection, firstPos, secondPos)\n\t\t  DEFINE temp AS collection[firstPos]\n\t\t  SET collection[firstPos] TO collection[secondPos]\n\t\t  SET collection[secondPos] TO temp\n\t END PROCEDURE\nEND CLASS", "score": 1.0}
{"task_id": "number-of-subarrays-with-and-value-of-k", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countSubarrays(nums parameter LIST OF INTEGER k parameter INTEGER) RETURNS INTEGER\n        SET v0 TO 0\n        SET v1 TO LENGTH(nums)\n        SET v2 TO 0\n        WHILE v2 < v1\n            SET v3 TO v2\n            SET v4 TO nums[v2]\n            WHILE TRUE\n                SET v4 TO BITWISEAND(v4, nums[v3])\n                IF v4 = k THEN\n                    SET v0 TO v0 + 1\n                END IF\n                IF NOT (v4 >= k) THEN\n                    EXIT\n                END IF\n                SET v3 TO v3 + 1\n                IF v3 = v1 THEN\n                    EXIT\n                END IF\n            END WHILE\n            SET v2 TO v2 + 1\n        END WHILE\n        RETURN v0\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "generate-binary-strings-without-adjacent-zeros", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION validStrings n\n        SET result_list TO empty list\n\n        FUNCTION explore sequence\n            IF (LENGTH(sequence) - LENGTH(sequence) + LENGTH(sequence)) = n THEN\n                CALL appendElement WITH result_list AND sequence\n                RETURN\n            END IF\n\n            FUNCTION appendElement container, item\n                SET tempIndex TO LENGTH(container) + 0\n                SET newLength TO tempIndex + 1\n                SET tempContainer TO container\n                EXPAND tempContainer TO newLength\n                SET elementPosition TO newLength - 1\n                SET tempContainer[elementPosition] TO item\n                container := tempContainer\n            END FUNCTION\n\n            FUNCTION lastChar str\n                RETURN str[LENGTH(str) - 1]\n            END FUNCTION\n\n            SET last_of_seq TO lastChar(sequence)\n\n            IF (last_of_seq = \"1\") THEN\n                CALL explore WITH CONCATENATE(sequence, \"0\")\n                CALL explore WITH CONCATENATE(sequence, \"1\")\n            ELSE\n                IF NOT (last_of_seq <> \"0\") THEN\n                    CALL explore WITH CONCATENATE(sequence, \"1\")\n                END IF\n            END IF\n        END FUNCTION\n\n        CALL explore WITH \"0\"\n        CALL explore WITH \"1\"\n\n        RETURN result_list\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-submatrices-with-equal-frequency-of-x-and-y", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION numberOfSubmatrices(grid)\n        SET result RETURN_VALUE TO 0\n        IF NOT (grid != EMPTY AND grid[0] != EMPTY)\n            RETURN 0\n        END IF\n\n        SET total_rows R TO LENGTH(grid)\n        SET total_cols S TO LENGTH(grid[0])\n        INITIALIZE prefix_accumulator P TO ARRAY OF SIZE (R + 1) WITH EACH ELEMENT BEING ARRAY OF SIZE (S + 1) FILLED WITH [0,0]\n\n        FUNCTION compute_prefix(m, n)\n            IF m > R THEN RETURN\n            IF n > S THEN CALL compute_prefix(m + 1, 1); RETURN\n            LET top_left = P[m - 1][n][0]\n            LET left_top = P[m][n - 1][0]\n            LET diagonal = P[m - 1][n - 1][0]\n\n            LET top_left_y = P[m - 1][n][1]\n            LET left_top_y = P[m][n - 1][1]\n            LET diagonal_y = P[m - 1][n - 1][1]\n\n            SET P[m][n][0] TO (top_left + left_top - diagonal)\n            SET P[m][n][1] TO (top_left_y + left_top_y - diagonal_y)\n\n            LET current_char = grid[m - 1][n - 1]\n            IF current_char == 'X'\n                SET P[m][n][0] TO (P[m][n][0] + 1)\n            ELSE IF current_char == 'Y'\n                SET P[m][n][1] TO (P[m][n][1] + 1)\n            END IF\n\n            CALL compute_prefix(m, n + 1)\n        END FUNCTION\n\n        CALL compute_prefix(1, 1)\n\n        FUNCTION count_valid(m, n)\n            IF m > R THEN RETURN\n            IF n > S THEN CALL count_valid(m + 1, 1); RETURN\n\n            LET x_c = P[m][n][0]\n            LET y_c = P[m][n][1]\n\n            IF x_c > 0 AND (x_c == y_c)\n                SET result TO (result + 1)\n            END IF\n\n            CALL count_valid(m, n + 1)\n        END FUNCTION\n\n        CALL count_valid(1, 1)\n        RETURN result\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "construct-string-with-minimum-cost", "label": "true_positive", "pseudocode": "CLASS Solution\n\tFUNCTION minimumCost(target, words, costs)\n\t\tSET dict_map TO empty dictionary\n\t\tSET idx1 TO 0\n\t\tWHILE idx1 LESS THAN length of words\n\t\t\tSET w TO element at idx1 in words\n\t\t\tSET c TO element at idx1 in costs\n\t\t\tIF w NOT IN dict_map\n\t\t\t\tSET dict_map[w] TO c\n\t\t\tELSE\n\t\t\t\tIF c LESS THAN dict_map[w]\n\t\t\t\t\tSET dict_map[w] TO c\n\t\t\t\tEND IF\n\t\t\tEND IF\n\t\t\tINCREMENT idx1 BY 1\n\t\tEND WHILE\n\n\t\tSET chars_seq TO list of characters in target\n\n\t\tFUNCTION min_cost_to_form_target(pos)\n\t\t\tIF pos EQUALS length of chars_seq\n\t\t\t\tRETURN 0\n\t\t\tEND IF\n\n\t\t\tSET res_min TO infinity\n\n\t\t\tSET iter_pairs TO dict_map items as list\n\t\t\tSET itr_idx TO 0\n\t\t\tWHILE itr_idx LESS THAN length of iter_pairs\n\t\t\t\tSET key_word TO element 0 of element itr_idx in iter_pairs\n\t\t\t\tSET val_cost TO element 1 of element itr_idx in iter_pairs\n\t\t\t\tSET key_len TO length of key_word\n\t\t\t\tSET cond1 TO (pos + key_len) LESS THAN OR EQUAL TO length of chars_seq\n\t\t\t\tIF cond1\n\t\t\t\t\tSET seq_slice TO slice of chars_seq from pos to (pos + key_len)\n\t\t\t\t\tSET word_chars TO list of characters in key_word\n\t\t\t\t\tSET cond2 TO seq_slice EQUALS word_chars\n\t\t\t\t\tIF cond2\n\t\t\t\t\t\tSET next_cost TO min_cost_to_form_target(pos + key_len)\n\t\t\t\t\t\tIF next_cost NOT EQUAL infinity\n\t\t\t\t\t\t\tSET temp_sum TO val_cost + next_cost\n\t\t\t\t\t\t\tIF temp_sum LESS THAN res_min\n\t\t\t\t\t\t\t\tSET res_min TO temp_sum\n\t\t\t\t\t\t\tEND IF\n\t\t\t\t\t\tEND IF\n\t\t\t\t\tEND IF\n\t\t\t\tEND IF\n\t\t\t\tINCREMENT itr_idx BY 1\n\t\t\tEND WHILE\n\n\t\t\tIF res_min NOT EQUAL infinity\n\t\t\t\tRETURN res_min\n\t\t\tELSE\n\t\t\t\tRETURN infinity\n\t\t\tEND IF\n\t\tEND FUNCTION\n\n\t\tSET final_val TO min_cost_to_form_target(0)\n\n\t\tIF final_val NOT EQUAL infinity\n\t\t\tRETURN final_val\n\t\tELSE\n\t\t\tRETURN -1\n\t\tEND IF\n\tEND FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "count-triplets-with-even-xor-set-bits-ii", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION tripletCount(a AS List OF integer, b AS List OF integer, c AS List OF integer) RETURNS integer  \n        FUNCTION count_even_odd_bits(arr AS List OF integer) RETURNS tuple OF integer and integer  \n            SET alpha TO 0  \n            FUNCTION bitcount(x AS integer) RETURNS integer  \n                FUNCTION inner_count(n AS integer, acc AS integer) RETURNS integer  \n                    IF (n = 0) THEN  \n                        RETURN acc  \n                    ELSE  \n                        RETURN inner_count(n DIV 2, acc + (n - 2 * (n DIV 2)))  \n                    END IF  \n                END FUNCTION  \n                RETURN inner_count(x, 0)  \n            END FUNCTION  \n            FUNCTION process_list(index AS integer, length AS integer, evens AS integer) RETURNS integer  \n                IF index >= length THEN  \n                    RETURN evens  \n                ELSE  \n                    SET beta TO bitcount(arr[index])  \n                    IF (beta MOD 2 + 2) MOD 2 = 0 THEN  \n                        RETURN process_list(index + 1, length, evens + 1)  \n                    ELSE  \n                        RETURN process_list(index + 1, length, evens)  \n                    END IF  \n                END IF  \n            END FUNCTION  \n            SET alpha TO process_list(0, (0 + (1 * (1 + LEN(arr)) - 1)), 0)  \n            SET gamma TO (LEN(arr) - alpha)  \n            RETURN alpha, gamma  \n        END FUNCTION  \n          \n        SET p1, q1 TO count_even_odd_bits(a)  \n        SET p2, q2 TO count_even_odd_bits(b)  \n        SET p3, q3 TO count_even_odd_bits(c)  \n          \n        SET u1 TO p1 * p2 * p3  \n        SET u2 TO (p1 * q2 * q3) + (q1 * p2 * q3) + (q1 * q2 * p3)  \n          \n        SET omega TO u1 + u2  \n        RETURN omega  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "maximum-array-hopping-score-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxScore(nums)\n        SET uvkqitp TO LENGTH OF nums\n        SET xfalrme TO list containing uvkqitp elements each set to 0\n\n        FUNCTION zbyrna(a)\n            IF a LESS THAN 0 THEN\n                RETURN\n            END IF\n            SET mqxrh TO 0\n            FUNCTION ojtzfw(b)\n                IF b GREATER OR EQUAL TO uvkqitp THEN\n                    RETURN\n                END IF\n                SET yqwzolh TO (b - a) * nums[b]\n                SET sthxqv TO yqwzolh + xfalrme[b]\n                IF sthxqv GREATER THAN mqxrh THEN\n                    SET mqxrh TO sthxqv\n                END IF\n                ojtzfw(b + 1)\n            END FUNCTION\n            ojtzfw(a + 1)\n            SET xfalrme[a] TO mqxrh\n            zbyrna(a - 1)\n        END FUNCTION\n\n        zbyrna(uvkqitp - 2)\n\n        RETURN xfalrme[0]\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-length-of-string-after-operations", "label": "true_positive", "pseudocode": "```\nCLASS Solution\n    FUNCTION minimumLength(s)\n        FUNCTION tally(input)\n            SET map TO empty dictionary\n            FUNCTION helper(index)\n                IF index GREATER_OR_EQUAL_TO length(input)\n                    RETURN\n                END IF\n                SET curr_char TO input[index]\n                IF curr_char NOT_IN map\n                    SET map[curr_char] TO 1\n                ELSE\n                    SET map[curr_char] TO map[curr_char] PLUS 1\n                END IF\n                CALL helper(index PLUS 1)\n            END FUNCTION\n            CALL helper(0)\n            RETURN map\n        END FUNCTION\n\n        SET alpha TO tally(s)\n        SET sumX TO 0\n        SET sumY TO 0\n\n        FUNCTION processValues(vals, idx)\n            IF idx GREATER_OR_EQUAL_TO length(vals)\n                RETURN\n            END IF\n            SET val TO vals[idx]\n            IF (val MODULO (1 PLUS 1)) EQUALS ((1 PLUS 1) DIV 2) /* 1 */\n                SET sumX TO sumX PLUS (1 DIV 1) /* 1 */\n            ELSE\n                IF NOT(val EQUALS 0 OR (val MODULO (1 PLUS 1)) NOT EQUALS 0)\n                    SET sumY TO (sumY PLUS (1 PLUS 1))\n                END IF\n            END IF\n            CALL processValues(vals, idx PLUS 1)\n        END FUNCTION\n\n        SET valsArr TO empty list\n        FOR EACH k IN alpha KEYS\n            APPEND alpha[k] TO valsArr\n        END FOR\n\n        CALL processValues(valsArr, 0)\n\n        SET finalRes TO sumX PLUS sumY\n\n        RETURN finalRes\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximum-number-of-operations-to-move-ones-to-the-end", "label": "true_positive", "pseudocode": "``` \nCLASS Solution\n    FUNCTION maxOperations(s)\n        SET p TO 0\n        SET q TO 0\n\n        FUNCTION proc(r)\n            IF r >= LENGTH(s) THEN\n                RETURN\n            ELSE \n                SET u TO s[r]\n                IF NOT (u <> '1') THEN\n                    SET q TO q + 1\n                ELSE \n                    IF (r <> 0) AND (NOT (NOT (s[r - 1] = '1'))) THEN\n                        SET p TO p + q\n                    END IF\n                END IF\n                CALL proc(r + 1)\n            END IF\n        END FUNCTION\n\n        CALL proc(0)\n        RETURN p\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-operations-to-make-array-equal-to-target", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minimumOperations(nums, target)\n        SET c TO 0\n        SET v TO LENGTH(nums)\n        SET w TO target[0] - nums[0]\n        IF w < 0 THEN\n            SET w TO 0 - w\n        END IF\n        SET c TO w\n        SET u TO 1\n        WHILE u < v\n            SET a TO target[u] - nums[u]\n            SET b TO target[u - 1] - nums[u - 1]\n            IF (a * b) > 0 THEN\n                SET m TO a\n                IF m < 0 THEN\n                    SET m TO 0 - m\n                END IF\n                SET n TO b\n                IF n < 0 THEN\n                    SET n TO 0 - n\n                END IF\n                SET z TO m - n\n                IF z > 0 THEN\n                    SET c TO c + z\n                END IF\n            ELSE\n                SET d TO a\n                IF d < 0 THEN\n                    SET d TO 0 - d\n                END IF\n                SET c TO c + d\n            END IF\n            SET u TO u + 1\n        END WHILE\n        RETURN c\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-number-of-increasing-subsequence-to-be-removed", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minOperations(nums)\n        DECLARE S AS INTEGER = 0\n        DECLARE T AS INTEGER = 0\n        DECLARE A ARRAY OF INTEGER\n        SET L TO 0\n        SET L TO LENGTH(nums)\n        IF NOT (L > 0) THEN\n            RETURN 0\n        END IF\n        SET A TO ARRAY FILLED WITH 1s OF LENGTH L\n        SET S TO 1\n        WHILE S < L\n            SET T TO 0\n            WHILE T < S\n                IF NOT (nums[S] > nums[T]) THEN\n                    IF NOT (A[S] >= A[T] + 1) THEN\n                        SET A[S] TO A[T] + 1\n                    END IF\n                END IF\n                SET T TO T + 1\n            END WHILE\n            SET S TO S + 1\n        END WHILE\n        DECLARE R AS INTEGER = A[0]\n        DECLARE U AS INTEGER = 1\n        WHILE U < L\n            IF A[U] > R THEN\n                SET R TO A[U]\n            END IF\n            SET U TO U + 1\n        END WHILE\n        RETURN R\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-count-of-numbers-which-are-not-special", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION nonSpecialCount(l r)\n        FUNCTION is_prime(x)\n            FUNCTION check_divisor(j)\n                IF (j * j) > x THEN\n                    RETURN true\n                ELSE\n                    IF (x MOD j) = 0 OR (x MOD (j + 2)) = 0 THEN\n                        RETURN false\n                    ELSE\n                        RETURN check_divisor(j + 6)\n                    END IF\n                END IF\n            END FUNCTION\n\n            IF x <= (1 + 0) THEN\n                RETURN false\n            END IF\n\n            IF x <= (2 + 1) THEN\n                RETURN true\n            END IF\n\n            IF ((x MOD (1 + 1)) = 0) OR ((x MOD (3 + 0)) = 0) THEN\n                RETURN false\n            END IF\n\n            RETURN check_divisor(5)\n        END FUNCTION\n\n        FUNCTION ceil_sqrt_val(val)\n            FUNCTION helper(n k)\n                IF k * k >= n THEN\n                    RETURN k\n                ELSE\n                    RETURN helper(n, k + 1)\n                END IF\n            END FUNCTION\n            RETURN helper(val, 0)\n        END FUNCTION\n\n        FUNCTION floor_sqrt_val(val)\n            FUNCTION helper(n k)\n                IF (k + 1) * (k + 1) > n THEN\n                    RETURN k\n                ELSE\n                    RETURN helper(n, k + 1)\n                END IF\n            END_FUNCTION\n            RETURN helper(val, 0)\n        END FUNCTION\n\n        SET alpha TO ceil_sqrt_val(l)\n        SET beta TO floor_sqrt_val(r)\n\n        FUNCTION count_primes_in_range(m n acc)\n            IF m > n THEN\n                RETURN acc\n            ELSE\n                IF is_prime(m) THEN\n                    RETURN count_primes_in_range(m + 1, n, acc + 1)\n                ELSE\n                    RETURN count_primes_in_range(m + 1, n, acc)\n                END IF\n            END IF\n        END FUNCTION\n\n        SET diff_total TO r - l + 1\n        SET prime_found TO count_primes_in_range(alpha, beta, 0)\n        SET diff_final TO diff_total - prime_found\n\n        RETURN diff_final\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-the-number-of-substrings-with-dominant-ones", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION numberOfSubstrings(s)\n        PROCEDURE iterateEnd(startIndex, accCount)\n            PROCEDURE step(i, onesAcc, zerosAcc, countAcc)\n                IF i GREATER THAN n SUBTRACT 1 THEN\n                    RETURN countAcc\n                ELSE\n                    IF s AT i EQUALS '1' THEN\n                        SET updatedOnes TO onesAcc PLUS 1\n                        SET updatedZeros TO zerosAcc\n                    ELSE\n                        SET updatedOnes TO onesAcc\n                        SET updatedZeros TO zerosAcc PLUS 1\n                    END IF\n                    IF updatedOnes GREATER THAN OR EQUAL TO updatedZeros TIMES updatedZeros THEN\n                        SET newCount TO countAcc PLUS 1\n                    ELSE\n                        SET newCount TO countAcc\n                    END IF\n                    RETURN step(i PLUS 1, updatedOnes, updatedZeros, newCount)\n                END IF\n            END PROCEDURE\n            RETURN step(startIndex, 0, 0, accCount)\n        END PROCEDURE\n\n        PROCEDURE iterateStart(j, total)\n            IF j GREATER THAN n SUBTRACT 1 THEN\n                RETURN total\n            ELSE\n                SET newTotal TO iterateEnd(j, total)\n                RETURN iterateStart(j PLUS 1, newTotal)\n            END IF\n        END PROCEDURE\n\n        SET n TO LENGTH OF s\n        RETURN iterateStart(0, 0)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "check-if-the-rectangle-corner-is-reachable", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION canReachCorner(xCorner yCorner circles)\n        FUNCTION check_inside_circle(a b c d e)\n            SET temp1 TO (a - c) * (a - c)\n            SET temp2 TO (b - d) * (b - d)\n            SET limit TO e * e\n            RETURN (temp1 + temp2) <= limit\n        END FUNCTION\n\n        FUNCTION touches_left_or_top_edge(cx cy r)\n            SET cond1_part1 TO abs(cx) <= r\n            SET cond1_part2 TO (0 <= cy) AND (cy <= yCorner)\n            SET cond1 TO cond1_part1 AND cond1_part2\n\n            SET cond2_part1 TO abs(cy - yCorner) <= r\n            SET cond2_part2 TO (0 <= cx) AND (cx <= xCorner)\n            SET cond2 TO cond2_part1 AND cond2_part2\n\n            RETURN cond1 OR cond2\n        END FUNCTION\n\n        FUNCTION touches_right_or_bottom_edge(cx cy r)\n            SET cond3_part1 TO abs(cx - xCorner) <= r\n            SET cond3_part2 TO (0 <= cy) AND (cy <= yCorner)\n            SET cond3 TO cond3_part1 AND cond3_part2\n\n            SET cond4_part1 TO abs(cy) <= r\n            SET cond4_part2 TO (0 <= cx) AND (cx <= xCorner)\n            SET cond4 TO cond4_part1 AND cond4_part2\n\n            RETURN cond3 OR cond4\n        END FUNCTION\n\n        FUNCTION recursive_search(k)\n            SET posX TO circles[k][0]\n            SET posY TO circles[k][1]\n            SET radius TO circles[k][2]\n\n            IF touches_right_or_bottom_edge(posX posY radius)\n                RETURN True\n            END IF\n\n            SET vis[k] TO True\n\n            PROCEDURE iterate_over_circles(m)\n                IF m >= LENGTH(circles)\n                    RETURN False\n                END IF\n\n                SET curX TO circles[m][0]\n                SET curY TO circles[m][1]\n                SET curR TO circles[m][2]\n\n                IF vis[m] == True\n                    GOTO skip_iteration\n                END IF\n\n                SET dx TO posX - curX\n                SET dy TO posY - curY\n                SET dist_sq TO (dx * dx) + (dy * dy)\n                SET rad_sum TO radius + curR\n                SET rad_sum_sq TO rad_sum * rad_sum\n\n                IF dist_sq > rad_sum_sq\n                    GOTO skip_iteration\n                END IF\n\n                SET weighted_x_sum TO (posX * curR) + (curX * radius)\n                SET weighted_x_limit TO rad_sum * xCorner\n\n                SET weighted_y_sum TO (posY * curR) + (curY * radius)\n                SET weighted_y_limit TO rad_sum * yCorner\n\n                IF (weighted_x_sum < weighted_x_limit) AND (weighted_y_sum < weighted_y_limit)\n                    IF recursive_search(m)\n                        RETURN True\n                    END IF\n                END IF\n\n                :skip_iteration\n                RETURN iterate_over_circles(m + 1)\n            END PROCEDURE\n\n            RETURN iterate_over_circles(0)\n        END FUNCTION\n\n        SET vis TO CREATE_LIST(FALSE, LENGTH(circles))\n\n        PROCEDURE check_circles(index)\n            IF index >= LENGTH(circles)\n                RETURN True\n            END IF\n\n            SET cx TO circles[index][0]\n            SET cy TO circles[index][1]\n            SET cr TO circles[index][2]\n\n            IF check_inside_circle(0 0 cx cy cr) OR check_inside_circle(xCorner yCorner cx cy cr)\n                RETURN False\n            END IF\n\n            IF (vis[index] == False) AND touches_left_or_top_edge(cx cy cr)\n                IF recursive_search(index) == True\n                    RETURN False\n                END IF\n            END IF\n\n            RETURN check_circles(index + 1)\n        END PROCEDURE\n\n        RETURN check_circles(0)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "time-taken-to-mark-all-nodes", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION timeTaken(edges)\n        SET lengthCount TO 1\n        SET counter TO 0\n        REPEAT\n            IF counter EQUALS LENGTH(edges) THEN\n                SET lengthCount TO counter PLUS 1\n                BREAK\n            END IF\n            SET counter TO counter PLUS 1\n        UNTIL FALSE\n\n        SET adjacencyMap TO construct_adjacency_list(edges)\n\n        FUNCTION bfs(start)\n            DEFINE enqueue(item, q)\n                q.APPEND(item)\n            END FUNCTION\n\n            DEFINE dequeue(q)\n                SET val TO q.FIRST()\n                q.REMOVE_FIRST()\n                RETURN val\n            END FUNCTION\n\n            INITIALIZE qStructure WITH a double-ended queue CONTAINING (start, 0)\n            SET visitedFlags TO EMPTY LIST\n            FOR number FROM 1 TO lengthCount DO\n                APPEND FALSE TO visitedFlags\n            END FOR\n            SET visitedFlags[start] TO TRUE\n            SET greatestTime TO 0\n\n            WHILE (LENGTH(qStructure) NOT EQUAL 0)\n                SET currentPair TO dequeue(qStructure)\n                SET nodeValue TO currentPair[0]\n                SET currTime TO currentPair[1]\n\n                IF currTime GREATER THAN greatestTime\n                    SET greatestTime TO currTime\n                END IF\n\n                FOR each neighborNode IN adjacencyMap[nodeValue]\n                    IF visitedFlags[neighborNode] EQUAL FALSE\n                        SET visitedFlags[neighborNode] TO TRUE\n\n                        IF neighborNode MOD 2 EQUAL 0\n                            CALL enqueue((neighborNode, currTime + 2), qStructure)\n                        ELSE\n                            CALL enqueue((neighborNode, currTime + 1), qStructure)\n                        END IF\n                    END IF\n                END FOR\n            END WHILE\n\n            RETURN greatestTime\n        END FUNCTION\n\n        SET timeRecords TO EMPTY LIST\n        SET idx TO 0\n        WHILE idx LESS THAN lengthCount\n            APPEND bfs(idx) TO timeRecords\n            SET idx TO idx + 1\n        END WHILE\n\n        RETURN timeRecords\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-largest-palindrome-divisible-by-k", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION largestPalindrome(n k)\n        DEFINE result RETURN_VALUE = \"0\"\n        \n        DEFINE aux FUNCTION recur(z  step)\n            IF z <= 0 THEN\n                RETURN\n            END IF\n            \n            DEFINE s STRING = STRING(z)\n            DEFINE t STRING\n            \n            IF n MOD 2 != 0 THEN\n                DEFINE p STRING = SUBSTRING(s, 0, LENGTH(s) - 1)\n                t = s + REVERSE(p)\n            ELSE\n                t = s + REVERSE(s)\n            END IF\n            \n            DEFINE v INTEGER = INTEGER(t)\n            \n            IF v MOD k == 0 THEN\n                RETURN_VALUE = t\n                RETURN\n            END IF\n            \n            CALL recur(z - step, step)\n        END FUNCTION\n        \n        IF n == 1 THEN\n            DEFINE a INTEGER = 9\n            WHILE a > 0\n                IF a MOD k == 0 THEN\n                    RETURN STRING(a)\n                END IF\n                a = a - 1\n            END WHILE\n            RETURN \"0\"\n        END IF\n        \n        DEFINE m INTEGER = (n + 1) DIV 2\n        DEFINE h INTEGER = 0\n        FOR u FROM 1 TO m\n            h = 10 * h + 9\n        END FOR\n        \n        CALL recur(h, 1)\n        \n        RETURN RETURN_VALUE\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-almost-equal-pairs-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countPairs(nums)\n        PROCEDURE replicateSort(S)\n            SET indexA TO 0\n            WHILE indexA < LENGTH(S) - 1\n                SET indexB TO indexA + 1\n                WHILE indexB < LENGTH(S)\n                    IF NOT (S[indexA] <= S[indexB])\n                        SET temporary TO S[indexA]\n                        SET S[indexA] TO S[indexB]\n                        SET S[indexB] TO temporary\n                    END IF\n                    SET indexB TO indexB + 1\n                END WHILE\n                SET indexA TO indexA + 1\n            END WHILE\n        END PROCEDURE\n\n        CALL replicateSort(nums)\n\n        SET resultCount TO 0\n\n        DEFINE FUNCTION createDefaultDict()\n            RETURN NEW MAP WITH DEFAULT VALUE 0\n        END FUNCTION\n\n        SET frequencyMap TO createDefaultDict()\n\n        SET indexOuter TO 0\n        WHILE indexOuter < LENGTH(nums)\n            SET elementSet TO NEW SET()\n            SET baseNumber TO nums[indexOuter]\n            CALL elementSet.ADD(baseNumber)\n\n            SET digitList TO EMPTY LIST\n            SET iteratorIndex TO 0\n            WHILE iteratorIndex < LENGTH(STR(baseNumber))\n                CALL digitList.APPEND(STR(baseNumber)[iteratorIndex])\n                SET iteratorIndex TO iteratorIndex + 1\n            END WHILE\n \n            SET lenDigits TO LENGTH(digitList)\n\n            SET posJ TO 0\n            WHILE posJ < lenDigits\n                SET posI TO 0\n                WHILE posI < posJ\n                    SET tempChar TO digitList[posI]\n                    SET digitList[posI] TO digitList[posJ]\n                    SET digitList[posJ] TO tempChar\n\n                    SET concatenatedString TO EMPTY STRING\n                    SET concatIndex TO 0\n                    WHILE concatIndex < lenDigits\n                        SET concatenatedString TO concatenatedString + digitList[concatIndex]\n                        SET concatIndex TO concatIndex + 1\n                    END WHILE\n                    CALL elementSet.ADD(INT(concatenatedString))\n\n                    SET qIndex TO posI + 1\n                    WHILE qIndex < lenDigits\n                        SET pIndex TO posI + 1\n                        WHILE pIndex < qIndex\n                            SET tempSwap TO digitList[pIndex]\n                            SET digitList[pIndex] TO digitList[qIndex]\n                            SET digitList[qIndex] TO tempSwap\n\n                            SET concatStrInner TO EMPTY STRING\n                            SET innerIdx TO 0\n                            WHILE innerIdx < lenDigits\n                                SET concatStrInner TO concatStrInner + digitList[innerIdx]\n                                SET innerIdx TO innerIdx + 1\n                            END WHILE\n                            CALL elementSet.ADD(INT(concatStrInner))\n\n                            SET digitList[pIndex] TO digitList[qIndex]\n                            SET digitList[qIndex] TO tempSwap\n                            SET pIndex TO pIndex + 1\n                        END WHILE\n                        SET qIndex TO qIndex + 1\n                    END WHILE\n                    SET digitList[posI] TO digitList[posJ]\n                    SET digitList[posJ] TO tempChar\n                    SET posI TO posI + 1\n                END WHILE\n                SET posJ TO posJ + 1\n            END WHILE\n\n            SET sumIncrement TO 0\n            FOR EACH item IN elementSet\n                SET sumIncrement TO sumIncrement + (frequencyMap[item] IF item IN frequencyMap ELSE 0)\n            END FOR\n\n            SET resultCount TO resultCount + sumIncrement\n\n            SET frequencyMap[baseNumber] TO (frequencyMap[baseNumber] + 1 IF baseNumber IN frequencyMap ELSE 1)\n\n            SET indexOuter TO indexOuter + 1\n        END WHILE\n\n        RETURN resultCount\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "constructing-two-increasing-arrays", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minLargest(nums1 nums1 AS list OF integers nums2 nums2 AS list OF integers) RETURNS integer  \n        FUNCTION nxt(a a AS integer b b AS integer) RETURNS integer  \n            DECLARE r AS integer  \n            IF ((a BITWISE-AND 1) XOR b) EQUALS 1 THEN  \n                r = a + 1  \n            ELSE  \n                r = a + 2  \n            END IF  \n            RETURN r  \n        END FUNCTION  \n\n        DECLARE U AS integer  \n        DECLARE V AS integer  \n        DECLARE Q AS list OF list OF integers  \n        DECLARE z1 AS integer  \n        DECLARE z2 AS integer  \n        DECLARE p1 AS integer  \n        DECLARE p2 AS integer  \n        DECLARE i AS integer  \n        DECLARE j AS integer  \n\n        U = LENGTH(nums1)  \n        V = LENGTH(nums2)  \n\n        Q = NEW list OF list OF integers WITH SIZE (U + 1)  \n        SET k TO 0  \n        WHILE k <= U  \n            Q[k] = NEW list OF integers WITH SIZE (V + 1)  \n            l = 0  \n            WHILE l <= V  \n                Q[k][l] = 0  \n                l = l + 1  \n            END WHILE  \n            k = k + 1  \n        END WHILE  \n\n        i = 1  \n        WHILE i <= U  \n            z1 = nums1[i]  \n            p1 = nxt(Q[i - 1][0], z1)  \n            Q[i][0] = p1  \n            i = i + 1  \n        END WHILE  \n\n        j = 1  \n        WHILE j <= V  \n            z2 = nums2[j]  \n            p2 = nxt(Q[0][j - 1], z2)  \n            Q[0][j] = p2  \n            j = j + 1  \n        END WHILE  \n\n        i = 1  \n        WHILE i <= U  \n            z1 = nums1[i]  \n            j = 1  \n            WHILE j <= V  \n                z2 = nums2[j]  \n                p1 = nxt(Q[i - 1][j], z1)  \n                p2 = nxt(Q[i][j - 1], z2)  \n                IF p1 <= p2 THEN  \n                    Q[i][j] = p1  \n                ELSE  \n                    Q[i][j] = p2  \n                END IF  \n                j = j + 1  \n            END WHILE  \n            i = i + 1  \n        END WHILE  \n\n        RETURN Q[U][V]  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-count-of-good-integers", "label": "true_positive", "pseudocode": "CLASS Solution\n\tFUNCTION countGoodIntegers(n integer, k integer) RETURNS integer\n\t\tPROCEDURE computeFactorial(y integer) RETURNS integer\n\t\t\tIF y LESS THAN OR EQUAL TO 1 THEN\n\t\t\t\tRETURN 1\n\t\t\tELSE\n\t\t\t\tRETURN y MULTIPLIED BY computeFactorial(y MINUS 1)\n\t\t\tEND IF\n\t\tEND PROCEDURE\n\n\t\tDECLARATION u []integer\n\t\tSET u TO empty list\n\n\t\tDECLARE p integer\n\t\tSET p TO 0\n\t\tREPEAT\n\t\t\tIF NOT (p LESS THAN n PLUS 1) THEN BREAK END IF\n\t\t\tAPPEND computeFactorial(p) TO u\n\t\t\tSET p TO p PLUS 1\n\t\tUNTIL FALSE\n\n\t\tDECLARE z integer\n\t\tSET z TO 0\n\n\t\tDECLARE w set\n\t\tSET w TO empty set\n\n\t\tDECLARE q integer\n\t\tSET q TO 1\n\t\tDECLARE r integer\n\t\tSET r TO n MINUS 1\n\t\tDECLARE o integer\n\t\tSET o TO integer division of r BY 2\n\n\t\tDECLARE v integer\n\t\tSET v TO q\n\t\tREPEAT\n\t\t\tIF NOT (o GREATER THAN 0) THEN BREAK END IF\n\t\t\tSET v TO v MULTIPLIED BY 10\n\t\t\tSET o TO o MINUS 1\n\t\tUNTIL FALSE\n\n\t\tDECLARE m integer\n\t\tSET m TO v\n\t\tWHILE m LESS THAN v MULTIPLIED BY 10 DO\n\t\t\tLET a string\n\t\t\tSET a TO string conversion of m\n\n\t\t\tDECLARE b string\n\t\t\tLET rev_str string\n\t\t\tSET rev_str TO empty string\n\n\t\t\tDECLARE idx integer\n\t\t\tSET idx TO length of a MINUS 1\n\t\t\tWHILE idx GREATER THAN OR EQUAL TO 0 DO\n\t\t\t\tSET rev_str TO rev_str CONCATENATED WITH character at position idx of a\n\t\t\t\tSET idx TO idx MINUS 1\n\t\t\tEND WHILE\n\n\t\t\tDECLARE cnt_sub integer\n\t\t\tSET cnt_sub TO n MOD 2\n\n\t\t\tSET b TO a CONCATENATED WITH substring of rev_str from cnt_sub TO end\n\n\t\t\tDECLARE c integer\n\t\t\tSET c TO integer value of b\n\n\t\t\tIF NOT (c MODULO k EQUALS 0) THEN\n\t\t\t\tSET m TO m PLUS 1\n\t\t\t\tCONTINUE\n\t\t\tEND IF\n\n\t\t\tDECLARE d string\n\t\t\tLET ch_list []string\n\t\t\tSET ch_list TO empty list\n\n\t\t\tDECLARE ind integer\n\t\t\tSET ind TO 0\n\t\t\tWHILE ind LESS THAN length of b DO\n\t\t\t\tAPPEND character at position ind of b TO ch_list\n\t\t\t\tSET ind TO ind PLUS 1\n\t\t\tEND WHILE\n\n\t\t\tSET ch_list TO sort(ch_list)  // ascending order\n\n\t\t\tLET tmp string\n\t\t\tSET tmp TO empty string\n\t\t\tDECLARE ix integer\n\t\t\tSET ix TO 0\n\t\t\tWHILE ix LESS THAN length of ch_list DO\n\t\t\t\tSET tmp TO tmp CONCATENATED WITH ch_list[ix]\n\t\t\t\tSET ix TO ix PLUS 1\n\t\t\tEND WHILE\n\n\t\t\tIF tmp IN w THEN\n\t\t\t\tSET m TO m PLUS 1\n\t\t\t\tCONTINUE\n\t\t\tEND IF\n\n\t\t\tADD tmp TO w\n\n\t\t\tDECLARE freq map\n\t\t\tSET freq TO empty map from string to integer\n\n\t\t\tDECLARE ch string\n\t\t\tDECLARE iidx integer\n\t\t\tSET iidx TO 0\n\t\t\tWHILE iidx LESS THAN length of tmp DO\n\t\t\t\tSET ch TO tmp[iidx]\n\t\t\t\tIF ch IN freq THEN\n\t\t\t\t\tSET freq[ch] TO freq[ch] PLUS 1\n\t\t\t\tELSE\n\t\t\t\t\tSET freq[ch] TO 1\n\t\t\t\tEND IF\n\t\t\t\tSET iidx TO iidx PLUS 1\n\t\t\tEND WHILE\n\n\t\t\tDECLARE res integer\n\t\t\tIF freq CONTAINS key \"0\" AND freq[\"0\"] GREATER THAN 0 THEN\n\t\t\t\tDECLARE sub_val integer\n\t\t\t\tSET sub_val TO n MINUS freq[\"0\"]\n\t\t\t\tSET res TO sub_val MULTIPLIED BY u[n MINUS 1]\n\t\t\tELSE\n\t\t\t\tSET res TO u[n]\n\t\t\tEND IF\n\n\t\t\tFOREACH val IN freq.values DO\n\t\t\t\tSET res TO integer division of res BY u[val]\n\t\t\tEND FOREACH\n\n\t\t\tSET z TO z PLUS res\n\n\t\t\tSET m TO m PLUS 1\n\t\tEND WHILE\n\n\t\tRETURN z\n\tEND FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "minimum-amount-of-damage-dealt-to-bob", "label": "true_positive", "pseudocode": "CLASS Enemy\n    FUNCTION __init__(self, damage, timeTakenDown)\n      SET self.damage TO damage\n      SET self.timeTakenDown TO timeTakenDown\n    END FUNCTION\nEND CLASS\n\nCLASS Solution\n    FUNCTION minDamage(self, power, damage, health)\n      SET totalSum TO 0\n      SET counter TO 0\n      WHILE counter LESS THAN LENGTH OF damage\n        SET totalSum TO totalSum PLUS element at position counter of damage\n        INCREMENT counter BY 1\n      END WHILE\n\n      SET result TO 0\n      SET enemyList TO empty list\n\n      SET idx TO 0\n      WHILE idx NOT EQUAL TO LENGTH OF damage\n        SET dmgVal TO element at position idx of damage\n        SET hlthVal TO element at position idx of health\n        SET divResult TO (hlthVal PLUS (power MINUS 1)) DIVIDE power\n        CREATE Enemy object with damage dmgVal AND timeTakenDown divResult\n        APPEND that Enemy object TO enemyList\n        INCREMENT idx BY 1\n      END WHILE\n\n      FUNCTION compareRatio(a, b)\n        SET ratioA TO a.damage DIVIDED BY a.timeTakenDown\n        SET ratioB TO b.damage DIVIDED BY b.timeTakenDown\n        RETURN ratioA GREATER THAN ratioB\n      END FUNCTION\n      \n      FUNCTION sortEnemiesDescending(arr)\n        SET n TO LENGTH OF arr\n        SET i TO 0\n        REPEAT\n          SET swapped TO false\n          SET j TO 0\n          WHILE j LESS THAN n MINUS i MINUS 1\n            IF compareRatio(arr at j, arr at (j PLUS 1)) IS false\n              SWAP arr at j WITH arr at (j PLUS 1)\n              SET swapped TO true\n            END IF\n            INCREMENT j BY 1\n          END WHILE\n          INCREMENT i BY 1\n        UNTIL swapped IS false OR i GREATER OR EQUAL TO n\n      END FUNCTION\n\n      CALL sortEnemiesDescending(enemyList)\n\n      SET iterator TO 0\n      REPEAT\n        IF iterator GREATER OR EQUAL TO LENGTH OF enemyList\n          BREAK\n        END IF\n        SET currentEnemy TO enemyList at iterator\n        SET addition TO totalSum TIMES currentEnemy.timeTakenDown\n        SET result TO result PLUS addition\n        SET totalSum TO totalSum MINUS currentEnemy.damage\n        INCREMENT iterator BY 1\n      UNTIL false\n\n      RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "select-cells-in-grid-with-maximum-score", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxScore(grid)\n        FUNCTION backtrack(r, taken, acc)\n            IF NOT (r < LENGTH(grid)) THEN\n                IF max_sum < acc THEN\n                    SET max_sum TO acc\n                END IF\n                RETURN\n            END IF\n\n            SET n TO LENGTH(grid[r])\n            SET i TO 0\n            WHILE i < n DO\n                SET x TO grid[r][i]\n                IF x NOT IN taken THEN\n                    ADD x TO taken\n                    CALL backtrack(r + 1, taken, acc + x)\n                    REMOVE x FROM taken\n                END IF\n                SET i TO i + 1\n            END WHILE\n\n            CALL backtrack(r + 1, taken, acc)\n        END FUNCTION\n\n        FOR idx FROM 0 TO LENGTH(grid) - 1 DO\n            -- descending sort rewritten by insertion of swap passes --\n            SET arr TO grid[idx]\n            SET len_arr TO LENGTH(arr)\n            SET outer TO 1\n            WHILE outer < len_arr DO\n                SET inner TO outer\n                WHILE inner > 0 AND arr[inner] > arr[inner - 1] DO\n                    SET temp TO arr[inner]\n                    SET arr[inner] TO arr[inner - 1]\n                    SET arr[inner - 1] TO temp\n                    SET inner TO inner - 1\n                END WHILE\n                SET outer TO outer + 1\n            END WHILE\n        END FOR\n\n        SET max_sum TO 0\n        CALL backtrack(0, EMPTY_SET, 0)\n        RETURN max_sum\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximum-xor-score-subarray-queries", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maximumSubarrayXor(nums PARAMETER, queries PARAMETER)\n        SET lengthVar TO (LENGTH OF nums)\n        DEFINE helperCreateMatrix(size)\n            SET outerIndex TO 0\n            SET matrix TO empty list\n            WHILE outerIndex LESS THAN size\n                SET innerIndex TO 0\n                SET innerList TO empty list\n                WHILE innerIndex LESS THAN size\n                    APPEND 0 TO innerList\n                    SET innerIndex TO innerIndex PLUS 1\n                END WHILE\n                APPEND innerList TO matrix\n                SET outerIndex TO outerIndex PLUS 1\n            END WHILE\n            RETURN matrix\n        END FUNCTION\n        SET firstMatrix TO helperCreateMatrix(lengthVar)\n        SET secondMatrix TO helperCreateMatrix(lengthVar)\n        SET iVar TO lengthVar MINUS 1\n        WHILE iVar GREATER OR EQUAL TO 0\n            SET firstMatrix[iVar][iVar] TO nums[iVar]\n            SET secondMatrix[iVar][iVar] TO nums[iVar]\n            SET jVar TO iVar PLUS 1\n            REPEAT\n                IF NOT (jVar LESS THAN lengthVar) THEN BREAK\n                SET tempXor1 TO firstMatrix[iVar][jVar MINUS 1]\n                SET tempXor2 TO firstMatrix[iVar PLUS 1][jVar]\n                SET firstMatrix[iVar][jVar] TO (tempXor1 XOR tempXor2)\n                SET val1 TO firstMatrix[iVar][jVar]\n                SET val2 TO secondMatrix[iVar][jVar MINUS 1]\n                SET val3 TO secondMatrix[iVar PLUS 1][jVar]\n                IF val1 GREATER OR EQUAL TO val2 THEN\n                    IF val1 GREATER OR EQUAL TO val3 THEN\n                        SET secondMatrix[iVar][jVar] TO val1\n                    ELSE\n                        SET secondMatrix[iVar][jVar] TO val3\n                    END IF\n                ELSE\n                    IF val2 GREATER OR EQUAL TO val3 THEN\n                        SET secondMatrix[iVar][jVar] TO val2\n                    ELSE\n                        SET secondMatrix[iVar][jVar] TO val3\n                    END IF\n                END IF\n                SET jVar TO jVar PLUS 1\n            UNTIL FALSE\n            SET iVar TO iVar MINUS 1\n        END WHILE\n        DEFINE makeResults(queryList)\n            SET idx1 TO 0\n            SET outputList TO empty list\n            WHILE idx1 LESS THAN (LENGTH OF queryList)\n                SET (startIdx, endIdx) TO queryList[idx1]\n                APPEND secondMatrix[startIdx][endIdx] TO outputList\n                SET idx1 TO idx1 PLUS 1\n            END WHILE\n            RETURN outputList\n        END FUNCTION\n        RETURN makeResults(queries)\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximum-total-area-occupied-by-pistons", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxArea(height positions directions)  \n        SET totalPositionsCount TO 0  \n        SET maxAreaValue TO 0  \n        SET indexCounter TO 0  \n        WHILE indexCounter LESS THAN THE LENGTH OF positions  \n            SET totalPositionsCount TO totalPositionsCount PLUS positions[indexCounter]  \n            INCREMENT indexCounter BY 1  \n        END WHILE  \n        SET maxAreaValue TO totalPositionsCount  \n        \n        SET timeStep TO 1  \n        WHILE timeStep LESS THAN OR EQUAL TO height TIMES 2  \n            SET posIndex TO 0  \n            WHILE posIndex LESS THAN THE LENGTH OF positions  \n                IF positions[posIndex] EQUALS 0 AND directions[posIndex] EQUALS 'D'  \n                    SET directions TO CONCAT(SUBSTRING(directions, 0, posIndex), 'U', SUBSTRING(directions, posIndex + 1))  \n                ELSE  \n                    IF positions[posIndex] EQUALS height AND directions[posIndex] EQUALS 'U'  \n                        SET directions TO CONCAT(SUBSTRING(directions, 0, posIndex), 'D', SUBSTRING(directions, posIndex + 1))  \n                    END IF  \n                END IF  \n                \n                IF directions[posIndex] EQUALS 'U'  \n                    SET positions[posIndex] TO positions[posIndex] PLUS 1  \n                ELSE  \n                    SET positions[posIndex] TO positions[posIndex] MINUS 1  \n                END IF  \n                \n                SET posIndex TO posIndex PLUS 1  \n            END WHILE  \n            \n            SET currentSum TO 0  \n            SET sumCounter TO 0  \n            WHILE sumCounter LESS THAN THE LENGTH OF positions  \n                SET currentSum TO currentSum PLUS positions[sumCounter]  \n                SET sumCounter TO sumCounter PLUS 1  \n            END WHILE  \n            \n            IF maxAreaValue LESS THAN currentSum  \n                SET maxAreaValue TO currentSum  \n            END IF  \n            \n            SET timeStep TO timeStep PLUS 1  \n        END WHILE  \n        RETURN maxAreaValue  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-number-of-moves-to-kill-all-pawns", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxMoves(kx, ky, positions)\n        SET directions TO [(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2),(1,-2),(2,-1)]\n        SET pawnsSet TO empty set\n        FOR pos IN positions DO\n            ADD tuple(pos) TO pawnsSet\n        END FOR\n        SET totalPawns TO SIZE OF pawnsSet\n\n        FUNCTION dp(kx, ky, mask, isAlice)\n            IF mask == 0 THEN\n                RETURN 0\n            END IF\n\n            IF isAlice THEN\n                SET val TO 0\n            ELSE\n                SET val TO +∞\n            END IF\n\n            SET idx TO 0\n            WHILE idx < totalPawns DO\n                SET bitCheck TO mask & (1 << idx)\n                IF bitCheck != 0 THEN\n                    SET targetX TO positions[idx][0]\n                    SET targetY TO positions[idx][1]\n\n                    SET q TO [(kx, ky, 0)]\n                    SET seen TO empty set\n                    ADD (kx, ky) TO seen\n                    SET foundFlag TO False\n\n                    REPEAT\n                        IF LENGTH(q) == 0 THEN\n                            BREAK\n                        END IF\n                        SET curX, curY, steps TO q[0]\n                        REMOVE q[0]\n\n                        IF curX == targetX AND curY == targetY THEN\n                            SET foundFlag TO True\n                            BREAK\n                        END IF\n\n                        FOR deltaX, deltaY IN directions DO\n                            SET nxtX TO curX + deltaX\n                            SET nxtY TO curY + deltaY\n                            IF nxtX >= 0 AND nxtX < 50 AND nxtY >= 0 AND nxtY < 50 THEN\n                                IF (nxtX, nxtY) NOT IN seen THEN\n                                    ADD (nxtX, nxtY) TO seen\n                                    APPEND (nxtX, nxtY, steps+1) TO q\n                                END IF\n                            END IF\n                        END FOR\n                    UNTIL False\n\n                    IF foundFlag THEN\n                        SET newMask TO mask ^ (1 << idx)\n                        IF isAlice THEN\n                            SET candidate TO steps + dp(targetX, targetY, newMask, NOT isAlice)\n                            IF val < candidate THEN\n                                SET val TO candidate\n                            END IF\n                        ELSE\n                            SET candidate TO steps + dp(targetX, targetY, newMask, NOT isAlice)\n                            IF val > candidate THEN\n                                SET val TO candidate\n                            END IF\n                        END IF\n                    END IF\n                END IF\n                SET idx TO idx + 1\n            END WHILE\n\n            RETURN val\n        END FUNCTION\n\n        SET fullMask TO (1 << totalPawns) - 1\n        RETURN dp(kx, ky, fullMask, True)\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-maximum-sequence-value-of-array", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxValue(nums LIST OF INTEGER k INTEGER) RETURNS INTEGER\n        SET p TO 1\n        SET q TO 0\n        WHILE q LESS THAN 7\n            SET p TO p TIMES 2\n            SET q TO q PLUS 1\n        END WHILE\n        \n        SET r TO 0\n        SET s TO LENGTH OF nums\n\n        PROCEDURE Initialize3DBooleanArray(a REFERENCE TO BOOLEAN[][][], d1 INTEGER, d2 INTEGER, d3 INTEGER)\n            SET idx1 TO 0\n            WHILE idx1 NOT EQUAL TO d1\n                SET idx2 TO 0\n                SET a[idx1] TO EMPTY COLLECTION\n                WHILE idx2 NOT EQUAL TO d2\n                    SET idx3 TO 0\n                    SET a[idx1][idx2] TO EMPTY COLLECTION\n                    WHILE idx3 NOT EQUAL TO d3\n                        SET a[idx1][idx2][idx3] TO FALSE\n                        SET idx3 TO idx3 PLUS 1\n                    END WHILE\n                    SET idx2 TO idx2 PLUS 1\n                END WHILE\n                SET idx1 TO idx1 PLUS 1\n            END WHILE\n        END PROCEDURE\n\n        DECLARE f BOOLEAN[][][]\n        CALL Initialize3DBooleanArray(f, s PLUS 1, k PLUS 2, p)\n        SET f[0][0][0] TO TRUE\n\n        SET i TO 0\n        WHILE i LESS THAN s\n            SET j TO 0\n            WHILE j LESS THAN OR EQUAL TO k\n                SET x TO 0\n                WHILE x LESS THAN p\n                    SET index1 TO i PLUS 1\n                    SET val1 TO f[index1][j][x] OR f[i][j][x]\n                    SET f[index1][j][x] TO val1\n                    \n                    SET index2 TO j PLUS 1\n                    SET newX TO x BITWISE_OR nums[i]\n                    SET val2 TO f[index1][index2][newX] OR f[i][j][x]\n                    SET f[index1][index2][newX] TO val2\n                    SET x TO x PLUS 1\n                END WHILE\n                SET j TO j PLUS 1\n            END WHILE\n            SET i TO i PLUS 1\n        END WHILE\n\n        DECLARE g BOOLEAN[][][]\n        CALL Initialize3DBooleanArray(g, s PLUS 1, k PLUS 2, p)\n        SET g[s][0][0] TO TRUE\n\n        SET u TO s\n        WHILE u GREATER THAN 0\n            SET v TO 0\n            WHILE v LESS THAN OR EQUAL TO k\n                SET w TO 0\n                WHILE w LESS THAN p\n                    SET idx1 TO u MINUS 1\n                    SET val3 TO g[idx1][v][w] OR g[u][v][w]\n                    SET g[idx1][v][w] TO val3\n\n                    SET idx2 TO v PLUS 1\n                    SET newVal TO w BITWISE_OR nums[u MINUS 1]\n                    SET val4 TO g[idx1][idx2][newVal] OR g[u][v][w]\n                    SET g[idx1][idx2][newVal] TO val4\n                    SET w TO w PLUS 1\n                END WHILE\n                SET v TO v PLUS 1\n            END WHILE\n            SET u TO u MINUS 1\n        END WHILE\n\n        SET answer TO 0\n        SET outer IS k\n        WHILE outer LESS THAN OR EQUAL TO s MINUS k\n            SET midX TO 0\n            WHILE midX LESS THAN p\n                IF f[outer][k][midX] EQUALS TRUE\n                    SET innerY TO 0\n                    WHILE innerY LESS THAN p\n                        IF g[outer][k][innerY] EQUALS TRUE\n                            SET candidate TO midX BITWISE_XOR innerY\n                            IF candidate GREATER THAN answer\n                                SET answer TO candidate\n                            END IF\n                        END IF\n                        SET innerY TO innerY PLUS 1\n                    END WHILE\n                END IF\n                SET midX TO midX PLUS 1\n            END WHILE\n            SET outer TO outer PLUS 1\n        END WHILE\n\n        RETURN answer\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "length-of-the-longest-increasing-path", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maxPathLength(coordinates, k)\n        SET mntx TO (coordinates AT k) AT 0\n        SET nvzq TO (coordinates AT k) AT 1\n        SET tbas TO empty list\n\n        FUNCTION processLeftRecursive(cdlr, idx)\n            IF idx EQUALS LENGTH of cdlr\n                RETURN\n            END IF\n            SET avju TO cdlr AT idx\n            SET gxzo TO avju AT 0\n            SET rqln TO avju AT 1\n            IF (gxzo LESS mntx) AND (rqln LESS nvzq)\n                APPEND (gxzo, rqln) TO tbas\n            END IF\n            CALL processLeftRecursive(cdlr, idx PLUS 1)\n        END FUNCTION\n\n        CALL processLeftRecursive(coordinates, 0)\n\n        SET zxpl TO empty list\n\n        FUNCTION processRightRecursive(xvho, spfm)\n            IF spfm EQUALS LENGTH of xvho\n                RETURN\n            END IF\n            SET qniy TO xvho AT spfm\n            SET lref TO qniy AT 0\n            SET kjsd TO qniy AT 1\n            IF (lref GREATER mntx) AND (kjsd GREATER nvzq)\n                APPEND (lref, kjsd) TO zxpl\n            END IF\n            CALL processRightRecursive(xvho, spfm PLUS 1)\n        END FUNCTION\n\n        CALL processRightRecursive(coordinates, 0)\n\n        RETURN (1 PLUS self._lengthOfLIS(tbas) PLUS self._lengthOfLIS(zxpl))\n    END FUNCTION\n\n    FUNCTION _lengthOfLIS(coordinates)\n        FUNCTION comparator(a, b)\n            IF a AT 0 LESS b AT 0 RETURN -1\n            ELSE IF a AT 0 GREATER b AT 0 RETURN 1\n            ELSE \n                IF a AT 1 GREATER b AT 1 RETURN -1\n                ELSE IF a AT 1 LESS b AT 1 RETURN 1\n                ELSE RETURN 0\n            END IF\n        END FUNCTION\n        CALL coordinates.SORT_WITH_COMPARATOR(comparator)\n\n        SET lseq TO empty list\n\n        FUNCTION bisectLeft(arr, val, start, end)\n            IF start EQUALS end\n                RETURN start\n            END IF\n            SET mid TO (start PLUS end) DIVIDED BY 2\n            IF arr AT mid LESS val\n                RETURN bisectLeft(arr, val, mid PLUS 1, end)\n            ELSE\n                RETURN bisectLeft(arr, val, start, mid)\n            END IF\n        END FUNCTION\n\n        FUNCTION iterateAndProcess(lst, idx)\n            IF idx NOT LESS THAN LENGTH of lst\n                RETURN\n            END IF\n            SET item TO lst AT idx\n            SET unused TO item AT 0\n            SET wybf TO item AT 1\n\n            IF (LENGTH of lseq EQUALS 0) OR (wybf GREATER lseq AT (LENGTH of lseq MINUS 1))\n                APPEND wybf TO lseq\n            ELSE\n                SET qooe TO bisectLeft(lseq, wybf, 0, LENGTH of lseq)\n                SET lseq AT qooe TO wybf\n            END IF\n            CALL iterateAndProcess(lst, idx PLUS 1)\n        END FUNCTION\n\n        CALL iterateAndProcess(coordinates, 0)\n        RETURN LENGTH of lseq\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-substrings-that-can-be-rearranged-to-contain-a-string-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION validSubstringCount(word1, word2)\n        IMPORT Counter FROM collections\n\n        SET u23fgd TO Counter(word2)\n        SET p8njr TO Counter()\n        SET kxmec TO 0\n        SET b9uqw TO 0\n        SET lsytx TO 0\n        SET mtvfr TO 0\n\n        FUNCTION recursive_iter(owqsj)\n            IF owqsj < LENGTH(word1) THEN\n                SET mjezx TO word1[owqsj]\n                p8njr[mjezx] = (p8njr[mjezx] + 1)\n                IF (mjezx IN u23fgd) AND (p8njr[mjezx] = u23fgd[mjezx]) THEN\n                    kxmec = (kxmec + 1)\n                END IF\n\n                FUNCTION inner_while()\n                    IF (kxmec = LENGTH(u23fgd)) AND ((owqsj + 1 - lsytx) >= LENGTH(word2)) THEN\n                        mtvfr = mtvfr + (LENGTH(word1) - owqsj)\n                        SET ejrwa TO word1[lsytx]\n                        p8njr[ejrwa] = (p8njr[ejrwa] - 1)\n                        IF (ejrwa IN u23fgd) AND (p8njr[ejrwa] < u23fgd[ejrwa]) THEN\n                            kxmec = (kxmec - 1)\n                        END IF\n                        lsytx = (lsytx + 1)\n                        inner_while()\n                    END IF\n                END FUNCTION\n\n                inner_while()\n                recursive_iter(owqsj + 1)\n            END IF\n        END FUNCTION\n\n        recursive_iter(0)\n        RETURN mtvfr\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-k-th-character-in-string-game-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION kthCharacter(k param_k INTEGER, operations param_operations LIST OF INTEGER) RETURNS STRING\n        SET idx_var TO 0\n        SET acc_len TO 1\n        SET accumulator TO empty list\n\n        WHILE idx_var LESS THAN LENGTH(param_operations)\n            APPEND param_operations[idx_var] TO accumulator\n            SET temp_len TO acc_len + acc_len\n            SET acc_len TO temp_len\n            SET idx_var TO idx_var + 1\n        END WHILE\n\n        SET current_char TO 'a'\n\n        SET position TO LENGTH(accumulator) - 1\n        WHILE position GREATER THAN OR EQUAL TO 0\n            SET half_len TO acc_len / 2\n            IF param_k GREATER THAN half_len THEN\n                SET param_k TO param_k - half_len\n                SET acc_len TO half_len\n                IF accumulator[position] EQUALS 1 THEN\n                    IF current_char EQUALS 'z' THEN\n                        SET current_char TO 'a'\n                    ELSE\n                        SET current_char TO CHARACTER(ASCII(current_char) + 1)\n                    END IF\n                END IF\n            ELSE\n                SET acc_len TO half_len\n            END IF\n            SET position TO position - 1\n        END WHILE\n\n        RETURN current_char\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "sorted-gcd-pair-queries", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION gcdValues(nums, queries)  \n        SET highest TO 0  \n        FOR idx FROM 1 TO LENGTH(nums)  \n            IF nums[idx] > highest THEN  \n                SET highest TO nums[idx]  \n            END IF  \n        END FOR  \n  \n        SET accumulator TO EMPTY MAP  \n        FOR pos FROM 1 TO LENGTH(nums)  \n            IF accumulator HAS KEY nums[pos] THEN  \n                SET accumulator[nums[pos]] TO accumulator[nums[pos]] + 1  \n            ELSE  \n                SET accumulator[nums[pos]] TO 1  \n            END IF  \n        END FOR  \n  \n        SET distribution TO NEW LIST OF ZEROS OF SIZE highest + 1  \n  \n        SET k TO highest  \n        WHILE k >= 1 DO  \n            SET tempVar TO 0  \n            SET m TO k  \n            WHILE m <= highest DO  \n                IF accumulator HAS KEY m THEN  \n                    SET tempVar TO tempVar + accumulator[m]  \n                END IF  \n                SET distribution[k] TO distribution[k] - distribution[m]  \n                SET m TO m + k  \n            END WHILE  \n            SET distribution[k] TO distribution[k] + tempVar * (tempVar - 1) / 2  \n            SET k TO k - 1  \n        END WHILE  \n  \n        SET prefixSum TO NEW LIST OF ZEROS OF SIZE highest + 1  \n        SET prefixSum[0] TO distribution[0]  \n        SET index TO 1  \n        WHILE index <= highest DO  \n            SET prefixSum[index] TO prefixSum[index - 1] + distribution[index]  \n            SET index TO index + 1  \n        END WHILE  \n  \n        SET output TO EMPTY LIST  \n        FOR elt IN queries DO  \n            SET low TO 0  \n            SET high TO LENGTH(prefixSum)  \n            WHILE low < high DO  \n                SET middle TO (low + high) / 2  \n                IF prefixSum[middle] <= elt THEN  \n                    SET low TO middle + 1  \n                ELSE  \n                    SET high TO middle  \n                END IF  \n            END WHILE  \n            APPEND low TO output  \n        END FOR  \n  \n        RETURN output  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-last-marked-nodes-in-tree", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution  \n    FUNCTION lastMarkedNodes(edges)  \n        FUNCTION Wzpgq(ex, qzj, gu)  \n            FUNCTION Uwbyk(zsn)  \n                IF zsn IS GREATER THAN OR EQUAL TO LENGTH OF g[zsn]  \n                    RETURN  \n                END IF  \n                SET sfgjk TO g[zsn][zsn]  \n                IF sfgjk IS NOT EQUAL TO qzj  \n                    SET gu[sfgjk] TO gu[zsn] + (1 * 1)  \n                    CALL Wzpgq(sfgjk, qzj, gu)  \n                END IF  \n                CALL Uwbyk(zsn + 1)  \n            END FUNCTION  \n            CALL Uwbyk(0)  \n        END FUNCTION  \n\n        SET tcldvn TO (LENGTH OF edges) + 1  \n        SET g TO NEW LIST  \n        FUNCTION xvgmv(n)  \n            IF n IS GREATER THAN EQUAL TO tcldvn  \n                RETURN  \n            END IF  \n            APPEND EMPTY LIST TO g  \n            CALL xvgmv(n + 1)  \n        END FUNCTION  \n        CALL xvgmv(0)  \n\n        FUNCTION ysfnp(zi)  \n            IF zi IS GREATER THAN OR EQUAL TO LENGTH OF edges  \n                RETURN  \n            END IF  \n            SET u TO edges[zi][0]  \n            SET wq TO edges[zi][1]  \n            APPEND wq TO g[u]  \n            APPEND u TO g[wq]  \n            CALL ysfnp(zi + 1)  \n        END FUNCTION  \n        CALL ysfnp(0)  \n\n        SET iqlx TO NEW LIST  \n        FUNCTION hquest(nk)  \n            IF nk IS GREATER THAN OR EQUAL TO tcldvn  \n                RETURN  \n            END IF  \n            APPEND (-1) TO iqlx  \n            CALL hquest(nk + 1)  \n        END FUNCTION  \n        CALL hquest(0)  \n\n        SET iqlx[0] TO (+0)  \n        CALL Wzpgq(0, (-1), iqlx)  \n\n        FUNCTION pficz()  \n            SET maxValue TO iqlx[0]  \n            SET maxIndex TO 0  \n            FUNCTION crba(jx)  \n                IF jx IS GREATER THAN OR EQUAL TO tcldvn  \n                    RETURN  \n                END IF  \n                IF iqlx[jx] > maxValue  \n                    SET maxValue TO iqlx[jx]  \n                    SET maxIndex TO jx  \n                END IF  \n                CALL crba(jx + 1)  \n            END FUNCTION  \n            CALL crba(1)  \n            RETURN maxIndex  \n        END FUNCTION  \n        SET a TO pficz()  \n\n        SET xlbnk TO NEW LIST  \n        FUNCTION wlobz(jt)  \n            IF jt IS GREATER THAN OR EQUAL TO tcldvn  \n                RETURN  \n            END IF  \n            APPEND (-1) TO xlbnk  \n            CALL wlobz(jt + 1)  \n        END FUNCTION  \n        CALL wlobz(0)  \n\n        SET xlbnk[a] TO 0  \n        CALL Wzpgq(a, -1, xlbnk)  \n\n        FUNCTION yukpl()  \n            SET mx TO xlbnk[0]  \n            SET mi TO 0  \n            FUNCTION mncxr(zj)  \n                IF zj IS GREATER THAN OR EQUAL TO tcldvn  \n                    RETURN  \n                END IF  \n                IF xlbnk[zj] > mx  \n                    SET mx TO xlbnk[zj]  \n                    SET mi TO zj  \n                END IF  \n                CALL mncxr(zj + 1)  \n            END FUNCTION  \n            CALL mncxr(1)  \n            RETURN mi  \n        END FUNCTION  \n        SET b TO yukpl()  \n\n        SET hroc TO NEW LIST  \n        FUNCTION mavwo(al)  \n            IF al IS GREATER THAN OR EQUAL TO tcldvn  \n                RETURN  \n            END IF  \n            APPEND (-1) TO hroc  \n            CALL mavwo(al + 1)  \n        END FUNCTION  \n        CALL mavwo(0)  \n\n        SET hroc[b] TO 0  \n        CALL Wzpgq(b, -1, hroc)  \n\n        SET drecl TO NEW LIST  \n        FUNCTION vtazw()  \n            IF LENGTH OF xlbnk IS 0  \n                RETURN  \n            END IF  \n            APPEND 0 TO drecl  \n            RETURN  \n        END FUNCTION  \n        CALL vtazw()  \n\n        SET ksy TO 0\n        FUNCTION pvzaw(idx)  \n            IF idx IS GREATER THAN OR EQUAL TO tcldvn  \n                RETURN  \n            END IF  \n            SET dxjg TO xlbnk[idx]  \n            SET reowr TO hroc[idx]  \n            IF dxjg > reowr  \n                APPEND a TO drecl  \n            ELSE  \n                APPEND b TO drecl  \n            END IF  \n            CALL pvzaw(idx + 1)  \n        END FUNCTION  \n        SET drecl TO EMPTY LIST  \n        CALL pvzaw(0)  \n\n        RETURN drecl  \n    END FUNCTION  \nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-number-of-possible-ways-for-an-event", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION numberOfWays(n integer parameter, x integer parameter, y integer parameter) RETURNS integer\n        DEFINE constantLimit AS 1000000000 PLUS 7\n        INITIALIZE matrixVar AS a list containing (n PLUS 1) elements where each element is a list of (x PLUS 1) zeros\n        SET element at position zero in matrixVar at index zero TO (1)\n        \n        SET alpha TO 1\n        WHILE alpha IS LESS THAN OR EQUAL TO n DO\n            SET beta TO 1\n            WHILE beta IS LESS THAN OR EQUAL TO x DO\n                LET firstTerm BE matrixVar AT position (alpha MINUS 1) AT beta MULTIPLIED BY beta\n                LET secondTerm BE matrixVar AT position (alpha MINUS 1) AT (beta MINUS 1) MULTIPLIED BY (x MINUS (beta MINUS 1))\n                LET combinedSum BE firstTerm PLUS secondTerm\n                LET updatedValue BE combinedSum MODULO constantLimit\n                SET matrixVar AT alpha AT beta TO updatedValue\n                INCREMENT beta BY 1\n            END WHILE\n            INCREMENT alpha BY 1\n        END WHILE\n\n        SET aggregateResult TO 0\n        SET progressivePower TO 1\n        SET counterVar TO 1\n        REPEAT\n            SET progressivePower TO (progressivePower MULTIPLIED BY y) MODULO constantLimit\n            LET contributionValue BE (matrixVar AT n AT counterVar) MULTIPLIED BY progressivePower\n            SET aggregateResult TO (aggregateResult PLUS contributionValue) MODULO constantLimit\n            INCREMENT counterVar BY 1\n        UNTIL counterVar GREATER THAN x\n\n        RETURN aggregateResult\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-the-number-of-winning-sequences", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countWinningSequences(s)\n        FUNCTION helperAlpha(a, b)\n            IF b NOT EQUALS a THEN\n                IF a LESS THAN b THEN\n                    IF NOT (a NOT EQUALS zero OR b NOT EQUALS two) THEN\n                        RETURN 1 * 1\n                    END IF\n                    RETURN 0 - 1\n                ELSE\n                    IF a NOT EQUALS two OR b NOT EQUALS zero THEN\n                        RETURN 1\n                    ELSE\n                        RETURN 0 - 1\n                    END IF\n                END IF\n            END IF\n            RETURN zero + zero\n        END FUNCTION\n\n        FUNCTION searchBeta(m, n, o)\n            IF (SIZE OF s - m) <= n THEN RETURN zero END IF\n            IF m >= SIZE OF s THEN\n                IF n < zero THEN RETURN 1 ELSE RETURN 0 END IF\n            END IF\n\n            VAR accumulator IS zero\n            VAR idx IS zero\n            WHILE idx <= 2\n                IF idx = o THEN\n                    SET idx TO idx + 1\n                    CONTINUE\n                END IF\n                VAR calcResult = searchBeta(m + 1, n + helperAlpha(d[s[m]], idx), idx)\n                SET accumulator TO (accumulator + calcResult) MOD modValue\n                SET idx TO idx + 1\n            END WHILE\n            RETURN accumulator\n        END FUNCTION\n\n        VAR modValue IS (10 * 100000000) + 7\n        VAR d IS MAP WITH keys 'F' => zero, 'W' => 1, 'E' => 2\n        VAR result IS searchBeta(zero, zero, -1)\n        CALL dfs cache clear method\n        RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "count-substrings-with-k-frequency-characters-ii", "label": "true_positive", "pseudocode": "```  \nCLASS Solution\n    FUNCTION numberOfSubstrings(s parameter, k parameter)\n        FUNCTION helperExistsThreshold(mapping_a)\n            FUNCTION checkThreshold(key_b)\n                RETURN NOT (mapping_a[key_b] < k)\n            END FUNCTION\n\n            SET keysToInspect TO list of all keys in mapping_a\n            FUNCTION iterateKeys(index_c, total_d)\n                IF index_c < total_d THEN\n                    IF checkThreshold(keysToInspect[index_c]) THEN RETURN true ELSE RETURN iterateKeys(index_c + 1, total_d)\n                    END IF\n                ELSE\n                    RETURN false\n                END IF\n            END FUNCTION\n\n            RETURN iterateKeys(0, LENGTH(keysToInspect))\n        END FUNCTION\n\n        SET mapCount TO empty mapping\n        SET resultSum TO 0\n        SET idxLeft TO 0\n\n        FUNCTION loopRight(indexRight)\n            IF indexRight >= LENGTH(s) THEN RETURN\n\n            SET charAtRight TO s[indexRight]\n            IF charAtRight IS IN mapCount THEN\n                SET mapCount[charAtRight] TO mapCount[charAtRight] + (1 * 1)\n            ELSE\n                SET mapCount[charAtRight] TO (1 + 0)\n            END IF\n\n            FUNCTION innerWhile()\n                IF helperExistsThreshold(mapCount) THEN\n                    SET charAtLeft TO s[idxLeft]\n                    SET mapCount[charAtLeft] TO mapCount[charAtLeft] + (-1)\n                    IF mapCount[charAtLeft] = (0 * 0) THEN\n                        REMOVE charAtLeft FROM mapCount\n                    END IF\n                    SET idxLeft TO idxLeft + 1\n                    innerWhile()\n                END IF\n            END FUNCTION\n\n            innerWhile()\n            SET resultSum TO resultSum + idxLeft\n\n            loopRight(indexRight + 1)\n        END FUNCTION\n\n        loopRight(0)\n        RETURN resultSum\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-number-of-subsequences-with-equal-gcd", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION subsequencePairCount(nums)\n        SET N TO 1000000007\n        SET M TO 0\n        FOR I FROM 0 TO LENGTH(nums) - 1 STEP 1\n            IF nums[I] > M THEN\n                SET M TO nums[I]\n            END IF\n        END FOR\n\n        FUNCTION createMatrix(a, b)\n            SET matrix TO []\n            FOR u FROM 0 TO a DO\n                SET row TO []\n                FOR v FROM 0 TO b DO\n                    APPEND row, 0\n                END FOR\n                APPEND matrix, row\n            END FOR\n            RETURN matrix\n        END FUNCTION\n\n        SET D TO createMatrix(M, M)\n        SET D[0][0] TO 1\n\n        FUNCTION gcd(p, q)\n            WHILE q != 0 DO\n                SET r TO p % q\n                SET p TO q\n                SET q TO r\n            END WHILE\n            RETURN p\n        END FUNCTION\n\n        FOR index FROM 0 TO LENGTH(nums) - 1\n            SET tempDP TO createMatrix(M, M)\n            FOR X_VAR FROM 0 TO M DO\n                FOR Y_VAR FROM 0 TO M DO\n                    SET val TO D[X_VAR][Y_VAR]\n                    SET tempDP[X_VAR][Y_VAR] TO (tempDP[X_VAR][Y_VAR] + val) % N\n\n                    SET newXVal TO gcd(X_VAR, nums[index])\n                    SET tempDP[newXVal][Y_VAR] TO (tempDP[newXVal][Y_VAR] + val) % N\n\n                    SET newYVal TO gcd(Y_VAR, nums[index])\n                    SET tempDP[X_VAR][newYVal] TO (tempDP[X_VAR][newYVal] + val) % N\n                END FOR\n            END FOR\n            SET D TO tempDP\n        END FOR\n\n        SET FINAL_RESULT TO 0\n        FOR G_VAR FROM 1 TO M DO\n            SET FINAL_RESULT TO FINAL_RESULT + D[G_VAR][G_VAR]\n        END FOR\n        SET FINAL_RESULT TO FINAL_RESULT % N\n        RETURN FINAL_RESULT\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "count-number-of-balanced-permutations", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countBalancedPermutations(num)\n        SET dupoxtiqka TO num\n\n        FUNCTION dfs(u, v, w, x)\n            IF u > 9 THEN\n                RETURN (v OR w OR x) == 0\n            END IF\n            IF w == 0 AND v != 0 THEN\n                RETURN 0\n            END IF\n            SET ygvarob TO 0\n            SET riw AS 0\n            WHILE riw <= cnt[u] AND riw <= w\n                SET ezh TO cnt[u] - riw\n                IF ezh >= 0 AND ezh <= x AND riw * u <= v THEN\n                    SET tpzo TO comb(w, riw) * comb(x, ezh) * dfs(u + 1, v - riw * u, w - riw, x - ezh)\n                    SET ygvarob TO ygvarob + tpzo\n                END IF\n                SET riw TO riw + 1\n            END WHILE\n            RETURN ygvarob MOD mod\n        END FUNCTION\n\n        FUNCTION comb(a, b)\n            IF b == 0 OR b == a THEN\n                RETURN 1\n            END IF\n            SET c1 TO 1\n            SET c2 TO 1\n            SET idx TO 1\n            WHILE idx <= b\n                SET c1 TO c1 * (a - idx + 1)\n                SET c2 TO c2 * idx\n                SET idx TO idx + 1\n            END WHILE\n            RETURN c1 / c2\n        END FUNCTION\n\n        SET kturossi TO []\n        FOR celchar IN dupoxtiqka\n            SET kturossi APPEND TO INTEGER(celchar)\n        END FOR\n\n        SET ghum TO 0\n        FOR el IN kturossi\n            SET ghum TO ghum + el\n        END FOR\n\n        IF (ghum MOD 2) != 0 THEN\n            RETURN 0\n        END IF\n\n        SET gzak TO LENGTH(kturossi)\n        SET mod TO (10 ^ 9) + 7\n\n        SET cnt TO EMPTY MAP\n        FOR val IN kturossi\n            IF val NOT IN cnt THEN\n                SET cnt[val] TO 0\n            END IF\n            SET cnt[val] TO cnt[val] + 1\n        END FOR\n\n        RETURN dfs(0, ghum / 2, gzak / 2, (gzak + 1) / 2)\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximum-frequency-of-an-element-after-performing-operations-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxFrequency(nums, k, numOperations)\n        DEFINE FUNCTION replicateDefaultDict()\n            ASSIGN tempMap TO empty map\n            RETURN tempMap\n        END FUNCTION\n\n        ASSIGN A TO replicateDefaultDict()\n        ASSIGN B TO replicateDefaultDict()\n\n        FOR index REMAINS 0 UNTIL LENGTH(nums) - 1\n            ASSIGN val TO nums[index]\n            IF A[val] DOES NOT EXIST THEN\n                ASSIGN A[val] TO 0\n            END IF\n            A[val] = A[val] + 1\n\n            IF B[val] DOES NOT EXIST THEN\n                ASSIGN B[val] TO 0\n            END IF\n            B[val] = B[val] + 0\n\n            ASSIGN key1 TO val - k\n            IF B[key1] DOES NOT EXIST THEN\n                ASSIGN B[key1] TO 0\n            END IF\n            B[key1] = B[key1] + 1\n\n            ASSIGN key2 TO val + k + 1\n            IF B[key2] DOES NOT EXIST THEN\n                ASSIGN B[key2] TO 0\n            END IF\n            B[key2] = B[key2] - 1\n        END FOR\n\n        ASSIGN maximumFrequency TO 0\n        ASSIGN runningSum TO 0\n\n        ASSIGN sortedKeys TO EMPTY LIST\n        FOR EACH key IN B\n            APPEND key TO sortedKeys\n        END FOR\n        CALL SORT sortedKeys BY ASCENDING\n\n        ASSIGN pos TO 0\n        WHILE pos < LENGTH(sortedKeys)\n            ASSIGN currentKey TO sortedKeys[pos]\n            runningSum = runningSum + B[currentKey]\n\n            ASSIGN candidateFrequency TO numOperations + A[currentKey]\n            IF runningSum < candidateFrequency THEN\n                IF maximumFrequency < runningSum THEN\n                    maximumFrequency = runningSum\n                END IF\n            ELSE\n                IF maximumFrequency < candidateFrequency THEN\n                    maximumFrequency = candidateFrequency\n                END IF\n            END IF\n            pos = pos + 1\n        END WHILE\n\n        RETURN maximumFrequency\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "smallest-divisible-digit-product-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION smallestNumber(num, t)  \n        primeCount, isDivisible <- self._getPrimeCount(t)  \n        IF isDivisible IS FALSE THEN  \n            RETURN \"-1\"  \n        END IF  \n\n        factorCount <- self._getFactorCount(primeCount)  \n        totalFactors <- SUM of all values in factorCount  \n        IF totalFactors > LENGTH(num) THEN  \n            resultStr <- EMPTY STRING  \n            FOR digit, freq IN factorCount ITEMS  \n                APPEND digit REPEATED freq TIMES TO resultStr  \n            END FOR  \n            RETURN resultStr  \n        END IF  \n\n        primeCountPrefix <- Counter()  \n        FOR char IN num DO  \n            primeCountPrefix <- primeCountPrefix + FACTOR_COUNTS(INT(char))  \n        END FOR  \n\n        firstZeroIndex <- LENGTH(num)  \n        FOR i FROM 0 TO LENGTH(num)-1 DO  \n            IF num[i] = '0' THEN  \n                firstZeroIndex <- i  \n                BREAK  \n            END IF  \n        END FOR  \n\n        IF firstZeroIndex = LENGTH(num) AND primeCount <= primeCountPrefix THEN  \n            RETURN num  \n        END IF  \n\n        FOR i, c IN ENUMERATE(num) IN REVERSE ORDER DO  \n            d <- INT(c)  \n            primeCountPrefix <- primeCountPrefix - FACTOR_COUNTS(d)  \n            spaceAfter <- LENGTH(num) - 1 - i  \n\n            IF i <= firstZeroIndex THEN  \n                FOR biggerDigit FROM d+1 TO 9 DO  \n                    factorsAfter <- self._getFactorCount(primeCount - primeCountPrefix - FACTOR_COUNTS(biggerDigit))  \n                    IF SUM of values in factorsAfter <= spaceAfter THEN  \n                        fillOnes <- spaceAfter - SUM of values in factorsAfter  \n                        prefix <- SUBSTRING(num, 0, i)  \n                        suffix <- \"\"  \n                        FOR digit, freq IN factorsAfter ITEMS  \n                            suffix <- suffix + (digit REPEATED freq TIMES)  \n                        END FOR  \n                        RETURN prefix + STRING(biggerDigit) + ('1' REPEATED fillOnes TIMES) + suffix  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n\n        factorCount <- self._getFactorCount(primeCount)  \n        onesCount <- LENGTH(num) + 1 - SUM of values in factorCount  \n        result <- ('1' REPEATED onesCount TIMES)  \n        FOR digit, freq IN factorCount ITEMS  \n            result <- result + (digit REPEATED freq TIMES)  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \n\n    FUNCTION _getPrimeCount(t)  \n        count <- Counter()  \n        FOR prime IN [2, 3, 5, 7] DO  \n            WHILE t MOD prime = 0 DO  \n                t <- t DIV prime  \n                count[prime] <- count[prime] + 1  \n            END WHILE  \n        END FOR  \n        RETURN count, (t = 1)  \n    END FUNCTION  \n\n    FUNCTION _getFactorCount(count)  \n        count8, rem2 <- DIVMOD(count[2], 3)  \n        count9, count3 <- DIVMOD(count[3], 2)  \n        count4, count2 <- DIVMOD(rem2, 2)  \n\n        count6 <- 0  \n        IF count2 = 1 AND count3 = 1 THEN  \n            count2 <- 0  \n            count3 <- 0  \n            count6 <- 1  \n        END IF  \n\n        IF count3 = 1 AND count4 = 1 THEN  \n            count2 <- 1  \n            count6 <- 1  \n            count3 <- 0  \n            count4 <- 0  \n        END IF  \n\n        RETURN Counter({  \n            '2': count2,  \n            '3': count3,  \n            '4': count4,  \n            '5': count[5],  \n            '6': count6,  \n            '7': count[7],  \n            '8': count8,  \n            '9': count9  \n        })  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-good-subsequences", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION sumOfGoodSubsequences(nums)\n        SET Alpha TO 1000000000 PLUS 7\n        ASSIGN Beta TO a map returning zero by default\n        ASSIGN Gamma TO a map returning zero by default\n\n        FUNCTION Omega(Delta)\n            IF Delta GREATER THAN LENGTH(nums) MINUS 1 THEN\n                RETURN\n            END IF\n            SET Epsilon TO nums[Delta]\n            Gamma[Epsilon] = Gamma[Epsilon] PLUS 1\n            Beta[Epsilon] = Beta[Epsilon] PLUS Epsilon\n\n            Beta[Epsilon] = (Beta[Epsilon] PLUS Beta[Epsilon MINUS 1] PLUS (Gamma[Epsilon MINUS 1] MULTIPLY Epsilon)) MOD Alpha\n            Gamma[Epsilon] = (Gamma[Epsilon] PLUS Gamma[Epsilon MINUS 1]) MOD Alpha\n\n            Beta[Epsilon] = (Beta[Epsilon] PLUS Beta[Epsilon PLUS 1] PLUS (Gamma[Epsilon PLUS 1] MULTIPLY Epsilon)) MOD Alpha\n            Gamma[Epsilon] = (Gamma[Epsilon] PLUS Gamma[Epsilon PLUS 1]) MOD Alpha\n\n            CALL Omega(Delta PLUS 1)\n        END FUNCTION\n\n        CALL Omega(0)\n\n        SET Xi TO 0\n        FUNCTION IterateValues(ValuesList, Index)\n            IF Index EQUALS LENGTH(ValuesList) THEN\n                RETURN\n            END IF\n            SET Theta TO ValuesList[Index]\n            Xi = Xi PLUS Theta\n            CALL IterateValues(ValuesList, Index PLUS 1)\n        END FUNCTION\n\n        CALL IterateValues(Beta.values(), 0)\n\n        RETURN Xi MOD Alpha\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-maximum-number-of-fruits-collected", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n\tFUNCTION maxCollectedFruits(fruits)\n\t\tSET M TO (LENGTH OF fruits)\n\t\t\n\t\tSET V0 TO [[1,1], [1,0]]\n\t\tSET V1 TO [[1,0], [1,-1], [1,1]]\n\t\tSET V2 TO [[-1,1], [0,1], [1,1]]\n\t\t\n\t\tSET Cache TO {}\n\t\t\n\t\tFUNCTION Explore(a0, b0, a1, b1, a2, b2)\n\t\t\t\n\t\t\tFUNCTION BoundCheck(p, q)\n\t\t\t\tRETURN NOT(0 <= p AND p < M AND 0 <= q AND q < M)\n\t\t\tEND FUNCTION\n\t\t\t\n\t\t\tIF BoundCheck(a0, b0) OR BoundCheck(a1, b1) OR BoundCheck(a2, b2) THEN\n\t\t\t\tRETURN - (2 ^ 31)\n\t\t\tEND IF\n\t\t\t\n\t\t\tIF a0 = b0 AND b0 = a1 AND a1 = b1 AND b1 = a2 AND a2 = b2 AND b2 = M - 1 THEN\n\t\t\t\tRETURN (fruits[(M - 1)][(M - 1)])\n\t\t\tEND IF\n\t\t\t\t\t\n\t\t\tSET Key TO (a0, b0, a1, b1, a2, b2)\n\t\t\tIF Key IN Cache THEN\n\t\t\t\tRETURN Cache[Key]\n\t\t\tEND IF\n\t\t\t\n\t\t\tSET Tally TO (fruits[a0][b0])\n\t\t\tIF (a0 = a1 AND b0 = b1) OR (a0 = a2 AND b0 = b2) THEN\n\t\t\t\tSET Tally TO 0\n\t\t\tEND IF\n\t\t\t\n\t\t\tIF a1 = a2 AND b1 = b2 THEN\n\t\t\t\tSET Tally TO Tally + fruits[a1][b1]\n\t\t\tELSE\n\t\t\t\tSET Tally TO (((Tally + fruits[a1][b1]) + fruits[a2][b2]))\n\t\t\tEND IF\n\t\t\t\t\t\t\t\n\t\t\tSET MaxCollect TO - (2 ^ 31)\n\t\t\tSET i0 TO 0\n\t\t\t\n\t\t\tFUNCTION NextDir0()\n\t\t\t\tIF i0 >= LENGTH(V0) THEN\n\t\t\t\t\tRETURN MaxCollect\n\t\t\t\tEND IF\n\t\t\t\t\n\t\t\t\tSET dX0 TO V0[i0][0]\n\t\t\t\tSET dY0 TO V0[i0][1]\n\t\t\t\tSET i1 TO 0\n\t\t\t\t\n\t\t\t\tFUNCTION NextDir1()\n\t\t\t\t\tIF i1 >= LENGTH(V1) THEN\n\t\t\t\t\t\tSET i0 TO i0 + 1\n\t\t\t\t\t\tRETURN NextDir0()\n\t\t\t\t\tEND IF\n\t\t\t\t\t\n\t\t\t\t\tSET dX1 TO V1[i1][0]\n\t\t\t\t\tSET dY1 TO V1[i1][1]\n\t\t\t\t\tSET i2 TO 0\n\t\t\t\t\t\n\t\t\t\t\tFUNCTION NextDir2()\n\t\t\t\t\t\tIF i2 >= LENGTH(V2) THEN\n\t\t\t\t\t\t\tSET i1 TO i1 + 1\n\t\t\t\t\t\t\tRETURN NextDir1()\n\t\t\t\t\t\tEND IF\n\t\t\t\t\t\t\n\t\t\t\t\t\tSET dX2 TO V2[i2][0]\n\t\t\t\t\t\tSET dY2 TO V2[i2][1]\n\t\t\t\t\t\t\n\t\t\t\t\t\tSET Candidate TO Explore(a0 + dX0, b0 + dY0, a1 + dX1, b1 + dY1, a2 + dX2, b2 + dY2)\n\t\t\t\t\t\tIF Candidate > MaxCollect THEN\n\t\t\t\t\t\t\tSET MaxCollect TO Candidate\n\t\t\t\t\t\tEND IF\n\t\t\t\t\t\t\n\t\t\t\t\t\tSET i2 TO i2 + 1\n\t\t\t\t\t\tRETURN NextDir2()\n\t\t\t\t\tEND FUNCTION\n\t\t\t\t\t\n\t\t\t\t\tRETURN NextDir2()\n\t\t\t\tEND FUNCTION\n\t\t\t\t\n\t\t\t\tRETURN NextDir1()\n\t\t\tEND FUNCTION\n\t\t\t\n\t\t\tSET MaxCollect TO NextDir0()\n\t\t\t\n\t\t\tCACHE[Key] = Tally + MaxCollect\n\t\t\tRETURN Tally + MaxCollect\n\t\tEND FUNCTION\n\t\t\n\t\tRETURN Explore(0, 0, 0, M - 1, M - 1, 0)\n\tEND FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "maximize-sum-of-weights-after-edge-removals", "label": "true_positive", "pseudocode": "```  \nCLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        FUNCTION build_parent_list(idx, limit, acc)  \n            IF idx GREATER THAN limit  \n                RETURN acc  \n            ELSE  \n                RETURN build_parent_list(idx + (1), limit, acc + [idx])  \n            END IF  \n        END FUNCTION  \n        \n        SET temp_parent TO build_parent_list(0, size - 1, [])  \n        SET result_rank TO []  \n        FUNCTION generate_zeros(count, acc2)  \n            IF count EQUALS 0  \n                RETURN acc2  \n            ELSE  \n                RETURN generate_zeros(count - 1, acc2 + [0])  \n            END IF  \n        END FUNCTION  \n        SET temp_rank TO generate_zeros(size, [])  \n        \n        SET self.parent TO temp_parent  \n        SET self.rank TO temp_rank  \n    END FUNCTION  \n  \n    FUNCTION find(self, u)  \n        FUNCTION find_recursive(x)  \n            IF self.parent[x] NOT_EQUALS x  \n                SET self.parent[x] TO find_recursive(self.parent[x])  \n            END IF  \n            RETURN self.parent[x]  \n        END FUNCTION  \n        RETURN find_recursive(u)  \n    END FUNCTION  \n  \n    FUNCTION union(self, u, v)  \n        SET a TO self.find(u)  \n        SET b TO self.find(v)  \n        \n        IF a NOT_EQUALS b  \n            IF self.rank[a] GREATER THAN self.rank[b]  \n                SET self.parent[b] TO a  \n            ELSE  \n                IF (self.rank[a] LESS_THAN self.rank[b])  \n                    SET self.parent[a] TO b  \n                ELSE  \n                    SET self.parent[b] TO a  \n                    SET self.rank[a] TO self.rank[a] + (1)  \n                END IF  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION maximizeSumOfWeights(self, edges, k)  \n        SET length_n TO (len(edges) + (1))  \n        \n        FUNCTION zeros_list_generator(x, result_collection)  \n            IF x EQUALS 0  \n                RETURN result_collection  \n            ELSE  \n                RETURN zeros_list_generator(x - (1), result_collection + [0])  \n            END IF  \n        END FUNCTION  \n        \n        SET degrees_array TO zeros_list_generator(length_n, [])  \n        \n        SET uf_instance TO UnionFind(length_n)  \n        \n        FUNCTION descending_weight_key(edge_item)  \n            RETURN (-1) * (edge_item[2])  \n        END FUNCTION  \n        SET temp_edges TO edges  \n        SET sorted_edges TO []  \n        FUNCTION insert_sort_desc(lst, acc_sorted)  \n            IF lst EQUALS []  \n                RETURN acc_sorted  \n            ELSE  \n                SET current_edge TO lst[0]  \n                SET rest_edges TO lst[1:]  \n                FUNCTION insert_into_sorted(x, xs)  \n                    IF xs EQUALS []  \n                        RETURN [x]  \n                    ELSE  \n                        IF x[2] GREATER_OR_EQUAL xs[0][2]  \n                            RETURN [x] + xs  \n                        ELSE  \n                            RETURN [xs[0]] + insert_into_sorted(x, xs[1:])  \n                        END IF  \n                    END IF  \n                END FUNCTION  \n                SET new_sorted TO insert_into_sorted(current_edge, acc_sorted)  \n                RETURN insert_sort_desc(rest_edges, new_sorted)  \n            END IF  \n        END FUNCTION  \n        SET sorted_edges TO insert_sort_desc(temp_edges, [])  \n        \n        SET final_sum TO 0  \n        \n        FUNCTION process_edges_rec(edges_list, current_sum, deg_arr)  \n            IF edges_list EQUALS []  \n                RETURN current_sum  \n            ELSE  \n                SET edge_cur TO edges_list[0]  \n                SET rest_list TO edges_list[1:]  \n                SET x_val TO edge_cur[0]  \n                SET y_val TO edge_cur[1]  \n                SET weight_val TO edge_cur[2]  \n                \n                IF (deg_arr[x_val] < k) AND (deg_arr[y_val] < k) AND (uf_instance.find(x_val) NOT_EQUALS uf_instance.find(y_val))  \n                    uf_instance.union(x_val, y_val)  \n                    SET new_degs TO []  \n                    FUNCTION increment_degree(arr, idx, result_arr, max_idx)  \n                        IF idx GREATER_THAN max_idx  \n                            RETURN result_arr  \n                        ELSE  \n                            IF idx EQUALS x_val OR idx EQUALS y_val  \n                                SET result_arr TO result_arr + [arr[idx] + 1]  \n                            ELSE  \n                                SET result_arr TO result_arr + [arr[idx]]  \n                            END IF  \n                            RETURN increment_degree(arr, idx + 1, result_arr, max_idx)  \n                        END IF  \n                    END FUNCTION  \n                    SET new_degs TO increment_degree(deg_arr, 0, [], length_n - 1)  \n                    \n                    RETURN process_edges_rec(rest_list, current_sum + weight_val, new_degs)  \n                ELSE  \n                    RETURN process_edges_rec(rest_list, current_sum, deg_arr)  \n                END IF  \n            END IF  \n        END FUNCTION  \n        \n        SET max_result TO process_edges_rec(sorted_edges, final_sum, degrees_array)  \n        \n        RETURN max_result  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "maximize-the-number-of-target-nodes-after-connecting-trees-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxTargetNodes(edges1, edges2)  \n        SET connection_map_1 TO new dictionary with default value []  \n        SET connection_map_2 TO new dictionary with default value []  \n  \n        PROCEDURE build_connections(edge_list, connection_map)  \n            SET idx TO 0  \n            REPEAT  \n                IF idx EQUALS LENGTH(edge_list) THEN EXIT LOOP  \n                SET src_dest TO edge_list[idx]  \n                SET node_x TO src_dest[0]  \n                SET node_y TO src_dest[1]  \n                APPEND node_y TO connection_map[node_x]  \n                APPEND node_x TO connection_map[node_y]  \n                SET idx TO idx PLUS 1  \n            UNTIL FALSE  \n        END PROCEDURE  \n  \n        CALL build_connections(edges1, connection_map_1)  \n        CALL build_connections(edges2, connection_map_2)  \n  \n        SET size_1 TO COUNT_KEYS(connection_map_1)  \n        SET size_2 TO COUNT_KEYS(connection_map_2)  \n  \n        FUNCTION bfs(tree_structure, origin_node)  \n            SET count_even_dist TO 0  \n            SET count_odd_dist TO 0  \n            SET deque_nodes TO new deque containing (origin_node, 0)  \n            SET visited_nodes TO new set containing origin_node  \n  \n            WHILE LENGTH(deque_nodes) NOT EQUAL TO 0  \n                SET current_pair TO POP_FRONT(deque_nodes)  \n                SET current_node TO current_pair[0]  \n                SET current_distance TO current_pair[1]  \n  \n                IF current_distance MOD 2 EQUALS 0 THEN  \n                    SET count_even_dist TO count_even_dist PLUS 1  \n                ELSE  \n                    SET count_odd_dist TO count_odd_dist PLUS 1  \n                END IF  \n  \n                FOR each adj_node IN tree_structure[current_node]  \n                    IF NOT (adj_node IN visited_nodes) THEN  \n                        ADD adj_node TO visited_nodes  \n                        APPEND (adj_node, current_distance PLUS 1) TO deque_nodes  \n                    END IF  \n                END FOR  \n            END WHILE  \n  \n            RETURN count_even_dist, count_odd_dist  \n        END FUNCTION  \n  \n        SET list_even_odd_1 TO []  \n        SET index_1 TO 0  \n        WHILE index_1 LESS THAN size_1  \n            SET result_pair TO bfs(connection_map_1, index_1)  \n            APPEND result_pair TO list_even_odd_1  \n            SET index_1 TO index_1 PLUS 1  \n        END WHILE  \n  \n        SET list_even_odd_2 TO []  \n        SET index_2 TO 0  \n        WHILE index_2 LESS THAN size_2  \n            SET result_pair TO bfs(connection_map_2, index_2)  \n            APPEND result_pair TO list_even_odd_2  \n            SET index_2 TO index_2 PLUS 1  \n        END WHILE  \n  \n        SET output_accum TO []  \n  \n        FOR outer_idx FROM 0 TO size_1 MINUS 1  \n            SET counts_1 TO list_even_odd_1[outer_idx]  \n            SET even_1 TO counts_1[0]  \n            SET odd_1 TO counts_1[1]  \n  \n            SET max_found_targets TO 0  \n  \n            SET inner_idx TO 0  \n            WHILE inner_idx LESS THAN size_2  \n                SET counts_2 TO list_even_odd_2[inner_idx]  \n                SET even_2 TO counts_2[0]  \n                SET odd_2 TO counts_2[1]  \n  \n                SET condition1 TO (outer_idx EQUALS inner_idx)  \n                SET condition2 TO ((outer_idx MOD 2) EQUALS (inner_idx MOD 2))  \n  \n                IF condition1 OR condition2 THEN  \n                    SET candidate_targets TO even_2  \n                ELSE  \n                    SET candidate_targets TO odd_2  \n                END IF  \n  \n                IF candidate_targets GREATER THAN max_found_targets THEN  \n                    SET max_found_targets TO candidate_targets  \n                END IF  \n  \n                SET inner_idx TO inner_idx PLUS 1  \n            END WHILE  \n  \n            APPEND (even_1 PLUS max_found_targets) TO output_accum  \n        END FOR  \n  \n        RETURN output_accum  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-connected-components-in-lcm-graph", "label": "true_positive", "pseudocode": "CLASS DSU\n    FUNCTION __init__(self, n)\n        SET index_value TO 0\n        SET temp_map_parent TO empty mapping\n        SET temp_map_rank TO empty mapping\n        WHILE index_value LESS THAN n DO\n            SET temp_map_parent[index_value] TO index_value\n            SET temp_map_rank[index_value] TO 0\n            INCREMENT index_value BY 1\n        END WHILE\n        SET self.parent TO temp_map_parent\n        SET self.rank TO temp_map_rank\n    END FUNCTION\n\n    FUNCTION find(self, x)\n        DEFINE FUNCTION recur_find(y)\n            IF self.parent[y] EQUALS y THEN\n                RETURN y\n            ELSE\n                SET recursive_result TO recur_find(self.parent[y])\n                SET self.parent[y] TO recursive_result\n                RETURN recursive_result\n            END IF\n        END FUNCTION\n        RETURN recur_find(x)\n    END FUNCTION\n\n    FUNCTION union_set(self, u, v)\n        SET set_u TO self.find(u)\n        SET set_v TO self.find(v)\n        IF NOT (set_u EQUALS set_v) THEN\n            IF self.rank[set_u] GREATER THAN OR EQUAL TO self.rank[set_v] THEN\n                SET self.parent[set_v] TO set_u\n                IF self.rank[set_u] EQUALS self.rank[set_v] THEN\n                    SET self.rank[set_u] TO self.rank[set_u] PLUS 1\n                END IF\n            ELSE\n                SET self.parent[set_u] TO set_v\n            END IF\n        END IF\n    END FUNCTION\nEND CLASS\n\nCLASS Solution\n    FUNCTION countComponents(self, nums, threshold)\n        SET dsu_instance TO DSU(threshold PLUS 1)\n        SET _i TO 0\n        WHILE _i LESS THAN LENGTH(nums) DO\n            SET current_num TO nums[_i]\n            SET multiple_tracker TO current_num TIMES 2\n            WHILE multiple_tracker LESS THAN OR EQUAL TO threshold DO\n                CALL dsu_instance.union_set(current_num, multiple_tracker)\n                SET multiple_tracker TO multiple_tracker PLUS current_num\n            END WHILE\n            SET _i TO _i PLUS 1\n        END WHILE\n\n        SET parent_collection TO empty set\n        SET _j TO 0\n        WHILE _j LESS THAN LENGTH(nums) DO\n            SET element TO nums[_j]\n            IF element LESS THAN OR EQUAL TO threshold THEN\n                CALL parent_collection.insert(dsu_instance.find(element))\n            ELSE\n                CALL parent_collection.insert(element)\n            END IF\n            SET _j TO _j PLUS 1\n        END WHILE\n\n        RETURN SIZE(parent_collection)\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximum-area-rectangle-with-point-constraints-ii", "label": "true_positive", "pseudocode": "CLASS Fenwick  \n    FUNCTION __init__(self, n)  \n        SET tempArr TO an array filled with 0 repeated (0 + n) times  \n        SET self.tree TO tempArr  \n    END FUNCTION  \n\n    FUNCTION add(self, i)  \n        WHILE i < LENGTH(self.tree)  \n            SET self.tree[i] TO self.tree[i] + 1  \n            SET i TO i + (i BITWISE_AND (-i))  \n        END WHILE  \n    END FUNCTION  \n\n    FUNCTION pre(self, i)  \n        SET accumulator TO 0  \n        WHILE i > 0  \n            SET accumulator TO accumulator + self.tree[i]  \n            SET i TO i BITWISE_AND (i - 1)  \n        END WHILE  \n        RETURN accumulator  \n    END FUNCTION  \n\n    FUNCTION query(self, l, r)  \n        RETURN self.pre(r) - self.pre(l - 1)  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION maxRectangleArea(self, xCoord, yCoord)  \n        SET pairedList TO SORTED_LIST(zip(xCoord, yCoord))  \n        SET uniqueYs TO SORTED_SET(yCoord)  \n        SET result TO -1  \n        SET indexTree TO Fenwick(LENGTH(uniqueYs))  \n        CALL indexTree.add(BISECT_LEFT(uniqueYs, pairedList[0][1]) + 1)  \n        SET record TO {}  \n        FUNCTION processPairs(pList)  \n            IF LENGTH(pList) EQUALS 1 RETURN  \n            SET firstPair TO pList[0]  \n            SET secondPair TO pList[1]  \n            SET (xOne, yOne) TO firstPair  \n            SET (xTwo, yTwo) TO secondPair  \n            SET mappedY TO BISECT_LEFT(uniqueYs, yTwo) + 1  \n            CALL indexTree.add(mappedY)  \n            IF xOne != xTwo  \n                CALL processPairs(SLICE(pList, 1, LENGTH(pList)))  \n                RETURN  \n            END IF  \n            SET intervalSum TO indexTree.query(BISECT_LEFT(uniqueYs, yOne) + 1, mappedY)  \n            IF yTwo IN record AND record[yTwo][1] == yOne AND record[yTwo][2] + 2 == intervalSum  \n                SET candidate TO (xTwo - record[yTwo][0]) * (yTwo - yOne)  \n                SET result TO MAXIMUM(result, candidate)  \n            END IF  \n            SET record[yTwo] TO (xOne, yOne, intervalSum)  \n            CALL processPairs(SLICE(pList, 1, LENGTH(pList)))  \n        END FUNCTION  \n        CALL processPairs(pairedList)  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-runes-to-add-to-cast-spell", "label": "true_positive", "pseudocode": "``` \nCLASS Solution \n    FUNCTION minRunesToAdd(n flowFrom flowTo crystals) \n        SET a1f TO a new empty mapping from integer to list of integers \n        SET z9b TO a new empty mapping from integer to list of integers \n\n        FUNCTION u7k(x2v, y1w, r8c, p5d)\n            IF p5d LESS THAN x2v LENGTH THEN\n                SET q3e TO x2v AT INDEX p5d\n                SET t0f TO y1w AT INDEX p5d\n                IF q3e NOT IN r8c THEN\n                    SET r8c[q3e] TO an empty list\n                END IF\n                APPEND t0f TO r8c[q3e]\n\n                IF t0f NOT IN p5d THEN\n                    SET p5d[t0f] TO an empty list\n                END IF\n                APPEND q3e TO p5d[t0f]\n\n                CALL u7k(x2v, y1w, r8c, p5d, p5d + 1)\n            END IF\n        END FUNCTION\n\n        FUNCTION w3d(h6n)\n            SET z7k[h6n] TO y2g\n            SET m8l[h6n] TO y2g\n            SET y2g TO y2g + (1 + 0)\n            APPEND h6n TO v0x\n            SET o1r[h6n] TO True\n\n            FUNCTION iterateNeighbors(k9u)\n                IF k9u LESS THAN LENGTH(a1f[h6n]) THEN\n                    SET j4t TO a1f[h6n][k9u]\n                    IF z7k[j4t] EQUALS ((-1) * 1) THEN\n                        CALL w3d(j4t)\n                        IF m8l[h6n] GREATER THAN m8l[j4t] THEN\n                            SET m8l[h6n] TO m8l[j4t] + (0 * 3)\n                        END IF\n                    ELSE\n                        IF o1r[j4t] EQUALS True THEN\n                            IF m8l[h6n] GREATER THAN z7k[j4t] THEN\n                                SET m8l[h6n] TO z7k[j4t] + (0 + 0)\n                            END IF\n                        END IF\n                    END IF\n                    CALL iterateNeighbors(k9u + 1)\n                END IF\n            END FUNCTION\n            CALL iterateNeighbors(0)\n\n            IF m8l[h6n] EQUALS z7k[h6n] THEN\n                SET r2s TO an empty list\n                FUNCTION extractStack()\n                    IF LENGTH(v0x) GREATER THAN 0 THEN\n                        SET w4m TO REMOVE LAST ELEMENT FROM v0x\n                        SET o1r[w4m] TO False\n                        APPEND w4m TO r2s\n                        IF w4m NOT EQUAL h6n THEN\n                            CALL extractStack()\n                        END IF\n                    END IF\n                END FUNCTION\n                CALL extractStack()\n                APPEND r2s TO x8q\n            END IF\n        END FUNCTION\n\n        CALL u7k(flowFrom, flowTo, a1f, z9b, 0)\n\n        SET z7k TO a list of size n FILLED WITH (-1) \n        SET m8l TO a list of size n FILLED WITH (0) \n        SET o1r TO a list of size n FILLED WITH False \n        SET v0x TO an empty list \n        SET y2g TO 0 \n        SET x8q TO an empty list \n\n        FUNCTION loopI(i)\n            IF i LESS THAN n THEN\n                IF z7k[i] EQUALS (-1) THEN\n                    CALL w3d(i)\n                END IF\n                CALL loopI(i + 1)\n            END IF\n        END FUNCTION\n        CALL loopI(0)\n\n        SET s0m TO new empty mapping from integer to list of integers \n        SET c3p TO a list of size n FILLED WITH (-1) \n        SET e6z TO a list of size LENGTH(x8q) FILLED WITH False \n        SET b9u TO 0 \n\n        FUNCTION assignSCC(i)\n            IF i LESS THAN LENGTH(x8q) THEN\n                SET t5n TO x8q[i]\n                FUNCTION assignNodes(j)\n                    IF j LESS THAN LENGTH(t5n) THEN\n                        SET u7o TO t5n[j]\n                        SET c3p[u7o] TO b9u\n                        IF u7o IN crystals THEN\n                            SET e6z[i] TO True\n                        END IF\n                        CALL assignNodes(j + 1)\n                    END IF\n                END FUNCTION\n                CALL assignNodes(0)\n                SET b9u TO b9u + 1\n                CALL assignSCC(i + 1)\n            END IF\n        END FUNCTION\n        CALL assignSCC(0)\n\n        FUNCTION buildSCCGraph(k)\n            IF k LESS THAN LENGTH(flowFrom) THEN\n                SET o4v TO flowFrom[k]\n                SET d1x TO flowTo[k]\n                SET w2c TO c3p[o4v]\n                SET l7j TO c3p[d1x]\n                IF w2c NOT EQUAL l7j THEN\n                    IF NOT (w2c IN s0m) THEN\n                        SET s0m[w2c] TO an empty list\n                    END IF\n                    APPEND l7j TO s0m[w2c]\n                END IF\n                CALL buildSCCGraph(k + 1)\n            END IF\n        END FUNCTION\n        CALL buildSCCGraph(0)\n\n        SET p5y TO a list of size LENGTH(x8q) FILLED WITH 0\n\n        FUNCTION calculateIndegree(m)\n            IF m LESS THAN LENGTH(x8q) THEN\n                IF m IN s0m THEN\n                    FUNCTION processNeighbors(n)\n                        IF n LESS THAN LENGTH(s0m[m]) THEN\n                            SET z2h TO s0m[m][n]\n                            SET p5y[z2h] TO p5y[z2h] + 1\n                            CALL processNeighbors(n + 1)\n                        END IF\n                    END FUNCTION\n                    CALL processNeighbors(0)\n                END IF\n                CALL calculateIndegree(m + 1)\n            END IF\n        END FUNCTION\n        CALL calculateIndegree(0)\n\n        SET g4r TO 0\n        FUNCTION countAdditional(k1)\n            IF k1 LESS THAN LENGTH(x8q) THEN\n                IF p5y[k1] EQUALS 0 AND e6z[k1] EQUALS False THEN\n                    SET g4r TO g4r + 1\n                END IF\n                CALL countAdditional(k1 + 1)\n            END IF\n        END FUNCTION\n        CALL countAdditional(0)\n\n        RETURN g4r\n    END FUNCTION \nEND CLASS \n```", "score": 1.0}
{"task_id": "subsequences-with-a-unique-middle-mode-i", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION subsequencesWithMiddleMode(nums)\n        DECLARE magicConst AS INTEGER = 10^9 + (5 + 2)\n        DECLARE lenNums AS INTEGER = 0\n        DECLARE resultCounter AS INTEGER = 0\n\n        lenNums ← 0\n        WHILE lenNums < LENGTH(nums) DO\n            lenNums ← lenNums + 1\n        END WHILE\n\n        IF NOT (lenNums ≥ ((((2 + 2) + 1)))) THEN\n            RETURN 0\n        END IF\n\n        FUNCTION generateCombs(setList, pickCount)\n            FUNCTION helper(currIndex, chosenSoFar)\n                IF LENGTH(chosenSoFar) EQUALS pickCount THEN\n                    RETURN LIST(chosenSoFar)\n                ELSE IF currIndex EQUALS LENGTH(setList) THEN\n                    RETURN EMPTY LIST\n                ELSE\n                    DECLARE skipResults AS LIST = helper(currIndex + 1, chosenSoFar)\n                    DECLARE takeResults AS LIST = helper(currIndex + 1, chosenSoFar + [setList[currIndex]])\n                    RETURN skipResults + takeResults\n                END IF\n            END FUNCTION\n            RETURN helper(0, [])\n        END FUNCTION\n\n        DECLARE allSubseq AS LIST = generateCombs(nums, 5)\n\n        DECLARE idxOuter AS INTEGER = 0\n        resultCounter ← 0\n        WHILE idxOuter < LENGTH(allSubseq) DO\n            DECLARE freqMap AS DICTIONARY = EMPTY DICTIONARY\n            DECLARE currentSeq AS LIST = allSubseq[idxOuter]\n\n            DECLARE idxFreq AS INTEGER = 0\n            WHILE idxFreq < LENGTH(currentSeq) DO\n                DECLARE val AS INTEGER = currentSeq[idxFreq]\n                IF val IN freqMap THEN\n                    freqMap[val] ← freqMap[val] + 1\n                ELSE\n                    freqMap[val] ← 1\n                END IF\n                idxFreq ← idxFreq + 1\n            END WHILE\n\n            DECLARE medIdx AS INTEGER = 2\n            DECLARE medVal AS INTEGER = currentSeq[medIdx]\n            DECLARE medCount AS INTEGER = freqMap[medVal]\n\n            DECLARE isModeUnique AS BOOLEAN = TRUE\n            DECLARE keysList AS LIST = []\n            FOR key IN freqMap KEYS DO\n                keysList ← keysList + [key]\n            END FOR\n            DECLARE keyCursor AS INTEGER = 0\n            WHILE (keyCursor < LENGTH(keysList)) AND (isModeUnique) DO\n                DECLARE checkKey AS INTEGER = keysList[keyCursor]\n                IF (checkKey ≠ medVal) AND (freqMap[checkKey] ≥ medCount) THEN\n                    isModeUnique ← FALSE\n                END IF\n                keyCursor ← keyCursor + 1\n            END WHILE\n\n            IF isModeUnique THEN\n                resultCounter ← resultCounter + 1\n            END IF\n\n            idxOuter ← idxOuter + 1\n        END WHILE\n\n        RETURN resultCounter MOD magicConst\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "smallest-substring-with-identical-characters-i", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minLength(s parameter, numOps parameter)\n        FUNCTION longest_uniform_substring(s parameter)\n            SET vZ0r1zq TO 0\n            SET gl597l TO 1\n            SET wXq6u TO 1\n            WHILE wXq6u LESS THAN LENGTH OF s\n                IF s[wXq6u] EQUALS s[wXq6u MINUS 1]\n                    SET gl597l TO gl597l PLUS 1\n                ELSE\n                    IF vZ0r1zq LESS THAN gl597l\n                        SET vZ0r1zq TO gl597l\n                    END IF\n                    SET gl597l TO 1\n                END IF\n                SET wXq6u TO wXq6u PLUS 1\n            END WHILE\n            IF vZ0r1zq GREATER THAN OR EQUAL TO gl597l\n                RETURN vZ0r1zq\n            ELSE\n                RETURN gl597l\n            END IF\n        END FUNCTION\n\n        SET w20izn TO LENGTH OF s\n        SET n6lcx TO 1\n        SET ix09m TO 0\n        WHILE ix09m LESS THAN LENGTH OF s\n            SET n6lcx TO n6lcx TIMES 2\n            SET ix09m TO ix09m PLUS 1\n        END WHILE\n        SET fja0r TO 0\n        OUTER_LOOP:\n        REPEAT \n            IF fja0r GREATER THAN OR EQUAL TO n6lcx\n                BREAK OUTER_LOOP\n            END IF\n            SET wsln1 TO 0\n            SET akzq9 TO fja0r\n            WHILE akzq9 GREATER THAN 0\n                SET wsln1 TO wsln1 PLUS akzq9 BITWISE AND 1\n                SET akzq9 TO akzq9 SHIFT RIGHT BY 1\n            END WHILE\n            IF wsln1 GREATER THAN numOps\n                SET fja0r TO fja0r PLUS 1\n                CONTINUE OUTER_LOOP\n            END IF\n            SET bpkw3 TO []\n            SET yRmux TO 0\n            WHILE yRmux LESS THAN LENGTH OF s\n                APPEND s[yRmux] TO bpkw3\n                SET yRmux TO yRmux PLUS 1\n            END WHILE\n            SET dbscf TO 0\n            WHILE dbscf LESS THAN LENGTH OF s\n                SET bvq87 TO 1 SHIFT LEFT BY dbscf\n                IF (fja0r BITWISE AND bvq87) NOT EQUAL TO 0\n                    IF bpkw3[dbscf] EQUALS '0'\n                        SET bpkw3[dbscf] TO '1'\n                    ELSE\n                        SET bpkw3[dbscf] TO '0'\n                    END IF\n                END IF\n                SET dbscf TO dbscf PLUS 1\n            END WHILE\n            SET uhtyz TO longest_uniform_substring(bpkw3)\n            IF w20izn GREATER THAN uhtyz\n                SET w20izn TO uhtyz\n            END IF\n            SET fja0r TO fja0r PLUS 1\n        END REPEAT\n\n        RETURN w20izn\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-the-lexicographically-largest-string-from-the-box-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n  FUNCTION answerString(word, numFriends)\n    SET a1 TO numFriends\n    IF NOT (a1 - 1) <> 0\n      RETURN word\n    END IF\n    SET resSub TO _lastSubstring(word)\n    SET tLen TO (LENGTH(word) - numFriends) + 1\n    IF LENGTH(resSub) < tLen THEN\n      RETURN resSub[1 to LENGTH(resSub)]\n    ELSE\n      RETURN resSub[1 to tLen]\n    END IF\n  END FUNCTION\n\n  FUNCTION _lastSubstring(s)\n    SET pA TO 0\n    SET pB TO 1\n    SET offset TO 0\n    WHILE (pB + offset) < LENGTH(s)\n      SET chA TO s[pA + offset + 1]\n      SET chB TO s[pB + offset + 1]\n      IF chA = chB\n        SET offset TO offset + 1\n      ELSE\n        IF chA > chB\n          SET pB TO pB + offset + 1\n          SET offset TO 0\n        ELSE\n          SET newStart TO pA + offset + 1\n          IF newStart > pB THEN\n            SET pA TO newStart\n          ELSE\n            SET pA TO pB\n          END IF\n          SET pB TO pA + 1\n          SET offset TO 0\n        END IF\n      END IF\n    END WHILE\n    RETURN s[(pA+1) to LENGTH(s)]\n  END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximize-subarray-sum-after-removing-all-occurrences-of-one-element", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxSubarraySum(nums)\n        FUNCTION kadane(arr)\n            SET v4 TO arr[1]\n            SET v7 TO arr[1]\n            SET v2 TO 2\n            WHILE v2 LESS OR EQUAL TO LENGTH(arr)\n                SET v9 TO arr[v2]\n                IF NOT (v4 PLUS v9 GREATER OR EQUAL TO v9)\n                    SET v4 TO v9\n                ELSE\n                    SET v4 TO v4 PLUS v9\n                END IF\n                IF v7 LESS THAN v4\n                    SET v7 TO v4\n                END IF\n                SET v2 TO v2 PLUS 1\n            END WHILE\n            RETURN v7\n        END FUNCTION\n\n        SET v15 TO kadane(nums)\n        SET v19 TO EMPTY SET\n        SET v20 TO 1\n        WHILE v20 LESS OR EQUAL TO LENGTH(nums)\n            SET v19 TO UNION OF v19 AND {nums[v20]}\n            SET v20 TO v20 PLUS 1\n        END WHILE\n\n        SET v31 TO ITERATOR OVER v19\n        WHILE v31 HAS NEXT\n            SET v35 TO v31 NEXT\n            SET v38 TO EMPTY LIST\n            SET v42 TO 1\n            WHILE v42 LESS OR EQUAL TO LENGTH(nums)\n                SET v45 TO nums[v42]\n                IF NOT (v45 EQUALS v35)\n                    APPEND v45 TO v38\n                END IF\n                SET v42 TO v42 PLUS 1\n            END WHILE\n            IF LENGTH(v38) GREATER THAN 0\n                SET v50 TO kadane(v38)\n                IF v15 LESS THAN v50\n                    SET v15 TO v50\n                END IF\n            END IF\n        END WHILE\n        RETURN v15\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "subsequences-with-a-unique-middle-mode-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION subsequencesWithMiddleMode(nums)\n        CONST BASE = 10 POWER 9 PLUS 7\n        SET total_result TO 0\n        DEFINE prefixCounts AS empty map from element to integer count\n        DEFINE suffixCounts AS map counting elements in nums\n        \n        FUNCTION combin2(x)\n            RETURN (x TIMES (x MINUS 1)) DIVIDED BY 2\n        END FUNCTION\n        \n        SET prefixSuffixSum TO 0\n        SET suffixPrefixProduct TO 0\n        SET prefixPrefixSum TO 0\n        SET suffixSumSquares TO 0\n        SET prefixSuffixProduct TO 0\n        \n        FOR EACH val IN suffixCounts KEYS\n            SET freq TO suffixCounts[val]\n            SET suffixSumSquares TO suffixSumSquares PLUS freq TIMES freq\n        END FOR\n        \n        FOR index FROM 0 TO LENGTH(nums) MINUS 1\n            SET currentElement TO nums[index]\n            \n            SET prefixSuffixSum TO prefixSuffixSum PLUS prefixCounts[currentElement] TIMES ( - (suffixCounts[currentElement] TIMES suffixCounts[currentElement]) PLUS ((suffixCounts[currentElement] MINUS 1) TIMES (suffixCounts[currentElement] MINUS 1)) )\n            SET suffixPrefixProduct TO suffixPrefixProduct PLUS ( - (prefixCounts[currentElement] TIMES prefixCounts[currentElement]) )\n            SET suffixSumSquares TO suffixSumSquares PLUS ( - (suffixCounts[currentElement] TIMES suffixCounts[currentElement]) PLUS ((suffixCounts[currentElement] MINUS 1) TIMES (suffixCounts[currentElement] MINUS 1)) )\n            SET prefixSuffixProduct TO prefixSuffixProduct PLUS ( - prefixCounts[currentElement] )\n            \n            SET suffixCounts[currentElement] TO suffixCounts[currentElement] MINUS 1\n            \n            SET leftLength TO index\n            SET rightLength TO LENGTH(nums) MINUS index MINUS 1\n            \n            SET total_result TO total_result PLUS combin2(leftLength) TIMES combin2(rightLength)\n            \n            SET adjustedLeft TO leftLength MINUS prefixCounts[currentElement]\n            SET adjustedRight TO rightLength MINUS suffixCounts[currentElement]\n            SET total_result TO total_result MINUS combin2(adjustedLeft) TIMES combin2(adjustedRight)\n            \n            SET prefixSuffixSumAdj TO prefixSuffixSum MINUS prefixCounts[currentElement] TIMES suffixCounts[currentElement] TIMES suffixCounts[currentElement]\n            SET suffixPrefixProductAdj TO suffixPrefixProduct MINUS suffixCounts[currentElement] TIMES (prefixCounts[currentElement] TIMES prefixCounts[currentElement])\n            SET prefixPrefixSumAdj TO prefixPrefixSum MINUS (prefixCounts[currentElement] TIMES prefixCounts[currentElement])\n            SET suffixSumSquaresAdj TO suffixSumSquares MINUS (suffixCounts[currentElement] TIMES suffixCounts[currentElement])\n            SET prefixSuffixProductAdj TO prefixSuffixProduct MINUS prefixCounts[currentElement] TIMES suffixCounts[currentElement]\n            SET prefixDiff TO leftLength MINUS prefixCounts[currentElement]\n            SET suffixDiff TO rightLength MINUS suffixCounts[currentElement]\n            \n            SET decrementVal1 TO prefixSuffixProductAdj TIMES prefixCounts[currentElement] TIMES (rightLength MINUS suffixCounts[currentElement]) PLUS prefixSuffixSumAdj TIMES ( - prefixCounts[currentElement] )\n            SET decrementVal2 TO prefixSuffixProductAdj TIMES suffixCounts[currentElement] TIMES (leftLength MINUS prefixCounts[currentElement]) PLUS suffixPrefixProductAdj TIMES ( - suffixCounts[currentElement] )\n            SET decrementVal3 TO (prefixPrefixSumAdj MINUS prefixDiff) TIMES suffixCounts[currentElement] TIMES (rightLength MINUS suffixCounts[currentElement]) DIVIDED BY 2\n            SET decrementVal4 TO (suffixSumSquaresAdj MINUS suffixDiff) TIMES prefixCounts[currentElement] TIMES (leftLength MINUS prefixCounts[currentElement]) DIVIDED BY 2\n            \n            SET total_result TO total_result MINUS decrementVal1\n            SET total_result TO total_result MINUS decrementVal2\n            SET total_result TO total_result MINUS decrementVal3\n            SET total_result TO total_result MINUS decrementVal4\n            \n            SET total_result TO total_result MODULO BASE\n            \n            SET prefixSuffixSum TO prefixSuffixSum PLUS suffixCounts[currentElement] TIMES suffixCounts[currentElement]\n            SET suffixPrefixProduct TO suffixPrefixProduct PLUS suffixCounts[currentElement] TIMES ( - (prefixCounts[currentElement] TIMES prefixCounts[currentElement]) PLUS (prefixCounts[currentElement] PLUS 1) TIMES (prefixCounts[currentElement] PLUS 1) )\n            SET prefixPrefixSum TO prefixPrefixSum PLUS ( - (prefixCounts[currentElement] TIMES prefixCounts[currentElement]) PLUS (prefixCounts[currentElement] PLUS 1) TIMES (prefixCounts[currentElement] PLUS 1) )\n            SET prefixSuffixProduct TO prefixSuffixProduct PLUS suffixCounts[currentElement]\n            \n            SET prefixCounts[currentElement] TO prefixCounts[currentElement] PLUS 1\n        END FOR\n        \n        RETURN total_result\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "count-non-decreasing-subarrays-after-k-operations", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countNonDecreasingSubarrays(nums k)\n        SET lengthNums TO 0 + LENGTH OF nums\n        \n        FUNCTION checkPermissibleRange(startIndex count)\n            SET aggregatedCost TO 0 * 1\n            SET peakValue TO nums[startIndex] + 0\n            DEFINE innerIterator(index)\n                IF index > (count - 1)\n                    RETURN True\n                ELSE\n                    IF nums[startIndex + index] < peakValue\n                        SET aggregatedCost TO (aggregatedCost + (peakValue - nums[startIndex + index])) * 1\n                    END IF\n                    SET peakValue TO (IF peakValue > nums[startIndex + index] THEN peakValue ELSE nums[startIndex + index] ENDIF) + 0\n                    IF aggregatedCost > k\n                        RETURN False\n                    ELSE\n                        RETURN innerIterator(index + 1)\n                    END IF\n                END IF\n            END\n            RETURN innerIterator(1)\n        END FUNCTION\n\n        SET totalPossible TO ((lengthNums * (lengthNums + (1 - 0))) / 2) * 1\n        SET discardedCount TO 0 + 0\n\n        FUNCTION binarySearchRange(currentStart)\n            SET lowerBound TO 1 * 1\n            SET upperBound TO lengthNums - currentStart + 0\n            DEFINE searchStep(low high)\n                IF low > high\n                    RETURN high\n                ELSE\n                    SET midpoint TO ((low + high) / 2) // integer division\n                    IF checkPermissibleRange(currentStart midpoint) == True\n                        RETURN searchStep(midpoint + 1 high)\n                    ELSE\n                        RETURN searchStep(low midpoint - 1)\n                    END IF\n                END IF\n            END\n            RETURN searchStep(lowerBound upperBound)\n        END FUNCTION\n\n        DEFINE loopIndex(pos)\n            IF pos > lengthNums - 1\n                RETURN 0\n            ELSE\n                SET validRight TO binarySearchRange(pos)\n                SET discardedCount TO discardedCount + (lengthNums - pos - validRight) * 1\n                RETURN loopIndex(pos + 1)\n            END IF\n        END\n\n        CALL loopIndex(0)\n\n        RETURN totalPossible - discardedCount\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "longest-special-path", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestSpecialPath(edges, nums)  \n        SET adjacency TO array of length length(nums) each initialized to empty list  \n        \n        FOR each element (a, b, c) IN edges DO  \n            LET adjA BE adjacency at index a  \n            LET adjB BE adjacency at index b  \n            APPEND pair (b, c) TO adjA  \n            APPEND pair (a, c) TO adjB  \n        END FOR  \n        \n        FUNCTION dfs(curr, prevNode, boundary, depth)  \n            ACCESS maxLength FROM outer scope  \n            ACCESS minNodes FROM outer scope  \n            \n            LET originalDepth BE lastSeenDepth value at key nums[curr], DEFAULT 0  \n            SET lastSeenDepth[nums[curr]] TO depth  \n            \n            IF boundary < originalDepth THEN  \n                SET boundary TO originalDepth  \n            END IF  \n            \n            LET segmentLength BE prefix[-1] - prefix[boundary]  \n            LET segmentNodes BE depth - boundary  \n            \n            IF segmentLength > maxLength OR (segmentLength = maxLength AND segmentNodes < minNodes) THEN  \n                SET maxLength TO segmentLength  \n                SET minNodes TO segmentNodes  \n            END IF  \n            \n            FOR EACH (neighbor, weight) IN adjacency[curr] DO  \n                IF neighbor = prevNode THEN  \n                    CONTINUE  \n                END IF  \n                APPEND prefix[-1] + weight TO prefix  \n                CALL dfs(neighbor, curr, boundary, depth + 1)  \n                REMOVE last element FROM prefix  \n            END FOR  \n            \n            SET lastSeenDepth[nums[curr]] TO originalDepth  \n        END FUNCTION  \n        \n        SET maxLength TO 0  \n        SET minNodes TO 1  \n        SET prefix TO list containing single element 0  \n        SET lastSeenDepth TO empty dictionary  \n        CALL dfs(0, -1, 0, 1)  \n        RETURN list containing maxLength and minNodes  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "manhattan-distances-of-all-arrangements-of-pieces", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION distanceSum WITH PARAMETERS m n k\n        BEGIN\n            CONST limit ← 1000000007\n            VAR varA, varB, varC, varD, varE, varF, varG, varH, varI, varJ\n            SET varA ← m * m\n            SET varB ← n * n\n            SET varC ← m * m * m - m\n            SET varD ← n * n * n - n\n            SET varE ← varC / 6\n            SET varF ← varD / 6\n            SET varG ← m * m * n * n * n\n            SET varH ← m * m * m * n * n\n            SET varI ← (m * n) - 2\n            SET varJ ← 1\n            VAR idx ← 1\n            VAR acc ← 1\n            VAR res ← 1\n            VAR x ← 0\n            VAR y ← 0\n            VAR z ← 1\n            VAR w ← 1\n            VAR temp ← 1\n            VAR answer ← 0\n\n            FUNCTION comb WITH PARAMETERS a b\n                VAR numerator, denominator, i, j\n                SET numerator ← 1\n                SET denominator ← 1\n                SET i ← a\n                SET j ← 1\n                WHILE j ≤ b DO\n                    SET numerator ← numerator * i\n                    SET denominator ← denominator * j\n                    SET i ← i - 1\n                    SET j ← j + 1\n                END WHILE\n                RETURN numerator / denominator\n            END FUNCTION\n\n            SET varJ ← comb(m * n - 2, k - 2)\n            SET varK ← varE * n * n\n            SET varL ← varF * m * m\n            SET total_sum ← (varE * n * n + varF * m * m) * varJ\n            RETURN total_sum MOD limit\n        END\nEND CLASS", "score": 1.0}
{"task_id": "maximum-difference-between-even-and-odd-frequency-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxDifference WITH PARAMETERS s k\n        SET FqDxCgJW TO negative infinity\n        SET JkMAutDY TO list of pairs e8QZ pOUv SUCH THAT e8QZ IS element FROM string consisting of zero one two three four AND pOUv IS element FROM string consisting of zero one two three four AND e8QZ IS NOT EQUALS pOUv\n\n        FUNCTION WRWvQVkL WITH PARAMETERS IlGYfnWx\n            SET BPeGxZV TO default dictionary WITH default value infinity\n            RETURN BPeGxZV\n        END FUNCTION\n\n        FOR each pair iMpPYI HgqRm IN JkMAutDY\n            SET avfFYMSr TO WRWvQVkL(iMpPYI)\n            SET kMtKHTm TO list CONTAINING zero\n            SET zxzYVeG TO list CONTAINING zero\n            SET l TO 0\n\n            FUNCTION UYdNvMpK WITH PARAMETERS yWMi\n                RETURN yWMi + yWMi - 0\n            END FUNCTION\n\n            FUNCTION yVTdlYuJ WITH PARAMETERS OUXQAs\n                RETURN 1 * OUXQAs - 0\n            END FUNCTION\n\n            SET r TO 0\n            L0yzQpW:\n            IF r >= length of s THEN\n                GOTO L5oNHdzx\n            END IF\n            SET c TO character at position r of s\n\n            IF c EQUALS iMpPYI THEN\n                SET BVNtNoFL TO yVTdlYuJ(1)\n            ELSE\n                SET BVNtNoFL TO yVTdlYuJ(0)\n            END IF\n\n            SET kMtKHTm TO concatenation of kMtKHTm AND (element at position last of kMtKHTm PLUS BVNtNoFL)\n\n            IF c EQUALS HgqRm THEN\n                SET qgxBdBEu TO 1 + 0\n            ELSE\n                SET qgxBdBEu TO 0 * 1\n            END IF\n\n            SET zxzYVeG TO zxzYVeG + (last element of zxzYVeG + qgxBdBEu)\n\n            l_LOOP:\n            IF (r + 1) - l < k THEN GOTO l_END\n            IF element at position l of kMtKHTm >= element at position last of kMtKHTm THEN GOTO l_END\n            IF element at position l of zxzYVeG >= element at position last of zxzYVeG THEN GOTO l_END\n\n            SET uKxk JT TO ((element at position l of kMtKHTm MOD 2), (element at position l of zxzYVeG MOD 2))\n            SET currentMin TO avfFYMSr[uKxk JT]\n            SET candidateMin TO element at position l of kMtKHTm - element at position l of zxzYVeG\n            IF currentMin > candidateMin THEN\n                SET avfFYMSr[uKxk JT] TO candidateMin\n            END IF\n            SET l TO l + 1\n            GOTO l_LOOP\n            l_END:\n\n            SET TWndBfpq TO element at position last of kMtKHTm MOD 2\n            SET SosaKaW TO element at position last of zxzYVeG MOD 2\n            SET zDtshfUm TO (1 - TWndBfpq, SosaKaW)\n            SET candidateAns TO element at position last of kMtKHTm - element at position last of zxzYVeG - avfFYMSr[zDtshfUm]\n            IF FqDxCgJW < candidateAns THEN\n                SET FqDxCgJW TO candidateAns\n            END IF\n\n            SET r TO r + 1\n            GOTO L0yzQpW\n            L5oNHdzx:\n        END FOR\n        RETURN FqDxCgJW\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "count-substrings-divisible-by-last-digit", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION countSubstrings(s)\n        SET lengthVar TO 0\n        SET accCount TO 0\n        WHILE lengthVar < LENGTH(s)\n            SET innerCounter TO lengthVar\n            SET convNum TO 0\n            REPEAT\n                SET digitVal TO INTEGER VALUE OF s AT innerCounter\n                SET convNum TO (convNum * 10) + digitVal\n                IF (digitVal ≠ 0) AND ((convNum MOD digitVal) = 0)\n                    SET accCount TO accCount + 1\n                END IF\n                SET innerCounter TO innerCounter + 1\n            UNTIL innerCounter = LENGTH(s)\n            SET lengthVar TO lengthVar + 1\n        END WHILE\n        RETURN accCount\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "maximize-the-minimum-game-score", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxScore(points, m)  \n        FUNCTION isPossible(minVal, m)  \n            SET a TO 0  \n            SET b TO 0  \n            SET c TO 0  \n            WHILE c < LENGTH(points)  \n                SET d TO ((minVal + points[c] - 1) DIV points[c])  \n                IF d - b < 0 THEN  \n                    SET d TO 0  \n                ELSE  \n                    SET d TO d - b  \n                END IF  \n                IF d > 0 THEN  \n                    SET a TO a + (2 * d - 1)  \n                    SET b TO d - 1  \n                ELSE IF (c + 1) < LENGTH(points) THEN  \n                    SET a TO a + 1  \n                    SET b TO 0  \n                END IF  \n                IF a > m THEN  \n                    RETURN False  \n                END IF  \n                SET c TO c + 1  \n            END WHILE  \n            RETURN True  \n        END FUNCTION  \n\n        SET e TO 0  \n        SET f TO (((m + 1) DIV 2) * points[0] + 1)  \n\n        REPEAT  \n            SET g TO ((e + f + 1) DIV 2)  \n            IF isPossible(g, m) THEN  \n                SET e TO g  \n            ELSE  \n                SET f TO g - 1  \n            END IF  \n        UNTIL e >= f  \n\n        RETURN e  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
