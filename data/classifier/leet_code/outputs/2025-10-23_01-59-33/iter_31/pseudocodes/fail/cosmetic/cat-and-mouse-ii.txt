CLASS Solution
    FUNCTION canMouseWin(grid, catJump, mouseJump)
        ASSIGN rows_count ← SIZE OF grid
        ASSIGN cols_count ← SIZE OF grid AT zero
        ASSIGN cat_init ← 0
        ASSIGN mouse_init ← 0
        ASSIGN food_pos ← 0
        ASSIGN directions ← [ -1, 0, 1, 0, -1 ]
        ASSIGN mouse_graph ← LIST OF EMPTY LISTS REPEATED rows_count * cols_count TIMES
        ASSIGN cat_graph ← LIST OF EMPTY LISTS REPEATED rows_count * cols_count TIMES

        FOR each row_index, row_val IN ENUMERATE(grid)
            FOR each col_index, cell IN ENUMERATE(row_val)
                IF cell IS EQUAL TO '#'
                    CONTINUE TO NEXT LOOP ITERATION
                END IF
                ASSIGN vertex ← (row_index * cols_count) + col_index
                IF cell IS 'C'
                    ASSIGN cat_init ← vertex
                ELSE IF cell IS 'M'
                    ASSIGN mouse_init ← vertex
                ELSE IF cell IS 'F'
                    ASSIGN food_pos ← vertex
                END IF

                FOR pos IN 0 TO LENGTH(directions) - 2
                    ASSIGN delta_x ← directions[pos]
                    ASSIGN delta_y ← directions[pos + 1]

                    FOR step FROM 0 TO mouseJump
                        ASSIGN new_x ← row_index + step * delta_x
                        ASSIGN new_y ← col_index + step * delta_y
                        IF new_x < 0 OR new_x >= rows_count OR new_y < 0 OR new_y >= cols_count OR grid[new_x][new_y] = '#'
                            LEAVE INNER LOOP
                        END IF
                        APPEND (new_x * cols_count + new_y) TO mouse_graph[vertex]
                    END FOR

                    FOR step FROM 0 TO catJump
                        ASSIGN new_x ← row_index + step * delta_x
                        ASSIGN new_y ← col_index + step * delta_y
                        IF new_x < 0 OR new_x >= rows_count OR new_y < 0 OR new_y >= cols_count OR grid[new_x][new_y] = '#'
                            LEAVE INNER LOOP
                        END IF
                        APPEND (new_x * cols_count + new_y) TO cat_graph[vertex]
                    END FOR
                END FOR
            END FOR
        END FOR
        RETURN calc(mouse_graph, cat_graph, mouse_init, cat_init, food_pos) IS EQUAL TO 1
    END FUNCTION

    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)
        FUNCTION get_prev_states(state)
            ASSIGN mouse_pos ← state[0]
            ASSIGN cat_pos ← state[1]
            ASSIGN turn_indicator ← state[2]
            ASSIGN prev_turn ← turn_indicator XOR 1
            ASSIGN results ← EMPTY LIST

            IF prev_turn = 1
                FOR each candidate_cat IN g_cat[cat_pos]
                    IF ans[mouse_pos][candidate_cat][1] = 0
                        APPEND (mouse_pos, candidate_cat, prev_turn) TO results
                    END IF
                END FOR
            ELSE
                FOR each candidate_mouse IN g_mouse[mouse_pos]
                    IF ans[candidate_mouse][cat_pos][0] = 0
                        APPEND (candidate_mouse, cat_pos, 0) TO results
                    END IF
                END FOR
            END IF
            RETURN results
        END FUNCTION

        ASSIGN total_states ← SIZE OF g_mouse
        ASSIGN degree ← 3D ARRAY FILLED WITH 0 WITH DIMENSIONS [total_states][total_states][2]

        FOR outer FROM 0 TO total_states - 1
            FOR inner FROM 0 TO total_states - 1
                degree[outer][inner][0] ← SIZE OF g_mouse[outer]
                degree[outer][inner][1] ← SIZE OF g_cat[inner]
            END FOR
        END FOR

        ASSIGN ans ← 3D ARRAY FILLED WITH 0 WITH DIMENSIONS [total_states][total_states][2]
        ASSIGN queue ← EMPTY DOUBLE-ENDED QUEUE

        FOR index FROM 0 TO total_states - 1
            ans[hole][index][1] ← 1
            ans[index][hole][0] ← 2
            ans[index][index][1] ← 2
            ans[index][index][0] ← 2

            APPEND (hole, index, 1) TO queue
            APPEND (index, hole, 0) TO queue
            APPEND (index, index, 0) TO queue
            APPEND (index, index, 1) TO queue
        END FOR

        WHILE queue IS NOT EMPTY
            ASSIGN current_state ← POP LEFT FROM queue
            ASSIGN current_value ← ans[current_state[0]][current_state[1]][current_state[2]]

            FOR each predecessor IN get_prev_states(current_state)
                ASSIGN pm ← predecessor[0]
                ASSIGN pc ← predecessor[1]
                ASSIGN pt ← predecessor[2]

                IF pt = current_value - 1
                    ans[pm][pc][pt] ← current_value
                    APPEND predecessor TO queue
                ELSE
                    degree[pm][pc][pt] ← degree[pm][pc][pt] - 1
                    IF degree[pm][pc][pt] = 0
                        ans[pm][pc][pt] ← current_value
                        APPEND predecessor TO queue
                    END IF
                END IF
            END FOR
        END WHILE
        RETURN ans[mouse_start][cat_start][0]
    END FUNCTION
END CLASS