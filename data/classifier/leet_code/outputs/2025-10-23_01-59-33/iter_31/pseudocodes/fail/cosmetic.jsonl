{"task_id": "longest-palindromic-substring", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestPalindrome(s)\n        SET length AS THE COUNT OF s\n        SET truth_matrix AS AN ARRAY (length) OF ARRAYS (length) FILLED WITH TRUE\n        SET start_index AS 0\n        SET max_length AS 1\n        \n        SET outer_index AS length MINUS 2\n        WHILE outer_index IS GREATER THAN OR EQUAL TO 0 DO\n            SET inner_index AS outer_index PLUS 1\n            WHILE inner_index IS LESS THAN length DO\n                SET truth_matrix[outer_index][inner_index] AS FALSE\n                \n                IF NOT (s[outer_index] NOT EQUAL TO s[inner_index]) THEN\n                    SET truth_matrix[outer_index][inner_index] AS truth_matrix[outer_index PLUS 1][inner_index MINUS 1]\n                    \n                    IF truth_matrix[outer_index][inner_index] IS TRUE THEN\n                        IF (max_length LESS THAN (inner_index MINUS outer_index PLUS 1)) THEN\n                            SET start_index AS outer_index\n                            SET max_length AS (inner_index MINUS outer_index PLUS 1)\n                        END IF\n                    END IF\n                END IF\n                INCREMENT inner_index BY 1\n            END WHILE\n            DECREMENT outer_index BY 1\n        END WHILE\n        \n        RETURN s SUBSTRING FROM start_index TO (start_index PLUS max_length MINUS 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-to-integer-atoi", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position ← position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity ← 0 - 1  \n                    position ← position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity ← 1  \n                    position ← position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber ← (accumulatedNumber * 10) + numericValue  \n            position ← position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "multiply-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF NOT (num1 NOT EQUALS string zero AND num2 NOT EQUALS string zero) THEN  \n            RETURN string zero  \n        END IF  \n\n        SET intermediateList TO new list  \n        SET lengthLimit TO (LENGTH OF num1) PLUS (LENGTH OF num2)  \n        FOR counter FROM zero UPTO lengthLimit MINUS one  \n            APPEND zero TO intermediateList  \n        END FOR   \n\n        SET reversedNum1 TO empty string  \n        SET indexA TO LENGTH OF num1 MINUS one  \n        WHILE indexA GREATER OR EQUAL TO zero DO  \n            SET reversedNum1 TO reversedNum1 PLUS CHARACTER AT indexA OF num1  \n            DECREMENT indexA BY one  \n        END WHILE  \n        SET num1 TO reversedNum1  \n\n        SET reversedNum2 TO empty string  \n        SET indexB TO LENGTH OF num2 MINUS one  \n        WHILE indexB GREATER OR EQUAL TO zero DO  \n            SET reversedNum2 TO reversedNum2 PLUS CHARACTER AT indexB OF num2  \n            DECREMENT indexB BY one  \n        END WHILE  \n        SET num2 TO reversedNum2  \n\n        SET posI TO zero  \n        WHILE posI LESS THAN LENGTH OF num1 DO  \n            SET posJ TO zero  \n            WHILE posJ LESS THAN LENGTH OF num2 DO  \n                SET codeA TO (CHARACTER CODE OF CHARACTER AT posI OF num1) MINUS (CHARACTER CODE OF string zero)  \n                SET codeB TO (CHARACTER CODE OF CHARACTER AT posJ OF num2) MINUS (CHARACTER CODE OF string zero)  \n                SET productVal TO codeA TIMES codeB  \n\n                SET positionOne TO posI PLUS posJ  \n                SET positionTwo TO positionOne PLUS one  \n\n                SET combinedSum TO productVal PLUS ELEMENT AT positionOne OF intermediateList  \n\n                SET ELEMENT AT positionOne OF intermediateList TO combinedSum MODULO ten  \n                SET ELEMENT AT positionTwo OF intermediateList TO ELEMENT AT positionTwo OF intermediateList PLUS (combinedSum DIVIDED BY ten)  \n                INCREMENT posJ BY one  \n            END WHILE  \n            INCREMENT posI BY one  \n        END WHILE  \n\n        SET reversedResultStr TO empty string  \n        SET revIndex TO LENGTH OF intermediateList MINUS one  \n        WHILE revIndex GREATER OR EQUAL TO zero DO  \n            SET reversedResultStr TO reversedResultStr PLUS STRING OF ELEMENT AT revIndex OF intermediateList  \n            DECREMENT revIndex BY one  \n        END WHILE  \n\n        SET startIndex TO zero  \n        WHILE startIndex LESS THAN LENGTH OF reversedResultStr AND CHARACTER AT startIndex OF reversedResultStr EQUALS string zero DO  \n            INCREMENT startIndex BY one  \n        END WHILE  \n\n        IF startIndex EQUALS LENGTH OF reversedResultStr THEN  \n            RETURN string zero  \n        END IF  \n\n        RETURN SUBSTRING OF reversedResultStr FROM startIndex TO LENGTH OF reversedResultStr MINUS one  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wildcard-matching", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        DECLARE table AS two-dimensional array FILLED WITH False, SIZE (length(s) + 1) BY (length(p) + 1)  \n        ASSIGN table[0][0] ← True  \n\n        SET indexP TO 1  \n        WHILE indexP ≤ length(p)  \n            IF p[indexP - 1] = '*' THEN  \n                ASSIGN table[0][indexP] ← table[0][indexP - 1]  \n            END IF  \n            INCREMENT indexP BY 1  \n        END WHILE  \n\n        SET indexS TO 1  \n        WHILE indexS ≤ length(s)  \n            SET indexPTmp TO 1  \n            WHILE indexPTmp ≤ length(p)  \n                IF p[indexPTmp - 1] = '*' THEN  \n                    ASSIGN table[indexS][indexPTmp] ← (table[indexS - 1][indexPTmp] OR table[indexS][indexPTmp - 1])  \n                ELSE  \n                    IF (p[indexPTmp - 1] = '?' OR s[indexS - 1] = p[indexPTmp - 1]) THEN  \n                        ASSIGN table[indexS][indexPTmp] ← table[indexS - 1][indexPTmp - 1]  \n                    END IF  \n                END IF  \n                SET indexPTmp ← indexPTmp + 1  \n            END WHILE  \n            SET indexS ← indexS + 1  \n        END WHILE  \n\n        RETURN table[length(s)][length(p)]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicates-from-sorted-array-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF NOT (LENGTH OF nums > 0) THEN  \n            RETURN 0  \n        END IF  \n        \n        SET ptr AS 0  \n        \n        SET idx AS 0  \n        WHILE idx <= (2 MINUS 1) AND idx <= (LENGTH OF nums MINUS 1)  \n            ASSIGN nums[ptr] AS nums[idx]  \n            SET ptr AS ptr + 1  \n            SET idx AS idx + 1  \n        END WHILE  \n        \n        SET cursor AS 2  \n        WHILE cursor <= (LENGTH OF nums MINUS 1)  \n            IF nums[cursor] = nums[(ptr MINUS 2)] THEN  \n                # do nothing, skip increment  \n            ELSE  \n                ASSIGN nums[ptr] AS nums[cursor]  \n                SET ptr AS ptr PLUS 1  \n            END IF  \n            SET cursor AS cursor + 1  \n        END WHILE  \n        \n        RETURN ptr  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "evaluate-reverse-polish-notation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION evalRPN(tokens)\n        INITIALIZE ledger WITH empty collection\n        INITIALIZE index TO 0\n        WHILE index LESS THAN LENGTH OF tokens\n            LET current_token BE tokens[index]\n            INCREMENT index BY 1\n            SWITCH current_token\n                CASE plus, minus, multiply, divide:\n                    LET right_operand BE ledger.REMOVE_LAST_ELEMENT()\n                    LET left_operand BE ledger.REMOVE_LAST_ELEMENT()\n                    IF current_token EQUALS plus THEN\n                        SET operation_result TO left_operand PLUS right_operand\n                    ELSE IF current_token EQUALS minus THEN\n                        SET operation_result TO left_operand MINUS right_operand\n                    ELSE IF current_token EQUALS multiply THEN\n                        SET operation_result TO left_operand MULTIPLIED BY right_operand\n                    ELSE /* current_token EQUALS divide */\n                        SET intermediate_result TO left_operand DIVIDED BY right_operand\n                        SET operation_result TO INTEGER_VALUE_OF(intermediate_result)\n                    END IF\n                    ledger.ADD_ELEMENT(operation_result)\n                DEFAULT:\n                    LET numeric_value BE INTEGER_VALUE_OF(current_token)\n                    ledger.ADD_ELEMENT(numeric_value)\n            END SWITCH\n        END WHILE\n        RETURN ledger[0]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION evalRPN(tokens)  \n        SET stack TO an empty list  \n        FOR each token IN tokens  \n            IF token EQUALS one of the symbols plus MINUS MULTIPLY DIVIDE  \n                SET b TO the last element removed from stack  \n                SET a TO the last element removed from stack  \n                IF token EQUALS plus  \n                    APPEND a PLUS b TO stack  \n                ELSE IF token EQUALS minus  \n                    APPEND a MINUS b TO stack  \n                ELSE IF token EQUALS multiply  \n                    APPEND a MULTIPLIED BY b TO stack  \n                ELSE IF token EQUALS divide  \n                    APPEND the integer value of a DIVIDED BY b TO stack  \n                END IF  \n            ELSE  \n                APPEND the integer value of token TO stack  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-primes", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        SWITCH  \n            CASE n > 2:  \n                BREAK  \n            DEFAULT:  \n                RETURN 0  \n        END SWITCH  \n        SET primality_flags AS empty list  \n        SET counter AS 0  \n        WHILE counter IS LESS THAN n DO  \n            ADD True TO primality_flags  \n            SET counter TO counter + 1  \n        END WHILE  \n        SET primality_flags[0] TO False  \n        SET primality_flags[1] TO False  \n        SET max_check AS FLOOR(SQRT(n))  \n        SET candidate AS 2  \n        WHILE candidate <= max_check DO  \n            IF primality_flags[candidate] IS NOT False THEN  \n                SET factor AS candidate * candidate  \n                WHILE factor < n DO  \n                    SET primality_flags[factor] TO False  \n                    SET factor TO factor + candidate  \n                END WHILE  \n            END IF  \n            SET candidate TO candidate + 1  \n        END WHILE  \n        SET tally AS 0  \n        FOR element IN primality_flags DO  \n            IF element THEN tally ← tally + 1  \n        END FOR  \n        RETURN tally  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "majority-element-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        ASSIGN countA AS 0  \n        ASSIGN countB AS 0  \n        ASSIGN candidateA AS 0  \n        ASSIGN candidateB AS 1  \n        SET index AS 0  \n        WHILE index LESS THAN LENGTH OF nums  \n            LET currentItem BE nums AT index  \n            IF currentItem IS candidateA THEN  \n                countA ← countA + 1  \n            ELSE IF currentItem IS candidateB THEN  \n                countB ← countB + 1  \n            ELSE IF countA IS 0 THEN  \n                candidateA ← currentItem  \n                countA ← 1  \n            ELSE IF countB IS 0 THEN  \n                candidateB ← currentItem  \n                countB ← 1  \n            ELSE  \n                countA ← countA - 1  \n                countB ← countB - 1  \n            END IF  \n            index ← index + 1  \n        END WHILE  \n        LET resultElements BE [candidateA, candidateB]  \n        LET threshold BE LENGTH OF nums DIV 3  \n        LET outputList BE EMPTY LIST  \n        FOR EACH element IN resultElements  \n            LET frequency BE 0  \n            FOR EACH val IN nums  \n                IF val EQUALS element THEN  \n                    frequency ← frequency + 1  \n                END IF  \n            END FOR  \n            IF frequency GREATER THAN threshold THEN  \n                APPEND element TO outputList  \n            END IF  \n        END FOR  \n        RETURN outputList  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each element m IN nums  \n            IF element m EQUALS value m1  \n                INCREMENT n1 BY one  \n            ELSE IF element m EQUALS value m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO element m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO element m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE the count of element m IN nums IS GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "different-ways-to-add-parentheses", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION diffWaysToCompute(expression)\n        FUNCTION compute(left, right, operator)\n            ASSIGN [] TO outcomes\n            SET l_index TO 0\n            WHILE l_index < LENGTH of left\n                SET r_pos TO 0\n                WHILE r_pos < LENGTH of right\n                    SET current_left TO left[l_index]\n                    SET current_right TO right[r_pos]\n                    IF NOT (operator != \"+\") THEN\n                        outcomes := outcomes + [current_left + current_right]\n                    ELSE IF NOT (operator != \"-\") THEN\n                        outcomes := outcomes + [current_left - current_right]\n                    ELSE IF NOT (operator != \"*\") THEN\n                        outcomes := outcomes + [current_left * current_right]\n                    END IF\n                    r_pos = r_pos + 1\n                END WHILE\n                l_index = l_index + 1\n            END WHILE\n            RETURN outcomes\n        END FUNCTION\n\n        FUNCTION helper(sub_expr)\n            IF sub_expr CONTAINS ONLY digits THEN\n                RETURN [TO_INTEGER(sub_expr)]\n            END IF\n\n            SET collected TO []\n            SET pointer TO 0\n            WHILE pointer < LENGTH(sub_expr)\n                SET ch TO sub_expr[pointer]\n                IF ch EQUALS \"+\" OR ch EQUALS \"-\" OR ch EQUALS \"*\" THEN\n                    ASSIGN helper(SUBSTRING(sub_expr, 0, pointer)) TO left_group\n                    ASSIGN helper(SUBSTRING(sub_expr, pointer+1, LENGTH(sub_expr)-1)) TO right_group\n                    FOR each val IN compute(left_group, right_group, ch)\n                        collected := collected + [val]\n                    END FOR\n                END IF\n                POINTER_INCREMENT pointer BY 1\n            END WHILE\n            RETURN collected\n        END FUNCTION\n\n        RETURN helper(expression)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION diffWaysToCompute(expression)  \n        FUNCTION compute(left, right, operator)  \n            SET results TO an empty list  \n            FOR each l IN left  \n                FOR each r IN right  \n                    IF operator EQUALS the plus symbol  \n                        APPEND l PLUS r TO results  \n                    ELSE IF operator EQUALS the minus symbol  \n                        APPEND l MINUS r TO results  \n                    ELSE IF operator EQUALS the multiplication symbol  \n                        APPEND l MULTIPLIED BY r TO results  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        FUNCTION helper(sub_expr)  \n            IF the entirety of sub_expr CONSISTS OF DIGITS  \n                RETURN a list containing the integer value of sub_expr  \n            END IF  \n          \n            SET results TO an empty list  \n            FOR index i FROM zero TO the LENGTH OF sub_expr MINUS one  \n                IF the element at position i of sub_expr EQUALS any of the plus symbol OR the minus symbol OR the multiplication symbol  \n                    SET left_results TO helper(the substring of sub_expr from position zero TO position i MINUS one)  \n                    SET right_results TO helper(the substring of sub_expr from position i PLUS one TO the last position)  \n                    FOR each result IN compute(left_results, right_results, the element at position i of sub_expr)  \n                        APPEND result TO results  \n                    END FOR  \n                END IF  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        RETURN helper(expression)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-iii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION strobogrammaticInRange(low  \n                                    high)\n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)\n            SWITCH n\n                CASE 0:\n                    RETURN [\"\"]\n\n                CASE 1:\n                    RETURN [\"0\", \"1\", \"8\"]\n            END SWITCH\n\n            SET innerStrings AS generate_strobogrammatic(final_length - 2, final_length)\n            SET collection AS []\n\n            SET idx TO 0\n            WHILE idx < LENGTH(innerStrings)\n                SET segment TO innerStrings[idx]\n\n                IF n IS DIFFERENT FROM final_length THEN\n                    INSERT \"0\" + segment + \"0\" INTO collection AT END\n                END IF\n\n                INSERT \"1\" + segment + \"1\" INTO collection AT END\n                INSERT \"6\" + segment + \"9\" INTO collection AT END\n                INSERT \"8\" + segment + \"8\" INTO collection AT END\n                INSERT \"9\" + segment + \"6\" INTO collection AT END\n\n                idx ← idx + 1\n            END WHILE\n\n            RETURN collection\n        END FUNCTION\n\n        FUNCTION count_strobogrammatic(low  \n                                       high)\n            SET total AS 0\n            SET lenLow TO LENGTH(low)\n            SET lenHigh TO LENGTH(high)\n\n            SET currentLen TO lenLow\n            WHILE currentLen <= lenHigh\n                SET generatedList AS generate_strobogrammatic(currentLen, currentLen)\n                SET pointer TO 0\n\n                WHILE pointer < LENGTH(generatedList)\n                    SET numberStr TO generatedList[pointer]\n\n                    IF NOT ((currentLen = lenLow AND numberStr < low) OR (currentLen = lenHigh AND numberStr > high)) THEN\n                        total ← total + 1\n                    END IF\n\n                    pointer ← pointer + 1\n                END WHILE\n\n                currentLen ← currentLen + 1\n            END WHILE\n\n            RETURN total\n        END FUNCTION\n\n        RETURN count_strobogrammatic(low, high)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            \n            IF n EQUALS one  \n                RETURN a list containing the string zero once the string one once the string eight  \n            END IF  \n            \n            SET middles TO the result of calling generate_strobogrammatic with arguments n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero PLUS middle PLUS zero TO result  \n                END IF  \n                APPEND the string one PLUS middle PLUS one TO result  \n                APPEND the string six PLUS middle PLUS nine TO result  \n                APPEND the string eight PLUS middle PLUS eight TO result  \n                APPEND the string nine PLUS middle PLUS six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN the result of calling generate_strobogrammatic with arguments length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of calling count_strobogrammatic with arguments low and high  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulls-and-cows", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION getHint(secret PARAMETER, guess PARAMETER)  \n        IMPORT a data structure offering a dictionary with zero as the default for any missing key  \n        \n        SET alpha TO 0  \n        SET beta TO 0  \n        \n        CREATE secret_map AS a dictionary defaulting to zero  \n        CREATE guess_map AS a dictionary defaulting to zero  \n        \n        SET counter TO 0  \n        WHILE counter LESS THAN LENGTH(secret)  \n            SET secret_char TO secret[counter]  \n            SET guess_char TO guess[counter]  \n            \n            IF NOT (secret_char DIFFERENT FROM guess_char) THEN\n                SET alpha TO alpha + 1\n            ELSE\n                INCREASE secret_map[secret_char] BY 1\n                INCREASE guess_map[guess_char] BY 1\n            END IF  \n            SET counter TO counter + 1\n        END WHILE  \n        \n        FOR each key_element IN secret_map KEYS  \n            SET min_val TO guess_map[key_element]  \n            IF min_val GREATER THAN secret_map[key_element] THEN\n                SET min_val TO secret_map[key_element]\n            END IF\n            SET beta TO beta + min_val\n        END FOR  \n        \n        RETURN (string CONCAT alpha CONCAT \"A\" CONCAT beta CONCAT \"B\")  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getHint(secret PARAMETER, guess PARAMETER)  \n        IMPORT a data structure that provides a dictionary with default zero values\n        \n        SET bulls TO zero  \n        SET cows TO zero  \n        \n        CREATE a dictionary named secret_count with default zero values  \n        CREATE a dictionary named guess_count with default zero values  \n        \n        FOR each element s and element g taken correspondingly from secret and guess  \n            IF element s EQUALS element g  \n                INCREMENT bulls BY one  \n            ELSE  \n                INCREMENT the value at key element s in secret_count BY one  \n                INCREMENT the value at key element g in guess_count BY one  \n            END IF  \n        END FOR  \n        \n        FOR each digit IN the keys of secret_count  \n            INCREMENT cows BY the smaller value BETWEEN the value at key digit in secret_count AND the value at key digit in guess_count  \n        END FOR  \n        \n        RETURN a string expressing bulls FOLLOWED BY the character representing bulls AND THEN cows FOLLOWED BY the character representing cows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-rectangle", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        LET minX BE positive infinity  \n        LET minY BE positive infinity  \n        LET maxX BE negative infinity  \n        LET maxY BE negative infinity  \n        \n        INITIALIZE corners AS empty set  \n        DEFINE totalArea AS 0  \n        \n        DEFINE idx AS 0  \n        WHILE idx LESS THAN LENGTH OF rectangles DO  \n            LET rect BE rectangles[idx]  \n            LET leftX BE rect[0]  \n            LET bottomY BE rect[1]  \n            LET rightX BE rect[2]  \n            LET topY BE rect[3]  \n            \n            IF NOT (leftX >= minX) THEN  \n                minX ← leftX  \n            END IF  \n            IF NOT (bottomY >= minY) THEN  \n                minY ← bottomY  \n            END IF  \n            IF NOT (rightX <= maxX) THEN  \n                maxX ← rightX  \n            END IF  \n            IF NOT (topY <= maxY) THEN  \n                maxY ← topY  \n            END IF  \n            \n            LET rectArea BE (rightX - leftX)  \n            LET height BE (topY - bottomY)  \n            LET thisArea BE rectArea * height  \n            totalArea ← totalArea + thisArea  \n            \n            LET cornerPoints BE list of pairs: (leftX, bottomY), (leftX, topY), (rightX, bottomY), (rightX, topY)  \n            \n            LET ctr AS 0  \n            WHILE ctr LESS THAN LENGTH OF cornerPoints DO  \n                LET corner BE cornerPoints[ctr]  \n                IF corners CONTAINS corner THEN  \n                    REMOVE corner FROM corners  \n                ELSE  \n                    INSERT corner INTO corners  \n                END IF  \n                ctr ← ctr + 1  \n            END WHILE  \n            idx ← idx + 1  \n        END WHILE  \n        \n        LET fullWidth BE maxX - minX  \n        LET fullHeight BE maxY - minY  \n        LET expectedArea BE fullWidth * fullHeight  \n        \n        IF totalArea IS NOT expectedArea THEN  \n            RETURN False  \n        END IF  \n        \n        LET requiredCorners BE set of pairs: (minX, minY), (minX, maxY), (maxX, minY), (maxX, maxY)  \n        IF corners IS NOT EQUAL TO requiredCorners THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-jump", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canCross(stones)\n        IF stones IS EMPTY OR NOT (LENGTH stones >= 2)\n            OUTPUT False\n        END IF\n        LET pebbleBank BE A HASH MAP(initialized empty)\n        LET cache BE A HASH MAP(empty)\n\n        FUNCTION can_jump_to(loc, step)\n            IF loc = stones[LENGTH stones - 1]\n                OUTPUT True\n            END IF\n            IF (loc, step) EXISTS IN cache\n                OUTPUT cache[(loc, step)]\n            END IF\n            LET delta BE -1\n            WHILE delta <= 1\n                LET candidateStep BE step + delta\n                IF candidateStep > 0 AND (loc + candidateStep) IN pebbleBank\n                    IF can_jump_to(loc + candidateStep, candidateStep)\n                        SET cache[(loc, step)] AS True\n                        OUTPUT True\n                    END IF\n                END IF\n                INCREMENT delta BY 1\n            END WHILE\n            SET cache[(loc, step)] AS False\n            OUTPUT False\n        END FUNCTION\n\n        FOR peb IN stones\n            SET pebbleBank[peb] AS True\n        END FOR\n\n        OUTPUT can_jump_to(stones[0], 0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS empty OR the LENGTH OF stones LESS THAN two  \n            RETURN False  \n        END IF  \n        SET stone_set TO the SET of all elements in stones  \n        SET memo TO an EMPTY DICTIONARY  \n\n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the element at the last position of stones  \n                RETURN True  \n            END IF  \n            IF the TUPLE of position AND jump IS IN memo  \n                RETURN the VALUE associated with the TUPLE of position AND jump in memo  \n            END IF  \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the SUM of position AND next_jump IS IN stone_set  \n                    IF can_jump_to(the SUM of position AND next_jump, next_jump)  \n                        SET memo at key TUPLE of position AND jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            SET memo at key TUPLE of position AND jump TO False  \n            RETURN False  \n        END FUNCTION  \n\n        RETURN can_jump_to(the element at the first position of stones, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET freqMap AS map of character counts in s  \n        SET digitCounts AS list WITH TEN elements INITIATED TO 0  \n        \n        SET digitCounts[0] AS freqMap['z']  \n        SET digitCounts[2] AS freqMap['w']  \n        SET digitCounts[4] AS freqMap['u']  \n        SET digitCounts[6] AS freqMap['x']  \n        SET digitCounts[8] AS freqMap['g']  \n        \n        SET digitCounts[3] AS freqMap['h'] - digitCounts[8]  \n        SET digitCounts[5] AS freqMap['f'] - digitCounts[4]  \n        SET digitCounts[7] AS freqMap['s'] - digitCounts[6]  \n        \n        SET tempI AS freqMap['i']  \n        SET digitCounts[9] AS tempI - digitCounts[5] - digitCounts[6] - digitCounts[8]  \n        \n        SET tempO AS freqMap['o']  \n        SET digitCounts[1] AS tempO - digitCounts[0] - digitCounts[2] - digitCounts[4]  \n        \n        SET collectionOfChars AS empty list  \n        \n        SET numberIdx AS 0  \n        WHILE numberIdx LESS THAN 10  \n            SET countRepeat AS digitCounts[numberIdx]  \n            WHILE countRepeat GREATER THAN 0  \n                APPEND STRING(numberIdx) TO collectionOfChars  \n                ASSIGN countRepeat ← countRepeat - 1  \n            END WHILE  \n            ASSIGN numberIdx ← numberIdx + 1  \n        END WHILE  \n        \n        SET outputString AS CONCATENATE elements of collectionOfChars SEQUENTIALLY  \n        RETURN outputString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-squares", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION wordSquares(words)\n        SET lookup TO an empty mapping from string to list of strings\n\n        SET w_index TO 0\n        WHILE w_index < LENGTH(words)\n            SET current_word TO words[w_index]\n            SET i TO 0\n            WHILE i < LENGTH(current_word)\n                SET key TO substring(current_word, 0, i)\n                IF NOT lookup HAS KEY key THEN\n                    lookup[key] ← an empty list\n                END IF\n                SET word_list TO lookup[key]\n                word_list ← word_list + [current_word]\n                lookup[key] ← word_list\n                i ← i + 1\n            END WHILE\n            w_index ← w_index + 1\n        END WHILE\n\n        SET output TO an empty list\n\n        FUNCTION backtrack(square)\n            IF NOT LENGTH(square) ≠ LENGTH(words[0]) THEN\n                output ← output + [square]\n                RETURN\n            END IF\n\n            SET build_prefix TO \"\"\n            SET idx TO 0\n            WHILE idx < LENGTH(square)\n                SET temp_word TO square[idx]\n                SET prefix_char TO temp_word[LENGTH(square)]\n                build_prefix ← build_prefix + prefix_char\n                idx ← idx + 1\n            END WHILE\n\n            IF lookup HAS KEY build_prefix THEN\n                SET candidates_list TO lookup[build_prefix]\n                SET c_idx TO 0\n                WHILE c_idx < LENGTH(candidates_list)\n                    SET next_word TO candidates_list[c_idx]\n                    backtrack(square + [next_word])\n                    c_idx ← c_idx + 1\n                END WHILE\n            END IF\n        END FUNCTION\n\n        FOR EACH initial_word IN words\n            backtrack([initial_word])\n        END FOR\n\n        RETURN output\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION wordSquares(words)  \n        SET prefix_to_words TO an empty mapping from string to list of strings  \n        FOR each word IN words  \n            FOR index FROM zero TO the LENGTH OF word MINUS one  \n                SET prefix TO the substring of word from position zero TO position index MINUS one  \n                APPEND word TO the list at prefix_to_words corresponding to prefix  \n            END FOR  \n        END FOR  \n        \n        SET results TO an empty list  \n        \n        FUNCTION backtrack(square)  \n            IF the LENGTH OF square EQUALS the LENGTH OF the first element of words THEN  \n                APPEND square TO results  \n                RETURN  \n            END IF  \n            \n            SET prefix TO an empty string  \n            FOR each word_element IN square  \n                APPEND the element at position the LENGTH OF square of word_element TO prefix  \n            END FOR  \n            \n            FOR each candidate IN the list at prefix_to_words corresponding to prefix  \n                CALL backtrack WITH the argument of the concatenation of square with candidate as a new list element  \n            END FOR  \n        END FUNCTION  \n        \n        FOR each word IN words  \n            CALL backtrack WITH a list containing only word  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "arithmetic-slices-ii-subsequence", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        SET lengthVal AS LENGTH(nums)  \n        IF NOT(lengthVal GREATER OR EQUAL TO 3) THEN  \n            RETURN 0  \n        END IF  \n        \n        SET dpList AS AN EMPTY list  \n        SET idxCounter TO 0  \n        WHILE idxCounter LESS THAN lengthVal DO  \n            APPEND a new default dictionary mapping integer TO integer TO dpList  \n            INCREMENT idxCounter BY 1  \n        END WHILE  \n        \n        SET aggregateCount TO 0  \n        \n        SET outerIdx TO 0  \n        WHILE outerIdx LESS THAN lengthVal DO  \n            SET innerIdx TO 0  \n            WHILE innerIdx LESS THAN outerIdx DO  \n                SET diffDelta AS nums[outerIdx] MINUS nums[innerIdx]  \n                \n                IF diffDelta IN dpList[innerIdx] THEN  \n                    SET prevVal TO dpList[innerIdx][diffDelta]  \n                    SET dpList[outerIdx][diffDelta] TO dpList[outerIdx].GET(diffDelta, 0) PLUS prevVal PLUS 1  \n                    SET aggregateCount TO aggregateCount PLUS prevVal  \n                ELSE  \n                    SET dpList[outerIdx][diffDelta] TO dpList[outerIdx].GET(diffDelta, 0) PLUS 1  \n                END IF  \n                \n                INCREMENT innerIdx BY 1  \n            END WHILE  \n            INCREMENT outerIdx BY 1  \n        END WHILE  \n        \n        RETURN aggregateCount  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n LESS THAN three  \n            RETURN zero  \n        END IF  \n        \n        SET dp TO a list OF default dictionaries EACH mapping integer TO integer WITH the LENGTH OF n  \n        SET total_count TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                SET d TO the element at position i of nums MINUS the element at position j of nums  \n                \n                IF dp at position j CONTAINS key d  \n                    INCREMENT the value at key d in dp at position i BY the value at key d in dp at position j PLUS one  \n                    INCREMENT total_count BY the value at key d in dp at position j  \n                ELSE  \n                    INCREMENT the value at key d in dp at position i BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ones-and-zeroes", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        DECLARE matrix AS LIST OF LIST OF INTEGER ← LIST CONTAINING (m + 1) ELEMENTS, EACH BEING A LIST OF (n + 1) ZEROS  \n        \n        INDEX ← 0  \n        WHILE INDEX < LENGTH OF strs  \n            STRING currentString ← strs AT INDEX  \n            ZEROES ← 0  \n            ONES ← 0  \n            \n            POSITION ← 0  \n            WHILE POSITION < LENGTH OF currentString  \n                CHARACTER char ← currentString AT POSITION  \n                IF char = '0' THEN  \n                    ZEROES ← ZEROES + 1  \n                ELSE IF char = '1' THEN  \n                    ONES ← ONES + 1  \n                END IF  \n                POSITION ← POSITION + 1  \n            END WHILE  \n            \n            iCounter ← m  \n            WHILE iCounter >= ZEROES  \n                jCounter ← n  \n                REPEAT  \n                    currentVal ← matrix AT iCounter AT jCounter  \n                    candidateVal ← matrix AT (iCounter - ZEROES) AT (jCounter - ONES) + 1  \n                    \n                    IF candidateVal > currentVal THEN  \n                        matrix AT iCounter AT jCounter ← candidateVal  \n                    END IF  \n                    jCounter ← jCounter - 1  \n                UNTIL jCounter < ONES  \n                iCounter ← iCounter - 1  \n            END WHILE  \n            \n            INDEX ← INDEX + 1  \n        END WHILE  \n        \n        RETURN matrix AT m AT n  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        SET dp TO a two dimensional list with the dimensions of m plus one by n plus one where each element is zero  \n        FOR each string s IN strs  \n            SET count_0 TO the number of elements EQUALS to zero in the string s  \n            SET count_1 TO the number of elements EQUALS to one in the string s  \n            FOR variable i FROM m DOWN TO count_0  \n                FOR variable j FROM n DOWN TO count_1  \n                    SET dp at position i and position j TO the maximum value between dp at position i and position j AND the value of dp at position i MINUS count_0 and position j MINUS count_1 PLUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp at position m and position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-window-median", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION medianSlidingWindow(nums k)\n        ASSIGN [] TO alpha\n        ASSIGN [] TO beta\n\n        FUNCTION balance_heaps()\n            WHEN LENGTH(alpha) > LENGTH(beta) + 1:\n                CALL heappush beta NEGATE CALL heappop alpha\n            OTHERWISE WHEN LENGTH(beta) > LENGTH(alpha):\n                CALL heappush alpha NEGATE CALL heappop beta\n            END WHEN\n        END FUNCTION\n\n        FUNCTION add_num(delta)\n            WHEN LENGTH(alpha) = 0 OR delta <= NEGATE alpha[0]:\n                CALL heappush alpha NEGATE delta\n            OTHERWISE:\n                CALL heappush beta delta\n            END WHEN\n            CALL balance_heaps()\n        END FUNCTION\n\n        FUNCTION remove_num(delta)\n            WHEN delta <= NEGATE alpha[0]:\n                DELETE element NEGATE delta FROM alpha\n                WHEN LENGTH(alpha) > 0:\n                    CALL heapify alpha\n                END WHEN\n            OTHERWISE:\n                DELETE element delta FROM beta\n                WHEN LENGTH(beta) > 0:\n                    CALL heapify beta\n                END WHEN\n            END WHEN\n            CALL balance_heaps()\n        END FUNCTION\n\n        FUNCTION get_median()\n            WHEN LENGTH(alpha) > LENGTH(beta):\n                RETURN NEGATE alpha[0]\n            END WHEN\n            RETURN (NEGATE alpha[0] + beta[0]) / 2\n        END FUNCTION\n\n        ASSIGN 0 TO mu\n        WHILE mu < k:\n            CALL add_num nums[mu]\n            ASSIGN mu + 1 TO mu\n        END WHILE\n\n        ASSIGN [get_median()] TO omegas\n\n        ASSIGN k TO pi\n        WHILE NOT (pi >= LENGTH(nums)):\n            CALL add_num nums[pi]\n            CALL remove_num nums[pi - k]\n            APPEND get_median() TO omegas\n            ASSIGN pi + 1 TO pi\n        END WHILE\n\n        RETURN omegas\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION medianSlidingWindow(nums k)  \n        SET lo TO empty list  \n        SET hi TO empty list  \n\n        FUNCTION balance_heaps()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi PLUS one  \n                CALL heappush WITH the argument hi AND NEGATIVE of the result of heappop ON lo  \n            ELSE IF the LENGTH OF hi IS GREATER THAN the LENGTH OF lo  \n                CALL heappush WITH the argument lo AND NEGATIVE of the result of heappop ON hi  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION add_num(num)  \n            IF lo IS empty OR num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                CALL heappush WITH the argument lo AND NEGATIVE num  \n            ELSE  \n                CALL heappush WITH the argument hi AND num  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION remove_num(num)  \n            IF num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                REMOVE NEGATIVE num FROM lo  \n                IF lo IS NOT empty  \n                    CALL heapify WITH the argument lo  \n                END IF  \n            ELSE  \n                REMOVE num FROM hi  \n                IF hi IS NOT empty  \n                    CALL heapify WITH the argument hi  \n                END IF  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION get_median()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi  \n                RETURN NEGATIVE of element at position zero of lo  \n            END IF  \n            RETURN NEGATIVE of element at position zero of lo PLUS element at position zero of hi DIVIDED BY two  \n        END FUNCTION  \n\n        FOR i FROM zero TO k MINUS one  \n            CALL add_num WITH element at position i of nums  \n        END FOR  \n\n        SET medians TO a list containing the result of get_median()  \n\n        FOR i FROM k TO the LENGTH OF nums MINUS one  \n            CALL add_num WITH element at position i of nums  \n            CALL remove_num WITH element at position i MINUS k of nums  \n            APPEND the result of get_median() TO medians  \n        END FOR  \n\n        RETURN medians  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "student-attendance-record-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION checkRecord(n)\n        ASSIGN 1000000000 + 7 TO MOD\n        ASSIGN a list composed of (n + 1) elements, each a list of 2 elements, each a list of 3 zeros TO dp\n        ASSIGN 1 TO dp[0][0][0]\n\n        ASSIGN 1 TO p\n        WHILE p <= n DO\n            ASSIGN 0 TO xq\n            WHILE xq <= 1 DO\n                ASSIGN 0 TO yf\n                WHILE yf <= 2 DO\n                    ASSIGN dp[p][xq][0] + dp[p - 1][xq][yf] TO dp[p][xq][0]\n                    ASSIGN dp[p][xq][0] MOD MOD TO dp[p][xq][0]\n\n                    IF NOT (xq != 0) THEN\n                        ASSIGN dp[p][1][0] + dp[p - 1][0][yf] TO dp[p][1][0]\n                        ASSIGN dp[p][1][0] MOD MOD TO dp[p][1][0]\n                    END IF\n\n                    IF yf < 2 THEN\n                        ASSIGN dp[p][xq][yf + 1] + dp[p - 1][xq][yf] TO dp[p][xq][yf + 1]\n                        ASSIGN dp[p][xq][yf + 1] MOD MOD TO dp[p][xq][yf + 1]\n                    END IF\n\n                    ASSIGN yf + 1 TO yf\n                END WHILE\n                ASSIGN xq + 1 TO xq\n            END WHILE\n            ASSIGN p + 1 TO p\n        END WHILE\n\n        ASSIGN 0 TO summary\n        ASSIGN 0 TO dt\n        WHILE dt <= 1 DO\n            ASSIGN 0 TO jq\n            WHILE jq <= 2 DO\n                ASSIGN (summary + dp[n][dt][jq]) MOD MOD TO summary\n                ASSIGN jq + 1 TO jq\n            END WHILE\n            ASSIGN dt + 1 TO dt\n        END WHILE\n\n        RETURN summary\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION checkRecord(n)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a three dimensional list of zeroes with dimensions n PLUS one BY two BY three  \n        SET element at position zero BY zero BY zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO one  \n                FOR k FROM zero TO two  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp PLUS element at position i MINUS one BY j BY k of dp  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp MODULO MOD  \n                    IF j EQUALS zero  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp PLUS element at position i MINUS one BY zero BY k of dp  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp MODULO MOD  \n                    END IF  \n                    IF k LESS THAN two  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp PLUS element at position i MINUS one BY j BY k of dp  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        SET result TO zero  \n        FOR j FROM zero TO one  \n            FOR k FROM zero TO two  \n                SET result TO result PLUS element at position n BY j BY k of dp  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-closest-palindrome", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET lenCount AS LENGTH OF n  \n        IF lenCount EQUALS 1  \n            SET valNum AS integer VALUE OF n  \n            RETURN string FORM valNum MINUS 1  \n        END IF  \n        \n        SET candSet AS AN EMPTY SET  \n        \n        SET powLen AS 10 TO THE POWER OF lenCount  \n        SET powLenMinusOne AS 10 TO THE POWER OF (lenCount MINUS 1)  \n        \n        ADD (powLen PLUS 1) TO candSet  \n        ADD (powLenMinusOne MINUS 1) TO candSet  \n        \n        SET prefVal AS integer VALUE OF SUBSTRING OF n FROM 1 TO ((lenCount PLUS 1) DIVIDED BY 2)  \n        \n        SET idx AS -1  \n        WHILE idx LESS THAN OR EQUAL TO 1  \n            SET newPrefNum AS prefVal PLUS idx  \n            SET newPrefStr AS string FORM newPrefNum  \n            \n            IF (lenCount MOD 2) EQUALS 0 THEN\n                SET revPart AS REVERSE OF newPrefStr  \n                SET candStr AS newPrefStr CONCATENATED WITH revPart  \n            ELSE  \n                SET subRev AS REVERSE OF SUBSTRING OF newPrefStr FROM 1 TO (LENGTH OF newPrefStr MINUS 1)  \n                SET candStr AS newPrefStr CONCATENATED WITH subRev  \n            END IF  \n            \n            SET candNum AS integer VALUE OF candStr  \n            ADD candNum TO candSet  \n            \n            SET idx AS idx PLUS 1  \n        END WHILE  \n        \n        SET origNum AS integer VALUE OF n  \n        IF candSet CONTAINS origNum THEN\n            REMOVE origNum FROM candSet  \n        END IF  \n        \n        SET bestCandidate AS NULL  \n        SET minDist AS POSITIVE_INFINITY  \n        \n        FOR EACH num IN candSet  \n            SET dist AS ABSOLUTE VALUE OF (num MINUS origNum)  \n            IF (dist LESS THAN minDist) OR (dist EQUALS minDist AND num LESS THAN bestCandidate) THEN\n                SET bestCandidate AS num  \n                SET minDist AS dist  \n            END IF  \n        END FOR  \n        \n        RETURN string FORM bestCandidate  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO integer VALUE OF n  \n            RETURN string REPRESENTATION OF numeric_value MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        SET power_length TO TEN RAISED TO THE power OF length  \n        SET power_length_minus_one TO TEN RAISED TO THE power OF length MINUS one  \n        \n        ADD the VALUE OF power_length PLUS one TO candidates  \n        ADD the VALUE OF power_length_minus_one MINUS one TO candidates  \n        \n        SET prefix TO integer VALUE OF substring FROM position one TO position (length PLUS one) DIVIDED BY two of n  \n        \n        FOR i FROM negative one TO positive one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO string REPRESENTATION OF new_prefix_numeric  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSED STRING OF new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH reversed_part  \n            ELSE  \n                SET substring_reversed TO the REVERSED STRING OF substring FROM position one TO LENGTH OF new_prefix MINUS one of new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH substring_reversed  \n            END IF  \n            \n            SET candidate_numeric TO integer VALUE OF candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO integer VALUE OF n  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO NULL  \n        SET smallest_distance TO INFINITY  \n        FOR each number IN candidates  \n            SET current_distance TO the ABSOLUTE VALUE OF number MINUS original_number  \n            IF current_distance LESS THAN smallest_distance OR (current_distance EQUALS smallest_distance AND number LESS THAN closest)  \n                SET closest TO number  \n                SET smallest_distance TO current_distance  \n            END IF  \n        END FOR  \n        \n        RETURN string REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-operation-for-two-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        ASSIGN length1 ← LENGTH OF word1  \n        ASSIGN length2 ← LENGTH OF word2  \n        \n        CREATE dp AS a list of (length1 PLUS 1) elements, EACH BEING a list of (length2 PLUS 1) zeros  \n        \n        ASSIGN outerCounter ← 1  \n        WHILE outerCounter <= length1  \n            ASSIGN innerCounter ← 1  \n            WHILE innerCounter <= length2  \n                ASSIGN charFromWord1 ← word1[outerCounter MINUS 1]  \n                ASSIGN charFromWord2 ← word2[innerCounter MINUS 1]  \n                \n                IF NOT (charFromWord1 NOT EQUAL TO charFromWord2) THEN  \n                    SET dp[outerCounter][innerCounter] ← dp[outerCounter MINUS 1][innerCounter MINUS 1] PLUS 1  \n                ELSE  \n                    ASSIGN topValue ← dp[outerCounter MINUS 1][innerCounter]  \n                    ASSIGN leftValue ← dp[outerCounter][innerCounter MINUS 1]  \n                    \n                    IF topValue >= leftValue THEN  \n                        SET dp[outerCounter][innerCounter] ← topValue  \n                    ELSE  \n                        SET dp[outerCounter][innerCounter] ← leftValue  \n                    END IF  \n                END IF  \n                \n                INCREMENT innerCounter BY 1  \n            END WHILE  \n            INCREMENT outerCounter BY 1  \n        END WHILE  \n        \n        ASSIGN lcsLength ← dp[length1][length2]  \n        \n        RETURN (length1 MINUS lcsLength) PLUS (length2 MINUS lcsLength)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        SET m TO the LENGTH OF word1  \n        SET n TO the LENGTH OF word2  \n        \n        CREATE a two dimensional list named dp with dimensions m PLUS one and n PLUS one  \n        FOR each index i FROM one TO m  \n            FOR each index j FROM one TO n  \n                IF the element at position i MINUS one of word1 EQUALS the element at position j MINUS one of word2  \n                    SET the element at position i and position j of dp TO the element at position i MINUS one and position j MINUS one of dp PLUS one  \n                ELSE  \n                    SET the element at position i and position j of dp TO the GREATER VALUE BETWEEN the element at position i MINUS one and position j of dp AND the element at position i and position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET lcs_length TO the element at position m and position n of dp  \n        \n        RETURN the value of m MINUS lcs_length PLUS the value of n MINUS lcs_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "solve-the-equation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION solveEquation(equation)\n        FUNCTION parse_side(side)\n            SET delimiter TO '#'\n            SET modified_side TO side\n            SET modified_side TO REPLACE all occurrences of '+' in modified_side WITH delimiter concatenated with '+'\n            SET modified_side TO REPLACE all occurrences of '-' in modified_side WITH delimiter concatenated with '-'\n            SET tokens_list TO SPLIT modified_side BY delimiter\n\n            SET coefficient_x TO 0\n            SET total_number TO 0\n\n            SET position TO 0\n            WHILE position < LENGTH(tokens_list)\n                SET element TO tokens_list[position]\n                IF element = '' THEN\n                    SET position TO position + 1\n                    CONTINUE\n                END IF\n\n                SET contains_x TO FALSE\n                SET char_index TO 0\n                WHILE char_index < LENGTH(element)\n                    IF element[char_index] = 'x' THEN\n                        SET contains_x TO TRUE\n                        BREAK\n                    END IF\n                    SET char_index TO char_index + 1\n                END WHILE\n\n                IF contains_x THEN\n                    SWITCH element\n                        CASE 'x':\n                            SET coefficient_x TO coefficient_x + 1\n                        CASE '+x':\n                            SET coefficient_x TO coefficient_x + 1\n                        CASE '-x':\n                            SET coefficient_x TO coefficient_x - 1\n                        DEFAULT:\n                            SET extracted_number TO SUBSTRING(element, 0, LENGTH(element) - 1)\n                            SET coefficient_x TO coefficient_x + TO_INTEGER(extracted_number)\n                    END SWITCH\n                ELSE\n                    SET total_number TO total_number + TO_INTEGER(element)\n                END IF\n\n                SET position TO position + 1\n            END WHILE\n\n            RETURN coefficient_x, total_number\n        END FUNCTION\n\n        SET parts TO SPLIT(equation, '=')\n        SET left_part TO parts[0]\n        SET right_part TO parts[1]\n\n        SET left_coefficient, left_sum TO parse_side(left_part)\n        SET right_coefficient, right_sum TO parse_side(right_part)\n\n        SET net_coefficient TO left_coefficient - right_coefficient\n        SET net_sum TO right_sum - left_sum\n\n        IF NOT (net_coefficient <> 0) THEN\n            IF NOT (net_sum <> 0) THEN\n                RETURN \"Infinite solutions\"\n            ELSE\n                RETURN \"No solution\"\n            END IF\n        ELSE\n            RETURN CONCAT(\"x=\", TO_STRING(net_sum DIV net_coefficient))\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION solveEquation(equation)  \n        FUNCTION parse_side(side)  \n            SET tokens TO the result of replacing plus signs in side with delimiter plus sign and replacing minus signs in side with delimiter minus sign and splitting the resulting string by the delimiter  \n            SET x_count TO zero  \n            SET num_sum TO zero  \n            FOR each token IN tokens  \n                IF token is an empty string THEN  \n                    CONTINUE to the next token  \n                END IF  \n                IF the character x exists in token THEN  \n                    IF token is equal to x OR token is equal to plus sign followed by x THEN  \n                        INCREMENT x_count BY one  \n                    ELSE IF token is equal to minus sign followed by x THEN  \n                        DECREMENT x_count BY one  \n                    ELSE  \n                        INCREMENT x_count BY the integer value of token with character x removed  \n                    END IF  \n                ELSE  \n                    INCREMENT num_sum BY the integer value of token  \n                END IF  \n            END FOR  \n            RETURN x_count and num_sum  \n        END FUNCTION  \n\n        SET left_side and right_side TO the parts of equation separated by the equal sign  \n        SET left_x and left_num TO the result of calling parse_side with left_side  \n        SET right_x and right_num TO the result of calling parse_side with right_side  \n\n        SET total_x TO left_x MINUS right_x  \n        SET total_num TO right_num MINUS left_num  \n\n        IF total_x EQUALS zero THEN  \n            IF total_num EQUALS zero THEN  \n                RETURN the string Infinite solutions  \n            ELSE  \n                RETURN the string No solution  \n            END IF  \n        ELSE  \n            RETURN the string formed by the character x equals the integer result of total_num DIVIDED BY total_x  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET length_s1 AS LENGTH OF s1  \n        SET length_s2 AS LENGTH OF s2  \n        \n        DECLARE dp AS LIST OF LISTS WITH (length_s1 + 1) ROWS AND (length_s2 + 1) COLUMNS FILLED WITH 0  \n        \n        SET idx_col TO 1  \n        WHILE idx_col <= length_s2  \n            LET previous_value BE dp[0][idx_col - 1]  \n            LET ascii_code BE ASCII OF s2[idx_col - 1]  \n            dp[0][idx_col] ← previous_value + ascii_code  \n            idx_col ← idx_col + 1  \n        END WHILE  \n        \n        SET idx_row TO 1  \n        WHILE idx_row <= length_s1  \n            LET previous_value_row BE dp[idx_row - 1][0]  \n            LET ascii_code_row BE ASCII OF s1[idx_row - 1]  \n            dp[idx_row][0] ← previous_value_row + ascii_code_row  \n            idx_row ← idx_row + 1  \n        END WHILE  \n        \n        SET outer_index TO 1  \n        WHILE outer_index <= length_s1  \n            SET inner_index TO 1  \n            WHILE inner_index <= length_s2  \n                LET char_s1 BE s1[outer_index - 1]  \n                LET char_s2 BE s2[inner_index - 1]  \n                IF char_s1 ≠ char_s2 THEN\n                    LET deletion_s1 COST ← dp[outer_index - 1][inner_index] + ASCII OF char_s1  \n                    LET deletion_s2 COST ← dp[outer_index][inner_index - 1] + ASCII OF char_s2  \n                    LET dp[outer_index][inner_index] BE MINIMUM OF deletion_s1 COST AND deletion_s2 COST  \n                ELSE  \n                    LET dp[outer_index][inner_index] BE dp[outer_index - 1][inner_index - 1]  \n                END IF  \n                inner_index ← inner_index + 1  \n            END WHILE  \n            outer_index ← outer_index + 1  \n        END WHILE  \n        \n        RETURN dp[length_s1][length_s2]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        DEFINE index AS 0  \n        SORT words USING a comparator THAT prioritizes shorter LENGTH first, THEN lex ORDER ascending  \n        INITIALIZE valid_words AS an empty set  \n        INITIALIZE longest_word AS empty string \"\"  \n  \n        WHILE index < LENGTH(words)  \n            LET candidate_word = words[index]  \n            LET candidate_length = LENGTH(candidate_word)  \n            LET prefix_word = candidate_word[0 : candidate_length - 1]  \n  \n            IF NOT (candidate_length ≠ 1 OR prefix_word ∈ valid_words) THEN  \n                INCREMENT index BY 1  \n                CONTINUE  \n            END IF  \n  \n            ADD candidate_word TO valid_words  \n  \n            IF LENGTH(longest_word) < candidate_length THEN  \n                longest_word ← candidate_word  \n            END IF  \n  \n            index ← index + 1  \n        END WHILE  \n  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN LEXICOGRAPHICAL ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO an empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from position one TO position LENGTH OF word MINUS one IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-different-palindromic-subsequences", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences WITH PARAMETER s  \n        DECLARE MOD AS 1000000007  \n        DECLARE length_s AS LENGTH OF s  \n        \n        DECLARE next_occurrence AS LIST CONTAINING 4 ELEMENTS EACH INITIALIZED TO LIST OF length_s ELEMENTS SET TO -1  \n        DECLARE prev_occurrence AS LIST CONTAINING 4 ELEMENTS EACH INITIALIZED TO LIST OF length_s ELEMENTS SET TO -1  \n        \n        SET index_c TO 0  \n        WHILE index_c LESS THAN 4 DO  \n            SET current_char TO CHARACTER AT (ASCII('a') + index_c)  \n            SET last_seen TO -1  \n            \n            SET pos_idx TO 0  \n            WHILE pos_idx LESS THAN length_s DO  \n                IF s ELEMENT AT pos_idx EQUALS current_char THEN  \n                    SET last_seen TO pos_idx  \n                END IF  \n                SET prev_occurrence[index_c][pos_idx] TO last_seen  \n                INCREMENT pos_idx BY 1  \n            END WHILE  \n            \n            SET last_seen TO -1  \n            SET pos_idx TO length_s - 1  \n            WHILE pos_idx GREATER OR EQUAL TO 0 DO  \n                IF s ELEMENT AT pos_idx EQUALS current_char THEN  \n                    SET last_seen TO pos_idx  \n                END IF  \n                SET next_occurrence[index_c][pos_idx] TO last_seen  \n                DECREMENT pos_idx BY 1  \n            END WHILE  \n            \n            INCREMENT index_c BY 1  \n        END WHILE  \n        \n        DECLARE dp AS LIST OF length_s ELEMENTS EACH BEING A LIST OF length_s ELEMENTS SET TO 0  \n        \n        SET diag_idx TO 0  \n        WHILE diag_idx LESS THAN length_s DO  \n            SET dp[diag_idx][diag_idx] TO 1  \n            INCREMENT diag_idx BY 1  \n        END WHILE  \n        \n        SET current_len TO 2  \n        WHILE current_len LESS OR EQUAL TO length_s DO  \n            SET start_pos TO 0  \n            WHILE start_pos + current_len - 1 LESS THAN length_s DO  \n                SET end_pos TO start_pos + current_len - 1  \n                SET color_code TO 0  \n                WHILE color_code LESS THAN 4 DO  \n                    SET current_char TO CHARACTER AT (ASCII('a') + color_code)  \n                    SET left_idx TO next_occurrence[color_code][start_pos]  \n                    SET right_idx TO prev_occurrence[color_code][end_pos]  \n                    \n                    IF left_idx GREATER THAN end_pos OR right_idx LESS THAN start_pos THEN  \n                        # skip this iteration  \n                    ELSE  \n                        IF left_idx EQUALS right_idx THEN  \n                            SET dp[start_pos][end_pos] TO (dp[start_pos][end_pos] + 1) MOD MOD  \n                        ELSE  \n                            DECLARE addition AS dp[left_idx + 1][right_idx - 1]  \n                            dp[start_pos][end_pos] ← (dp[start_pos][end_pos] + addition + 2) MOD MOD  \n                        END IF  \n                    END IF  \n                    \n                    INCREMENT color_code BY 1  \n                END WHILE  \n                INCREMENT start_pos BY 1  \n            END WHILE  \n            INCREMENT current_len BY 1  \n        END WHILE  \n        \n        RETURN dp[0][length_s - 1]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences WITH PARAMETER s  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        \n        SET next_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        SET prev_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        \n        FOR each c FROM zero TO three  \n            SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n            SET last TO negative one  \n            FOR each i FROM zero TO n MINUS one  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of prev_occurrence TO last  \n            END FOR  \n            \n            SET last TO negative one  \n            FOR each i FROM n MINUS one DOWN TO zero  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of next_occurrence TO last  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a two dimensional list of n lists each containing n times zero  \n        \n        FOR each i FROM zero TO n MINUS one  \n            SET element at position i of element at position i of dp TO one  \n        END FOR  \n        \n        FOR each length FROM two TO n  \n            FOR each i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                FOR each c FROM zero TO three  \n                    SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n                    SET left TO element at position i of element at position c of next_occurrence  \n                    SET right TO element at position j of element at position c of prev_occurrence  \n                    \n                    IF left GREATER THAN j OR right LESS THAN i THEN  \n                        CONTINUE TO next iteration of the innermost loop  \n                    ELSE IF left EQUALS right THEN  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS one is divided by MOD  \n                    ELSE  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS element at position left PLUS one of element at position right MINUS one of dp PLUS two is divided by MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero of element at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pour-water", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers\n        ASSIGN n TO LENGTH(heights)\n\n        SET stepCounter TO 1\n        WHILE stepCounter LESS THAN OR EQUAL TO volume\n            ASSIGN cursor TO k\n\n            WHILE NOT (cursor EQUALS 0 OR heights[cursor - 1] GREATER THAN heights[cursor])\n                SUBTRACT 1 FROM cursor\n            END WHILE\n\n            WHILE NOT (cursor EQUALS k OR heights[cursor] NOT EQUAL heights[cursor + 1])\n                ADD 1 TO cursor\n            END WHILE\n\n            IF NOT cursor GREATER OR EQUAL k THEN\n                ASSIGN prevHeight TO heights[cursor]\n                ASSIGN updatedHeight TO prevHeight + 1\n                ASSIGN heights[cursor] TO updatedHeight\n                ADD 1 TO stepCounter\n                CONTINUE TO NEXT iteration of WHILE\n            END IF\n\n            ASSIGN cursor TO k\n\n            WHILE NOT (cursor EQUALS n - 1 OR heights[cursor + 1] GREATER THAN heights[cursor])\n                ADD 1 TO cursor\n            END WHILE\n\n            WHILE NOT (cursor EQUALS k OR heights[cursor] NOT EQUAL heights[cursor - 1])\n                SUBTRACT 1 FROM cursor\n            END WHILE\n\n            IF cursor GREATER THAN k THEN\n                ASSIGN baseHeight TO heights[cursor]\n                ASSIGN incrementedHeight TO baseHeight + 1\n                ASSIGN heights[cursor] TO incrementedHeight\n                ADD 1 TO stepCounter\n                CONTINUE TO NEXT iteration of WHILE\n            END IF\n\n            ASSIGN currentHeight TO heights[k]\n            ASSIGN newHeight TO currentHeight + 1\n            ASSIGN heights[k] TO newHeight\n\n            ADD 1 TO stepCounter\n        END WHILE\n\n        RETURN heights\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN zero AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            INCREMENT element at position k of heights BY one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-symbol-in-grammar", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION kthGrammar(n k)  \n        WHILE TRUE  \n            IF n IS 1 THEN  \n                RETURN 0  \n            END IF  \n            ASSIGN (2 ^ (n - 1)) TO temp_length  \n            ASSIGN temp_length TO half_length  \n            IF k <= half_length THEN  \n                ASSIGN n - 1 TO next_n  \n                RETURN kthGrammar(next_n k)  \n            ELSE  \n                ASSIGN n - 1 TO prev_n  \n                ASSIGN k - half_length TO index_offset  \n                ASSIGN kthGrammar(prev_n index_offset) TO prev_val  \n                ASSIGN 1 - prev_val TO result_val  \n                RETURN result_val  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthGrammar(n k)  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET length_of_previous_row TO two MULTIPLIED BY two RAISED TO THE POWER OF n MINUS two MINUS one  \n        IF k LESS THAN OR EQUAL TO length_of_previous_row  \n            RETURN call kthGrammar WITH n MINUS one AND k  \n        ELSE  \n            SET previous_value TO call kthGrammar WITH n MINUS one AND k MINUS length_of_previous_row  \n            SET complement_value TO one MINUS previous_value  \n            RETURN complement_value  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-smallest-prime-fraction", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION kthSmallestPrimeFraction(arr, k)\n        LET totalElements BE LENGTH(arr)\n        LET heapElements BE an EMPTY LIST\n\n        LET indexCounter BE 0\n        WHILE indexCounter < totalElements - 1\n            LET fractionValue BE arr[indexCounter] DIVIDED_BY arr[totalElements - 1]\n            INSERT (fractionValue, indexCounter, totalElements - 1) INTO heapElements\n            SET indexCounter TO indexCounter + 1\n        END WHILE\n\n        LET iterationCounter BE 0\n        WHILE iterationCounter < k - 1\n            EXTRACT_MIN FROM heapElements INTO (_, idxA, idxB)\n            IF (idxB - 1) > idxA THEN\n                LET newFraction BE arr[idxA] DIVIDED_BY arr[idxB - 1]\n                INSERT (newFraction, idxA, idxB - 1) INTO heapElements\n            END IF\n            SET iterationCounter TO iterationCounter + 1\n        END WHILE\n\n        EXTRACT_MIN FROM heapElements INTO (_, finalI, finalJ)\n        RETURN [arr[finalI], arr[finalJ]]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallestPrimeFraction(arr, k)  \n        SET n TO the LENGTH OF arr  \n        SET min_heap TO an empty list  \n        FOR i FROM zero TO n MINUS one MINUS one  \n            PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position n MINUS one of arr AND i AND n MINUS one  \n        END FOR  \n        FOR iteration FROM zero TO k MINUS one MINUS one  \n            POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n            IF j MINUS one IS GREATER THAN i THEN  \n                PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position j MINUS one of arr AND i AND j MINUS one  \n            END IF  \n        END FOR  \n        POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n        RETURN a list containing element at position i of arr AND element at position j of arr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD to 1_000_000_007  \n        \n        SET dp AS a list initialized with zeros, size n PLUS 1  \n        SET dp1 AS a list initialized with zeros, size n PLUS 1  \n        \n        ASSIGN 1 TO dp[0]  \n        ASSIGN 1 TO dp[1]  \n        IF n LESS THAN 2 THEN  \n            GOTO after_initialization  \n        ELSE  \n            ASSIGN 2 TO dp[2]  \n            ASSIGN 1 TO dp1[2]  \n        END IF  \n        LABEL after_initialization  \n        \n        SET index TO 3  \n        WHILE index LESS THAN OR EQUAL TO n DO  \n            SET part1 TO (dp[index - 1] + dp[index - 2]) MOD MOD  \n            SET part2 TO (2 * dp1[index - 1]) MOD MOD  \n            ASSIGN (part1 + part2) MOD MOD TO dp[index]  \n            \n            SET dp1[index] TO ((dp[index - 2] + dp1[index - 1]) MOD MOD)  \n            INCREMENT index BY 1  \n        END WHILE  \n        \n        RETURN dp[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO the one billion PLUS seven  \n        \n        SET dp TO a list of zeros with LENGTH n PLUS one  \n        SET dp1 TO a list of zeros with LENGTH n PLUS one  \n        \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder of the sum of element at position i MINUS one of dp PLUS element at position i MINUS two of dp PLUS two MULTIPLIED BY element at position i MINUS one of dp1 when divided by MOD  \n            SET element at position i of dp1 TO the remainder of the sum of element at position i MINUS two of dp PLUS element at position i MINUS one of dp1 when divided by MOD  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-tic-tac-toe-state", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION validTicTacToe(board)\n        SET tallyAlpha TO 0\n        SET lineBuffer TO 0\n\n        WHILE lineBuffer LESS THAN LENGTH(board)\n            SET currentLine TO board[lineBuffer]\n            SET idxChar TO 0\n            WHILE idxChar LESS THAN LENGTH(currentLine)\n                IF currentLine[idxChar] EQUALS 'X'\n                    SET tallyAlpha TO tallyAlpha + 1\n                END IF\n                SET idxChar TO idxChar + 1\n            END WHILE\n            SET lineBuffer TO lineBuffer + 1\n        END WHILE\n\n        SET tallyBeta TO 0\n        SET scanRow TO 0\n\n        WHILE scanRow LESS THAN LENGTH(board)\n            SET currentSequence TO board[scanRow]\n            SET posChar TO 0\n            LOOP\n                IF posChar GREATER THAN OR EQUAL TO LENGTH(currentSequence)\n                    BREAK\n                END IF\n                IF currentSequence[posChar] EQUALS 'O'\n                    SET tallyBeta TO tallyBeta + 1\n                END IF\n                SET posChar TO posChar + 1\n            END LOOP\n            SET scanRow TO scanRow + 1\n        END WHILE\n\n        IF NOT (tallyAlpha GREATER THAN OR EQUAL TO tallyBeta AND tallyAlpha LESS THAN OR EQUAL TO tallyBeta + 1)\n            RETURN False\n        END IF\n\n        FUNCTION check_win(player)\n            SET lineIndex TO 0\n            WHILE lineIndex LESS THAN LENGTH(board)\n                SET candidateRow TO board[lineIndex]\n                IF candidateRow EQUALS player + player + player\n                    RETURN True\n                END IF\n                SET lineIndex TO lineIndex + 1\n            END WHILE\n\n            SET columnIndex TO 0\n            WHILE columnIndex LESS THAN 3\n                IF board[0][columnIndex] EQUALS player\n                   AND board[1][columnIndex] EQUALS player\n                   AND board[2][columnIndex] EQUALS player\n                    RETURN True\n                END IF\n                SET columnIndex TO columnIndex + 1\n            END WHILE\n\n            IF board[0][0] EQUALS player\n               AND board[1][1] EQUALS player\n               AND board[2][2] EQUALS player\n                RETURN True\n            END IF\n\n            IF board[0][2] EQUALS player\n               AND board[1][1] EQUALS player\n               AND board[2][0] EQUALS player\n                RETURN True\n            END IF\n\n            RETURN False\n        END FUNCTION\n\n        SET victoriousX TO check_win('X')\n        SET victoriousO TO check_win('O')\n\n        SELECT\n            CASE victoriousX AND victoriousO\n                RETURN False\n            CASE victoriousX AND (tallyAlpha EQUALS tallyBeta)\n                RETURN False\n            CASE victoriousO AND (tallyAlpha NOT EQUALS tallyBeta)\n                RETURN False\n            DEFAULT\n                RETURN True\n        END SELECT\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "race-car", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION racecar(target)  \n        DECLARE sequence ← new double ended queue containing [(0, 1, 0)]  \n        DECLARE visited ← empty set  \n        INSERT (0, 1) INTO visited  \n        \n        LOOP indefinitely  \n            IF sequence IS empty THEN BREAK  \n            END IF  \n            \n            POP (current_pos, current_spd, current_steps) FROM the front of sequence  \n            \n            SWITCH  \n                CASE current_pos = target:  \n                    RETURN current_steps  \n                DEFAULT:  \n                    CONTINUE  \n            END SWITCH  \n            \n            SET projected_pos TO current_pos + current_spd  \n            SET projected_spd TO current_spd × 2  \n            \n            IF NOT ((projected_pos, projected_spd) IN visited) AND 0 ≤ projected_pos < (2 × target) THEN  \n                INSERT (projected_pos, projected_spd) INTO visited  \n                ENQUEUE (projected_pos, projected_spd, current_steps + 1) TO the rear of sequence  \n            END IF  \n            \n            DECLARE alt_spd  \n            IF current_spd > 0 THEN  \n                alt_spd ← -1  \n            ELSE  \n                alt_spd ← +1  \n            END IF  \n            \n            IF NOT ((current_pos, alt_spd) IN visited) AND 0 ≤ current_pos < (2 × target) THEN  \n                INSERT (current_pos, alt_spd) INTO visited  \n                ENQUEUE (current_pos, alt_spd, current_steps + 1) TO the rear of sequence  \n            END IF  \n        END LOOP  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION racecar(target)  \n        ASSIGN reference TO a new double ended queue containing a single tuple of zero for position one for speed and zero for steps  \n        ASSIGN reference TO a new empty set  \n        ADD a tuple of zero for position and one for speed TO the set  \n        \n        WHILE the queue is not empty  \n            REMOVE and ASSIGN a tuple from the left side of the queue TO position speed and steps  \n            \n            IF position EQUALS target  \n                RETURN steps  \n            END IF  \n            \n            SET next_position TO position PLUS speed  \n            SET next_speed TO speed MULTIPLIED BY two  \n            IF the tuple of next_position and next_speed NOT IN the set AND next_position IS GREATER THAN OR EQUAL TO zero AND next_position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of next_position and next_speed TO the set  \n                APPEND the tuple of next_position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n            \n            IF speed IS GREATER THAN zero  \n                SET next_speed TO negative one  \n            ELSE  \n                SET next_speed TO one  \n            END IF  \n            IF the tuple of position and next_speed NOT IN the set AND position IS GREATER THAN OR EQUAL TO zero AND position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of position and next_speed TO the set  \n                APPEND the tuple of position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "new-21-game", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION new21Game(n INTEGER, k INTEGER, maxPts INTEGER) RETURNS FLOAT\n        FUNCTION dfs(pos INTEGER) RETURNS FLOAT\n            SWITCH TRUE\n                CASE pos >= k:\n                    RETURN 1.0 IF pos <= n ELSE 0.0\n                CASE pos = k - 1:\n                    LET coverage FLOAT = n - k + 1\n                    RETURN coverage / maxPts IF coverage < maxPts ELSE 1.0\n            END SWITCH\n\n            LET valStart FLOAT = dfs(pos + 1)\n            LET valEnd FLOAT = dfs(pos + maxPts + 1)\n            LET outcome FLOAT = valStart + (valStart - valEnd) / maxPts\n            RETURN outcome\n        END FUNCTION\n\n        RETURN dfs(0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION new21Game(n INTEGER PARAMETER k INTEGER PARAMETER maxPts INTEGER PARAMETER) RETURNS FLOAT  \n        FUNCTION dfs(i INTEGER PARAMETER) RETURNS FLOAT  \n            IF i GREATER THAN OR EQUAL TO k THEN  \n                IF i LESS THAN OR EQUAL TO n THEN  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF i EQUALS k MINUS one THEN  \n                IF n MINUS k PLUS one LESS THAN maxPts THEN  \n                    RETURN (n MINUS k PLUS one) DIVIDED BY maxPts  \n                ELSE  \n                    RETURN one  \n                END IF  \n            END IF  \n            SET first_call TO dfs(i PLUS one)  \n            SET second_call TO dfs(i PLUS maxPts PLUS one)  \n            SET result TO first_call PLUS (first_call MINUS second_call) DIVIDED BY maxPts  \n            RETURN result  \n        END FUNCTION  \n        RETURN dfs(zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "magic-squares-in-grid", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numMagicSquaresInside(grid)  \n        FUNCTION is_magic(i, j)  \n            IF grid[i][j] ≠ 5 THEN  \n                RETURN False  \n            END IF  \n\n            SET unique_values AS empty set  \n            SET a AS i - 1  \n            WHILE a ≤ i + 1 DO  \n                SET b AS j - 1  \n                WHILE b ≤ j + 1 DO  \n                    SET val AS grid[a][b]  \n                    IF val < 1 OR val > 9 OR val IN unique_values THEN  \n                        RETURN False  \n                    END IF  \n                    INSERT val INTO unique_values  \n                    b ← b + 1  \n                END WHILE  \n                a ← a + 1  \n            END WHILE  \n\n            SET c AS i - 1  \n            REPEAT UNTIL c > i + 1  \n                SET row_sum AS grid[c][j - 1] + grid[c][j] + grid[c][j + 1]  \n                SET col_sum AS grid[i - 1][c] + grid[i][c] + grid[i + 1][c]  \n\n                IF row_sum ≠ 15 THEN  \n                    RETURN False  \n                ELSE IF col_sum ≠ 15 THEN  \n                    RETURN False  \n                END IF  \n\n                c ← c + 1  \n            END REPEAT  \n\n            SWITCH TRUE  \n                CASE grid[i - 1][j - 1] + grid[i][j] + grid[i + 1][j + 1] ≠ 15:  \n                    RETURN False  \n                CASE grid[i - 1][j + 1] + grid[i][j] + grid[i + 1][j - 1] ≠ 15:  \n                    RETURN False  \n            END SWITCH  \n\n            RETURN True  \n        END FUNCTION  \n\n        SET total_count AS 0  \n        SET row_count AS LENGTH(grid)  \n        SET column_count AS LENGTH(grid[0])  \n        SET idx_i AS 1  \n        WHILE idx_i < row_count - 1 DO  \n            SET idx_j AS 1  \n            WHILE idx_j < column_count - 1 DO  \n                IF is_magic(idx_i, idx_j) THEN  \n                    total_count ← total_count + 1  \n                END IF  \n                idx_j ← idx_j + 1  \n            END WHILE  \n            idx_i ← idx_i + 1  \n        END WHILE  \n\n        RETURN total_count  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numMagicSquaresInside(grid)  \n        FUNCTION is_magic(i, j)  \n            IF element at position i of grid at position j NOT EQUALS five  \n                RETURN False  \n            END IF  \n            SET numbers TO empty set  \n            FOR x FROM i MINUS one TO i PLUS one  \n                FOR y FROM j MINUS one TO j PLUS one  \n                    IF element at position x of grid at position y LESS THAN one OR element at position x of grid at position y GREATER THAN nine OR element at position x of grid at position y IN numbers  \n                        RETURN False  \n                    END IF  \n                    ADD element at position x of grid at position y TO numbers  \n                END FOR  \n            END FOR  \n            FOR start FROM i MINUS one TO i PLUS one  \n                IF sum of element at position start of grid at position j MINUS one PLUS element at position start of grid at position j PLUS element at position start of grid at position j PLUS one NOT EQUALS fifteen OR sum of element at position i MINUS one of grid at position start PLUS element at position i of grid at position start PLUS element at position i PLUS one of grid at position start NOT EQUALS fifteen  \n                    RETURN False  \n                END IF  \n            END FOR  \n            IF sum of element at position i MINUS one of grid at position j MINUS one PLUS element at position i of grid at position j PLUS element at position i PLUS one of grid at position j PLUS one NOT EQUALS fifteen OR sum of element at position i MINUS one of grid at position j PLUS one PLUS element at position i of grid at position j PLUS element at position i PLUS one of grid at position j MINUS one NOT EQUALS fifteen  \n                RETURN False  \n            END IF  \n            RETURN True  \n        END FUNCTION  \n        SET count TO zero  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        FOR i FROM one TO rows MINUS one  \n            FOR j FROM one TO cols MINUS one  \n                IF is_magic(i, j)  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n\tFUNCTION rectangleArea(rectangles)\n\t\tASSIGN (10 ^ 9) PLUS 1 TO moduloLimit\n\n\t\tDECLARE verticalPositions AS empty associative array\n\t\tLOOP THROUGH rect IN rectangles:\n\t\t\tverticalPositions[rect[1]] = TRUE\n\t\t\tverticalPositions[rect[3]] = TRUE\n\t\tEND LOOP\n\n\t\tCONVERT verticalPositions KEYS TO ARRAY AS sortedVerticals\n\t\tSORT sortedVerticals BY ASCENDING ORDER\n\n\t\tDECLARE lookupIndices AS empty map\n\t\tSET positionTracker TO 0\n\t\tWHILE positionTracker < LENGTH OF sortedVerticals\n\t\t\tlookupIndices[sortedVerticals[positionTracker]] = positionTracker\n\t\t\tSET positionTracker TO positionTracker + 1\n\t\tEND WHILE\n\n\t\tDECLARE coverage AS ARRAY OF LENGTH LENGTH OF sortedVerticals FILLED WITH 0\n\t\tDECLARE lineEvents AS empty array\n\n\t\tSET pointer TO 0\n\t\twhile pointer < LENGTH OF rectangles:\n\t\t\tASSIGN rectangles[pointer][0], rectangles[pointer][1], rectangles[pointer][2], rectangles[pointer][3] TO a, b, c, d\n\t\t\tAPPEND (a, 1, b, d) TO lineEvents\n\t\t\tAPPEND (c, -1, b, d) TO lineEvents\n\t\t\tSET pointer TO pointer + 1\n\t\tEND WHILE\n\n\t\tSORT lineEvents ACCORDING TO EVENT[0] IN ASCENDING ORDER\n\n\t\tSET priorX TO 0\n\t\tASSIGN 0 TO totalArea\n\n\t\tDECLARE eventCounter TO 0\n\t\tWHILE eventCounter < LENGTH OF lineEvents:\n\t\t\tASSIGN lineEvents[eventCounter] TO currX, evtType, ypos1, ypos2\n\n\t\t\tASSIGN 0 TO cumLength\n\t\t\tDECLARE idx TO 1\n\t\t\tWHILE idx < LENGTH OF coverage\n\t\t\t\tIF coverage[idx - 1] > 0 THEN\n\t\t\t\t\tASSIGN sortedVerticals[idx] - sortedVerticals[idx - 1] TO segmentLength\n\t\t\t\t\tASSIGN cumLength + segmentLength TO cumLength\n\t\t\t\tEND IF\n\t\t\t\tSET idx TO idx + 1\n\t\t\tEND WHILE\n\n\t\t\tASSIGN totalArea + cumLength * (currX - priorX) TO totalArea\n\t\t\tASSIGN totalArea MOD moduloLimit TO totalArea\n\n\t\t\tASSIGN lookupIndices[ypos1] TO startPos\n\t\t\tASSIGN lookupIndices[ypos2] TO endPos\n\t\t\tASSIGN startPos TO modifyIdx\n\n\t\t\tWHILE modifyIdx < endPos\n\t\t\t\tIF evtType EQUALS 1 THEN\n\t\t\t\t\tcoverage[modifyIdx] = coverage[modifyIdx] + 1\n\t\t\t\tELSE\n\t\t\t\t\tcoverage[modifyIdx] = coverage[modifyIdx] - 1\n\t\t\t\tEND IF\n\t\t\t\tSET modifyIdx TO modifyIdx + 1\n\t\t\tEND WHILE\n\n\t\t\tSET priorX TO currX\n\t\t\tSET eventCounter TO eventCounter + 1\n\t\tEND WHILE\n\n\t\tYIELD totalArea\n\tEND FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION rectangleArea(rectangles)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET y_coords TO an empty set  \n        FOR each quadruple x1 y1 x2 y2 IN rectangles  \n            ADD y1 TO y_coords  \n            ADD y2 TO y_coords  \n        END FOR  \n        SET y_coords TO the sorted list of y_coords  \n        SET y_index TO an empty dictionary  \n        FOR each index i AND value y IN the enumeration of y_coords  \n            SET element at position y of y_index TO i  \n        END FOR  \n        SET count TO a list of zeros with the length equal to the length of y_coords  \n        SET events TO an empty list  \n        FOR each quadruple x1 y1 x2 y2 IN rectangles  \n            APPEND a tuple of x1 one y1 y2 TO events  \n            APPEND a tuple of x2 minus one y1 y2 TO events  \n        END FOR  \n        SORT events by the first element of each tuple in ascending order  \n        SET prev_x TO zero  \n        SET area TO zero  \n        FOR each tuple x eventType y1 y2 IN events  \n            SET current_length TO zero  \n            FOR integer i FROM one TO the length of count MINUS one  \n                IF the element at position i MINUS one of count is GREATER THAN zero  \n                    INCREMENT current_length BY the element at position i of y_coords MINUS the element at position i MINUS one of y_coords  \n                END IF  \n            END FOR  \n            INCREMENT area BY current_length MULTIPLIED BY x MINUS prev_x  \n            SET area TO area MODULO MOD  \n            IF eventType EQUALS one  \n                FOR integer i FROM the element at position y1 of y_index TO the element at position y2 MINUS one of y_index  \n                    INCREMENT the element at position i of count BY one  \n                END FOR  \n            ELSE  \n                FOR integer i FROM the element at position y1 of y_index TO the element at position y2 MINUS one of y_index  \n                    DECREMENT the element at position i of count BY one  \n                END FOR  \n            END IF  \n            SET prev_x TO x  \n        END FOR  \n        RETURN area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "car-fleet", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION carFleet(target, position, speed)  \n        SET combinedPairs AS EMPTY LIST  \n        SET idx TO 0  \n        WHILE idx LESS THAN LENGTH OF position  \n            APPEND (position[idx], speed[idx]) TO combinedPairs  \n            INCREMENT idx BY 1  \n        END WHILE  \n\n        SORT combinedPairs BY FIRST ELEMENT DESCENDING  \n\n        SET arrivalTimes AS EMPTY LIST  \n        SET pairIndex TO 0  \n        WHILE pairIndex LESS THAN LENGTH OF combinedPairs  \n            LET loc BE combinedPairs[pairIndex][0]  \n            LET vel BE combinedPairs[pairIndex][1]  \n            LET timeVal BE (target MINUS loc) DIVIDED BY vel  \n            APPEND timeVal TO arrivalTimes  \n            INCREMENT pairIndex BY 1  \n        END WHILE  \n\n        SET fleetCount TO 0  \n        SET maxObservedTime TO 0  \n\n        SET timeIdx TO 0  \n        WHILE timeIdx LESS THAN LENGTH OF arrivalTimes  \n            LET currentTime BE arrivalTimes[timeIdx]  \n            IF NOT (currentTime LESS OR EQUAL maxObservedTime) THEN  \n                SET maxObservedTime TO currentTime  \n                SET fleetCount TO fleetCount PLUS 1  \n            END IF  \n            INCREMENT timeIdx BY 1  \n        END WHILE  \n\n        RETURN fleetCount  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION carFleet(target position speed)  \n        SET paired_list TO the list of elements obtained by pairing each element at each position in position WITH the element at the corresponding position in speed  \n        SORT paired_list in order from the greatest element of the first component to the smallest element of the first component  \n\n        SET time_to_target TO an empty list  \n        FOR each pair IN paired_list  \n            SET p TO the first component of pair  \n            SET s TO the second component of pair  \n            SET time TO target MINUS p DIVIDED BY s  \n            APPEND time TO time_to_target  \n        END FOR  \n\n        SET fleets TO zero  \n        SET current_max_time TO zero  \n\n        FOR each time IN time_to_target  \n            IF time GREATER THAN current_max_time  \n                INCREMENT fleets BY one  \n                SET current_max_time TO time  \n            END IF  \n        END FOR  \n\n        RETURN fleets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-subsequence-widths", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION sumSubseqWidths(nums)\n        ASSIGN 1000000000 PLUS 7 TO MOD\n        EXECUTE nums SORTED ASCENDING AND ASSIGN BACK TO nums\n        ASSIGN LENGTH OF nums TO count\n        ASSIGN 0 TO accumulator\n        CREATE LIST powers WITH count ELEMENTS INITIALIZED TO 1\n\n        ASSIGN 1 TO index\n        WHILE index NOT GREATER THAN count MINUS 1\n            ASSIGN (powers[index MINUS 1] TIMES 2) MOD MOD TO powers[index]\n            INCREMENT index BY 1\n        END WHILE\n\n        ASSIGN 0 TO pointer\n        WHILE pointer LESS THAN count\n            ASSIGN (accumulator PLUS (nums[pointer] TIMES (powers[pointer] MINUS powers[count MINUS pointer MINUS 1]))) MOD MOD TO accumulator\n            INCREMENT pointer BY 1\n        END WHILE\n\n        RETURN accumulator\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MOD TO one billion PLUS seven  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list of length n FILLED WITH one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO element at position i MINUS one of power MULTIPLIED BY two MODULO MOD  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS element at position i of nums MULTIPLIED BY element at position i of power MINUS element at position n MINUS i MINUS one of power  \n            SET total_sum TO total_sum MODULO MOD  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "numbers-at-most-n-given-digit-set", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION numbers_of_length(k)  \n            VAR base_num <- LENGTH OF digits  \n            VAR total_count <- 1  \n            VAR step <- 0  \n            WHILE step < k  \n                total_count <- total_count * base_num  \n                step <- step + 1  \n            END WHILE  \n            RETURN total_count  \n        END FUNCTION  \n        \n        FUNCTION count_up_to_limit(limit)  \n            VAR rep <- TO_STRING(limit)  \n            VAR len_rep <- LENGTH OF rep  \n            VAR acc <- 0  \n            \n            VAR idx <- 1  \n            LOOP UNTIL idx >= len_rep  \n                acc <- acc + numbers_of_length(idx)  \n                idx <- idx + 1  \n            END LOOP  \n            \n            VAR pos <- 0  \n            WHILE pos < len_rep  \n                VAR val <- TO_INTEGER(rep[pos])  \n                VAR j <- 0  \n                \n                REPEAT  \n                    IF j >= LENGTH OF digits THEN  \n                        BREAK  \n                    END IF  \n                    \n                    VAR d_val <- TO_INTEGER(digits[j])  \n                    \n                    IF d_val < val THEN  \n                        acc <- acc + numbers_of_length(len_rep - pos - 1)  \n                        j <- j + 1  \n                    ELSE IF d_val = val THEN  \n                        IF pos = len_rep - 1 THEN  \n                            acc <- acc + 1  \n                        END IF  \n                        BREAK  \n                    ELSE  \n                        BREAK  \n                    END IF  \n                UNTIL FALSE  \n                pos <- pos + 1  \n            END WHILE  \n            \n            RETURN acc  \n        END FUNCTION  \n        \n        RETURN count_up_to_limit(n)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION count_numbers_with_length(length)  \n            RETURN the LENGTH OF digits RAISED TO THE POWER OF length  \n        END FUNCTION  \n        \n        FUNCTION count_numbers_up_to_n(n)  \n            SET str_n TO the string representation of n  \n            SET length TO the LENGTH OF str_n  \n            SET count TO zero  \n            \n            FOR l FROM one TO length MINUS one  \n                INCREMENT count BY count_numbers_with_length(l)  \n            END FOR  \n            \n            FOR i FROM zero TO length MINUS one  \n                SET current_digit TO the integer value of the element at position i of str_n  \n                FOR each digit IN digits  \n                    IF the integer value of digit LESS THAN current_digit THEN  \n                        INCREMENT count BY count_numbers_with_length(length MINUS i MINUS one)  \n                    ELSE IF the integer value of digit EQUALS current_digit THEN  \n                        IF i EQUALS length MINUS one THEN  \n                            INCREMENT count BY one  \n                        END IF  \n                    ELSE IF the integer value of digit GREATER THAN current_digit THEN  \n                        BREAK the inner loop  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN count_numbers_up_to_n(n)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "least-operators-to-express-number", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION leastOpsExpressTarget(x, target)\n        FUNCTION dp(target_inner)\n            IF NOT (target_inner ≠ 0) THEN\n                RETURN -1\n            END IF\n\n            IF target_inner >= x THEN\n                INTEGER exponent_tracker ← 1\n                WHILE POWER(x, exponent_tracker) ≤ target_inner DO\n                    exponent_tracker ← exponent_tracker + 1\n                END WHILE\n                exponent_tracker ← exponent_tracker - 1\n\n                INTEGER intermediate_value ← dp(target_inner - POWER(x, exponent_tracker)) + exponent_tracker\n\n                INTEGER candidate ← POWER(x, exponent_tracker + 1) - target_inner\n                IF candidate < target_inner THEN\n                    INTEGER alternate_value ← dp(candidate) + exponent_tracker + 1\n                    intermediate_value ← (intermediate_value < alternate_value) ? intermediate_value : alternate_value\n                END IF\n\n                RETURN intermediate_value\n            ELSE\n                INTEGER left_option ← 2 * target_inner - 1\n                INTEGER right_option ← 2 * (x - target_inner)\n                RETURN (left_option < right_option) ? left_option : right_option\n            END IF\n        END FUNCTION\n\n        RETURN dp(target)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION leastOpsExpressTarget(x, target)  \n        FUNCTION dp(target_inner)  \n            IF target_inner EQUALS zero  \n                RETURN negative one  \n            END IF  \n            \n            IF target_inner LESS THAN x  \n                RETURN the minimum BETWEEN the expression two MULTIPLIED BY target_inner MINUS one AND the expression two MULTIPLIED BY the difference BETWEEN x MINUS target_inner  \n            END IF  \n            \n            SET power TO one  \n            WHILE x RAISED TO power IS LESS THAN OR EQUAL TO target_inner  \n                INCREMENT power BY one  \n            END WHILE  \n            DECREMENT power BY one  \n            \n            SET result TO the value returned BY dp WITH the argument target_inner MINUS x RAISED TO power PLUS power  \n            \n            IF the expression x RAISED TO the sum OF power PLUS one MINUS target_inner IS LESS THAN target_inner  \n                SET result TO the minimum BETWEEN result AND the value returned BY dp WITH the argument x RAISED TO the sum OF power PLUS one MINUS target_inner PLUS power PLUS one  \n            END IF  \n            \n            RETURN result  \n        END FUNCTION  \n        \n        RETURN the value returned BY dp WITH the argument target  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-rational-numbers", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean  \n        SET fractions AS [1, 1/9, 1/99, 1/999, 1/9999]  \n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number  \n            SET openPos TO INDEX_OF('(' IN s)  \n            IF openPos IS NOT_EQUAL_TO -1 THEN  \n                SET closePos TO INDEX_OF(')' IN s)  \n                SET decimalPos TO INDEX_OF('.' IN s)  \n                SET baseValue TO TO_FLOAT(SUBSTRING(s, 0, openPos))  \n                SET nonRepeatCount TO openPos - decimalPos - 1  \n                SET repeatValue TO TO_INT(SUBSTRING(s, openPos + 1, closePos))  \n                SET repeatLength TO closePos - openPos - 1  \n\n                SET part1 TO repeatValue * fractions[repeatLength]  \n                SET part2 TO part1 / (10 ^ nonRepeatCount)  \n                RETURN baseValue + part2  \n            END IF  \n            RETURN TO_FLOAT(s)  \n        END FUNCTION  \n\n        SET diff TO ABS(valueOf(s) - valueOf(t))  \n        RETURN diff < (1 / (10 ^ 9))  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean  \n        SET ratios TO a list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number  \n            IF position of opening parenthesis in s EQUALS negative one  \n                RETURN the conversion of s TO a floating point number  \n            END IF  \n\n            SET leftParenIndex TO position of opening parenthesis in s  \n            SET rightParenIndex TO position of closing parenthesis in s  \n            SET dotIndex TO position of decimal point in s  \n\n            SET integerAndNonRepeating TO the conversion TO floating point number OF the substring of s from the start TO the position leftParenIndex minus one  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the conversion TO integer OF the substring of s from position leftParenIndex PLUS one TO position rightParenIndex MINUS one  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY the number one DIVIDED BY ten RAISED TO the power of nonRepeatingLength MULTIPLIED BY element at position repeatingLength OF the list ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of valueOf of s MINUS valueOf of t LESS THAN one DIVIDED BY ten RAISED TO the power of nine  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "grid-illumination", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION gridIllumination(n, lamps, queries)  \n        INITIALIZE freqRows AS a dictionary defaulting to 0  \n        INITIALIZE freqCols AS a dictionary defaulting to 0  \n        INITIALIZE freqDiags AS a dictionary defaulting to 0  \n        INITIALIZE freqAntiDiags AS a dictionary defaulting to 0  \n        INITIALIZE activeLamps AS an empty set  \n        \n        SET idx TO 0  \n        WHILE idx < LENGTH(lamps)  \n            LET x TO lamps[idx][0]  \n            LET y TO lamps[idx][1]  \n            IF NOT (x, y) IN activeLamps  \n                INSERT (x, y) INTO activeLamps  \n                freqRows[x] ← freqRows[x] + 1  \n                freqCols[y] ← freqCols[y] + 1  \n                LET dKey TO x - y  \n                LET adKey TO x + y  \n                freqDiags[dKey] ← freqDiags[dKey] + 1  \n                freqAntiDiags[adKey] ← freqAntiDiags[adKey] + 1  \n            END IF  \n            idx ← idx + 1  \n        END WHILE  \n        \n        DECLARE neighbors AS a list containing (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 0), (0, 1), (1, -1), (1, 0), (1, 1)  \n        \n        DEFINE results AS an empty list  \n        \n        SET qIndex TO 0  \n        WHILE qIndex < LENGTH(queries)  \n            LET currRow TO queries[qIndex][0]  \n            LET currCol TO queries[qIndex][1]  \n            \n            IF freqRows[currRow] > 0 OR freqCols[currCol] > 0 OR freqDiags[currRow - currCol] > 0 OR freqAntiDiags[currRow + currCol] > 0 THEN  \n                APPEND 1 TO results  \n            ELSE  \n                APPEND 0 TO results  \n            END IF  \n            \n            DECLARE nIndex AS 0  \n            WHILE nIndex < LENGTH(neighbors)  \n                LET deltaRow TO neighbors[nIndex][0]  \n                LET deltaCol TO neighbors[nIndex][1]  \n                LET newRow TO currRow + deltaRow  \n                LET newCol TO currCol + deltaCol  \n                \n                IF (newRow, newCol) IN activeLamps THEN  \n                    DELETE (newRow, newCol) FROM activeLamps  \n                    freqRows[newRow] ← freqRows[newRow] - 1  \n                    freqCols[newCol] ← freqCols[newCol] - 1  \n                    freqDiags[newRow - newCol] ← freqDiags[newRow - newCol] - 1  \n                    freqAntiDiags[newRow + newCol] ← freqAntiDiags[newRow + newCol] - 1  \n                END IF  \n                nIndex ← nIndex + 1  \n            END WHILE  \n            qIndex ← qIndex + 1  \n        END WHILE  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION gridIllumination(n, lamps, queries)  \n        SET row_count TO an empty dictionary with default integer zero  \n        SET col_count TO an empty dictionary with default integer zero  \n        SET diag_count TO an empty dictionary with default integer zero  \n        SET anti_diag_count TO an empty dictionary with default integer zero  \n        SET lamp_positions TO an empty set  \n        \n        FOR each pair r c IN the elements of lamps  \n            IF the tuple of r and c is not in lamp_positions  \n                ADD the tuple of r and c TO lamp_positions  \n                INCREMENT the value at key r in row_count BY one  \n                INCREMENT the value at key c in col_count BY one  \n                INCREMENT the value at key the subtraction of c from r in diag_count BY one  \n                INCREMENT the value at key the sum of r and c in anti_diag_count BY one  \n            END IF  \n        END FOR  \n        \n        SET directions TO the list of pairs negative one negative one negative one zero negative one one zero negative one zero zero zero zero one one negative one one zero one one one  \n        \n        SET result TO an empty list  \n        \n        FOR each pair r c IN the elements of queries  \n            IF the value at key r in row_count is greater than zero OR the value at key c in col_count is greater than zero OR the value at key the subtraction of c from r in diag_count is greater than zero OR the value at key the sum of r and c in anti_diag_count is greater than zero  \n                APPEND one TO result  \n            ELSE  \n                APPEND zero TO result  \n            END IF  \n            \n            FOR each pair dr dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF the tuple of nr and nc is in lamp_positions  \n                    REMOVE the tuple of nr and nc FROM lamp_positions  \n                    DECREMENT the value at key nr in row_count BY one  \n                    DECREMENT the value at key nc in col_count BY one  \n                    DECREMENT the value at key the subtraction of nc from nr in diag_count BY one  \n                    DECREMENT the value at key the sum of nr and nc in anti_diag_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parsing-a-boolean-expression", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        INITIALIZE container AS empty list  \n        SET pointer TO 0  \n        WHILE pointer LESS THAN length of expression  \n            LET symbol BE element at position pointer in expression  \n            \n            SWITCH symbol  \n                CASE 't', 'f', '!', '&', '|'  \n                    ADD symbol TO container  \n                    INCREMENT pointer BY 1  \n                    CONTINUE  \n                CASE ')'  \n                    DECLARE tally_true AS 0  \n                    DECLARE tally_false AS 0  \n                    \n                    WHILE container[last element] IS 't' OR container[last element] IS 'f'  \n                        LET current_char BE container[last element]  \n                        \n                        IF current_char IS 't'  \n                            SET tally_true TO tally_true + 1  \n                        END IF  \n                        IF current_char IS 'f'  \n                            SET tally_false TO tally_false + 1  \n                        END IF  \n                        REMOVE last element FROM container  \n                    END WHILE  \n                    \n                    LET operator_char BE container[last element]  \n                    REMOVE last element FROM container  \n                    \n                    IF operator_char IS '!'  \n                        IF tally_false NOT EQUAL TO 0  \n                            SET symbol TO 't'  \n                        ELSE  \n                            SET symbol TO 'f'  \n                        END IF  \n                    ELSE IF operator_char IS '&'  \n                        IF tally_false NOT EQUAL TO 0  \n                            SET symbol TO 'f'  \n                        ELSE  \n                            SET symbol TO 't'  \n                        END IF  \n                    ELSE IF operator_char IS '|'  \n                        IF tally_true NOT EQUAL TO 0  \n                            SET symbol TO 't'  \n                        ELSE  \n                            SET symbol TO 'f'  \n                        END IF  \n                    END IF  \n                    ADD symbol TO container  \n                    INCREMENT pointer BY 1  \n                DEFAULT  \n                    INCREMENT pointer BY 1  \n            END SWITCH  \n        END WHILE  \n        \n        RETURN (container[0] IS 't')  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each c IN expression  \n            IF c EQUALS character representing true OR c EQUALS character representing false OR c EQUALS character representing not OR c EQUALS character representing and OR c EQUALS character representing or  \n                APPEND c TO stk  \n            ELSE IF c EQUALS character representing closing parenthesis  \n                SET count_true TO zero  \n                SET count_false TO zero  \n                WHILE the element at the last position of stk EQUALS character representing true OR the element at the last position of stk EQUALS character representing false  \n                    IF the element at the last position of stk EQUALS character representing true  \n                        INCREMENT count_true BY one  \n                    END IF  \n                    IF the element at the last position of stk EQUALS character representing false  \n                        INCREMENT count_false BY one  \n                    END IF  \n                    REMOVE the element at the last position FROM stk  \n                END WHILE  \n                SET op TO the element at the last position of stk  \n                REMOVE the element at the last position FROM stk  \n                IF op EQUALS character representing not  \n                    IF count_false GREATER THAN zero  \n                        SET c TO character representing true  \n                    ELSE  \n                        SET c TO character representing false  \n                    END IF  \n                ELSE IF op EQUALS character representing and  \n                    IF count_false GREATER THAN zero  \n                        SET c TO character representing false  \n                    ELSE  \n                        SET c TO character representing true  \n                    END IF  \n                ELSE IF op EQUALS character representing or  \n                    IF count_true GREATER THAN zero  \n                        SET c TO character representing true  \n                    ELSE  \n                        SET c TO character representing false  \n                    END IF  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stk EQUALS character representing true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-transforms-into-another-string", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canConvert WITH PARAMETERS str1 str2\n        IF NOT (str1 IS NOT str2) THEN\n            RETURN True\n        END IF\n\n        DEFINE char_to_char_map AS empty dictionary\n\n        SET index_var TO 0\n        WHILE index_var LESS THAN LENGTH(str1)\n            ASSIGN charA TO str1 AT index_var\n            ASSIGN charB TO str2 AT index_var\n\n            IF charA IN char_to_char_map THEN\n                IF NOT (char_to_char_map[charA] EQUALS charB) THEN\n                    RETURN False\n                END IF\n            ELSE\n                ASSIGN charB TO char_to_char_map AT charA\n            END IF\n\n            INCREMENT index_var BY 1\n        END WHILE\n\n        IF LENGTH(SET OF ELEMENTS OF str2) GREATER THAN OR EQUAL TO 26 THEN\n            RETURN False\n        END IF\n\n        RETURN True\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO an empty mapping from characters to characters  \n        FOR each pair of characters char1 and char2 FROM str1 AND str2 in order  \n            IF char1 IS IN conversion_map  \n                IF the value mapped from char1 in conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET the value mapped from char1 in conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the number of unique characters IN str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-items-by-groups-respecting-dependencies", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION sortItems(n, m, group, beforeItems)\n        SET next_group_id TO m\n        SET idx TO 0\n        WHILE idx LESS THAN n\n            IF group[idx] EQUALS -1\n                ASSIGN next_group_id TO group[idx]\n                INCREMENT next_group_id\n            END IF\n            INCREMENT idx\n        END WHILE\n\n        ASSIGN group_contents TO empty dictionary mapping keys to empty lists\n        ASSIGN adjacency_per_group TO empty dictionary mapping keys to empty lists\n        ASSIGN adjacency_per_item TO empty dictionary mapping keys to empty lists\n        ASSIGN in_degree_per_item TO list of zeros repeated n times\n        ASSIGN in_degree_per_group TO list of zeros repeated next_group_id times\n\n        ASSIGN index_var TO 0\n        WHILE index_var LESS THAN n\n            APPEND index_var TO group_contents[group[index_var]]\n            INCREMENT index_var\n        END WHILE\n\n        SET outer_index TO 0\n        WHILE outer_index LESS THAN n\n            SET inner_index TO 0\n            SET current_dependencies TO beforeItems[outer_index]\n            WHILE inner_index LESS THAN LENGTH OF current_dependencies\n                SET dependency TO current_dependencies[inner_index]\n                IF NOT (group[dependency] DIFFERENT FROM group[outer_index])\n                    APPEND outer_index TO adjacency_per_item[dependency]\n                    in_degree_per_item[outer_index] = in_degree_per_item[outer_index] + 1\n                ELSE\n                    APPEND group[outer_index] TO adjacency_per_group[group[dependency]]\n                    in_degree_per_group[group[outer_index]] = in_degree_per_group[group[outer_index]] + 1\n                END IF\n                INCREMENT inner_index\n            END WHILE\n            INCREMENT outer_index\n        END WHILE\n\n        FUNCTION topological_sort(graph, in_degree, items)\n            ASSIGN processing_queue TO empty double-ended queue\n            ASSIGN collected_result TO empty list\n\n            FOR each element IN items\n                IF in_degree[element] EQUALS 0\n                    APPEND element TO processing_queue\n                END IF\n            END FOR\n\n            WHILE LENGTH OF processing_queue GREATER THAN 0\n                REMOVE front OF processing_queue AND STORE IN current_node\n                APPEND current_node TO collected_result\n                ASSIGN neighbors TO graph[current_node]\n                ASSIGN neighbor_counter TO 0\n                WHILE neighbor_counter LESS THAN LENGTH OF neighbors\n                    SET neighbor TO neighbors[neighbor_counter]\n                    DECREMENT in_degree[neighbor] BY 1\n                    IF in_degree[neighbor] EQUALS 0\n                        APPEND neighbor TO processing_queue\n                    END IF\n                    INCREMENT neighbor_counter\n                END WHILE\n            END WHILE\n\n            IF LENGTH OF collected_result EQUALS LENGTH OF items\n                RETURN collected_result\n            ELSE\n                RETURN empty list\n            END IF\n        END FUNCTION\n\n        ASSIGN global_sorted_items TO empty list\n        FOR EACH group_key IN group_contents KEYS\n            ASSIGN sorted_sequence TO topological_sort(adjacency_per_item, in_degree_per_item, group_contents[group_key])\n            IF LENGTH OF sorted_sequence EQUALS 0\n                RETURN empty list\n            END IF\n            FOR each element IN sorted_sequence\n                APPEND element TO global_sorted_items\n            END FOR\n        END FOR\n\n        ASSIGN sorted_group_order TO topological_sort(adjacency_per_group, in_degree_per_group, LIST OF INTEGERS FROM 0 TO next_group_id MINUS 1)\n        IF LENGTH OF sorted_group_order EQUALS 0\n            RETURN empty list\n        END IF\n\n        ASSIGN ordered_items_per_group TO empty dictionary mapping keys to empty lists\n        FOR EACH sorted_item IN global_sorted_items\n            APPEND sorted_item TO ordered_items_per_group[group[sorted_item]]\n        END FOR\n\n        ASSIGN final_sorted_list TO empty list\n        FOR EACH group_in_order IN sorted_group_order\n            CONCATENATE ordered_items_per_group[group_in_order] TO final_sorted_list\n        END FOR\n\n        RETURN final_sorted_list\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION sortItems(n, m, group, beforeItems)  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of group EQUALS minus one  \n                SET element at position i of group TO m  \n                INCREMENT m BY one  \n            END IF  \n        END FOR  \n        \n        SET group_items TO a mapping from keys to empty lists  \n        SET group_graph TO a mapping from keys to empty lists  \n        SET item_graph TO a mapping from keys to empty lists  \n        SET item_in_degree TO a list consisting of zero repeated n times  \n        SET group_in_degree TO a list consisting of zero repeated m times  \n        \n        FOR i FROM zero TO n MINUS one  \n            APPEND i TO list at key element at position i of group in group_items  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR each before_element IN element at position i of beforeItems  \n                IF element at position before_element of group EQUALS element at position i of group  \n                    APPEND i TO list at key before_element in item_graph  \n                    INCREMENT element at position i of item_in_degree BY one  \n                ELSE  \n                    APPEND element at position i of group TO list at key element at position before_element of group in group_graph  \n                    INCREMENT element at position element at position i of group of group_in_degree BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION topological_sort(graph, in_degree, items)  \n            SET queue TO a double-ended queue initialized with elements from items WHERE element at position element of in_degree EQUALS zero  \n            SET result TO empty list  \n            \n            WHILE queue is not empty  \n                REMOVE element from front of queue and assign to u  \n                APPEND u TO result  \n                FOR each v IN list at key u in graph  \n                    DECREMENT element at position v of in_degree BY one  \n                    IF element at position v of in_degree EQUALS zero  \n                        APPEND v TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            IF LENGTH OF result EQUALS LENGTH OF items  \n                RETURN result  \n            ELSE  \n                RETURN empty list  \n            END IF  \n        END FUNCTION  \n        \n        SET sorted_within_groups TO empty list  \n        FOR each items_list IN all values of group_items  \n            SET sorted_items TO topological_sort(item_graph, item_in_degree, items_list)  \n            IF LENGTH OF sorted_items EQUALS zero  \n                RETURN empty list  \n            END IF  \n            EXTEND sorted_within_groups BY sorted_items  \n        END FOR  \n        \n        SET sorted_groups TO topological_sort(group_graph, group_in_degree, list of elements from zero TO m MINUS one)  \n        IF LENGTH OF sorted_groups EQUALS zero  \n            RETURN empty list  \n        END IF  \n        \n        SET group_to_items_map TO a mapping from keys to empty lists  \n        FOR each item IN sorted_within_groups  \n            APPEND item TO list at key element at position item of group in group_to_items_map  \n        END FOR  \n        \n        SET result TO empty list  \n        FOR each grp IN sorted_groups  \n            EXTEND result BY list at key grp in group_to_items_map  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-vowels-permutation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION countVowelPermutation(n)\n        DEFINE DIVISOR AS 1_000_000_007\n        INITIALIZE alpha AS 1\n        INITIALIZE beta AS 1\n        INITIALIZE gamma AS 1\n        INITIALIZE delta AS 1\n        INITIALIZE epsilon AS 1\n\n        SET counter TO 2\n        WHILE counter ≤ n DO\n            DEFINE next_alpha AS beta + gamma + epsilon\n            DEFINE next_beta AS alpha + gamma\n            DEFINE next_gamma AS beta + delta\n            DEFINE next_delta AS gamma\n            DEFINE next_epsilon AS gamma + delta\n\n            alpha ← next_alpha MODULO DIVISOR\n            beta ← next_beta MODULO DIVISOR\n            gamma ← next_gamma MODULO DIVISOR\n            delta ← next_delta MODULO DIVISOR\n            epsilon ← next_epsilon MODULO DIVISOR\n\n            INCREMENT counter BY 1\n        END WHILE\n\n        COMPUTE aggregate_total = alpha + beta + gamma + delta + epsilon\n        ASSIGN final_result AS aggregate_total MODULO DIVISOR\n        RETURN final_result\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each index FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder when a_next is DIVIDED BY MOD  \n            SET e TO the remainder when e_next is DIVIDED BY MOD  \n            SET i TO the remainder when i_next is DIVIDED BY MOD  \n            SET o TO the remainder when o_next is DIVIDED BY MOD  \n            SET u TO the remainder when u_next is DIVIDED BY MOD  \n        END FOR  \n        SET total_count TO the sum of a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO the remainder when total_count is DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dice-roll-simulation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION dieSimulator(n, rollMax)\n        SET MOD TO 1000000007\n\n        SET dp TO list of size (n + 1), EACH element a list of size 6, EACH element a list of zeros of size (max element in rollMax + 1)\n\n        SET idx TO 0\n        WHILE idx LESS_THAN 6\n            SET temp_list TO dp[1][idx]\n            temp_list[1] ← 1\n            idx ← idx + 1\n        END WHILE\n\n        SET i TO 2\n        WHILE i LESS_THAN_OR_EQUAL n\n            SET j TO 0\n            WHILE j LESS_THAN 6\n                SET k TO 1\n                WHILE k LESS_THAN_OR_EQUAL rollMax[j]\n                    IF k LESS_THAN 2\n                        SET acc TO 0\n                        SET x TO 0\n                        WHILE x LESS_THAN 6\n                            IF x NOT_EQUALS j THEN\n                                SET y TO 1\n                                WHILE y LESS_THAN_OR_EQUAL rollMax[x]\n                                    acc ← acc + dp[i - 1][x][y]\n                                    y ← y + 1\n                                END WHILE\n                            END IF\n                            x ← x + 1\n                        END WHILE\n                        dp[i][j][k] ← acc MOD MOD\n                    ELSE\n                        dp[i][j][k] ← dp[i - 1][j][k - 1]\n                    END IF\n                    k ← k + 1\n                END WHILE\n                j ← j + 1\n            END WHILE\n            i ← i + 1\n        END WHILE\n\n        SET final_result TO 0  \n        FOR INDEX j FROM 0 TO 5\n            SET subIdx TO 1\n            WHILE subIdx LESS_THAN_OR_EQUAL rollMax[j]\n                ADD dp[n][j][subIdx] TO final_result\n                subIdx ← subIdx + 1\n            END WHILE  \n        END FOR\n\n        RETURN final_result MOD MOD\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution\n    FUNCTION dieSimulator(n, rollMax)\n        SET MOD TO one billion PLUS seven\n\n        SET dp TO a three dimensional list of zeros with dimensions of n PLUS one BY six BY maximum value in rollMax PLUS one\n\n        FOR j FROM zero TO five\n            SET element at position one of list at position j of list at position one of dp TO one\n        END FOR\n\n        FOR i FROM two TO n\n            FOR j FROM zero TO five\n                FOR k FROM one TO element at position j of rollMax\n                    IF k GREATER THAN one\n                        SET element at position k of list at position j of list at position i of dp TO element at position k MINUS one of list at position j of list at position i MINUS one of dp\n                    ELSE\n                        SET total_sum TO zero\n                        FOR x FROM zero TO five\n                            IF x NOT EQUALS j\n                                FOR y FROM one TO element at position x of rollMax\n                                    INCREMENT total_sum BY element at position y of list at position x of list at position i MINUS one of dp\n                                END FOR\n                            END IF\n                        END FOR\n                        SET element at position k of list at position j of list at position i of dp TO total_sum MODULO MOD\n                    END IF\n                END FOR\n            END FOR\n        END FOR\n\n        SET result TO zero\n        FOR j FROM zero TO five\n            FOR k FROM one TO element at position j of rollMax\n                INCREMENT result BY element at position k of list at position j of list at position n of dp\n            END FOR\n        END FOR\n\n        RETURN result MODULO MOD\n    END FUNCTION\nEND CLASS"}
{"task_id": "divide-chocolate", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximizeSweetness(sweetness list OF integer, k integer) RETURNS integer\n        FUNCTION canDivide(min_sweet integer) RETURNS boolean\n            ASSIGN 0 TO count_pieces\n            ASSIGN 0 TO aggregate_sweet\n            ASSIGN 0 TO idx\n            WHILE idx LESS THAN LENGTH(sweetness)\n                ASSIGN aggregate_sweet PLUS sweetness[idx] TO aggregate_sweet\n                IF NOT (aggregate_sweet LESS THAN min_sweet)\n                    ASSIGN count_pieces PLUS 1 TO count_pieces\n                    ASSIGN 0 TO aggregate_sweet\n                    IF NOT (count_pieces LESS THAN OR EQUAL TO k)\n                        RETURN True\n                    END IF\n                END IF\n                INCREMENT idx BY 1\n            END WHILE\n            RETURN count_pieces GREATER THAN k\n        END FUNCTION\n\n        ASSIGN sweetness[0] TO low\n        ASSIGN 0 TO i\n        WHILE i LESS THAN LENGTH(sweetness)\n            IF sweetness[i] LESS THAN low\n                ASSIGN sweetness[i] TO low\n            END IF\n            INCREMENT i BY 1\n        END WHILE\n\n        ASSIGN 0 TO total_value\n        ASSIGN 0 TO j\n        WHILE j LESS THAN LENGTH(sweetness)\n            ASSIGN total_value PLUS sweetness[j] TO total_value\n            INCREMENT j BY 1\n        END WHILE\n\n        ASSIGN total_value DIVIDED BY (k PLUS 1) TO high\n        ASSIGN 0 TO final_ans\n\n        WHILE low LESS THAN OR EQUAL TO high\n            ASSIGN (low PLUS high) DIVIDED BY 2 TO mid_val\n            IF canDivide(mid_val) IS True\n                ASSIGN mid_val TO final_ans\n                ASSIGN mid_val PLUS 1 TO low\n                CONTINUE\n            ELSE\n                ASSIGN mid_val MINUS 1 TO high\n            END IF\n        END WHILE\n\n        RETURN final_ans\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximizeSweetness(sweetness list OF integer k integer) RETURNS integer  \n        FUNCTION canDivide(min_sweet integer) RETURNS boolean  \n            SET pieces TO zero  \n            SET current_sweet TO zero  \n            FOR each sweet IN sweetness  \n                SET current_sweet TO current_sweet PLUS sweet  \n                IF current_sweet GREATER THAN OR EQUAL TO min_sweet  \n                    INCREMENT pieces BY one  \n                    SET current_sweet TO zero  \n                    IF pieces GREATER THAN k  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN pieces GREATER THAN k  \n        END FUNCTION  \n\n        SET left TO the smallest element IN sweetness  \n        SET right TO the total sum OF all elements IN sweetness DIVIDED BY the value of k PLUS one  \n        SET result TO zero  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the integer value of left PLUS right DIVIDED BY two  \n            IF canDivide(mid) IS True  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-subarray-to-maximize-array-value", "label": "cosmetic", "pseudocode": "```\nCLASS Solution\n    FUNCTION maxValueAfterReverse(nums)\n        ASSIGN SIZE OF nums TO lengthCounter\n        IF NOT (lengthCounter GREATER THAN 2) THEN\n            ASSIGN ABS(nums[0] - nums[1]) TO resultVal\n            RETURN resultVal\n        END IF\n\n        ASSIGN 0 TO sumAbsDiff\n        ASSIGN 1 TO idx\n        WHILE idx LESS THAN lengthCounter\n            ASSIGN sumAbsDiff + ABS(nums[idx] - nums[idx - 1]) TO sumAbsDiff\n            ASSIGN idx + 1 TO idx\n        END WHILE\n\n        ASSIGN 0 TO edgeMaxGain\n        ASSIGN 1 TO pointerA\n        WHILE pointerA LESS THAN lengthCounter\n            ASSIGN ABS(nums[0] - nums[pointerA]) - ABS(nums[pointerA] - nums[pointerA - 1]) TO candidateGainA\n            IF candidateGainA GREATER THAN edgeMaxGain THEN\n                ASSIGN candidateGainA TO edgeMaxGain\n            END IF\n            ASSIGN pointerA + 1 TO pointerA\n        END WHILE\n\n        ASSIGN 0 TO pointerB\n        WHILE pointerB LESS THAN lengthCounter - 1\n            ASSIGN ABS(nums[lengthCounter - 1] - nums[pointerB]) - ABS(nums[pointerB + 1] - nums[pointerB]) TO candidateGainB\n            IF candidateGainB GREATER THAN edgeMaxGain THEN\n                ASSIGN candidateGainB TO edgeMaxGain\n            END IF\n            ASSIGN pointerB + 1 TO pointerB\n        END WHILE\n\n        ASSIGN +Infinity TO minMaxPair\n        ASSIGN -Infinity TO maxMinPair\n        ASSIGN 0 TO iteratorC\n        WHILE iteratorC LESS THAN lengthCounter - 1\n            ASSIGN MAX(nums[iteratorC], nums[iteratorC + 1]) TO currentMaxVal\n            IF currentMaxVal LESS THAN minMaxPair THEN\n                ASSIGN currentMaxVal TO minMaxPair\n            END IF\n\n            ASSIGN MIN(nums[iteratorC], nums[iteratorC + 1]) TO currentMinVal\n            IF currentMinVal GREATER THAN maxMinPair THEN\n                ASSIGN currentMinVal TO maxMinPair\n            END IF\n            ASSIGN iteratorC + 1 TO iteratorC\n        END WHILE\n\n        ASSIGN MAX(0, 2 * (maxMinPair - minMaxPair)) TO generalMaxGain\n\n        RETURN sumAbsDiff + MAX(edgeMaxGain, generalMaxGain)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxValueAfterReverse(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS two  \n            RETURN the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position one of nums  \n        END IF  \n        \n        SET initial_value TO zero  \n        FOR i FROM one TO n MINUS one  \n            INCREMENT initial_value BY the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n        END FOR  \n        \n        SET max_edge_gain TO zero  \n        FOR i FROM one TO n MINUS one  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position n MINUS one of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i PLUS one of nums MINUS element at position i of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        SET min_pair TO the MINIMUM VALUE among for each i FROM zero TO n MINUS two the MAXIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        SET max_pair TO the MAXIMUM VALUE among for each i FROM zero TO n MINUS two the MINIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        \n        SET general_gain TO the MAXIMUM VALUE between zero AND two MULTIPLIED BY the DIFFERENCE between max_pair AND min_pair  \n        \n        RETURN initial_value PLUS the MAXIMUM VALUE between max_edge_gain AND general_gain  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-target-array-with-multiple-sums", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION isPossible(target)\n        SET heapData AS an empty list\n        DEFINE helper_add_negatives(index)\n            IF index GREATER OR EQUAL TO LENGTH of target THEN\n                RETURN\n            END IF\n            APPEND NEGATION of target[index] TO heapData\n            CALL helper_add_negatives(index PLUS 1)\n        END FUNCTION\n        CALL helper_add_negatives(0)\n\n        TRANSFORM heapData INTO a heap\n\n        SET sumTotal AS 0\n        FOR idx FROM 0 TO LENGTH of target MINUS 1\n            SET sumTotal TO sumTotal PLUS target[idx]\n        END FOR\n\n        WHILE heapData[0] GREATER THAN NEGATION of 1 DO\n            SET maxValue TO NEGATION of EXTRACT from heapData\n            SET remaining AS sumTotal MINUS maxValue\n\n            SWITCH TRUE\n                CASE maxValue LESS OR EQUAL TO remaining:\n                CASE remaining EQUALS 0:\n                    RETURN False\n            END SWITCH\n\n            SET modResult AS maxValue MINUS (remaining MULTIPLY (maxValue DIVIDED BY remaining))\n\n            IF NOT (modResult NOT EQUAL 0 OR remaining EQUAL 1) THEN\n                RETURN False\n            END IF\n\n            SET sumTotal TO remaining PLUS modResult\n            INSERT NEGATION of modResult INTO heapData AS a heap element\n        END WHILE\n\n        RETURN True\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isPossible(target)  \n        SET max_heap TO an empty list  \n        FOR each num IN target  \n            APPEND the NEGATION of num TO max_heap  \n        END FOR  \n        TRANSFORM max_heap INTO a heap structure  \n        \n        SET total_sum TO the sum of elements in target  \n        \n        WHILE the element at position zero of max_heap LESS THAN NEGATION of one holds  \n            SET largest TO the NEGATION of the element extracted from max_heap  \n            SET rest_sum TO total_sum MINUS largest  \n            \n            IF largest LESS THAN OR EQUAL TO rest_sum OR rest_sum EQUALS zero THEN  \n                RETURN False  \n            END IF  \n            \n            SET new_value TO the remainder of largest DIVIDED BY rest_sum  \n            \n            IF new_value EQUALS zero AND rest_sum NOT EQUALS one THEN  \n                RETURN False  \n            END IF  \n            \n            SET total_sum TO rest_sum PLUS new_value  \n            INSERT the NEGATION of new_value INTO max_heap maintaining heap order  \n        END WHILE  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-multiple-of-three", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET freq_map AS a mapping from digits to their counts in digits  \n        SET summation TO 0  \n        FOR index FROM 0 TO LENGTH OF digits MINUS 1  \n            summation ← summation PLUS digits[index]  \n        END FOR  \n        SET mod_val AS summation MODULO 3  \n        \n        SWITCH mod_val  \n            CASE 1:  \n                DEFINE singles AS [1, 4, 7]  \n                SET changed_flag AS false  \n                SET pointer AS 0  \n                WHILE pointer < LENGTH OF singles AND changed_flag EQUALS false  \n                    IF freq_map CONTAINS singles[pointer] AND freq_map[singles[pointer]] > 0 THEN  \n                        freq_map[singles[pointer]] ← freq_map[singles[pointer]] MINUS 1  \n                        changed_flag ← true  \n                    END IF  \n                    pointer ← pointer PLUS 1  \n                END WHILE  \n                IF changed_flag EQUALS false THEN  \n                    DEFINE doubles AS [2, 5, 8]  \n                    SET idx AS 0  \n                    WHILE idx < LENGTH OF doubles AND changed_flag EQUALS false  \n                        IF freq_map CONTAINS doubles[idx] AND freq_map[doubles[idx]] > 1 THEN  \n                            freq_map[doubles[idx]] ← freq_map[doubles[idx]] MINUS 2  \n                            changed_flag ← true  \n                        END IF  \n                        idx ← idx PLUS 1  \n                    END WHILE  \n                END IF  \n                BREAK  \n            \n            CASE 2:  \n                DEFINE singles_arr AS [2, 5, 8]  \n                SET done AS false  \n                SET position AS 0  \n                WHILE position < LENGTH OF singles_arr AND done EQUALS false  \n                    IF freq_map CONTAINS singles_arr[position] AND freq_map[singles_arr[position]] > 0 THEN  \n                        freq_map[singles_arr[position]] ← freq_map[singles_arr[position]] MINUS 1  \n                        done ← true  \n                    END IF  \n                    position ← position PLUS 1  \n                END WHILE  \n                IF done EQUALS false THEN  \n                    DEFINE doubles_arr AS [1, 4, 7]  \n                    SET pos AS 0  \n                    WHILE pos < LENGTH OF doubles_arr AND done EQUALS false  \n                        IF freq_map CONTAINS doubles_arr[pos] AND freq_map[doubles_arr[pos]] > 1 THEN  \n                            freq_map[doubles_arr[pos]] ← freq_map[doubles_arr[pos]] MINUS 2  \n                            done ← true  \n                        END IF  \n                        pos ← pos PLUS 1  \n                    END WHILE  \n                END IF  \n                BREAK  \n            DEFAULT:  \n                // no action needed  \n                BREAK  \n        END SWITCH  \n        \n        SET output_segments AS an empty list  \n        SET digit_val AS 9  \n        WHILE digit_val >= 0  \n            IF freq_map CONTAINS digit_val THEN  \n                SET count_value AS freq_map[digit_val]  \n                SET part_str AS empty string  \n                SET iter_num AS 0  \n                WHILE iter_num < count_value  \n                    part_str ← part_str CONCATENATED WITH STRING OF digit_val  \n                    iter_num ← iter_num PLUS 1  \n                END WHILE  \n                IF LENGTH OF part_str > 0 THEN  \n                    output_segments APPEND part_str  \n                END IF  \n            END IF  \n            digit_val ← digit_val MINUS 1  \n        END WHILE  \n        \n        SET assembled_str AS empty string  \n        FOR each segment IN output_segments  \n            assembled_str ← assembled_str CONCATENATED WITH segment  \n        END FOR  \n        \n        IF LENGTH OF assembled_str > 0 THEN  \n            IF assembled_str[0] EQUALS \"0\" THEN  \n                RETURN \"0\"  \n            END IF  \n        ELSE  \n            RETURN \"\"  \n        END IF  \n        \n        RETURN assembled_str  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO the frequency counter of digits  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder after dividing total_sum BY three  \n        IF remainder EQUALS one  \n            FOR each digit d IN the list consisting of one four seven  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of two five eight  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit d IN the list consisting of two five eight  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of one four seven  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        SET result TO an empty list  \n        FOR each digit d FROM nine DOWN TO zero  \n            APPEND the string representation of digit d REPEATED frequency count of digit d times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF the length of final_number IS GREATER THAN zero AND the element at position zero of final_number EQUALS zero  \n            RETURN the string zero  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-performance-of-a-team", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maxPerformance(n speed efficiency k)\n        ASSIGN empty array TO specialist_tuples\n        ASSIGN 0 TO idx\n        WHILE idx LESS THAN length of efficiency\n            ASSIGN (efficiency[idx], speed[idx]) TO pair_val\n            APPEND pair_val TO specialist_tuples\n            INCREMENT idx BY 1\n        END WHILE\n\n        ASSIGN specialist_tuples SORTED BY first element DESCENDING TO sorted_specialists\n\n        ASSIGN empty min-heap TO velocity_container\n        ASSIGN 0 TO cumulative_velocity\n        ASSIGN 0 TO top_performance\n\n        ASSIGN 0 TO iterate_index\n        WHILE iterate_index LESS THAN length of sorted_specialists\n            ASSIGN sorted_specialists[iterate_index] TO current_pair\n            ASSIGN current_pair.first TO efficiency_val\n            ASSIGN current_pair.second TO velocity_val\n\n            PUSH velocity_val INTO velocity_container\n            SET cumulative_velocity TO cumulative_velocity PLUS velocity_val\n\n            IF SIZE of velocity_container GREATER THAN k THEN\n                ASSIGN HEAP POP from velocity_container TO lowest_velocity\n                SET cumulative_velocity TO cumulative_velocity MINUS lowest_velocity\n            END IF\n\n            ASSIGN cumulative_velocity TIMES efficiency_val TO performance_val\n\n            IF performance_val GREATER THAN top_performance THEN\n                SET top_performance TO performance_val\n            END IF\n\n            INCREMENT iterate_index BY 1\n        END WHILE\n\n        RETURN top_performance MOD (10 POWER 9 PLUS 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxPerformance(n speed efficiency k)  \n        SET engineers TO list of pairs of element at position index of efficiency AND element at position index of speed FOR index FROM the first TO the last position in efficiency  \n        SORT engineers BY the first element of each pair IN descending order  \n        SET speed_heap TO empty list  \n        SET speed_sum TO zero  \n        SET max_performance TO zero  \n        FOR each pair IN engineers  \n            SET eff TO the first element of pair  \n            SET spd TO the second element of pair  \n            ADD spd TO speed_heap USING heap push operation  \n            INCREMENT speed_sum BY spd  \n            IF the LENGTH OF speed_heap GREATER THAN k THEN  \n                SET smallest_speed TO the result of heap pop operation on speed_heap  \n                DECREMENT speed_sum BY smallest_speed  \n            END IF  \n            SET current_performance TO speed_sum MULTIPLIED BY eff  \n            IF current_performance GREATER THAN max_performance THEN  \n                SET max_performance TO current_performance  \n            END IF  \n        END FOR  \n        RETURN max_performance MODULO the result of ten RAISED TO THE POWER OF nine PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-the-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer\n        SET MOD TO 1000000000 PLUS 7\n        SET length_s TO LENGTH OF s\n        INITIALIZE dp AS an array containing (length_s PLUS 1) zeros\n        SET dp[0] AS 1\n\n        SET outer_index TO 1\n        WHILE outer_index LESS THAN OR EQUAL TO length_s DO\n            SET inner_idx TO 0\n            WHILE inner_idx LESS THAN outer_index DO\n                SET current_char TO s[inner_idx]\n                IF NOT (current_char EQUALS '0') THEN\n                    SET substring_str TO EXTRACT s FROM inner_idx TO (outer_index MINUS 1)\n                    SET num_value TO CONVERT substring_str TO integer\n                    IF (num_value GREATER THAN OR EQUAL TO 1) AND (num_value LESS THAN OR EQUAL TO k) THEN\n                        SET dp[outer_index] TO (dp[outer_index] PLUS dp[inner_idx]) MODULO MOD\n                    END IF\n                END IF\n                INCREMENT inner_idx BY 1\n            END WHILE\n            INCREMENT outer_index BY 1\n        END WHILE\n\n        RETURN dp[length_s]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cherry-pickup-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION cherryPickup(grid)\n        SET totalRows AS LENGTH(grid)\n        SET totalCols AS LENGTH(grid[0])\n        \n        FUNCTION dp(r c1 c2)\n            IF (c1 < 0) OR (c1 >= totalCols) OR (c2 < 0) OR (c2 >= totalCols) THEN\n                RETURN 0\n            END IF\n\n            IF c1 = c2 THEN\n                SET gathered AS grid[r][c1]\n            ELSE\n                SET gathered AS grid[r][c1] + grid[r][c2]\n            END IF\n\n            IF r = totalRows - 1 THEN\n                RETURN gathered\n            END IF\n            \n            SET supremeValue TO 0\n            SET deltaIndexOneList TO [-1 0 1]\n            SET deltaIndexTwoList TO [-1 0 1]\n            SET outerCounter TO 0\n            WHILE outerCounter < LENGTH(deltaIndexOneList)\n                SET innerCounter TO 0\n                WHILE innerCounter < LENGTH(deltaIndexTwoList)\n                    SET candidateSum TO dp(r + 1 c1 + deltaIndexOneList[outerCounter] c2 + deltaIndexTwoList[innerCounter])\n                    IF candidateSum > supremeValue THEN\n                        supremeValue ← candidateSum\n                    END IF\n                    innerCounter ← innerCounter + 1\n                END WHILE\n                outerCounter ← outerCounter + 1\n            END WHILE\n\n            RETURN gathered + supremeValue\n        END FUNCTION\n\n        RETURN dp(0 0 totalCols - 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dp(r c1 c2)  \n            IF c1 LESS THAN zero OR c1 GREATER THAN OR EQUAL TO cols OR c2 LESS THAN zero OR c2 GREATER THAN OR EQUAL TO cols THEN  \n                RETURN zero  \n            END IF  \n            \n            IF c1 EQUALS c2 THEN  \n                SET cherries TO element at position r of grid element at position c1  \n            ELSE  \n                SET cherries TO element at position r of grid element at position c1 PLUS element at position r of grid element at position c2  \n            END IF  \n            \n            IF r EQUALS rows MINUS one THEN  \n                RETURN cherries  \n            END IF  \n            \n            SET max_cherries TO zero  \n            FOR each dc1 IN list containing negative one zero and one  \n                FOR each dc2 IN list containing negative one zero and one  \n                    SET possible TO dp(r PLUS one c1 PLUS dc1 c2 PLUS dc2)  \n                    IF possible GREATER THAN max_cherries THEN  \n                        SET max_cherries TO possible  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN cherries PLUS max_cherries  \n        END FUNCTION  \n        \n        RETURN dp(zero zero cols MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parallel-courses-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minNumberOfSemesters(n k relations)\n        INITIALIZE graph AS a mapping with default empty list for unseen keys\n        INITIALIZE in_degree AS a list containing (n + 1) zeros\n        \n        SET edgeIndex TO 0\n        WHILE edgeIndex < LENGTH(relations)\n            SET fromNode TO relations[edgeIndex][0]\n            SET toNode TO relations[edgeIndex][1]\n            ADD toNode TO graph[fromNode]\n            SET in_degree[toNode] TO in_degree[toNode] + 1\n            INCREMENT edgeIndex BY 1\n        END WHILE\n        \n        INITIALIZE pendingCourses AS empty deque\n        SET courseID TO 1\n        LOOP\n            IF courseID > n THEN BREAK\n            IF in_degree[courseID] = 0 THEN\n                APPEND courseID TO pendingCourses\n            END IF\n            INCREMENT courseID BY 1\n        END LOOP\n        \n        SET semesterCount TO 0\n        \n        WHILE LENGTH(pendingCourses) > 0\n            SET maxCoursesThisRound TO k\n            IF maxCoursesThisRound > LENGTH(pendingCourses) THEN\n                SET maxCoursesThisRound TO LENGTH(pendingCourses)\n            END IF\n            \n            SET counter TO 0\n            RECURSIVE_PROCESS:\n                IF counter >= maxCoursesThisRound THEN\n                    GOTO FINISH_PROCESS\n                END IF\n                \n                SET currentCourse TO REMOVE_LEFT(pendingCourses)\n                FOR every adjacentCourse IN graph[currentCourse]\n                    SET in_degree[adjacentCourse] TO in_degree[adjacentCourse] - 1\n                    IF in_degree[adjacentCourse] = 0 THEN\n                        APPEND adjacentCourse TO pendingCourses\n                    END IF\n                END FOR\n                \n                SET counter TO counter + 1\n                GOTO RECURSIVE_PROCESS\n            FINISH_PROCESS:\n            \n            SET semesterCount TO semesterCount + 1\n        END WHILE\n        \n        RETURN semesterCount\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minNumberOfSemesters(n k relations)  \n        SET graph TO a new mapping with default empty list for each key  \n        SET in_degree TO a list of zeros with length equal to n PLUS one  \n        \n        FOR each pair prevCourse AND nextCourse IN relations  \n            APPEND nextCourse TO the list associated with prevCourse in graph  \n            INCREMENT the element at position nextCourse of in_degree BY one  \n        END FOR  \n        \n        SET queue TO an empty double-ended queue  \n        FOR course FROM one TO n  \n            IF the element at position course of in_degree EQUALS zero  \n                APPEND course TO queue  \n            END IF  \n        END FOR  \n        \n        SET semesters TO zero  \n        \n        WHILE queue holds any elements  \n            SET numberOfCoursesThisSemester TO the smaller of k AND the length of queue  \n            FOR index FROM one TO numberOfCoursesThisSemester  \n                REMOVE the element from the left end of queue AND ASSIGN to current_course  \n                FOR each next_course IN the list associated with current_course in graph  \n                    DECREMENT the element at position next_course of in_degree BY one  \n                    IF the element at position next_course of in_degree EQUALS zero  \n                        APPEND next_course TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT semesters BY one  \n        END WHILE  \n        \n        RETURN semesters  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-position-for-a-service-centre", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION getMinDistSum(positions)\n        LET totalPoints ← LENGTH OF positions\n        LET centerX ← 0\n        LET centerY ← 0\n        FOR each coord IN positions DO\n            LET px ← coord[0]\n            LET py ← coord[1]\n            centerX ← centerX + px\n            centerY ← centerY + py\n        END FOR\n        centerX ← centerX / totalPoints\n        centerY ← centerY / totalPoints\n\n        LET shrinkFactor ← 0.999\n        LET threshold ← 0.000001\n        LET rate ← 0.5\n\n        REPEAT\n            LET gradientX ← 0\n            LET gradientY ← 0\n            LET totalDistance ← 0\n            FOR each coord IN positions DO\n                LET xVal ← coord[0]\n                LET yVal ← coord[1]\n                LET diffX ← centerX - xVal\n                LET diffY ← centerY - yVal\n                LET distVal ← SQRT(diffX * diffX + diffY * diffY)\n                gradientX ← gradientX + (diffX / distVal + 0.00000001)\n                gradientY ← gradientY + (diffY / distVal + 0.00000001)\n                totalDistance ← totalDistance + distVal\n            END FOR\n\n            LET stepX ← gradientX * rate\n            LET stepY ← gradientY * rate\n\n            centerX ← centerX - stepX\n            centerY ← centerY - stepY\n\n            rate ← rate * shrinkFactor\n\n            IF (ABS(stepX) ≤ threshold) AND (ABS(stepY) ≤ threshold) THEN\n                RETURN totalDistance\n            END IF\n        UNTIL FALSE\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getMinDistSum(positions)  \n        SET n TO the LENGTH OF positions  \n        SET x TO zero  \n        SET y TO zero  \n        FOR each position IN positions  \n            SET x1 TO the first element AT position  \n            SET y1 TO the second element AT position  \n            INCREMENT x BY x1  \n            INCREMENT y BY y1  \n        END FOR  \n        SET x TO x DIVIDED BY n  \n        SET y TO y DIVIDED BY n  \n        SET decay TO zero POINT nine nine nine  \n        SET eps TO zero POINT zero zero zero zero zero one  \n        SET alpha TO zero POINT five  \n        WHILE TRUE  \n            SET grad_x TO zero  \n            SET grad_y TO zero  \n            SET dist TO zero  \n            FOR each position IN positions  \n                SET x1 TO the first element AT position  \n                SET y1 TO the second element AT position  \n                SET a TO x MINUS x1  \n                SET b TO y MINUS y1  \n                SET c TO the square root of a MULTIPLIED BY a PLUS b MULTIPLIED BY b  \n                INCREMENT grad_x BY a DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT grad_y BY b DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT dist BY c  \n            END FOR  \n            SET dx TO grad_x MULTIPLIED BY alpha  \n            SET dy TO grad_y MULTIPLIED BY alpha  \n            DECREMENT x BY dx  \n            DECREMENT y BY dy  \n            MULTIPLY alpha BY decay  \n            IF the absolute value of dx IS LESS THAN OR EQUAL TO eps AND the absolute value of dy IS LESS THAN OR EQUAL TO eps  \n                RETURN dist  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-cut-a-stick", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minCost(n, cuts)\n        SET boundaries TO an ordered collection formed by merging cuts WITH [0, n]\n        \n        FUNCTION dp(start, end)\n            IF NOT (end - start > 1) THEN\n                OUTPUT 0\n            END IF\n            \n            SET lowest_cost TO a very large number\n            SET index_tracker TO start + 1\n            WHILE index_tracker < end\n                SET segment_cost TO (boundaries[end] - boundaries[start]) + dp(start, index_tracker) + dp(index_tracker, end)\n                \n                IF NOT (lowest_cost <= segment_cost) THEN\n                    SET lowest_cost TO segment_cost\n                END IF\n                \n                ADD 1 TO index_tracker\n            END WHILE\n            \n            OUTPUT lowest_cost\n        END FUNCTION\n        \n        OUTPUT dp(0, LENGTH(boundaries) - 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO sorted list consisting of all elements of cuts PLUS zero PLUS n  \n        \n        FUNCTION dp(left, right)  \n            IF right MINUS left LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing positive infinity  \n            FOR i FROM left PLUS one TO right MINUS one  \n                SET cost TO element at position right of cuts MINUS element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-instructions", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPath(destination PARAMETERS destination AND k)  \n        SET xPos AS destination AT index 0  \n        SET yPos AS destination AT index 1  \n        SET resultPath AS an empty list  \n        SET stepsTotal AS xPos PLUS yPos  \n        SET counter AS 0  \n        WHILE counter NOT EQUAL stepsTotal  \n            IF yPos NOT EQUAL 0 THEN  \n                SET combCount AS combinations(xPos PLUS yPos MINUS 1, yPos MINUS 1)  \n                IF k GREATER THAN combCount THEN  \n                    APPEND 'V' TO resultPath  \n                    SET xPos AS xPos MINUS 1  \n                    SET k AS k MINUS combCount  \n                ELSE  \n                    APPEND 'H' TO resultPath  \n                    SET yPos AS yPos MINUS 1  \n                END IF  \n            ELSE  \n                APPEND 'V' TO resultPath  \n                SET xPos AS xPos MINUS 1  \n            END IF  \n            SET counter AS counter PLUS 1  \n        END WHILE  \n        RETURN combined string of elements in resultPath  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallestPath(destination PARAMETERS destination AND k)  \n        SET row TO element at position zero of destination  \n        SET col TO element at position one of destination  \n        SET path TO empty list  \n        SET total_moves TO col PLUS row  \n        FOR i FROM zero TO total_moves MINUS one  \n            IF col GREATER THAN zero  \n                SET paths_with_H TO the number of combinations of row PLUS col MINUS one TAKEN col MINUS one  \n                IF k LESS THAN OR EQUAL TO paths_with_H  \n                    APPEND character H TO path  \n                    DECREMENT col BY one  \n                ELSE  \n                    APPEND character V TO path  \n                    DECREMENT row BY one  \n                    DECREMENT k BY paths_with_H  \n                END IF  \n            ELSE  \n                APPEND character V TO path  \n                DECREMENT row BY one  \n            END IF  \n        END FOR  \n        RETURN concatenation of all elements in path as a string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "create-sorted-array-through-instructions", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        ASSIGN MOD ← 1 + (10 ^ 9)  \n        ASSIGN MAX ← 1 + MAX_VALUE(instructions)  \n        ASSIGN bit ← LIST_OF_ZEROS_WITH_LENGTH(MAX)  \n\n        FUNCTION update(idx val)  \n            LOOP  \n                IF NOT (idx < MAX) THEN BREAK  \n                bit[idx] ← bit[idx] + val  \n                idx ← idx + (idx AND (-idx))  \n            END LOOP  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            ASSIGN acc ← 0  \n            REPEAT WHILE idx > 0  \n                acc ← acc + bit[idx]  \n                idx ← idx - (idx AND (-idx))  \n            END REPEAT  \n            RETURN acc  \n        END FUNCTION  \n\n        ASSIGN total_cost ← 0  \n        SET enumerator ← ENUMERATE(instructions)  \n        FOR EACH i_num IN enumerator  \n            LET i ← i_num[0]  \n            LET num ← i_num[1]  \n            ASSIGN less_than ← query(num - 1)  \n            ASSIGN greater_than ← i - query(num)  \n            IF less_than <= greater_than THEN  \n                ASSIGN cost ← less_than  \n            ELSE  \n                ASSIGN cost ← greater_than  \n            END IF  \n            total_cost ← (total_cost + cost) MOD MOD  \n            CALL update(num, 1)  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET MAX TO the maximum element of instructions PLUS one  \n        SET bit TO a list of zeros with length MAX  \n\n        FUNCTION update(idx val)  \n            WHILE idx LESS THAN MAX holds  \n                INCREMENT element at position idx of bit BY val  \n                INCREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            SET total TO zero  \n            WHILE idx GREATER THAN zero holds  \n                INCREMENT total BY element at position idx of bit  \n                DECREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n            RETURN total  \n        END FUNCTION  \n\n        SET total_cost TO zero  \n        FOR each pair of i num IN the enumeration of instructions  \n            SET less_than TO the result of query with argument num MINUS one  \n            SET greater_than TO i MINUS the result of query with argument num  \n            IF less_than LESS THAN OR EQUAL TO greater_than holds  \n                SET cost TO less_than  \n            ELSE  \n                SET cost TO greater_than  \n            END IF  \n            SET total_cost TO the remainder of total_cost PLUS cost DIVIDED BY MOD  \n            CALL update with arguments num and one  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-initial-energy-to-finish-tasks", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumEffort(tasks)  \n        SET sorted_tasks AS tasks SORTED BY (task -> (task[1] - task[0])) IN DESCENDING ORDER  \n        SET energy_now TO 0  \n        SET initial_energy_needed TO 0  \n        SET index_counter TO 0  \n        WHILE index_counter < LENGTH(sorted_tasks) DO  \n            SET task_entry TO sorted_tasks[index_counter]  \n            SET consumption TO task_entry[0]  \n            SET threshold TO task_entry[1]  \n            IF NOT (energy_now >= threshold) THEN  \n                SET difference TO threshold - energy_now  \n                SET initial_energy_needed TO initial_energy_needed + difference  \n                SET energy_now TO threshold  \n            END IF  \n            SET energy_now TO energy_now - consumption  \n            SET index_counter TO index_counter + 1  \n        END WHILE  \n        RETURN initial_energy_needed  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumEffort(tasks)  \n        SORT tasks IN ORDER WHERE the element representing the difference between the second element MINUS the first element of each task IS IN DESCENDING ORDER  \n        SET current_energy TO zero  \n        SET required_initial_energy TO zero  \n        FOR each element IN tasks  \n            ASSIGN actual TO the first element of element  \n            ASSIGN minimum TO the second element of element  \n            IF current_energy LESS THAN minimum THEN  \n                INCREMENT required_initial_energy BY minimum MINUS current_energy  \n                SET current_energy TO minimum  \n            END IF  \n            DECREMENT current_energy BY actual  \n        END FOR  \n        RETURN required_initial_energy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-incompatibility", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        LET totalElements ← LENGTH nums  \n        LET sizePerSubset ← totalElements DIV k  \n        LET elementCounts ← COUNT ELEMENTS IN nums  \n        \n        FOR countValue IN elementCounts.VALUES  \n            IF countValue > k THEN RETURN -1  \n        END FOR  \n        \n        LET incompatibilityMap ← EMPTY DICTIONARY  \n        LET maxMask ← (2 POWER totalElements) - 1  \n        LET currentMask ← 0  \n        \n        WHILE currentMask <= maxMask DO  \n            LET bitsSet ← COUNT OF BITS SET IN currentMask  \n            \n            IF bitsSet = sizePerSubset THEN  \n                LET collected ← EMPTY LIST  \n                LET index ← 0  \n                \n                WHILE index < totalElements DO  \n                    IF (currentMask BITWISE-AND (2 POWER index)) ≠ 0 THEN  \n                        collected.APPEND(nums[index])  \n                    END IF  \n                    index ← index + 1  \n                END WHILE  \n                \n                LET uniqueElements ← SET OF collected  \n                IF LENGTH uniqueElements = sizePerSubset THEN  \n                    LET maxVal ← MAX OF collected  \n                    LET minVal ← MIN OF collected  \n                    LET diff ← maxVal - minVal  \n                    incompatibilityMap[currentMask] ← diff  \n                END IF  \n            END IF  \n            \n            currentMask ← currentMask + 1  \n        END WHILE  \n        \n        LET dpArray ← ARRAY OF SIZE (2 POWER totalElements) FILLED WITH INFINITY  \n        dpArray[0] ← 0  \n        \n        FOR maskValue FROM 0 TO maxMask DO  \n            IF (COUNT OF BITS SET IN maskValue) MOD sizePerSubset ≠ 0 THEN CONTINUE  \n            \n            FOR each candidateSubset IN incompatibilityMap.KEYS DO  \n                IF (maskValue BITWISE-AND candidateSubset) = candidateSubset THEN  \n                    LET attempt ← dpArray[maskValue - candidateSubset] + incompatibilityMap[candidateSubset]  \n                    IF attempt < dpArray[maskValue] THEN  \n                        dpArray[maskValue] ← attempt  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        LET fullSetMask ← maxMask  \n        IF dpArray[fullSetMask] ≠ INFINITY THEN  \n            RETURN dpArray[fullSetMask]  \n        ELSE  \n            RETURN -1  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        CREATE counter_object AS a COUNT of each element IN nums  \n        IF any count IN the VALUES OF counter_object is GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        CREATE empty dictionary subset_incompatibility  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask  \n            IF bit_count EQUALS subset_size THEN  \n                CREATE empty list elements  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BITWISE AND OF mask AND TWO RAISED TO THE POWER OF i is NOT EQUAL TO zero THEN  \n                        APPEND element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the NUMBER OF UNIQUE ELEMENTS IN elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM ELEMENT IN elements MINUS the MINIMUM ELEMENT IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT key mask  \n                END IF  \n            END IF  \n        END FOR  \n        CREATE list dp WITH LENGTH TWO RAISED TO THE POWER OF n FILLED WITH infinity  \n        SET dp AT position zero TO zero  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            IF the REMAINDER OF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask DIVIDED BY subset_size IS NOT EQUAL TO zero THEN  \n                CONTINUE TO the NEXT iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND OF mask AND subset_mask EQUALS subset_mask THEN  \n                    SET candidate_value TO dp AT position mask MINUS subset_mask PLUS subset_incompatibility AT subset_mask  \n                    IF candidate_value IS LESS THAN dp AT position mask THEN  \n                        SET dp AT position mask TO candidate_value  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET full_mask TO TWO RAISED TO THE POWER OF n MINUS one  \n        IF dp AT position full_mask IS NOT EQUAL TO infinity THEN  \n            RETURN dp AT position full_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canMouseWin(grid, catJump, mouseJump)\n        ASSIGN rows_count ← SIZE OF grid\n        ASSIGN cols_count ← SIZE OF grid AT zero\n        ASSIGN cat_init ← 0\n        ASSIGN mouse_init ← 0\n        ASSIGN food_pos ← 0\n        ASSIGN directions ← [ -1, 0, 1, 0, -1 ]\n        ASSIGN mouse_graph ← LIST OF EMPTY LISTS REPEATED rows_count * cols_count TIMES\n        ASSIGN cat_graph ← LIST OF EMPTY LISTS REPEATED rows_count * cols_count TIMES\n\n        FOR each row_index, row_val IN ENUMERATE(grid)\n            FOR each col_index, cell IN ENUMERATE(row_val)\n                IF cell IS EQUAL TO '#'\n                    CONTINUE TO NEXT LOOP ITERATION\n                END IF\n                ASSIGN vertex ← (row_index * cols_count) + col_index\n                IF cell IS 'C'\n                    ASSIGN cat_init ← vertex\n                ELSE IF cell IS 'M'\n                    ASSIGN mouse_init ← vertex\n                ELSE IF cell IS 'F'\n                    ASSIGN food_pos ← vertex\n                END IF\n\n                FOR pos IN 0 TO LENGTH(directions) - 2\n                    ASSIGN delta_x ← directions[pos]\n                    ASSIGN delta_y ← directions[pos + 1]\n\n                    FOR step FROM 0 TO mouseJump\n                        ASSIGN new_x ← row_index + step * delta_x\n                        ASSIGN new_y ← col_index + step * delta_y\n                        IF new_x < 0 OR new_x >= rows_count OR new_y < 0 OR new_y >= cols_count OR grid[new_x][new_y] = '#'\n                            LEAVE INNER LOOP\n                        END IF\n                        APPEND (new_x * cols_count + new_y) TO mouse_graph[vertex]\n                    END FOR\n\n                    FOR step FROM 0 TO catJump\n                        ASSIGN new_x ← row_index + step * delta_x\n                        ASSIGN new_y ← col_index + step * delta_y\n                        IF new_x < 0 OR new_x >= rows_count OR new_y < 0 OR new_y >= cols_count OR grid[new_x][new_y] = '#'\n                            LEAVE INNER LOOP\n                        END IF\n                        APPEND (new_x * cols_count + new_y) TO cat_graph[vertex]\n                    END FOR\n                END FOR\n            END FOR\n        END FOR\n        RETURN calc(mouse_graph, cat_graph, mouse_init, cat_init, food_pos) IS EQUAL TO 1\n    END FUNCTION\n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)\n        FUNCTION get_prev_states(state)\n            ASSIGN mouse_pos ← state[0]\n            ASSIGN cat_pos ← state[1]\n            ASSIGN turn_indicator ← state[2]\n            ASSIGN prev_turn ← turn_indicator XOR 1\n            ASSIGN results ← EMPTY LIST\n\n            IF prev_turn = 1\n                FOR each candidate_cat IN g_cat[cat_pos]\n                    IF ans[mouse_pos][candidate_cat][1] = 0\n                        APPEND (mouse_pos, candidate_cat, prev_turn) TO results\n                    END IF\n                END FOR\n            ELSE\n                FOR each candidate_mouse IN g_mouse[mouse_pos]\n                    IF ans[candidate_mouse][cat_pos][0] = 0\n                        APPEND (candidate_mouse, cat_pos, 0) TO results\n                    END IF\n                END FOR\n            END IF\n            RETURN results\n        END FUNCTION\n\n        ASSIGN total_states ← SIZE OF g_mouse\n        ASSIGN degree ← 3D ARRAY FILLED WITH 0 WITH DIMENSIONS [total_states][total_states][2]\n\n        FOR outer FROM 0 TO total_states - 1\n            FOR inner FROM 0 TO total_states - 1\n                degree[outer][inner][0] ← SIZE OF g_mouse[outer]\n                degree[outer][inner][1] ← SIZE OF g_cat[inner]\n            END FOR\n        END FOR\n\n        ASSIGN ans ← 3D ARRAY FILLED WITH 0 WITH DIMENSIONS [total_states][total_states][2]\n        ASSIGN queue ← EMPTY DOUBLE-ENDED QUEUE\n\n        FOR index FROM 0 TO total_states - 1\n            ans[hole][index][1] ← 1\n            ans[index][hole][0] ← 2\n            ans[index][index][1] ← 2\n            ans[index][index][0] ← 2\n\n            APPEND (hole, index, 1) TO queue\n            APPEND (index, hole, 0) TO queue\n            APPEND (index, index, 0) TO queue\n            APPEND (index, index, 1) TO queue\n        END FOR\n\n        WHILE queue IS NOT EMPTY\n            ASSIGN current_state ← POP LEFT FROM queue\n            ASSIGN current_value ← ans[current_state[0]][current_state[1]][current_state[2]]\n\n            FOR each predecessor IN get_prev_states(current_state)\n                ASSIGN pm ← predecessor[0]\n                ASSIGN pc ← predecessor[1]\n                ASSIGN pt ← predecessor[2]\n\n                IF pt = current_value - 1\n                    ans[pm][pc][pt] ← current_value\n                    APPEND predecessor TO queue\n                ELSE\n                    degree[pm][pc][pt] ← degree[pm][pc][pt] - 1\n                    IF degree[pm][pc][pt] = 0\n                        ans[pm][pc][pt] ← current_value\n                        APPEND predecessor TO queue\n                    END IF\n                END IF\n            END FOR\n        END WHILE\n        RETURN ans[mouse_start][cat_start][0]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the LIST of MINUS one zero ONE zero MINUS one  \n        SET g_mouse TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n        SET g_cat TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n\n        FOR each index i AND element row IN the ENUMERATION OF grid  \n            FOR each index j AND element c IN the ENUMERATION OF row  \n                IF c EQUALS the character representing a HASH  \n                    CONTINUE  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character representing uppercase C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character representing uppercase M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character representing uppercase F  \n                    SET food TO v  \n                END IF  \n                FOR each element a AND next element b IN consecutive pairs of dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the RESULT OF calling calc WITH g_mouse, g_cat, mouse_start, cat_start, food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            SET m TO element at position zero of state  \n            SET c TO element at position one of state  \n            SET t TO element at position two of state  \n            SET pt TO the EXCLUSIVE OR of t AND one  \n            SET pre TO an empty LIST  \n            IF pt EQUALS one  \n                FOR each pc IN element at position c of g_cat  \n                    IF element at position m AND position pc AND position one of ans EQUALS zero  \n                        APPEND the TUPLE of m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN element at position m of g_mouse  \n                    IF element at position pm AND position c AND position zero of ans EQUALS zero  \n                        APPEND the TUPLE of pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET element at position zero of element at position j of element at position i of degree TO the LENGTH OF element at position i of g_mouse  \n                SET element at position one of element at position j of element at position i of degree TO the LENGTH OF element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position hole AND position i AND position one of ans TO one  \n            SET element at position i AND position hole AND position zero of ans TO two  \n            SET element at position i AND position i AND position one of ans TO two  \n            SET element at position i AND position i AND position zero of ans TO two  \n            ADD the TUPLE of hole i one TO the end of q  \n            ADD the TUPLE of i hole zero TO the end of q  \n            ADD the TUPLE of i i zero TO the end of q  \n            ADD the TUPLE of i i one TO the end of q  \n        END FOR  \n        WHILE q is not empty  \n            REMOVE the element from the front of q AND ASSIGN to state  \n            SET t TO element at position zero AND position one AND position two of ans ACCORDING TO state  \n            FOR each prev_state IN get_prev_states WITH state  \n                SET pm TO element at position zero of prev_state  \n                SET pc TO element at position one of prev_state  \n                SET pt TO element at position two of prev_state  \n                IF pt EQUALS t MINUS one  \n                    SET element at position pm AND position pc AND position pt of ans TO t  \n                    ADD prev_state TO the end of q  \n                ELSE  \n                    DECREMENT element at position pm AND position pc AND position pt of degree BY one  \n                    IF element at position pm AND position pc AND position pt of degree EQUALS zero  \n                        SET element at position pm AND position pc AND position pt of ans TO t  \n                        ADD prev_state TO the end of q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN element at position mouse_start AND position cat_start AND position zero of ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-different-subsequences-gcds", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET upper_bound AS the largest element found in nums  \n        SET elements_map AS a mapping of all items in nums to true  \n        SET total_count AS 0  \n        SET g_index AS 1  \n        WHILE g_index <= upper_bound DO  \n            SET current_gcd AS 0  \n            SET multiplier AS 1  \n            LOOP   \n                SET candidate_num AS g_index * multiplier  \n                IF candidate_num > upper_bound THEN  \n                    EXIT LOOP  \n                END IF  \n                IF elements_map HAS candidate_num THEN  \n                    SET current_gcd AS gcd(current_gcd, candidate_num)  \n                    IF current_gcd = g_index THEN  \n                        total_count ← total_count + 1  \n                        EXIT LOOP  \n                    END IF  \n                END IF  \n                SET multiplier ← multiplier + 1  \n            END LOOP  \n            SET g_index ← g_index + 1  \n        END WHILE  \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET max_num TO the maximum value in nums  \n        SET num_set TO the set of elements in nums  \n        SET count TO zero  \n        FOR g FROM one TO max_num INCLUSIVE  \n            SET gcd_val TO zero  \n            FOR m FROM g TO max_num INCLUSIVE IN STEPS OF g  \n                IF element at position m of num_set IS PRESENT  \n                    SET gcd_val TO the greatest common divisor of gcd_val AND m  \n                    IF gcd_val EQUALS g  \n                        INCREMENT count BY one  \n                        BREAK out of inner loop  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-floored-pairs", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION sumOfFlooredPairs(nums)\n        ASSIGN MOD ← 1_000_000_001\n        ASSIGN max_val ← MAXIMUM element in nums\n        ASSIGN freq_map ← DICTIONARY mapping elements in nums TO their respective counts\n        ASSIGN prefix_arr ← ARRAY filled with 0, of size (max_val + 1)\n\n        FOR EACH element IN freq_map DO\n            prefix_arr[element] ← prefix_arr[element] + freq_map[element]\n        END FOR\n\n        SET idx ← 1\n        WHILE idx ≤ max_val DO\n            prefix_arr[idx] ← prefix_arr[idx] + prefix_arr[idx - 1]\n            idx ← idx + 1\n        END WHILE\n\n        ASSIGN ans ← 0\n\n        FOR key IN freq_map DO\n            ASSIGN multiplier ← 1\n            WHILE multiplier * key ≤ max_val DO\n                ASSIGN range_start ← multiplier * key\n                \n                IF multiplier * key + key - 1 ≤ max_val THEN\n                    ASSIGN range_end ← multiplier * key + key - 1\n                ELSE\n                    ASSIGN range_end ← max_val\n                END IF\n                \n                ASSIGN count_in_range ← prefix_arr[range_end] - prefix_arr[range_start - 1]\n                ans ← (ans + (count_in_range * multiplier * freq_map[key])) MOD MOD\n                multiplier ← multiplier + 1\n            END WHILE\n        END FOR\n\n        RETURN ans\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET max_num TO the maximum element in nums  \n        SET count TO a mapping from elements in nums to their frequencies  \n        SET prefix_sum TO a list of zeroes with length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num in count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the integer division of max_num BY num  \n                SET start TO num MULTIPLIED BY multiple  \n                IF num MULTIPLIED BY the sum of multiple PLUS one MINUS one LESS THAN OR EQUAL TO max_num  \n                    SET end TO num MULTIPLIED BY multiple PLUS one MINUS one  \n                ELSE  \n                    SET end TO max_num  \n                END IF  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num in count  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "painting-a-grid-with-three-different-colors", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION colorTheGrid(m PARAMETER n PARAMETER)  \n        SET MOD ← 10^9 + 7  \n        \n        FUNCTION generate_valid_columns(prev_col PARAMETER)  \n            SET palette ← [2, 1, 3]  \n            SET valid_columns ← []  \n            \n            FUNCTION backtrack(col PARAMETER row PARAMETER)  \n                IF (m = row) THEN  \n                    SET valid_columns ← valid_columns + [(col)]  \n                    RETURN  \n                END IF  \n                \n                SET index ← 0  \n                WHILE index < LENGTH(palette) DO  \n                    SET current_color ← palette[index]  \n                    \n                    IF (LENGTH(col) = 0 OR col[-1] ≠ current_color) THEN  \n                        IF (prev_col ≠ null AND prev_col[row] = current_color) THEN  \n                            SET index ← index + 1  \n                            CONTINUE  \n                        END IF  \n                        \n                        SET col ← col + [current_color]  \n                        CALL backtrack(col, row + 1)  \n                        SET col ← col[0 : LENGTH(col) - 1]  \n                    END IF  \n                    SET index ← index + 1  \n                END WHILE  \n            END FUNCTION  \n            \n            CALL backtrack([], 0)  \n            RETURN valid_columns  \n        END FUNCTION  \n        \n        SET all_valid_cols ← generate_valid_columns(null)  \n        SET total_valid_cols ← LENGTH(all_valid_cols)  \n        \n        SET compatible_cols ← DICTIONARY()  \n        SET pos_i ← 0  \n        WHILE pos_i < total_valid_cols DO  \n            SET compatible_cols[pos_i] ← []  \n            SET pos_j ← 0  \n            WHILE pos_j < total_valid_cols DO  \n                SET compatible ← true  \n                SET pos_k ← 0  \n                WHILE pos_k < m DO  \n                    IF all_valid_cols[pos_i][pos_k] = all_valid_cols[pos_j][pos_k] THEN  \n                        SET compatible ← false  \n                        BREAK  \n                    END IF  \n                    SET pos_k ← pos_k + 1  \n                END WHILE  \n                \n                IF compatible THEN  \n                    SET compatible_cols[pos_i] ← compatible_cols[pos_i] + [pos_j]  \n                END IF  \n                SET pos_j ← pos_j + 1  \n            END WHILE  \n            SET pos_i ← pos_i + 1  \n        END WHILE  \n        \n        SET dp ← []  \n        SET idx ← 0  \n        WHILE idx < total_valid_cols DO  \n            SET dp ← dp + [1]  \n            SET idx ← idx + 1  \n        END WHILE  \n        \n        SET iteration ← 1  \n        WHILE iteration < n DO  \n            SET next_dp ← []  \n            SET jdx ← 0  \n            WHILE jdx < total_valid_cols DO  \n                SET next_dp ← next_dp + [0]  \n                SET jdx ← jdx + 1  \n            END WHILE  \n            \n            SET idx ← 0  \n            WHILE idx < total_valid_cols DO  \n                FOR each compatible_index IN compatible_cols[idx] DO  \n                    SET next_dp[compatible_index] ← (next_dp[compatible_index] + dp[idx]) MOD MOD  \n                END FOR  \n                SET idx ← idx + 1  \n            END WHILE  \n            \n            SET dp ← next_dp  \n            SET iteration ← iteration + 1  \n        END WHILE  \n        \n        SET sum_ways ← 0  \n        FOR each val IN dp DO  \n            SET sum_ways ← sum_ways + val  \n        END FOR  \n        SET sum_ways ← sum_ways MOD MOD  \n        \n        RETURN sum_ways  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION colorTheGrid(m PARAMETER n PARAMETER)  \n        SET MOD TO one billion PLUS seven  \n        \n        FUNCTION generate_valid_columns(prev_col PARAMETER)  \n            SET colors TO list containing one two three  \n            SET valid_cols TO empty list  \n            \n            FUNCTION backtrack(col PARAMETER row PARAMETER)  \n                IF row EQUALS m  \n                    APPEND a tuple of col TO valid_cols  \n                    RETURN  \n                END IF  \n                FOR each color IN colors  \n                    IF col IS empty OR element at position the last of col NOT EQUALS color  \n                        IF prev_col IS NOT null AND element at position row of prev_col EQUALS color  \n                            CONTINUE to next iteration of loop  \n                        END IF  \n                        APPEND color TO col  \n                        CALL backtrack WITH col AND row PLUS one  \n                        REMOVE last element FROM col  \n                    END IF  \n                END FOR  \n            END FUNCTION  \n            \n            CALL backtrack WITH empty list AND zero  \n            RETURN valid_cols  \n        END FUNCTION  \n        \n        SET all_valid_cols TO the result of calling generate_valid_columns WITH null  \n        SET num_valid_cols TO the length of all_valid_cols  \n        \n        SET compatible_cols TO a mapping FROM each index i FROM zero TO num_valid_cols MINUS one TO empty list  \n        FOR i FROM zero TO num_valid_cols MINUS one  \n            FOR j FROM zero TO num_valid_cols MINUS one  \n                SET are_compatible TO true  \n                FOR k FROM zero TO m MINUS one  \n                    IF element at position k of element at position i of all_valid_cols EQUALS element at position k of element at position j of all_valid_cols  \n                        SET are_compatible TO false  \n                        BREAK inner loop  \n                    END IF  \n                END FOR  \n                IF are_compatible  \n                    APPEND j TO element at position i of compatible_cols  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a list of length num_valid_cols WITH each element SET TO one  \n        \n        FOR each _ FROM one TO n MINUS one  \n            SET next_dp TO a list of length num_valid_cols WITH each element SET TO zero  \n            FOR i FROM zero TO num_valid_cols MINUS one  \n                FOR each j IN element at position i of compatible_cols  \n                    SET element at position j of next_dp TO element at position j of next_dp PLUS element at position i of dp MODULO MOD  \n                END FOR  \n            END FOR  \n            SET dp TO next_dp  \n        END FOR  \n        \n        SET total_ways TO zero  \n        FOR each value IN dp  \n            INCREMENT total_ways BY value  \n        END FOR  \n        SET total_ways TO total_ways MODULO MOD  \n        \n        RETURN total_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-duplicate-folders-in-system", "label": "cosmetic", "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        LET alphaChildren BE a newly created default dictionary that returns TrieNode objects  \n        ASSIGN self.children ← alphaChildren  \n        SET self.deleted AS False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION deleteDuplicateFolder(self, paths)  \n        LET collectedResults BE an empty list  \n        INITIALIZE root TO a new TrieNode instance  \n        LET groupsBySubtree BE a fresh default dictionary that defaults to empty lists  \n\n        LET indexA BE 0  \n        LET sortedPaths BE paths arranged in ascending order  \n        WHILE indexA < LENGTH OF sortedPaths  \n            LET currentPath BE sortedPaths[indexA]  \n            LET cursorNode BE root  \n\n            LET indexB BE 0  \n            WHILE indexB < LENGTH OF currentPath  \n                LET folderName BE currentPath[indexB]  \n                cursorNode ← cursorNode.children[folderName]  \n                indexB ← indexB + 1  \n            END WHILE  \n\n            indexA ← indexA + 1  \n        END WHILE  \n\n        FUNCTION buildSubtreeToRoots(node)  \n            LET componentList BE \"(\"  \n            LET keyCollection BE KEYS OF node.children  \n            LET idx BE 0  \n            WHILE idx < LENGTH OF keyCollection  \n                LET keyString BE keyCollection[idx]  \n                LET childNode BE node.children[keyString]  \n                LET childSubtree BE buildSubtreeToRoots(childNode)  \n                componentList ← componentList + keyString + childSubtree  \n                idx ← idx + 1  \n            END WHILE  \n            componentList ← componentList + \")\"  \n\n            IF componentList <> \"()\" THEN  \n                groupsBySubtree[componentList].APPEND(node)  \n            END IF  \n\n            RETURN componentList  \n        END FUNCTION  \n\n        CALL buildSubtreeToRoots WITH root  \n\n        FOR EACH nodeGroup IN groupsBySubtree.VALUES() DO  \n            IF LENGTH OF nodeGroup > 1 THEN  \n                LET pos BE 0  \n                WHILE pos < LENGTH OF nodeGroup  \n                    LET currentNode TO nodeGroup[pos]  \n                    currentNode.deleted ← True  \n                    pos ← pos + 1  \n                END WHILE  \n            END IF  \n        END FOR  \n\n        FUNCTION constructPath(node, path)  \n            LET keysList BE node.children.KEYS()  \n            LET i BE 0  \n            WHILE i < LENGTH OF keysList  \n                LET keyName BE keysList[i]  \n                LET childNode BE node.children[keyName]  \n                IF childNode.deleted = False THEN  \n                    constructPath(childNode, path + [keyName])  \n                END IF  \n                i ← i + 1  \n            END WHILE  \n            IF LENGTH OF path > 0 THEN  \n                collectedResults.APPEND(path)  \n            END IF  \n        END FUNCTION  \n\n        constructPath(root, [])  \n        RETURN collectedResults  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        SET self.children TO a new default dictionary that creates TrieNode objects  \n        SET self.deleted TO False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION deleteDuplicateFolder(self, paths)  \n        SET ans TO an empty list  \n        SET root TO a new TrieNode object  \n        SET subtreeToNodes TO a new default dictionary with list as default value  \n\n        FOR each path IN the sorted order of paths  \n            SET node TO root  \n            FOR each s IN path  \n                SET node TO the child node of node.children corresponding to the element s  \n            END FOR  \n        END FOR  \n\n        FUNCTION buildSubtreeToRoots(node)  \n            SET subtree TO the concatenation of an opening parenthesis WITH  \n                the concatenation FOR each s IN the children of node OF  \n                    the element s concatenated WITH buildSubtreeToRoots called with the child node corresponding to s  \n                AND THEN a closing parenthesis  \n            IF subtree NOT EQUALS the string consisting of opening and closing parenthesis with nothing in between  \n                APPEND node TO the list in subtreeToNodes corresponding to the key subtree  \n            END IF  \n            RETURN subtree  \n        END FUNCTION  \n\n        CALL buildSubtreeToRoots with root as argument  \n\n        FOR each nodes IN the values of subtreeToNodes  \n            IF the length of nodes GREATER THAN one  \n                FOR each node IN nodes  \n                    SET node.deleted TO True  \n                END FOR  \n            END IF  \n        END FOR  \n\n        FUNCTION constructPath(node, path)  \n            FOR each pair of s and child IN the items of node.children  \n                IF child.deleted EQUALS False  \n                    CALL constructPath with child and the concatenation of path WITH the element s as a new list  \n                END IF  \n            END FOR  \n            IF the length of path GREATER THAN zero  \n                APPEND path TO ans  \n            END IF  \n        END FUNCTION  \n\n        CALL constructPath with root and an empty list as arguments  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gcd-sort-of-an-array", "label": "cosmetic", "pseudocode": "CLASS UnionFind  \n  FUNCTION __init__(self, size)  \n    LET ancestry_list BE empty list  \n    LET hierarchy_levels BE empty list  \n    LET index_counter BE 0  \n    WHILE index_counter LESS THAN OR EQUAL TO size MINUS 1  \n      APPEND index_counter TO ancestry_list  \n      INCREMENT index_counter BY 1  \n    END WHILE  \n    LET copy_counter BE 0  \n    WHILE copy_counter LESS THAN size  \n      APPEND 1 TO hierarchy_levels  \n      INCREMENT copy_counter BY 1  \n    END WHILE  \n    ASSIGN self.parent TO ancestry_list  \n    ASSIGN self.rank TO hierarchy_levels  \n  END FUNCTION  \n  \n  FUNCTION find(self, p)  \n    IF self.parent[p] IS NOT EQUAL TO p  \n      ASSIGN self.parent[p] TO self.find(self.parent[p])  \n    END IF  \n    RETURN self.parent[p]  \n  END FUNCTION  \n  \n  FUNCTION union(self, p, q)  \n    LET rootA BE self.find(p)  \n    LET rootB BE self.find(q)  \n    IF NOT (rootA IS NOT rootB)  \n      RETURN False  \n    END IF  \n    IF self.rank[rootA] GREATER THAN self.rank[rootB]  \n      ASSIGN self.parent[rootB] TO rootA  \n    ELSE IF NOT (self.rank[rootA] GREATER THAN OR EQUAL TO self.rank[rootB])  \n      ASSIGN self.parent[rootA] TO rootB  \n    ELSE  \n      ASSIGN self.parent[rootB] TO rootA  \n      LET current_rank BE self.rank[rootA]  \n      LET updated_rank BE current_rank PLUS 1  \n      ASSIGN self.rank[rootA] TO updated_rank  \n    END IF  \n    RETURN True  \n  END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n  FUNCTION gcdSort(self, nums)  \n    LET ordered_nums BE new list of elements of nums sorted by ascending order  \n    LET peak_value BE nums[0]  \n    LET idx_check BE 1  \n    WHILE idx_check LESS THAN LENGTH of nums  \n      IF nums[idx_check] GREATER THAN peak_value  \n        ASSIGN peak_value TO nums[idx_check]  \n      END IF  \n      INCREMENT idx_check BY 1  \n    END WHILE  \n  \n    LET union_struct BE UnionFind(peak_value PLUS 1)  \n  \n    LET outer_pos BE 0  \n    WHILE outer_pos LESS THAN LENGTH of nums  \n      LET current_element BE nums[outer_pos]  \n      LET factor_check BE 2  \n      LET limit_factor BE INTEGER(SQRT(current_element)) PLUS 1  \n      WHILE factor_check LESS THAN limit_factor  \n        LET division_remainder BE (current_element MINUS factor_check * (current_element DIV factor_check))  \n        IF division_remainder IS EQUAL TO 0  \n          union_struct.union(current_element, factor_check)  \n          union_struct.union(current_element, current_element DIV factor_check)  \n        END IF  \n        INCREMENT factor_check BY 1  \n      END WHILE  \n      INCREMENT outer_pos BY 1  \n    END WHILE  \n  \n    LET compare_index BE 0  \n    WHILE compare_index LESS THAN LENGTH of nums  \n      LET original_parent BE union_struct.find(nums[compare_index])  \n      LET sorted_parent BE union_struct.find(ordered_nums[compare_index])  \n      IF original_parent IS NOT EQUAL TO sorted_parent  \n        RETURN False  \n      END IF  \n      INCREMENT compare_index BY 1  \n    END WHILE  \n  \n    RETURN True  \n  END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n        SET self.rank TO list containing size copies of one  \n    END FUNCTION  \n\n    FUNCTION find(self, p)  \n        IF element at position p of self.parent NOT EQUALS p  \n            SET element at position p of self.parent TO self.find(element at position p of self.parent)  \n        END IF  \n        RETURN element at position p of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, p, q)  \n        SET rootP TO self.find(p)  \n        SET rootQ TO self.find(q)  \n        IF rootP EQUALS rootQ  \n            RETURN False  \n        END IF  \n        IF element at position rootP of self.rank GREATER THAN element at position rootQ of self.rank  \n            SET element at position rootQ of self.parent TO rootP  \n        ELSE IF element at position rootP of self.rank LESS THAN element at position rootQ of self.rank  \n            SET element at position rootP of self.parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of self.parent TO rootP  \n            INCREMENT element at position rootP of self.rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION gcdSort(self, nums)  \n        SET sorted_nums TO nums sorted in ascending order  \n        SET max_val TO the maximum value in nums  \n        SET uf TO a new UnionFind object initialized with max_val PLUS one  \n\n        FOR each num IN nums  \n            FOR each factor FROM two TO the integer part of the square root of num PLUS one  \n                IF num MODULO factor EQUALS zero  \n                    CALL uf.union(num, factor)  \n                    CALL uf.union(num, num DIVIDED BY factor)  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each i FROM zero TO the length of nums MINUS one  \n            IF uf.find(element at position i of nums) NOT EQUALS uf.find(element at position i of sorted_nums)  \n                RETURN False  \n            END IF  \n        END FOR  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-score-of-students-solving-math-expression", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION scoreOfStudents(s STRING, answers LIST OF INT)  \n        FUNCTION evaluate_expression(expression STRING)  \n            DECLARE fragments AS LIST OF INT OR CHAR ← EMPTY LIST  \n            DECLARE temp_number AS INT ← 0  \n            \n            DECLARE idx AS INT ← 0  \n            WHILE idx LESS THAN LENGTH(expression) DO  \n                DECLARE current_char AS CHAR ← expression[idx]  \n                IF current_char IN ['0','1','2','3','4','5','6','7','8','9'] THEN  \n                    SET temp_number ← (temp_number * 10) + (current_char - '0')  \n                ELSE  \n                    APPEND temp_number TO fragments  \n                    APPEND current_char TO fragments  \n                    SET temp_number ← 0  \n                END IF  \n                INCREMENT idx BY 1  \n            END WHILE  \n            APPEND temp_number TO fragments  \n            \n            DECLARE pos AS INT ← 1  \n            WHILE pos LESS THAN LENGTH(fragments) DO  \n                SWITCH fragments[pos]  \n                    CASE '*':  \n                        DECLARE multiplied_value AS INT ← fragments[pos - 1] * fragments[pos + 1]  \n                        SET fragments[pos - 1] ← multiplied_value  \n                        REMOVE elements from fragments at indices pos and pos + 1  \n                    DEFAULT:  \n                        INCREMENT pos BY 1  \n                END SWITCH  \n            END WHILE  \n            \n            DECLARE final_result AS INT ← fragments[0]  \n            DECLARE iterator AS INT ← 1  \n            WHILE iterator LESS THAN LENGTH(fragments) DO  \n                IF fragments[iterator] = '+' THEN  \n                    SET final_result ← final_result + fragments[iterator + 1]  \n                END IF  \n                SET iterator ← iterator + 2  \n            END WHILE  \n            \n            RETURN final_result  \n        END FUNCTION  \n        \n        FUNCTION get_possible_answers(expression STRING)  \n            DECLARE all_digits_flag AS BOOLEAN ← TRUE  \n            DECLARE pos_check AS INT ← 0  \n            WHILE pos_check LESS THAN LENGTH(expression) DO  \n                IF NOT (expression[pos_check] IN ['0','1','2','3','4','5','6','7','8','9']) THEN  \n                    SET all_digits_flag ← FALSE  \n                    BREAK  \n                END IF  \n                INCREMENT pos_check BY 1  \n            END WHILE  \n            IF all_digits_flag THEN  \n                DECLARE numeric_val AS INT ← 0  \n                DECLARE digit_index AS INT ← 0  \n                WHILE digit_index LESS THAN LENGTH(expression) DO  \n                    SET numeric_val ← (numeric_val * 10) + (expression[digit_index] - '0')  \n                    INCREMENT digit_index BY 1  \n                END WHILE  \n                RETURN SET WITH ELEMENT numeric_val  \n            END IF  \n            \n            DECLARE answer_set AS SET OF INT ← EMPTY SET  \n            DECLARE split_pos AS INT ← 1  \n            WHILE split_pos LESS THAN LENGTH(expression) - 1 DO  \n                IF split_pos MOD 2 = 1 THEN  \n                    DECLARE left_side AS SET OF INT ← get_possible_answers(expression[0 : split_pos])  \n                    DECLARE right_side AS SET OF INT ← get_possible_answers(expression[split_pos + 1 : LENGTH(expression)])  \n                    FOR EACH left_val IN left_side DO  \n                        FOR EACH right_val IN right_side DO  \n                            DECLARE combined_val AS INT  \n                            IF expression[split_pos] = '+' THEN  \n                                SET combined_val ← left_val + right_val  \n                            ELSE  \n                                SET combined_val ← left_val * right_val  \n                            END IF  \n                            IF combined_val <= 1000 THEN  \n                                INSERT combined_val INTO answer_set  \n                            END IF  \n                        END FOR  \n                    END FOR  \n                END IF  \n                INCREMENT split_pos BY 1  \n            END WHILE  \n            \n            RETURN answer_set  \n        END FUNCTION  \n        \n        DECLARE evaluation_result AS INT ← evaluate_expression(s)  \n        DECLARE all_possible_answers AS SET OF INT ← get_possible_answers(s)  \n        \n        DECLARE total_points AS INT ← 0  \n        FOR EACH submitted_answer IN answers DO  \n            IF submitted_answer = evaluation_result THEN  \n                SET total_points ← total_points + 5  \n            ELSE  \n                IF submitted_answer IN all_possible_answers THEN  \n                    SET total_points ← total_points + 2  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN total_points  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION scoreOfStudents(s parameter named s AND answers parameter named answers)  \n        FUNCTION evaluate_expression(expression parameter named expression)  \n            SET tokens TO an empty list  \n            SET num TO zero  \n            FOR each character IN expression  \n                IF character is a digit THEN  \n                    SET num TO num MULTIPLIED BY ten PLUS numeric value of character  \n                ELSE  \n                    APPEND num TO tokens  \n                    APPEND character TO tokens  \n                    SET num TO zero  \n                END IF  \n            END FOR  \n            APPEND num TO tokens  \n            \n            SET i TO one  \n            WHILE i LESS THAN the LENGTH OF tokens DO  \n                IF element at position i of tokens EQUALS the multiplication symbol THEN  \n                    SET element at position i MINUS one of tokens TO the product of element at position i MINUS one of tokens MULTIPLIED BY element at position i PLUS one of tokens  \n                    REMOVE elements at positions i TO i PLUS two EXCLUSIVE FROM tokens  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n            \n            SET result TO element at position zero of tokens  \n            SET i TO one  \n            WHILE i LESS THAN the LENGTH OF tokens DO  \n                IF element at position i of tokens EQUALS the addition symbol THEN  \n                    SET result TO result PLUS element at position i PLUS one of tokens  \n                END IF  \n                INCREMENT i BY two  \n            END WHILE  \n            \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION get_possible_answers(expression parameter named expression)  \n            IF expression is composed entirely of digits THEN  \n                RETURN a set containing the numeric value of expression  \n            END IF  \n            \n            SET results TO an empty set  \n            FOR i FROM one TO the LENGTH OF expression MINUS one MINUS one STEP two DO  \n                SET left_results TO the return value of get_possible_answers with substring of expression from position zero TO position i MINUS one  \n                SET right_results TO the return value of get_possible_answers with substring of expression from position i PLUS one TO the end  \n                FOR each left IN left_results  \n                    FOR each right IN right_results  \n                        IF element at position i of expression EQUALS the addition symbol THEN  \n                            SET result TO left PLUS right  \n                        ELSE  \n                            SET result TO left MULTIPLIED BY right  \n                        END IF  \n                        IF result LESS THAN OR EQUAL TO one thousand THEN  \n                            ADD result TO results  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n        \n        SET correct_answer TO the return value of evaluate_expression with s as argument  \n        SET possible_answers TO the return value of get_possible_answers with s as argument  \n        \n        SET points TO zero  \n        FOR each answer IN answers  \n            IF answer EQUALS correct_answer THEN  \n                INCREMENT points BY five  \n            ELSE IF answer IS IN possible_answers THEN  \n                INCREMENT points BY two  \n            END IF  \n        END FOR  \n        \n        RETURN points  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-array-into-two-arrays-to-minimize-sum-difference", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minimumDifference(nums)\n        ASSIGN (LENGTH OF nums) DIV 2 TO half_length\n        ASSIGN ADD ALL ELEMENTS IN nums TO sum_total\n        ASSIGN sum_total DIV 2 TO half_target\n        ASSIGN positive infinity TO minimal_difference\n\n        ASSIGN SUBARRAY OF nums FROM INDEX 0 TO half_length EXCLUSIVE TO left_segment\n        ASSIGN SUBARRAY OF nums FROM INDEX half_length TO END TO right_segment\n\n        ASSIGN A LIST OF (half_length + 1) EMPTY MAPS TO sums_left\n        ASSIGN A LIST OF (half_length + 1) EMPTY MAPS TO sums_right\n\n        ASSIGN 0 TO idx_i\n        WHILE idx_i <= half_length\n            FOR EACH grouping IN COMBINATIONS(left_segment, idx_i) DO\n                ASSIGN SUM OF grouping TO curr_sum\n                IF curr_sum NOT IN sums_left[idx_i] THEN\n                    ASSIGN 0 TO sums_left[idx_i][curr_sum]\n                END IF\n                ASSIGN sums_left[idx_i][curr_sum] + 1 TO sums_left[idx_i][curr_sum]\n            END FOR\n\n            FOR EACH grouping IN COMBINATIONS(right_segment, idx_i) DO\n                ASSIGN SUM OF grouping TO curr_sum\n                IF curr_sum NOT IN sums_right[idx_i] THEN\n                    ASSIGN 0 TO sums_right[idx_i][curr_sum]\n                END IF\n                ASSIGN sums_right[idx_i][curr_sum] + 1 TO sums_right[idx_i][curr_sum]\n            END FOR\n            ASSIGN idx_i + 1 TO idx_i\n        END WHILE\n\n        ASSIGN 0 TO idx_i\n        WHILE idx_i <= half_length\n            ASSIGN SORTED KEYS OF sums_left[idx_i] TO left_keys_sorted\n            ASSIGN SORTED KEYS OF sums_right[half_length - idx_i] TO right_keys_sorted\n\n            ASSIGN 0 TO ptr_left\n            ASSIGN LENGTH OF right_keys_sorted - 1 TO ptr_right\n\n            WHILE ptr_left < LENGTH OF left_keys_sorted AND ptr_right >= 0\n                ASSIGN left_keys_sorted[ptr_left] + right_keys_sorted[ptr_right] TO combined_sum\n                ASSIGN sum_total - 2 * combined_sum TO candidate_diff\n\n                IF candidate_diff < 0 THEN\n                    ASSIGN -candidate_diff TO candidate_diff\n                END IF\n\n                IF candidate_diff < minimal_difference THEN\n                    ASSIGN candidate_diff TO minimal_difference\n                END IF\n\n                IF combined_sum < half_target THEN\n                    INCREMENT ptr_left BY 1\n                ELSE IF combined_sum > half_target THEN\n                    DECREMENT ptr_right BY 1\n                ELSE\n                    RETURN 0\n                END IF\n            END WHILE\n            INCREMENT idx_i BY 1\n        END WHILE\n\n        RETURN minimal_difference\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumDifference(nums)  \n        SET n TO the LENGTH OF nums DIVIDED BY two  \n        SET total_sum TO the SUM OF nums  \n        SET target TO total_sum DIVIDED BY two  \n        SET min_diff TO positive infinity  \n        \n        SET left_half TO the first n elements of nums  \n        SET right_half TO the elements of nums from position n plus one TO the end  \n        \n        SET left_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        SET right_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        \n        FOR i FROM zero TO n  \n            FOR each combination of i elements IN left_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN left_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN left_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN left_sums at position i BY one  \n            END FOR  \n            \n            FOR each combination of i elements IN right_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN right_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN right_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN right_sums at position i BY one  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO n  \n            SET left_values TO the keys of left_sums at position i SORTED in ascending order  \n            SET right_values TO the keys of right_sums at position n MINUS i SORTED in ascending order  \n            \n            SET j TO zero  \n            SET k TO the LENGTH OF right_values MINUS one  \n            \n            WHILE j LESS THAN the LENGTH OF left_values AND k GREATER THAN OR EQUAL TO zero  \n                SET current_sum TO the element at position j of left_values PLUS the element at position k of right_values  \n                SET diff_candidate TO total_sum MINUS two MULTIPLIED BY current_sum  \n                IF diff_candidate IS LESS THAN zero  \n                    SET diff_candidate TO the NEGATIVE of diff_candidate  \n                END IF  \n                IF diff_candidate LESS THAN min_diff  \n                    SET min_diff TO diff_candidate  \n                END IF  \n                \n                IF current_sum LESS THAN target  \n                    INCREMENT j BY one  \n                ELSE IF current_sum GREATER THAN target  \n                    DECREMENT k BY one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "second-minimum-time-to-reach-destination", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION secondMinimum(n  \n                            edges  \n                            time  \n                            change)  \n        SET adjacencyList AS empty lists for every integer idx IN RANGE 0 TO n INCLUSIVE  \n        FOR EACH edgePair IN edges  \n            LET x, y BE unwrapped FROM edgePair  \n            INSERT y INTO adjacencyList AT position x  \n            INSERT x INTO adjacencyList AT position y  \n        END FOR  \n        \n        CREATE deque WITH element (1, 0, 0) AS (node, elapsed, visits)  \n        DEFINE times AS list WITH (infinity, infinity) FOR EACH index FROM 0 TO n  \n        ASSIGN 0 TO times[1][0]  \n        \n        WHILE NOT deque IS EMPTY  \n            EXTRACT deque's front ELEMENT INTO currentNode, elapsedTime, visitCount  \n            \n            IF currentNode IS n THEN  \n                IF visitCount IS 1 THEN RETURN elapsedTime END IF  \n            END IF  \n            \n            LET phase BE (elapsedTime DIV change) MOD 2  \n            IF phase IS 0 THEN  \n                ASSIGN elapsedTime + time TO nextElapsed  \n            ELSE  \n                ASSIGN ((elapsedTime DIV change) + 1) * change + time TO nextElapsed  \n            END IF  \n            \n            FOR adjNode IN adjacencyList[currentNode] DO  \n                IF times[adjNode][0] > nextElapsed THEN  \n                    ASSIGN times[adjNode][1] TO times[adjNode][0]  \n                    ASSIGN nextElapsed TO times[adjNode][0]  \n                    PUSH BACK (adjNode, nextElapsed, 0) INTO deque  \n                ELSE  \n                    IF times[adjNode][0] < nextElapsed AND nextElapsed < times[adjNode][1] THEN  \n                        ASSIGN nextElapsed TO times[adjNode][1]  \n                        PUSH BACK (adjNode, nextElapsed, 1) INTO deque  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION secondMinimum(n  \n                            edges  \n                            time  \n                            change)  \n        SET graph TO list of empty lists for each integer from one TO n PLUS one  \n        FOR each pair u AND v IN edges  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n          \n        SET queue TO a double ended queue containing a tuple of one current vertex AND zero current time AND zero count  \n        SET minTimes TO list containing two elements each set to infinite value for each integer from one TO n PLUS one  \n        SET element at position one of minTimes at position zero TO zero  \n          \n        WHILE queue is not empty  \n            REMOVE the first element FROM queue AND ASSIGN TO current AND currentTime AND count  \n              \n            IF current EQUALS n AND count EQUALS one  \n                RETURN currentTime  \n            END IF  \n              \n            IF integer division of currentTime BY change MODULO two EQUALS zero  \n                SET nextTime TO currentTime PLUS time  \n            ELSE  \n                SET nextTime TO (integer division of currentTime BY change PLUS one) MULTIPLIED BY change PLUS time  \n            END IF  \n              \n            FOR each neighbor IN element at position current of graph  \n                IF element at position neighbor of minTimes at position zero GREATER THAN nextTime  \n                    SET element at position neighbor of minTimes at position one TO element at position neighbor of minTimes at position zero  \n                    SET element at position neighbor of minTimes at position zero TO nextTime  \n                    APPEND tuple containing neighbor AND nextTime AND zero TO queue  \n                ELSE IF element at position neighbor of minTimes at position zero LESS THAN nextTime AND nextTime LESS THAN element at position neighbor of minTimes at position one  \n                    SET element at position neighbor of minTimes at position one TO nextTime  \n                    APPEND tuple containing neighbor AND nextTime AND one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "recover-the-original-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION recoverArray(nums)\n        ARRAY sortedNums ← nums\n        CALL sortedNums.SORT_ASCENDING()\n\n        INTEGER length ← CALL sortedNums.LENGTH()\n        INTEGER base ← sortedNums[0]\n\n        INTEGER idx ← 1\n        WHILE idx < length\n            INTEGER diffVal ← (sortedNums[idx] - base) / 2\n            IF diffVal <= 0 OR base + 2 * diffVal ≠ sortedNums[idx]\n                idx ← idx + 1\n                CONTINUE\n            END IF\n\n            DICTIONARY frequencyMap ← EMPTY_DICTIONARY()\n            FOR element IN sortedNums\n                IF NOT frequencyMap.CONTAINS(element)\n                    frequencyMap[element] ← 0\n                END IF\n                frequencyMap[element] ← frequencyMap[element] + 1\n            END FOR\n\n            ARRAY candidate ← EMPTY_ARRAY()\n            INTEGER pos ← 0\n            WHILE pos < length\n                INTEGER current ← sortedNums[pos]\n                IF frequencyMap[current] == 0\n                    pos ← pos + 1\n                    CONTINUE\n                END IF\n                INTEGER pairedKey ← current + 2 * diffVal\n                IF frequencyMap.GET_OR_DEFAULT(pairedKey, 0) == 0\n                    BREAK\n                END IF\n\n                CALL candidate.APPEND(current + diffVal)\n                frequencyMap[current] ← frequencyMap[current] - 1\n                frequencyMap[pairedKey] ← frequencyMap[pairedKey] - 1\n                pos ← pos + 1\n            END WHILE\n\n            IF CALL candidate.LENGTH() == length / 2\n                RETURN candidate\n            END IF\n            idx ← idx + 1\n        END WHILE\n\n        RETURN EMPTY_ARRAY()\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION recoverArray(nums)  \n        SORT the elements of nums in ascending order  \n        SET n TO the LENGTH OF nums  \n        SET first TO the element at position zero of nums  \n        FOR i FROM one TO n MINUS one  \n            SET k TO the element at position i of nums MINUS first DIVIDED BY two  \n            IF k LESS THAN OR EQUAL TO zero OR first PLUS two MULTIPLIED BY k NOT EQUALS the element at position i of nums  \n                CONTINUE to the next iteration  \n            END IF  \n            SET count TO a mapping of each element of nums to its frequency  \n            SET arr TO an empty list  \n            FOR each element x IN nums  \n                IF the value at key x in count EQUALS zero  \n                    CONTINUE to the next iteration  \n                END IF  \n                IF the value at key the sum of x PLUS two MULTIPLIED BY k in count EQUALS zero  \n                    BREAK out of the loop  \n                END IF  \n                APPEND the sum of x PLUS k TO arr  \n                DECREMENT the value at key x in count BY one  \n                DECREMENT the value at key the sum of x PLUS two MULTIPLIED BY k in count BY one  \n            END FOR  \n            IF the LENGTH OF arr EQUALS n DIVIDED BY two  \n                RETURN arr  \n            END IF  \n        END FOR  \n        RETURN an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-good-people-based-on-statements", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumGood(statements)\n        ASSIGN n AS LENGTH(statements)\n        LET maximumCount BE 0\n        LET mask BE 0\n        WHILE mask < (1 << n)\n            DECLARE truthful AS ARRAY OF n ELEMENTS FILLED WITH FALSE\n            DECLARE deceitful AS ARRAY OF n ELEMENTS FILLED WITH FALSE\n            LET position BE 0\n            REPEAT UNTIL position = n\n                LET bitmask BE (1 << position)\n                IF (mask & bitmask) = bitmask THEN\n                    truthful[position] ← TRUE\n                ELSE\n                    deceitful[position] ← TRUE\n                END IF\n                position ← position + 1\n            END REPEAT\n            LET isConsistent BE TRUE\n            LET idx BE 0\n            WHILE idx < n AND isConsistent\n                IF truthful[idx] = TRUE THEN\n                    LET innerIdx BE 0\n                    REPEAT UNTIL innerIdx = n OR NOT isConsistent\n                        LET statementValue BE statements[idx][innerIdx]\n                        IF (statementValue = 0 AND truthful[innerIdx] = TRUE) OR (statementValue = 1 AND deceitful[innerIdx] = TRUE) THEN\n                            isConsistent ← FALSE\n                        END IF\n                        innerIdx ← innerIdx + 1\n                    END REPEAT\n                END IF\n                idx ← idx + 1\n            END WHILE\n            IF isConsistent THEN\n                LET countTruthful BE 0\n                FOR countIdx FROM 0 TO n - 1\n                    IF truthful[countIdx] = TRUE THEN\n                        countTruthful ← countTruthful + 1\n                    END IF\n                END FOR\n                IF countTruthful > maximumCount THEN\n                    maximumCount ← countTruthful\n                END IF\n            END IF\n            mask ← mask + 1\n        END WHILE\n        RETURN maximumCount\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-substring-with-given-hash-value", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION subStrHash(s string power integer modulo integer k integer hashValue integer) RETURNS string  \n        FUNCTION val(c character) RETURNS integer  \n            RETURN (UNICODE(c) - UNICODE('a')) + 1  \n        END FUNCTION  \n\n        SET length_s AS LENGTH(s)  \n        SET rolling_hash TO 0  \n        SET multiplier TO 1  \n\n        SET idx TO length_s - k  \n        WHILE idx < length_s  \n            SET char_val TO val(s[idx])  \n            SET rolling_hash TO (rolling_hash + (char_val * multiplier) MOD modulo) MOD modulo  \n            IF idx < length_s - 1 THEN  \n                SET multiplier TO (multiplier * power) MOD modulo  \n            END IF  \n            SET idx TO idx + 1  \n        END WHILE  \n\n        SET substring_start TO length_s - k  \n        IF rolling_hash = hashValue THEN  \n            RETURN SUBSTRING(s, substring_start, length_s - 1)  \n        END IF  \n\n        SET highest_power TO multiplier  \n\n        SET j TO length_s - k - 1  \n        WHILE j >= 0  \n            SET removed_char_val TO val(s[j + k])  \n            SET rolling_hash TO rolling_hash - (removed_char_val * highest_power)  \n            SET rolling_hash TO rolling_hash MOD modulo  \n            IF rolling_hash < 0 THEN  \n                SET rolling_hash TO rolling_hash + modulo  \n            END IF  \n            SET rolling_hash TO ((rolling_hash * power) + val(s[j])) MOD modulo  \n\n            IF rolling_hash = hashValue THEN  \n                SET substring_start TO j  \n            END IF  \n            SET j TO j - 1  \n        END WHILE  \n\n        RETURN SUBSTRING(s, substring_start, substring_start + k - 1)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION subStrHash(s string power integer modulo integer k integer hashValue integer) RETURNS string  \n        FUNCTION val(c character) RETURNS integer  \n            RETURN the unicode code of character c MINUS the unicode code of character a PLUS one  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF string s  \n        SET current_hash TO zero  \n        SET p_pow TO one  \n\n        FOR i FROM n MINUS k TO n MINUS one  \n            SET current_hash TO current_hash PLUS val(the element at position i of s) MULTIPLIED BY p_pow MODULO modulo  \n            IF i LESS THAN n MINUS one  \n                SET p_pow TO p_pow MULTIPLIED BY power MODULO modulo  \n            END IF  \n        END FOR  \n\n        SET start_index TO n MINUS k  \n        IF current_hash EQUALS hashValue  \n            RETURN the substring from position start_index TO the position one LESS THAN n of s  \n        END IF  \n\n        SET p_pow_k_minus_1 TO p_pow  \n\n        FOR i FROM n MINUS k MINUS one DOWN TO zero  \n            SET current_hash TO current_hash MINUS val(the element at position i PLUS k of s) MULTIPLIED BY p_pow_k_minus_1 MODULO modulo  \n            SET current_hash TO current_hash MULTIPLIED BY power PLUS val(the element at position i of s) MODULO modulo  \n\n            IF current_hash EQUALS hashValue  \n                SET start_index TO i  \n            END IF  \n        END FOR  \n\n        RETURN the substring from position start_index TO the position start_index PLUS k MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-and-sum-of-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumANDSum(nums numSlots)\n        FUNCTION dp(index slots)\n            IF NOT (index DIFFERENT FROM LENGTH OF nums) THEN\n                YIELD zero\n            END IF\n\n            ASSIGN zero TO highest_and\n            ASSIGN list(slots) TO modifiable_slots\n\n            SET iterator TO zero\n            WHILE iterator LESS THAN numSlots DO\n                IF modifiable_slots[iterator] LESS THAN 2 THEN\n                    ASSIGN (modifiable_slots[iterator] + 1) TO modifiable_slots[iterator]\n                    ASSIGN ( (nums[index] BITWISE-AND (iterator + 1)) + dp(index + 1, tuple(modifiable_slots)) ) TO current_and\n                    IF current_and GREATER THAN highest_and THEN\n                        ASSIGN current_and TO highest_and\n                    END IF\n                    ASSIGN (modifiable_slots[iterator] - 1) TO modifiable_slots[iterator]\n                END IF\n                INCREMENT iterator BY 1\n            END WHILE\n\n            YIELD highest_and\n        END FUNCTION\n\n        ASSIGN tuple REPEATED zero NUMSLOTS TIMES TO start_slots\n        RETURN dp(zero, start_slots)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumANDSum(nums numSlots)  \n        FUNCTION dp(index slots)  \n            IF index EQUALS LENGTH OF nums  \n                RETURN zero  \n            END IF  \n              \n            SET max_and_sum TO zero  \n            SET slots_list TO list converted from slots  \n              \n            FOR i FROM zero TO numSlots MINUS one  \n                IF element at position i of slots_list LESS THAN two  \n                    INCREMENT element at position i of slots_list BY one  \n                    SET and_sum TO bitwise AND of element at position index of nums AND i PLUS one PLUS dp function called with index PLUS one AND tuple converted from slots_list  \n                    IF and_sum GREATER THAN max_and_sum  \n                        SET max_and_sum TO and_sum  \n                    END IF  \n                    DECREMENT element at position i of slots_list BY one  \n                END IF  \n            END FOR  \n              \n            RETURN max_and_sum  \n        END FUNCTION  \n          \n        SET initial_slots TO tuple consisting of zero repeated numSlots times  \n        RETURN dp function called with zero AND initial_slots  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-array-pairs-divisible-by-k", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET divisorFrequency AS a new counter collection  \n        \n        SET indexA TO 0  \n        WHILE indexA < LENGTH(nums)  \n            SET currentNum TO nums[indexA]  \n            SET divisorKey TO gcd(currentNum, k)  \n            INCREMENT divisorFrequency AT divisorKey BY 1  \n            SET indexA TO indexA + 1  \n        END WHILE  \n        \n        SET pairSum TO 0  \n        \n        SET divisorList TO KEYS(divisorFrequency)  \n        SET totalDivisors TO LENGTH(divisorList)  \n        \n        SET outerIdx TO 0  \n        WHILE outerIdx < totalDivisors  \n            SET innerIdx TO outerIdx  \n            WHILE innerIdx < totalDivisors  \n                SET firstDivisor TO divisorList[outerIdx]  \n                SET secondDivisor TO divisorList[innerIdx]  \n                \n                IF (firstDivisor * secondDivisor) MOD k = 0 THEN  \n                    IF outerIdx = innerIdx THEN  \n                        SET freqVal TO divisorFrequency[firstDivisor]  \n                        SET pairSum TO pairSum + (freqVal * (freqVal - 1)) / 2  \n                    ELSE  \n                        SET pairSum TO pairSum + (divisorFrequency[firstDivisor] * divisorFrequency[secondDivisor])  \n                    END IF  \n                END IF  \n                \n                SET innerIdx TO innerIdx + 1  \n            END WHILE  \n            SET outerIdx TO outerIdx + 1  \n        END WHILE  \n        \n        RETURN pairSum  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET gcd_count TO a new counter collection  \n        \n        FOR each num IN nums  \n            INCREMENT the count in gcd_count for the gcd of num AND k BY one  \n        END FOR  \n        \n        SET total_pairs TO zero  \n        \n        SET gcd_values TO the list of keys of gcd_count  \n        SET n TO the length of gcd_values  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET gcd1 TO the element at position i of gcd_values  \n                SET gcd2 TO the element at position j of gcd_values  \n                \n                IF the remainder of gcd1 MULTIPLIED BY gcd2 DIVIDED BY k EQUALS zero THEN  \n                    IF i EQUALS j THEN  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd1 in gcd_count MINUS one DIVIDED BY two  \n                    ELSE  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd2 in gcd_count  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-of-one-repeating-character", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestRepeating(s queryCharacters queryIndices)\n        FUNCTION merge_intervals()\n            SET counter AS 0\n            WHILE counter < (LENGTH(intervals) - 1)\n                SET currentTriplet TO intervals[counter]\n                SET nextTriplet TO intervals[counter + 1]\n                IF (currentTriplet[2] = nextTriplet[2])\n                    SET mergedStart TO currentTriplet[0]\n                    SET mergedEnd TO (currentTriplet[1] + 1)\n                    SET mergedChar TO currentTriplet[2]\n                    SET intervals[counter] AS (mergedStart, mergedEnd, mergedChar)\n                    REMOVE intervals[counter + 1]\n                ELSE\n                    SET counter AS (counter + 1)\n                END IF\n            END WHILE\n        END FUNCTION\n\n        SET intervals AS []\n        SET lengthOfS AS LENGTH(s)\n        SET initialPos AS 0\n        SET positionTracker AS 1\n        WHILE positionTracker < lengthOfS\n            IF s[positionTracker] ≠ s[initialPos]\n                APPEND (initialPos, (positionTracker - 1), s[initialPos]) TO intervals\n                SET initialPos AS positionTracker\n            END IF\n            SET positionTracker AS (positionTracker + 1)\n        END WHILE\n        APPEND (initialPos, (lengthOfS - 1), s[initialPos]) TO intervals\n\n        SET outputList AS []\n        SET maxLength AS MAXIMUM OVER EACH (start, end, c) IN intervals OF ((end - start) + 1)\n\n        FOR EACH charValue indexValue IN PAIRS(queryCharacters, queryIndices)\n            SET intervalIndex AS 0\n            WHILE intervalIndex < LENGTH(intervals)\n                SET (segmentStart, segmentEnd, segmentChar) AS intervals[intervalIndex]\n                IF (segmentStart ≤ indexValue) AND (indexValue ≤ segmentEnd)\n                    EXIT WHILE\n                END IF\n                SET intervalIndex AS (intervalIndex + 1)\n            END WHILE\n\n            IF indexValue > segmentStart\n                INSERT AT intervals[intervalIndex] THE TUPLE (segmentStart, (indexValue - 1), segmentChar)\n                SET intervals[intervalIndex + 1] AS (indexValue, segmentEnd, segmentChar)\n            END IF\n            IF indexValue < segmentEnd\n                INSERT AT intervals[intervalIndex + 1] THE TUPLE ((indexValue + 1), segmentEnd, segmentChar)\n                SET intervals[intervalIndex] AS (segmentStart, indexValue, segmentChar)\n            END IF\n\n            SET intervals[intervalIndex] AS (intervals[intervalIndex][0], intervals[intervalIndex][1], charValue)\n\n            CALL merge_intervals()\n\n            SET maxLength AS MAXIMUM OVER EACH (start, end, c) IN intervals OF ((end - start) + 1)\n            APPEND maxLength TO outputList\n        END FOR\n\n        RETURN outputList\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestRepeating(s queryCharacters queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF the character element at position three of element at position i of intervals EQUALS the character element at position three of element at position i PLUS one of intervals  \n                    SET element at position i of intervals TO a tuple consisting of element at position one of element at position i of intervals COMMA element at position two of element at position i PLUS one of intervals COMMA character element at position three of element at position i of intervals  \n                    REMOVE element at position i PLUS one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n        \n        SET intervals TO an empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple consisting of start COMMA i MINUS one COMMA element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple consisting of start COMMA n MINUS one COMMA element at position start of s TO intervals  \n        \n        SET results TO an empty list  \n        SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n        \n        FOR each char idx IN the corresponding pairs of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start end c TO the tuple element at position i of intervals  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF idx GREATER THAN start  \n                INSERT a tuple consisting of start COMMA idx MINUS one COMMA c AT position i OF intervals  \n                SET element at position i PLUS one of intervals TO a tuple consisting of idx COMMA end COMMA c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT a tuple consisting of idx PLUS one COMMA end COMMA c AT position i PLUS one OF intervals  \n                SET element at position i of intervals TO a tuple consisting of start COMMA idx COMMA c  \n            END IF  \n            \n            SET element at position i of intervals TO a tuple consisting of the first element of element at position i of intervals COMMA the second element of element at position i of intervals COMMA char  \n            \n            CALL merge_intervals()  \n            \n            SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n            APPEND longest TO results  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-total-beauty-of-the-gardens", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET length_of_flowers TO the LENGTH OF flowers  \n        SET highest_beauty TO 0  \n        DEFINE prefix_accumulation AS A LIST WITH length_of_flowers PLUS one ELEMENTS INITIALIZED TO 0  \n        \n        SET idx TO 0  \n        WHILE idx < length_of_flowers  \n            SET prefix_accumulation[idx + 1] AS prefix_accumulation[idx] + flowers[idx]  \n            SET idx TO idx + 1  \n        END WHILE  \n        \n        SET count_full_gardens TO 0  \n        SET pointer TO length_of_flowers - 1  \n        LOOP  \n            IF pointer < 0 THEN  \n                BREAK  \n            ENDIF  \n            \n            IF flowers[pointer] >= target THEN  \n                SET count_full_gardens AS count_full_gardens + 1  \n                SET pointer AS pointer - 1  \n            ELSE  \n                BREAK  \n            ENDIF  \n        END LOOP  \n        \n        SET flowers_left TO newFlowers  \n        SET incomplete_max_flowers TO 0  \n        \n        SET current_index TO count_full_gardens  \n        WHILE current_index <= length_of_flowers  \n            \n            IF current_index > 0 THEN  \n                SET flowers_left AS flowers_left - (target - flowers[length_of_flowers - current_index])  \n                IF NOT (flowers_left >= 0) THEN  \n                    BREAK  \n                ENDIF  \n            ENDIF  \n            \n            SET low_bound TO 0  \n            SET high_bound TO length_of_flowers - current_index - 1  \n            \n            WHILE low_bound <= high_bound  \n                SET midpoint TO (low_bound + high_bound) DIVIDED BY 2 USING INTEGER DIVISION  \n                \n                SET required_flowers TO (flowers[midpoint] * (midpoint+1)) - (prefix_accumulation[midpoint + 1])  \n                \n                IF required_flowers > flowers_left THEN  \n                    SET high_bound TO midpoint - 1  \n                ELSE  \n                    SET low_bound TO midpoint + 1  \n                ENDIF  \n            END WHILE  \n            \n            IF high_bound >= 0 THEN  \n                SET numerator TO flowers_left - ((flowers[high_bound] * (high_bound + 1)) - prefix_accumulation[high_bound + 1])  \n                SET incomplete_max_flowers AS flowers[high_bound] + (numerator DIVIDED BY (high_bound + 1) USING INTEGER DIVISION)  \n            ELSE  \n                SET incomplete_max_flowers TO 0  \n            ENDIF  \n            \n            SET candidate_beauty TO (current_index * full) + (MIN(incomplete_max_flowers, target - 1) * partial)  \n            IF candidate_beauty > highest_beauty THEN  \n                SET highest_beauty AS candidate_beauty  \n            ENDIF  \n            \n            SET current_index TO current_index + 1  \n        END WHILE  \n        \n        RETURN highest_beauty  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET n TO the LENGTH OF flowers  \n        SET max_beauty TO zero  \n        SET prefix_sum TO A LIST OF ZEROS WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at POSITION i PLUS one OF prefix_sum TO element at POSITION i OF prefix_sum PLUS element at POSITION i OF flowers  \n        END FOR  \n        SET complete_gardens TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at POSITION i OF flowers GREATER THAN OR EQUAL TO target THEN  \n                INCREMENT complete_gardens BY one  \n            ELSE  \n                BREAK  \n            END IF  \n        END FOR  \n        SET remaining_flowers TO newFlowers  \n        SET max_incomplete_flowers TO zero  \n        FOR i FROM complete_gardens TO n  \n            IF i GREATER THAN zero THEN  \n                DECREMENT remaining_flowers BY target MINUS element at POSITION n MINUS i OF flowers  \n                IF remaining_flowers LESS THAN zero THEN  \n                    BREAK  \n                END IF  \n            END IF  \n            SET left TO zero  \n            SET right TO n MINUS i MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n                SET cost TO element at POSITION mid OF flowers MULTIPLIED BY mid PLUS one MINUS element at POSITION mid PLUS one OF prefix_sum  \n                IF cost GREATER THAN remaining_flowers THEN  \n                    DECREMENT right BY one PLUS mid MINUS right  \n                ELSE  \n                    INCREMENT left BY one PLUS mid MINUS left  \n                END IF  \n            END WHILE  \n            IF right GREATER THAN OR EQUAL TO zero THEN  \n                SET max_incomplete_flowers TO element at POSITION right OF flowers PLUS remaining_flowers MINUS element at POSITION right OF flowers MULTIPLIED BY right PLUS one PLUS NEGATION OF element at POSITION right PLUS one OF prefix_sum DIVIDED BY right PLUS one USING INTEGER DIVISION  \n            ELSE  \n                SET max_incomplete_flowers TO zero  \n            END IF  \n            SET total_beauty TO i MULTIPLIED BY full PLUS THE MINIMUM OF max_incomplete_flowers AND target MINUS one MULTIPLIED BY partial  \n            IF total_beauty GREATER THAN max_beauty THEN  \n                SET max_beauty TO total_beauty  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-of-a-node-sequence", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(scores, edges)  \n        CREATE neighbors AS empty default mapping where each key maps to an empty list  \n        SET indexA TO 0  \n        WHILE indexA < LENGTH(edges)  \n            LET edgePair BE edges[indexA]  \n            LET firstNode TO edgePair[0]  \n            LET secondNode TO edgePair[1]  \n            LET scoreSecond TO scores[secondNode]  \n            LET scoreFirst TO scores[firstNode]  \n            ADD (scoreSecond, secondNode) TO neighbors[firstNode]  \n            ADD (scoreFirst, firstNode) TO neighbors[secondNode]  \n            INCREMENT indexA BY 1  \n        END WHILE  \n\n        LET nodeIterKeys BE KEYS(neighbors)  \n        LET indexB TO 0  \n        WHILE indexB < LENGTH(nodeIterKeys)  \n            LET currNode TO nodeIterKeys[indexB]  \n            LET currList TO neighbors[currNode]  \n            SORT currList DESCENDING BY first ELEMENT OF PAIRS  \n            SET neighbors[currNode] TO SUBLIST(currList, 0, MIN(3, LENGTH(currList)))  \n            INCREMENT indexB BY 1  \n        END WHILE  \n\n        SET highestScore TO -1  \n        LET idxEdge TO 0  \n        WHILE idxEdge < LENGTH(edges)  \n            LET currentEdge TO edges[idxEdge]  \n            LET nodeU TO currentEdge[0]  \n            LET nodeV TO currentEdge[1]  \n            LET listU TO neighbors[nodeU]  \n            LET listV TO neighbors[nodeV]  \n            LET idxU TO 0  \n            WHILE idxU < LENGTH(listU)  \n                LET pairU TO listU[idxU]  \n                LET scr1 TO pairU[0]  \n                LET xNode TO pairU[1]  \n                LET idxV TO 0  \n                WHILE idxV < LENGTH(listV)  \n                    LET pairV TO listV[idxV]  \n                    LET scr2 TO pairV[0]  \n                    LET yNode TO pairV[1]  \n                    IF (xNode ≠ yNode) AND (xNode ≠ nodeU) AND (xNode ≠ nodeV) AND (yNode ≠ nodeU) AND (yNode ≠ nodeV) AND (nodeU ≠ nodeV) THEN  \n                        LET tempSum TO scr1 + scr2 + scores[nodeU] + scores[nodeV]  \n                        IF tempSum > highestScore THEN  \n                            SET highestScore TO tempSum  \n                        END IF  \n                    END IF  \n                    INCREMENT idxV BY 1  \n                END WHILE  \n                INCREMENT idxU BY 1  \n            END WHILE  \n            INCREMENT idxEdge BY 1  \n        END WHILE  \n\n        RETURN highestScore  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumScore(scores, edges)  \n        CREATE graph AS a new default mapping from elements to empty lists  \n        FOR each element u AND element v IN edges  \n            APPEND a pair consisting of the element at position v of scores AND element v TO the list associated with element u in graph  \n            APPEND a pair consisting of the element at position u of scores AND element u TO the list associated with element v in graph  \n        END FOR  \n        FOR each element node IN graph  \n            SET the list associated with element node in graph TO the three highest scoring pairs from the list associated with element node in graph  \n        END FOR  \n        SET max_score TO negative one  \n        FOR each element u AND element v IN edges  \n            FOR each pair consisting of score1 AND x IN the list associated with element u in graph  \n                FOR each pair consisting of score2 AND y IN the list associated with element v in graph  \n                    IF the set containing x AND y AND u AND v HAS size EQUALS four  \n                        SET max_score TO the greater value between max_score AND the sum of score1 PLUS score2 PLUS the element at position u of scores PLUS the element at position v of scores  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN max_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-the-spreading-fire", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumMinutes(grid)\n        SET rowCount AS LENGTH OF grid\n        SET colCount AS LENGTH OF element AT 0 OF grid\n        SET moves AS LIST OF PAIRS: (1, 0), (-1, 0), (0, 1), (0, -1)\n\n        FUNCTION can_escape(wait)\n            SET fireArrival TO a 2D LIST sized rowCount BY colCount FILLED WITH infinity\n            CREATE deque AS empty double-ended queue\n\n            SET iCounter TO 0\n            WHILE iCounter < rowCount\n                SET jCounter TO 0\n                WHILE jCounter < colCount\n                    IF element AT iCounter OF grid = 1 THEN\n                        PUSH (iCounter, jCounter, 0) TO deque\n                        ASSIGN fireArrival[iCounter][jCounter] ← 0\n                    END IF\n                    INCREMENT jCounter BY 1\n                END WHILE\n                INCREMENT iCounter BY 1\n            END WHILE\n\n            WHILE deque IS NOT empty\n                POP_LEFT (currX, currY, currTime) FROM deque\n                FOR EACH (dx, dy) IN moves DO\n                    SET nextX TO currX + dx\n                    SET nextY TO currY + dy\n                    IF (nextX ≥ 0) AND (nextX < rowCount) AND (nextY ≥ 0) AND (nextY < colCount) AND (grid[nextX][nextY] = 0) AND (fireArrival[nextX][nextY] = infinity) THEN\n                        ASSIGN fireArrival[nextX][nextY] ← currTime + 1\n                        PUSH (nextX, nextY, currTime + 1) TO deque\n                    END IF\n                END FOR\n            END WHILE\n\n            SET explorerQueue TO new double-ended queue WITH ELEMENT (0, 0, wait)\n            SET visitedSet TO SET CONTAINING PAIR (0, 0)\n\n            WHILE explorerQueue IS NOT empty\n                POP_LEFT (posX, posY, timePassed) FROM explorerQueue\n                FOR EACH (offsetX, offsetY) IN moves DO\n                    SET candidateX TO posX + offsetX\n                    SET candidateY TO posY + offsetY\n                    IF (candidateX ≥ 0) AND (candidateX < rowCount) AND (candidateY ≥ 0) AND (candidateY < colCount) AND NOT ((candidateX, candidateY) IN visitedSet) AND (grid[candidateX][candidateY] = 0) THEN\n                        IF (candidateX = rowCount - 1) AND (candidateY = colCount - 1) THEN\n                            IF fireArrival[candidateX][candidateY] ≥ timePassed + 1 THEN\n                                RETURN true\n                            ELSE\n                                RETURN false\n                            END IF\n                        END IF\n                        IF fireArrival[candidateX][candidateY] > timePassed + 1 THEN\n                            ADD (candidateX, candidateY) TO visitedSet\n                            PUSH (candidateX, candidateY, timePassed + 1) TO explorerQueue\n                        END IF\n                    END IF\n                END FOR\n            END WHILE\n\n            RETURN false\n        END FUNCTION\n\n        SET startPos TO 0\n        SET endPos TO rowCount * colCount\n        SET answer TO -1\n\n        WHILE startPos ≤ endPos\n            SET middle TO startPos + FLOOR((endPos - startPos) / 2)\n            IF can_escape(middle) THEN\n                ASSIGN answer ← middle\n                ASSIGN startPos ← middle + 1\n            ELSE\n                ASSIGN endPos ← middle - 1\n            END IF\n        END WHILE\n\n        IF answer ≠ rowCount * colCount THEN\n            RETURN answer\n        ELSE\n            RETURN 1000000000\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO the LIST of elements each being a PAIR consisting of one and zero MINUS one and zero zero and one zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two-dimensional list of size m by n each element set TO infinity  \n            SET queue TO an empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one  \n                        APPEND the TRIPLE consisting of i j and zero TO queue  \n                        SET element at position i and j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx and ny of grid EQUALS zero AND element at position nx and ny of fire_times EQUALS infinity  \n                        SET element at position nx and ny of fire_times TO t PLUS one  \n                        APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a double-ended queue containing a single TRIPLE consisting of zero zero and wait  \n            SET visited TO a set containing the PAIR zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the PAIR nx ny NOT IN visited AND element at position nx and ny of grid EQUALS zero  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one  \n                            IF element at position nx and ny of fire_times GREATER THAN OR EQUAL TO t PLUS one  \n                                RETURN true  \n                            ELSE  \n                                RETURN false  \n                            END IF  \n                        END IF  \n                        IF element at position nx and ny of fire_times GREATER THAN t PLUS one  \n                            ADD the PAIR nx ny TO visited  \n                            APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two rounded down to the nearest integer  \n            IF can_escape(mid)  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result NOT EQUALS m MULTIPLIED BY n  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-there-is-a-valid-parentheses-string-path", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET totalRows AS the LENGTH OF grid  \n        SET totalColumns AS the LENGTH OF element at position zero of grid  \n        \n        IF ( (totalRows PLUS totalColumns MINUS 1) MOD 2 ) IS NOT EQUAL TO 0  \n            RETURN false  \n        END IF  \n        \n        INITIALIZE dp AS a three-dimensional array of size (totalRows PLUS 1) BY (totalColumns PLUS 1) BY (totalRows PLUS totalColumns PLUS 1) FILLED WITH false  \n        \n        dp[1][0][0] ← true  \n        \n        SET rowIndex TO 0  \n        WHILE rowIndex LESS THAN totalRows  \n            SET columnIndex TO 0  \n            WHILE columnIndex LESS THAN totalColumns  \n                SET depthIndex TO 0  \n                WHILE depthIndex LESS THAN OR EQUAL TO totalRows PLUS totalColumns  \n                    IF (dp[rowIndex][columnIndex PLUS 1][depthIndex] OR dp[rowIndex PLUS 1][columnIndex][depthIndex]) IS true THEN  \n                        IF (grid[rowIndex][columnIndex] IS '(' AND depthIndex PLUS 1 LESS THAN totalRows PLUS totalColumns PLUS 1) THEN  \n                            dp[rowIndex PLUS 1][columnIndex PLUS 1][depthIndex PLUS 1] ← true  \n                        ELSE  \n                            IF (grid[rowIndex][columnIndex] IS ')' AND depthIndex MINUS 1 GREATER THAN OR EQUAL TO 0) THEN  \n                                dp[rowIndex PLUS 1][columnIndex PLUS 1][depthIndex MINUS 1] ← true  \n                            END IF  \n                        END IF  \n                    END IF  \n                    SET depthIndex TO depthIndex PLUS 1  \n                END WHILE  \n                SET columnIndex TO columnIndex PLUS 1  \n            END WHILE  \n            SET rowIndex TO rowIndex PLUS 1  \n        END WHILE  \n        \n        RETURN dp[totalRows][totalColumns][0]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF the sum of m PLUS n MINUS one MODULO two NOT EQUALS zero  \n            RETURN false  \n        END IF  \n        \n        SET dp TO a three dimensional collection of size m PLUS one BY n PLUS one BY m PLUS n PLUS one FILLED WITH false  \n        \n        SET element at position zero of element at position one of dp TO true  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                FOR k FROM zero TO m PLUS n  \n                    IF element at position i of element at position j PLUS one of dp at position k OR element at position i PLUS one of element at position j of dp at position k  \n                        IF element at position i of element at position j of grid EQUALS the opening parenthesis AND k PLUS one LESS THAN m PLUS n PLUS one  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k PLUS one TO true  \n                        ELSE IF element at position i of element at position j of grid EQUALS the closing parenthesis AND k MINUS one GREATER THAN OR EQUAL TO zero  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k MINUS one TO true  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m of element at position n of dp at position zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "substring-with-largest-variance", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION largestVariance(s)  \n        FUNCTION calculate_variance(substring, char_a, char_b)  \n            SET peak_variance ← 0  \n            SET tally_a ← 0  \n            SET tally_b ← 0  \n            SET observed_b ← false  \n            SET encountered_first_b ← false  \n            \n            SET iterator ← 0  \n            WHILE iterator < LENGTH(substring)  \n                SET current_char ← substring[iterator]  \n                IF current_char = char_a THEN  \n                    tally_a ← tally_a + 1  \n                ELSE  \n                    IF current_char = char_b THEN  \n                        tally_b ← tally_b + 1  \n                        observed_b ← true  \n                    END IF  \n                END IF  \n                \n                IF NOT (tally_b ≤ 0) THEN  \n                    IF peak_variance < (tally_a - tally_b) THEN  \n                        peak_variance ← tally_a - tally_b  \n                    END IF  \n                ELSE  \n                    IF (tally_b = 0) AND encountered_first_b THEN  \n                        IF peak_variance < (tally_a - 1) THEN  \n                            peak_variance ← tally_a - 1  \n                        END IF  \n                    END IF  \n                END IF  \n                \n                IF tally_b > tally_a THEN  \n                    SET tally_a ← 0  \n                    SET tally_b ← 0  \n                    SET encountered_first_b ← observed_b  \n                END IF  \n                \n                iterator ← iterator + 1  \n            END WHILE  \n            \n            RETURN peak_variance  \n        END FUNCTION  \n        \n        SET overall_max ← 0  \n        SET character_pool ← EMPTY SET  \n        SET index ← 0  \n        WHILE index < LENGTH(s)  \n            character_pool ← character_pool UNION { s[index] }  \n            index ← index + 1  \n        END WHILE  \n        \n        SET unique_list ← LIST(character_pool)  \n        SET n ← LENGTH(unique_list)  \n        SET outer_index ← 0  \n        WHILE outer_index < n  \n            SET inner_index ← 0  \n            WHILE inner_index < n  \n                IF outer_index ≠ inner_index THEN  \n                    SET candidate_a ← unique_list[outer_index]  \n                    SET candidate_b ← unique_list[inner_index]  \n                    SET probe_variance ← calculate_variance(s, candidate_a, candidate_b)  \n                    IF probe_variance > overall_max THEN  \n                        overall_max ← probe_variance  \n                    END IF  \n                END IF  \n                inner_index ← inner_index + 1  \n            END WHILE  \n            outer_index ← outer_index + 1  \n        END WHILE  \n        \n        RETURN overall_max  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION largestVariance(s)  \n        FUNCTION calculate_variance(substring, char_a, char_b)  \n            SET max_variance TO zero  \n            SET count_a TO zero  \n            SET count_b TO zero  \n            SET has_b TO false  \n            SET first_b TO false  \n            \n            FOR each char IN substring  \n                IF char EQUALS char_a  \n                    INCREMENT count_a BY one  \n                ELSE IF char EQUALS char_b  \n                    INCREMENT count_b BY one  \n                    SET has_b TO true  \n                END IF  \n                \n                IF count_b GREATER THAN zero  \n                    SET max_variance TO the greater value BETWEEN max_variance AND count_a MINUS count_b  \n                ELSE IF count_b EQUALS zero AND first_b EQUALS true  \n                    SET max_variance TO the greater value BETWEEN max_variance AND count_a MINUS one  \n                END IF  \n                \n                IF count_b GREATER THAN count_a  \n                    SET count_a TO zero  \n                    SET count_b TO zero  \n                    SET first_b TO has_b  \n                END IF  \n            END FOR  \n            \n            RETURN max_variance  \n        END FUNCTION  \n        \n        SET max_variance TO zero  \n        SET unique_chars TO the set of all different characters in s  \n        \n        FOR each ordered pair of distinct characters char_a AND char_b IN all permutations of unique_chars taking two at a time  \n            IF char_a EQUALS char_b  \n                CONTINUE to the next iteration  \n            END IF  \n            SET max_variance TO the greater value BETWEEN max_variance AND calculate_variance with arguments s char_a char_b  \n        END FOR  \n        \n        RETURN max_variance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-number", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        DECLARE expressionPattern AS string  \n        ASSIGN expressionPattern WITH \"^([+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))([eE][+-]?\\d+)?)$\"  \n        SET matchResult TO RegMatch(s, expressionPattern)  \n        IF matchResult == null THEN  \n            RETURN false    \n        ELSE  \n            RETURN true  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        SET number pattern TO a string matching an optional plus or minus sign followed by either one or more digits optionally followed by a decimal point and zero or more digits or a decimal point followed by one or more digits and optionally followed by an exponent part consisting of the letter e followed by an optional plus or minus sign and one or more digits  \n        RETURN the result of matching the entire string s to the number pattern is not equal to nothing  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-subsequences", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(currentIndex, previousValue, sequenceAccumulator)  \n            IF currentIndex IS THE SAME AS LENGTH OF nums THEN  \n                IF LENGTH OF sequenceAccumulator EXCEEDS 1 THEN  \n                    APPEND COPY OF sequenceAccumulator INTO results  \n                END IF  \n                EXIT FUNCTION  \n            END IF  \n            IF nums[currentIndex] IS AT LEAST previousValue THEN  \n                ADD nums[currentIndex] TO sequenceAccumulator  \n                EXECUTE dfs WITH (currentIndex + 1, nums[currentIndex], sequenceAccumulator)  \n                DISCARD LAST ELEMENT FROM sequenceAccumulator  \n            END IF  \n            IF nums[currentIndex] IS DISTINCT FROM previousValue THEN  \n                INVOKE dfs WITH (currentIndex + 1, previousValue, sequenceAccumulator)  \n            END IF  \n        END FUNCTION  \n        INITIALIZE results AS EMPTY LIST  \n        INVOKE dfs WITH (0, -1000, EMPTY LIST)  \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(u, last, t)  \n            IF u EQUALS the LENGTH OF nums  \n                IF the LENGTH OF t GREATER THAN one  \n                    APPEND a copy of t TO ans  \n                END IF  \n                RETURN  \n            END IF  \n            IF element at position u of nums GREATER THAN OR EQUAL TO last  \n                APPEND element at position u of nums TO t  \n                CALL dfs with arguments u PLUS one, element at position u of nums, t  \n                REMOVE last element FROM t  \n            END IF  \n            IF element at position u of nums NOT EQUALS last  \n                CALL dfs with arguments u PLUS one, last, t  \n            END IF  \n        END FUNCTION  \n        SET ans TO an empty list  \n        CALL dfs with arguments zero, negative one thousand, an empty list  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        INITIALIZE cache AS an empty list  \n        SET index TO 0  \n        WHILE index LESS THAN length of expression DO  \n            SET token TO expression[index]  \n            IF token IS \"(\" OR token IS \"&\" OR token IS \"|\" THEN  \n                INSERT (token, 0) AT END OF cache  \n                INCREMENT index BY 1  \n                CONTINUE WHILE  \n            ELSE IF token IS \")\" THEN  \n                SET group TO REMOVE and RETURN last element of cache  \n                DISCARD last element from cache (which must be the opening parenthesis)  \n            ELSE  \n                SET group TO (token, 1)  \n            END IF  \n\n            IF length of cache GREATER THAN 0 AND (cache[-1][0] IS \"&\" OR cache[-1][0] IS \"|\") THEN  \n                SET operatorPair TO REMOVE and RETURN last element of cache  \n                SET operator TO operatorPair[0]  \n\n                SET leftPair TO REMOVE and RETURN last element of cache  \n                SET leftValue TO leftPair[0]  \n                SET leftCost TO leftPair[1]  \n\n                SET rightValue TO group[0]  \n                SET rightCost TO group[1]  \n\n                IF operator IS \"&\" THEN  \n                    IF leftValue + rightValue EQUALS 0 THEN  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (0, 1 + minCost)  \n                    ELSE IF leftValue IS 0 AND rightValue IS 1 THEN  \n                        SET group TO (0, 1)  \n                    ELSE IF leftValue IS 1 AND rightValue IS 0 THEN  \n                        SET group TO (0, 1)  \n                    ELSE  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (1, minCost)  \n                    END IF  \n                ELSE  /* operator IS \"|\" */  \n                    IF leftValue + rightValue EQUALS 0 THEN  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (0, minCost)  \n                    ELSE IF leftValue IS 0 AND rightValue IS 1 THEN  \n                        SET group TO (1, 1)  \n                    ELSE IF leftValue IS 1 AND rightValue IS 0 THEN  \n                        SET group TO (1, 1)  \n                    ELSE  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (1, 1 + minCost)  \n                    END IF  \n                END IF  \n            END IF  \n\n            INSERT group AT END OF cache  \n            INCREMENT index BY 1  \n        END WHILE  \n\n        RETURN cache[-1][1]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS an opening parenthesis OR element e EQUALS an ampersand OR element e EQUALS a vertical bar  \n                APPEND a tuple containing element e AND zero TO stack  \n                CONTINUE to the next iteration  \n            ELSE IF element e EQUALS a closing parenthesis  \n                SET lastPair TO the result of removing and returning the last element from stack  \n                REMOVE and discard the last element from stack corresponding to an opening parenthesis  \n            ELSE  \n                SET lastPair TO a tuple containing element e AND one  \n            END IF  \n            IF the length of stack IS GREATER THAN zero AND the first item of the last tuple in stack IS EQUAL TO an ampersand OR a vertical bar  \n                SET op TO the first element of the result of removing and returning the last tuple from stack  \n                SET a AND costA TO the elements of the result of removing and returning the last tuple from stack  \n                SET b AND costB TO the elements of lastPair  \n                IF op EQUALS an ampersand  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one PLUS the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND the smaller of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND one PLUS the smaller of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last tuple in stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "encode-string-with-shortest-length", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION encode(s)\n        FUNCTION get_encoded_length(count, substring)\n            ASSIGN LENGTH(TO_STRING(count)) + LENGTH(substring) + 2 TO result\n            GIVE BACK result\n        END FUNCTION\n\n        FUNCTION dp(i, j)\n            ASSIGN SUBSTRING(s; i; j + 1) TO segment\n            ASSIGN j + 1 - i TO segment_length\n            IF NOT(segment_length >= 5) THEN\n                GIVE BACK segment\n            END IF\n\n            ASSIGN segment TO minimal_encoding\n            ASSIGN 1 TO index_var\n            WHILE index_var <= (segment_length // 2 + 1)\n                IF segment_length MOD index_var = 0 THEN\n                    ASSIGN segment_length // index_var TO repetition_times\n                    ASSIGN TRUE TO matches_pattern\n                    ASSIGN SUBSTRING(segment; 0; index_var) TO pattern_piece\n\n                    IF segment = REPEAT(pattern_piece; repetition_times) THEN\n                        ASSIGN TO_STRING(repetition_times) + \"[\" + dp(i; i + index_var - 1) + \"]\" TO candidate_encoding\n                        IF LENGTH(candidate_encoding) < LENGTH(minimal_encoding) THEN\n                            ASSIGN candidate_encoding TO minimal_encoding\n                        END IF\n                    END IF\n                END IF\n                ASSIGN index_var + 1 TO index_var\n            END WHILE\n\n            ASSIGN i TO left_pointer\n            WHILE left_pointer <= j - 1\n                ASSIGN dp(i; left_pointer) TO left_part\n                ASSIGN dp(left_pointer + 1; j) TO right_part\n                ASSIGN left_part + right_part TO combined_candidate\n                IF LENGTH(combined_candidate) < LENGTH(minimal_encoding) THEN\n                    ASSIGN combined_candidate TO minimal_encoding\n                END IF\n                ASSIGN left_pointer + 1 TO left_pointer\n            END WHILE\n\n            GIVE BACK minimal_encoding\n        END FUNCTION\n\n        GIVE BACK dp(0; LENGTH(s) - 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION encode(s)  \n        FUNCTION get_encoded_length(count, substring)  \n            RETURN the LENGTH OF the string CONVERTED FROM count PLUS the LENGTH OF substring PLUS two  \n        END FUNCTION  \n\n        FUNCTION dp(i, j)  \n            SET substring TO the element at position i UP TO and INCLUDING position j OF s  \n            SET n TO j MINUS i PLUS one  \n            IF n LESS THAN five THEN  \n                RETURN substring  \n            END IF  \n\n            SET shortest TO substring  \n            FOR k FROM one TO n DIVIDED BY two PLUS one  \n                IF n MODULO k EQUALS zero THEN  \n                    SET repeat_count TO n DIVIDED BY k  \n                    IF substring EQUALS substring from position zero UP TO but NOT INCLUDING position k REPEATED repeat_count TIMES THEN  \n                        SET encoded_candidate TO string CONVERTED FROM repeat_count CONCATENATED WITH the LEFT SQUARE BRACKET CONCATENATED WITH dp(i, i PLUS k MINUS one) CONCATENATED WITH the RIGHT SQUARE BRACKET  \n                        IF the LENGTH OF encoded_candidate LESS THAN the LENGTH OF shortest THEN  \n                            SET shortest TO encoded_candidate  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n\n            FOR k FROM i TO j MINUS one  \n                SET left_encoded TO dp(i, k)  \n                SET right_encoded TO dp(k PLUS one, j)  \n                SET combined TO left_encoded CONCATENATED WITH right_encoded  \n                IF the LENGTH OF combined LESS THAN the LENGTH OF shortest THEN  \n                    SET shortest TO combined  \n                END IF  \n            END FOR  \n\n            RETURN shortest  \n        END FUNCTION  \n\n        RETURN dp(zero, the LENGTH OF s MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pacific-atlantic-water-flow", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION pacificAtlantic WITH PARAMETER heights\n        FUNCTION bfs WITH PARAMETERS q AND vis\n            ASSIGN m TO LENGTH OF heights\n            ASSIGN n TO LENGTH OF heights[0]\n            DEFINE directions AS LIST OF PAIRS: (-1, 0), (1, 0), (0, 1), (0, -1)\n            \n            WHILE LENGTH OF q IS GREATER THAN 0\n                ASSIGN count TO LENGTH OF q\n                ASSIGN idx TO 0\n                WHILE idx IS LESS THAN count\n                    REMOVE THE LEFTMOST ELEMENT FROM q AND ASSIGN IT TO pos\n                    ASSIGN i TO pos[0]\n                    ASSIGN j TO pos[1]\n                    \n                    ASSIGN d_idx TO 0\n                    WHILE d_idx IS LESS THAN LENGTH OF directions\n                        ASSIGN delta TO directions[d_idx]\n                        ASSIGN x TO i + delta[0]\n                        ASSIGN y TO j + delta[1]\n                        \n                        IF x >= 0 AND x < m AND y >= 0 AND y < n AND NOT (x, y) IN vis AND heights[x][y] >= heights[i][j]\n                            ADD (x, y) TO vis\n                            ADD (x, y) TO RIGHT OF q\n                        ENDIF\n                        \n                        INCREMENT d_idx BY 1\n                    END WHILE\n                    \n                    INCREMENT idx BY 1\n                END WHILE\n            END WHILE\n        END FUNCTION\n        \n        ASSIGN m TO LENGTH OF heights\n        ASSIGN n TO LENGTH OF heights[0]\n        INITIALIZE vis1 TO AN EMPTY SET\n        INITIALIZE vis2 TO AN EMPTY SET\n        INITIALIZE q1 TO AN EMPTY DEQUE\n        INITIALIZE q2 TO AN EMPTY DEQUE\n        \n        ASSIGN row TO 0\n        WHILE row < m\n            ASSIGN col TO 0\n            WHILE col < n\n                IF row = 0 OR col = 0\n                    ADD (row, col) TO vis1\n                    ADD (row, col) TO RIGHT OF q1\n                ENDIF\n                \n                IF row = m - 1 OR col = n - 1\n                    ADD (row, col) TO vis2\n                    ADD (row, col) TO RIGHT OF q2\n                ENDIF\n                \n                INCREMENT col BY 1\n            END WHILE\n            INCREMENT row BY 1\n        END WHILE\n        \n        CALL bfs WITH q1 AND vis1\n        CALL bfs WITH q2 AND vis2\n        \n        INITIALIZE result TO AN EMPTY LIST\n        \n        ASSIGN r_idx TO 0\n        WHILE r_idx < m\n            ASSIGN c_idx TO 0\n            WHILE c_idx < n\n                ASSIGN pos TO (r_idx, c_idx)\n                IF pos IN vis1 AND pos IN vis2\n                    ADD pos TO result\n                ENDIF\n                INCREMENT c_idx BY 1\n            END WHILE\n            INCREMENT r_idx BY 1\n        END WHILE\n        \n        RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION pacificAtlantic WITH PARAMETER heights  \n        FUNCTION bfs WITH PARAMETERS q AND vis  \n            WHILE the LENGTH OF q is greater than zero  \n                FOR each element from zero TO the LENGTH OF q MINUS one  \n                    SET i TO the first element of the element at position zero of q removed from the front  \n                    SET j TO the second element of the element at position zero of q removed from the front  \n                    FOR each pair a and b IN the list of pairs where the pairs are zero and MINUS one, zero and one, one and zero, MINUS one and zero  \n                        SET x TO i PLUS a  \n                        SET y TO j PLUS b  \n                        IF x GREATER THAN OR EQUAL TO zero AND x LESS THAN m AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n AND the tuple consisting of x and y is NOT IN vis AND the element at position x of heights AT position y OF heights GREATER THAN OR EQUAL TO the element at position i of heights AT position j OF heights  \n                            ADD the tuple consisting of x and y TO vis  \n                            APPEND the tuple consisting of x and y TO the end of q  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END WHILE  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF heights  \n        SET n TO the LENGTH OF the element at position zero of heights  \n        SET vis1 TO an empty set  \n        SET vis2 TO an empty set  \n        SET q1 TO an empty double ended queue  \n        SET q2 TO an empty double ended queue  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF i EQUALS zero OR j EQUALS zero  \n                    ADD the tuple consisting of i and j TO vis1  \n                    APPEND the tuple consisting of i and j TO the end of q1  \n                END IF  \n                IF i EQUALS m MINUS one OR j EQUALS n MINUS one  \n                    ADD the tuple consisting of i and j TO vis2  \n                    APPEND the tuple consisting of i and j TO the end of q2  \n                END IF  \n            END FOR  \n        END FOR  \n        CALL bfs WITH q1 AND vis1  \n        CALL bfs WITH q2 AND vis2  \n        SET result TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the tuple consisting of i and j IS IN vis1 AND the tuple consisting of i and j IS IN vis2  \n                    APPEND the tuple consisting of i and j TO result  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION getProbability(balls)\n        FUNCTION dfs(i, j, diff)\n            IF i IS AT LEAST k THEN\n                RETURN 1 IF j IS 0 AND diff IS 0 OTHERWISE 0\n            END IF\n            IF j IS LESS THAN 0 THEN\n                RETURN 0\n            END IF\n            ASSIGN 0 TO result\n            ASSIGN 0 TO idx\n            WHILE idx <= balls[i] DO\n                IF idx IS balls[i] THEN\n                    ASSIGN 1 TO val\n                ELSEIF idx IS 0 THEN\n                    ASSIGN -1 TO val\n                ELSE\n                    ASSIGN 0 TO val\n                END IF\n                ASSIGN result + (dfs(i + 1, j - idx, diff + val) * (combination(balls[i], idx))) TO result\n                INCREMENT idx BY 1\n            END WHILE\n            RETURN result\n        END FUNCTION\n\n        ASSIGN (SUM over element IN balls) / 2 TO half_total\n        ASSIGN LENGTH(balls) TO k\n        RETURN dfs(0, half_total, 0) / combination(half_total + half_total, half_total)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(i, j, diff)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i of balls INCLUSIVE  \n                IF x EQUALS element at position i of balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO minus one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS dfs(i PLUS one, j MINUS x, diff PLUS y) MULTIPLIED BY combination of element at position i of balls CHOOSE x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO LENGTH OF balls  \n        RETURN dfs(zero, n, zero) DIVIDED BY combination of n PLUS n CHOOSE n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-derangement-of-an-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION findDerangement(n)\n        ASSIGN (10 ^ 9 + 7) TO modulus\n        \n        IF NOT (n <> 1) THEN\n            RETURN 0\n        END IF\n        \n        IF NOT (n <> 2) THEN\n            RETURN 1\n        END IF\n        \n        ASSIGN 1 TO alpha\n        ASSIGN 0 TO beta\n        \n        ASSIGN 3 TO omega\n        \n        WHILE omega <= n\n            ASSIGN (omega - 1) * (beta + alpha) TO delta\n            ASSIGN delta - (delta / modulus) * modulus TO delta        # delta MOD modulus without using MOD operator directly\n            ASSIGN alpha TO beta\n            ASSIGN delta TO alpha\n            ASSIGN omega + 1 TO omega\n        END WHILE\n        \n        RETURN alpha\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findDerangement(n)  \n        SET MODULO TO ten RAISED TO THE POWER OF nine PLUS seven  \n        \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        IF n EQUALS two  \n            RETURN one  \n        END IF  \n        \n        SET previous_twice TO one  \n        SET previous_once TO zero  \n        \n        FOR integer i FROM three TO n  \n            SET current_value TO integer i MINUS one MULTIPLIED BY the SUM OF previous_once AND previous_twice  \n            SET current_value TO current_value MODULO MODULO  \n            SET previous_twice TO previous_once  \n            SET previous_once TO current_value  \n        END FOR  \n        \n        RETURN previous_once  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-product-of-two-sorted-arrays", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)\n\n        FUNCTION count(p PARAMETER)\n            ASSIGN 0 TO tally\n            ASSIGN LENGTH OF nums2 TO lengthB\n            ASSIGN 0 TO idxA\n            WHILE idxA LESS THAN LENGTH OF nums1\n                ASSIGN nums1[idxA] TO valA\n                IF valA NOT EQUAL TO 0 THEN\n                    IF valA GREATER THAN 0 THEN\n                        ASSIGN TRUNCATED_UPPER_BOUND(nums2, p DIVIDED BY valA) TO pos\n                        ADD pos TO tally\n                    ELSE\n                        ASSIGN lengthB MINUS TRUNCATED_LOWER_BOUND(nums2, p DIVIDED BY valA) TO remainder\n                        ADD remainder TO tally\n                    END IF\n                ELSE\n                    ADD (p GREATER THAN OR EQUAL TO 0) TIMES lengthB TO tally\n                END IF\n                ADD 1 TO idxA\n            END WHILE\n            YIELD tally\n        END FUNCTION\n\n        ASSIGN MAX(ABS(nums1[0]), ABS(nums1[-1])) TIMES MAX(ABS(nums2[0]), ABS(nums2[-1])) TO maximumValue\n        ASSIGN -maximumValue TO leftExtreme\n        ASSIGN maximumValue TO rightExtreme\n        ASSIGN BINARY_SEARCH(leftExtreme, rightExtreme + 1, k, count) TO answer\n        YIELD answer MINUS maximumValue\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)  \n        \n        FUNCTION count(p PARAMETER)  \n            SET cnt TO zero  \n            SET n TO the LENGTH OF nums2  \n            FOR each element x IN nums1  \n                IF x GREATER THAN zero  \n                    INCREMENT cnt BY the POSITION TO THE RIGHT IN nums2 OF the value p DIVIDED BY x  \n                ELSE IF x LESS THAN zero  \n                    INCREMENT cnt BY n MINUS the POSITION TO THE LEFT IN nums2 OF the value p DIVIDED BY x  \n                ELSE  \n                    INCREMENT cnt BY n MULTIPLIED BY the LOGICAL VALUE OF p GREATER THAN OR EQUAL TO zero  \n                END IF  \n            END FOR  \n            RETURN cnt  \n        END FUNCTION  \n        \n        SET mx TO the MAXIMUM OF the ABSOLUTE VALUE OF the element at POSITION zero OF nums1 AND the ABSOLUTE VALUE OF the element at the LAST POSITION OF nums1 MULTIPLIED BY the MAXIMUM OF the ABSOLUTE VALUE OF the element at POSITION zero OF nums2 AND the ABSOLUTE VALUE OF the element at the LAST POSITION OF nums2  \n        RETURN the POSITION TO THE LEFT WITHIN THE RANGE FROM NEGATIVE mx TO mx PLUS one OF the value k WHERE the KEY FUNCTION IS count MINUS mx  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tag-validator", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION isValid(code)\n        IMPORT regular expression module\n        DEFINE cdata_regex AS the pattern: literal \"<![CDATA[\" concatenated with any characters repeated reluctantly followed by \"]]>\"\n        SET code TO the output of substituting all matches of cdata_regex in code with empty string using regular expression substitution\n        ASSIGN pile TO an empty list\n        ASSIGN position TO 0\n        WHILE position < LENGTH(code)\n            IF code[position] = \"<\"\n                ASSIGN end_pos TO the index of \">\" found in code starting from position + 1\n                IF end_pos = -1\n                    RETURN false\n                END IF\n                ASSIGN content TO SUBSTRING(code, position + 1, end_pos)\n                IF content IS EMPTY\n                    RETURN false\n                END IF\n                IF content[0] = \"/\"\n                    ASSIGN tag TO SUBSTRING(content, 1, LENGTH(content))\n                    IF pile IS EMPTY OR pile[ LENGTH(pile) - 1 ] ≠ tag\n                        RETURN false\n                    END IF\n                    REMOVE the element at pile[ LENGTH(pile) - 1 ]\n                ELSE\n                    IF content[0] = \"!\"\n                        RETURN false\n                    OTHERWISE\n                        DEFINE is_valid_tag AS (LENGTH(content) ≥ 1) AND (LENGTH(content) ≤ 9)\n                        ASSIGN is_valid_tag TO is_valid_tag AND ALL(char IS UPPERCASE LETTER FOR EACH char IN content)\n                        IF NOT is_valid_tag\n                            RETURN false\n                        END IF\n                        APPEND content TO pile\n                    END IF\n                END IF\n                ASSIGN position TO end_pos + 1\n            OTHERWISE\n                INCREMENT position BY 1\n            END IF\n        END WHILE\n        DEFINE valid_tag_expr AS the pattern: \"<\" + one or more uppercase letters + \">\" + any characters any number of times + \"</\" + one or more uppercase letters + \">\"\n        RETURN (pile IS EMPTY) AND (COUNT OF ALL MATCHES OF valid_tag_expr IN code > 0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isValid(code)  \n        IMPORT regular expression module  \n        SET cdata_pattern TO the regular expression pattern representing the string starting with less than followed by an exclamation mark followed by open square bracket followed by CDATA followed by open square bracket followed by any character any number of times reluctantly followed by close square bracket followed by close square bracket followed by greater than  \n        SET code TO the result of replacing all occurrences matching cdata_pattern in code with empty string using regular expression substitution  \n        SET stack TO an empty list  \n        SET i TO zero  \n        WHILE i IS LESS THAN the LENGTH OF code  \n            IF the character at position i of code EQUALS the less than character  \n                SET j TO the position of the first occurrence of the greater than character in code starting from one position after i  \n                IF j EQUALS negative one  \n                    RETURN false  \n                END IF  \n                SET tag_content TO the substring from position i plus one TO position j of code  \n                IF tag_content IS EMPTY  \n                    RETURN false  \n                END IF  \n                IF the first character of tag_content EQUALS the forward slash character  \n                    SET tag_name TO the substring from position two TO the end of tag_content  \n                    IF stack IS EMPTY OR element at the last position of stack DOES NOT EQUAL tag_name  \n                        RETURN false  \n                    END IF  \n                    REMOVE the element at the last position FROM stack  \n                ELSE IF the first character of tag_content EQUALS the exclamation mark character  \n                    RETURN false  \n                ELSE  \n                    IF NOT the condition that the LENGTH OF tag_content IS GREATER THAN OR EQUAL TO one AND IS LESS THAN OR EQUAL TO nine AND every character in tag_content IS AN UPPERCASE LETTER  \n                        RETURN false  \n                    END IF  \n                    APPEND tag_content TO stack  \n                END IF  \n                SET i TO j PLUS one  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        SET valid_tag_pattern TO the regular expression pattern representing the string starting with less than followed by one or more uppercase letters followed by greater than followed by any character any number of times followed by less than followed by forward slash followed by one or more uppercase letters followed by greater than  \n        RETURN the condition that stack IS EMPTY AND the count of all occurrences matching valid_tag_pattern in code IS GREATER THAN zero  \n    END FUNCTION  \nEND CLASS"}
