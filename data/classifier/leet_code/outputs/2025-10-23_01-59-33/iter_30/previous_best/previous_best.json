{
  "prompt": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *fully reproducible*\u2014meaning it can be translated directly and unambiguously into correct, complete, deterministic executable code that will pass *all* valid unit tests *without fail* in the implied problem domain; otherwise, output **`0`**. Output nothing else\u2014no explanation, no whitespace, no extra characters.\n\nTo determine this, apply a deep, step-by-step, holistic verification against *all* of these refined and rigorous criteria:\n\n---\n\n### 1. Unambiguous Explicitness and Self-Containment  \n- Every input, output, variable, constant, data structure, and subroutine must be explicitly declared or uniquely and logically inferable solely from the pseudocode.  \n- Data types, sizes, initial values, and all state changes must be fully and precisely specified or unambiguously deducible.  \n- All subroutines and called methods must include full algorithmic details or exact behavior without requiring outside knowledge, external code, or assumptions.  \n- No placeholders, ellipses, omissions, or incomplete logic segments anywhere.  \n- The pseudocode must be entirely self-contained; no implicit context, hidden state, external dependencies, or unstated environment assumptions allowed.\n\n### 2. Full Coverage and Deterministic Completeness  \n- The pseudocode must correctly and explicitly handle *every* possible valid input in the problem\u2019s domain, including all edge cases (empty inputs, minimal and maximal values, boundary conditions, and special cases), either by explicit checks or logically guaranteed behavior.  \n- Control flow is fully specified with no ambiguities: all branches, loops, and recursions must be clearly defined, terminating under all valid inputs, with no possibility of infinite loops or unreachable code paths.  \n- No ambiguous or undefined branching or conditional logic; all decisions have deterministic outcomes.\n\n### 3. Semantic Precision and Single-Interpretation Behavior  \n- Each operation, statement, and expression must have a unique, well-defined meaning and effect, with no room for multiple interpretations or informal/colloquial wording.  \n- No nondeterminism allowed: no random, concurrent, or parallel execution implications, no reliance on unspecified evaluation order, and no outputs varying per run on the same input.  \n- The output must be a single deterministic result for every given valid input.\n\n### 4. Robustness and Logical Soundness  \n- The logic flow and computations must be free from contradictions, inconsistencies, or logical errors that could cause failure or incorrect results on any valid input.  \n- All necessary calculations, validations, and state transitions required to yield correct outputs must be explicitly or logically included.  \n- If any part can cause error, ambiguity, incorrect output, or incomplete behavior under *any* conceivable unit test or scenario, output must be **`0`**.\n\n### 5. Absolute Guarantee of Passing All Unit Tests  \n- Given the pseudocode\u2019s stated behavior and implied problem requirements, any faithful implementation based strictly on it will pass every valid unit test, including hidden edge cases testing correctness, completeness, and boundary conditions, without exceptions or errors.  \n- If *any* potential test can fail due to incomplete specification, ambiguity, logical gap, or hidden assumption, output **`0`**.\n\n---\n\n**Instructions:**  \n- Analyze the ENTIRE pseudocode as a complete whole; isolated fragments or partial logic are insufficient for positive determination.  \n- Ignore all formatting, comments, example code, problem statements outside the pseudocode text, or external descriptions\u2014decide strictly based on the pseudocode content.  \n- If any doubt, underspecification, vagueness, incomplete handling, contradictory logic, or external dependency is detected, output **`0`**.  \n- Output **`1`** *only* if every one of these exacting criteria is fulfilled beyond any reasonable doubt.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "response": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *fully reproducible*\u2014meaning it can be translated directly and unambiguously into correct, complete, deterministic executable code that will pass *all* valid unit tests *without fail* in the implied problem domain; otherwise, output **`0`**. Output nothing else\u2014no explanation, no whitespace, no extra characters.\n\nTo determine this, apply a deep, step-by-step, holistic verification against *all* of these refined and rigorous criteria:\n\n---\n\n### 1. Unambiguous Explicitness and Self-Containment  \n- Every input, output, variable, constant, data structure, and subroutine must be explicitly declared or uniquely and logically inferable solely from the pseudocode.  \n- Data types, sizes, initial values, and all state changes must be fully and precisely specified or unambiguously deducible.  \n- All subroutines and called methods must include full algorithmic details or exact behavior without requiring outside knowledge, external code, or assumptions.  \n- No placeholders, ellipses, omissions, or incomplete logic segments anywhere.  \n- The pseudocode must be entirely self-contained; no implicit context, hidden state, external dependencies, or unstated environment assumptions allowed.\n\n### 2. Full Coverage and Deterministic Completeness  \n- The pseudocode must correctly and explicitly handle *every* possible valid input in the problem\u2019s domain, including all edge cases (empty inputs, minimal and maximal values, boundary conditions, and special cases), either by explicit checks or logically guaranteed behavior.  \n- Control flow is fully specified with no ambiguities: all branches, loops, and recursions must be clearly defined, terminating under all valid inputs, with no possibility of infinite loops or unreachable code paths.  \n- No ambiguous or undefined branching or conditional logic; all decisions have deterministic outcomes.\n\n### 3. Semantic Precision and Single-Interpretation Behavior  \n- Each operation, statement, and expression must have a unique, well-defined meaning and effect, with no room for multiple interpretations or informal/colloquial wording.  \n- No nondeterminism allowed: no random, concurrent, or parallel execution implications, no reliance on unspecified evaluation order, and no outputs varying per run on the same input.  \n- The output must be a single deterministic result for every given valid input.\n\n### 4. Robustness and Logical Soundness  \n- The logic flow and computations must be free from contradictions, inconsistencies, or logical errors that could cause failure or incorrect results on any valid input.  \n- All necessary calculations, validations, and state transitions required to yield correct outputs must be explicitly or logically included.  \n- If any part can cause error, ambiguity, incorrect output, or incomplete behavior under *any* conceivable unit test or scenario, output must be **`0`**.\n\n### 5. Absolute Guarantee of Passing All Unit Tests  \n- Given the pseudocode\u2019s stated behavior and implied problem requirements, any faithful implementation based strictly on it will pass every valid unit test, including hidden edge cases testing correctness, completeness, and boundary conditions, without exceptions or errors.  \n- If *any* potential test can fail due to incomplete specification, ambiguity, logical gap, or hidden assumption, output **`0`**.\n\n---\n\n**Instructions:**  \n- Analyze the ENTIRE pseudocode as a complete whole; isolated fragments or partial logic are insufficient for positive determination.  \n- Ignore all formatting, comments, example code, problem statements outside the pseudocode text, or external descriptions\u2014decide strictly based on the pseudocode content.  \n- If any doubt, underspecification, vagueness, incomplete handling, contradictory logic, or external dependency is detected, output **`0`**.  \n- Output **`1`** *only* if every one of these exacting criteria is fulfilled beyond any reasonable doubt.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "score": 0.6533333333333333,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nfunction fractionToDecimal(n, d):\n    sign \u2190 \"-\" if (n < 0) xor (d < 0) else \"\"\n    n, d \u2190 abs(n), abs(d)\n    q, r \u2190 divmod(n, d)\n    int_part \u2190 str(q)\n    if r = 0: return sign + int_part\n    seen \u2190 map remainder \u2192 index\n    frac \u2190 []\n    while r \u2260 0:\n        if r in seen:\n            i \u2190 seen[r]\n            return sign + int_part + \".\" + join(frac[:i]) + \"(\" + join(frac[i:]) + \")\"\n        seen[r] \u2190 length(frac)\n        r \u2190 r * 10\n        q, r \u2190 divmod(r, d)\n        append str(q) to frac\n    return sign + int_part + \".\" + join(frac)\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION coinChange(list_of_coins, target_amount)\n        SET dynamic_programming_array TO a list WHERE each element is SET TO the target_amount PLUS one AND the LENGTH OF the list IS the target_amount PLUS one\n        SET element at position zero OF dynamic_programming_array TO zero\n        \n        FOR current_amount FROM one TO target_amount INCLUSIVE\n            FOR each coin IN list_of_coins\n                IF current_amount MINUS coin IS GREATER THAN OR EQUAL TO zero THEN\n                    SET element at position current_amount OF dynamic_programming_array TO the MINIMUM BETWEEN element at position current_amount OF dynamic_programming_array AND element at position current_amount MINUS coin OF dynamic_programming_array PLUS one\n                END IF\n            END FOR\n        END FOR\n        \n        IF element at position target_amount OF dynamic_programming_array IS NOT EQUAL TO target_amount PLUS one THEN\n            RETURN element at position target_amount OF dynamic_programming_array\n        ELSE\n            RETURN negative one\n        END IF\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION isRectangleCover(list_of_rectangles)\n        SET X1 TO positive infinity\n        SET Y1 TO positive infinity\n        SET X2 TO negative infinity\n        SET Y2 TO negative infinity\n        \n        ASSIGN points TO an empty set\n        SET total_area TO zero\n        \n        FOR each rectangle IN list_of_rectangles\n            ASSIGN x1 TO element at position zero of rectangle\n            ASSIGN y1 TO element at position one of rectangle\n            ASSIGN x2 TO element at position two of rectangle\n            ASSIGN y2 TO element at position three of rectangle\n            \n            SET X1 TO the minimum of X1 AND x1\n            SET Y1 TO the minimum of Y1 AND y1\n            SET X2 TO the maximum of X2 AND x2\n            SET Y2 TO the maximum of Y2 AND y2\n            \n            SET rectangle_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)\n            INCREMENT total_area BY rectangle_area\n            \n            SET corner_points TO a list containing tuples of:\n                tuple of x1 AND y1\n                tuple of x1 AND y2\n                tuple of x2 AND y1\n                tuple of x2 AND y2\n            \n            FOR each point IN corner_points\n                IF point IS IN points\n                    REMOVE point FROM points\n                ELSE\n                    ADD point TO points\n                END IF\n            END FOR\n        END FOR\n        \n        IF total_area IS NOT EQUAL TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)\n            RETURN false\n        END IF\n        \n        SET expected_points TO a set containing tuples of:\n            tuple of X1 AND Y1\n            tuple of X1 AND Y2\n            tuple of X2 AND Y1\n            tuple of X2 AND Y2\n        \n        IF points IS NOT EQUAL TO expected_points\n            RETURN false\n        END IF\n        \n        RETURN true\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION originalDigits(s)\n        SET count TO the frequency count of each character in s\n        \n        SET digits TO a list of zero repeated ten times\n        \n        SET the element at position zero of digits TO the count of character Z in count\n        SET the element at position two of digits TO the count of character W in count\n        SET the element at position four of digits TO the count of character U in count\n        SET the element at position six of digits TO the count of character X in count\n        SET the element at position eight of digits TO the count of character G in count\n        \n        SET the element at position three of digits TO the count of character H in count MINUS the element at position eight of digits\n        SET the element at position five of digits TO the count of character F in count MINUS the element at position four of digits\n        SET the element at position seven of digits TO the count of character S in count MINUS the element at position six of digits\n        SET the element at position nine of digits TO the count of character I in count MINUS the element at position five of digits MINUS the element at position six of digits MINUS the element at position eight of digits\n        SET the element at position one of digits TO the count of character O in count MINUS the element at position zero of digits MINUS the element at position two of digits MINUS the element at position four of digits\n        \n        SET result TO an empty list\n        \n        FOR index FROM zero TO nine\n            APPEND the string representation of index repeated the element at position index of digits times TO result\n        END FOR\n        \n        RETURN the concatenation of all elements in result\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6533333333333333",
  "iter": 29
}