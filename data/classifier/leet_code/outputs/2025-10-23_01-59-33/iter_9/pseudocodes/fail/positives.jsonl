{"task_id": "unique-paths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "remove-duplicates-from-sorted-array-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "gray-code", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "majority-element-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each element m IN nums  \n            IF element m EQUALS value m1  \n                INCREMENT n1 BY one  \n            ELSE IF element m EQUALS value m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO element m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO element m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE the count of element m IN nums IS GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "strobogrammatic-number-iii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            \n            IF n EQUALS one  \n                RETURN a list containing the string zero once the string one once the string eight  \n            END IF  \n            \n            SET middles TO the result of calling generate_strobogrammatic with arguments n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero PLUS middle PLUS zero TO result  \n                END IF  \n                APPEND the string one PLUS middle PLUS one TO result  \n                APPEND the string six PLUS middle PLUS nine TO result  \n                APPEND the string eight PLUS middle PLUS eight TO result  \n                APPEND the string nine PLUS middle PLUS six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN the result of calling generate_strobogrammatic with arguments length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of calling count_strobogrammatic with arguments low and high  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "flip-game-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "bulls-and-cows", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION getHint(secret PARAMETER, guess PARAMETER)  \n        IMPORT a data structure that provides a dictionary with default zero values\n        \n        SET bulls TO zero  \n        SET cows TO zero  \n        \n        CREATE a dictionary named secret_count with default zero values  \n        CREATE a dictionary named guess_count with default zero values  \n        \n        FOR each element s and element g taken correspondingly from secret and guess  \n            IF element s EQUALS element g  \n                INCREMENT bulls BY one  \n            ELSE  \n                INCREMENT the value at key element s in secret_count BY one  \n                INCREMENT the value at key element g in guess_count BY one  \n            END IF  \n        END FOR  \n        \n        FOR each digit IN the keys of secret_count  \n            INCREMENT cows BY the smaller value BETWEEN the value at key digit in secret_count AND the value at key digit in guess_count  \n        END FOR  \n        \n        RETURN a string expressing bulls FOLLOWED BY the character representing bulls AND THEN cows FOLLOWED BY the character representing cows  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "integer-break", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dp TO a list of zeros with the length of n PLUS one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            SET max_product TO zero  \n            FOR j FROM one TO i MINUS one  \n                SET product_one TO j MULTIPLIED BY element at position i MINUS j of dp  \n                SET product_two TO j MULTIPLIED BY i MINUS j  \n                IF max_product LESS THAN product_one AND max_product LESS THAN product_two  \n                    SET max_product TO the larger value BETWEEN product_one AND product_two  \n                ELSE IF max_product LESS THAN product_one  \n                    SET max_product TO product_one  \n                ELSE IF max_product LESS THAN product_two  \n                    SET max_product TO product_two  \n                END IF  \n            END FOR  \n            SET element at position i of dp TO max_product  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "word-squares", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION wordSquares(words)  \n        SET prefix_to_words TO an empty mapping from string to list of strings  \n        FOR each word IN words  \n            FOR index FROM zero TO the LENGTH OF word MINUS one  \n                SET prefix TO the substring of word from position zero TO position index MINUS one  \n                APPEND word TO the list at prefix_to_words corresponding to prefix  \n            END FOR  \n        END FOR  \n        \n        SET results TO an empty list  \n        \n        FUNCTION backtrack(square)  \n            IF the LENGTH OF square EQUALS the LENGTH OF the first element of words THEN  \n                APPEND square TO results  \n                RETURN  \n            END IF  \n            \n            SET prefix TO an empty string  \n            FOR each word_element IN square  \n                APPEND the element at position the LENGTH OF square of word_element TO prefix  \n            END FOR  \n            \n            FOR each candidate IN the list at prefix_to_words corresponding to prefix  \n                CALL backtrack WITH the argument of the concatenation of square with candidate as a new list element  \n            END FOR  \n        END FUNCTION  \n        \n        FOR each word IN words  \n            CALL backtrack WITH a list containing only word  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sort-characters-by-frequency", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION frequencySort WITH PARAMETER s  \n        SET frequency TO the character frequency mapping of s  \n        SET sorted_characters TO the list of characters in frequency arranged in descending order according to their frequency values  \n        SET result TO an empty string  \n        FOR each character IN sorted_characters  \n            APPEND the character repeated the number of times equal to the frequency of the character TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sliding-window-median", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION medianSlidingWindow(nums k)  \n        SET lo TO empty list  \n        SET hi TO empty list  \n\n        FUNCTION balance_heaps()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi PLUS one  \n                CALL heappush WITH the argument hi AND NEGATIVE of the result of heappop ON lo  \n            ELSE IF the LENGTH OF hi IS GREATER THAN the LENGTH OF lo  \n                CALL heappush WITH the argument lo AND NEGATIVE of the result of heappop ON hi  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION add_num(num)  \n            IF lo IS empty OR num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                CALL heappush WITH the argument lo AND NEGATIVE num  \n            ELSE  \n                CALL heappush WITH the argument hi AND num  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION remove_num(num)  \n            IF num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                REMOVE NEGATIVE num FROM lo  \n                IF lo IS NOT empty  \n                    CALL heapify WITH the argument lo  \n                END IF  \n            ELSE  \n                REMOVE num FROM hi  \n                IF hi IS NOT empty  \n                    CALL heapify WITH the argument hi  \n                END IF  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION get_median()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi  \n                RETURN NEGATIVE of element at position zero of lo  \n            END IF  \n            RETURN NEGATIVE of element at position zero of lo PLUS element at position zero of hi DIVIDED BY two  \n        END FUNCTION  \n\n        FOR i FROM zero TO k MINUS one  \n            CALL add_num WITH element at position i of nums  \n        END FOR  \n\n        SET medians TO a list containing the result of get_median()  \n\n        FOR i FROM k TO the LENGTH OF nums MINUS one  \n            CALL add_num WITH element at position i of nums  \n            CALL remove_num WITH element at position i MINUS k of nums  \n            APPEND the result of get_median() TO medians  \n        END FOR  \n\n        RETURN medians  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-closest-palindrome", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO integer VALUE OF n  \n            RETURN string REPRESENTATION OF numeric_value MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        SET power_length TO TEN RAISED TO THE power OF length  \n        SET power_length_minus_one TO TEN RAISED TO THE power OF length MINUS one  \n        \n        ADD the VALUE OF power_length PLUS one TO candidates  \n        ADD the VALUE OF power_length_minus_one MINUS one TO candidates  \n        \n        SET prefix TO integer VALUE OF substring FROM position one TO position (length PLUS one) DIVIDED BY two of n  \n        \n        FOR i FROM negative one TO positive one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO string REPRESENTATION OF new_prefix_numeric  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSED STRING OF new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH reversed_part  \n            ELSE  \n                SET substring_reversed TO the REVERSED STRING OF substring FROM position one TO LENGTH OF new_prefix MINUS one of new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH substring_reversed  \n            END IF  \n            \n            SET candidate_numeric TO integer VALUE OF candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO integer VALUE OF n  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO NULL  \n        SET smallest_distance TO INFINITY  \n        FOR each number IN candidates  \n            SET current_distance TO the ABSOLUTE VALUE OF number MINUS original_number  \n            IF current_distance LESS THAN smallest_distance OR (current_distance EQUALS smallest_distance AND number LESS THAN closest)  \n                SET closest TO number  \n                SET smallest_distance TO current_distance  \n            END IF  \n        END FOR  \n        \n        RETURN string REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-different-palindromic-subsequences", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences WITH PARAMETER s  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        \n        SET next_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        SET prev_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        \n        FOR each c FROM zero TO three  \n            SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n            SET last TO negative one  \n            FOR each i FROM zero TO n MINUS one  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of prev_occurrence TO last  \n            END FOR  \n            \n            SET last TO negative one  \n            FOR each i FROM n MINUS one DOWN TO zero  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of next_occurrence TO last  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a two dimensional list of n lists each containing n times zero  \n        \n        FOR each i FROM zero TO n MINUS one  \n            SET element at position i of element at position i of dp TO one  \n        END FOR  \n        \n        FOR each length FROM two TO n  \n            FOR each i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                FOR each c FROM zero TO three  \n                    SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n                    SET left TO element at position i of element at position c of next_occurrence  \n                    SET right TO element at position j of element at position c of prev_occurrence  \n                    \n                    IF left GREATER THAN j OR right LESS THAN i THEN  \n                        CONTINUE TO next iteration of the innermost loop  \n                    ELSE IF left EQUALS right THEN  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS one is divided by MOD  \n                    ELSE  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS element at position left PLUS one of element at position right MINUS one of dp PLUS two is divided by MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero of element at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "k-th-symbol-in-grammar", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kthGrammar(n k)  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET length_of_previous_row TO two MULTIPLIED BY two RAISED TO THE POWER OF n MINUS two MINUS one  \n        IF k LESS THAN OR EQUAL TO length_of_previous_row  \n            RETURN call kthGrammar WITH n MINUS one AND k  \n        ELSE  \n            SET previous_value TO call kthGrammar WITH n MINUS one AND k MINUS length_of_previous_row  \n            SET complement_value TO one MINUS previous_value  \n            RETURN complement_value  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "is-graph-bipartite", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        SET n TO the LENGTH OF graph  \n        SET color TO a list of zeros with LENGTH n  \n        \n        FUNCTION dfs(node c)  \n            SET the element at position node of color TO c  \n            FOR each neighbor IN the element at position node of graph  \n                IF the element at position neighbor of color EQUALS c  \n                    RETURN False  \n                END IF  \n                IF the element at position neighbor of color EQUALS zero  \n                    IF dfs(neighbor the NEGATION OF c) EQUALS False  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of color EQUALS zero  \n                IF dfs(i one) EQUALS False  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "k-th-smallest-prime-fraction", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPrimeFraction(arr, k)  \n        SET n TO the LENGTH OF arr  \n        SET min_heap TO an empty list  \n        FOR i FROM zero TO n MINUS one MINUS one  \n            PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position n MINUS one of arr AND i AND n MINUS one  \n        END FOR  \n        FOR iteration FROM zero TO k MINUS one MINUS one  \n            POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n            IF j MINUS one IS GREATER THAN i THEN  \n                PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position j MINUS one of arr AND i AND j MINUS one  \n            END IF  \n        END FOR  \n        POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n        RETURN a list containing element at position i of arr AND element at position j of arr  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "domino-and-tromino-tiling", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO the one billion PLUS seven  \n        \n        SET dp TO a list of zeros with LENGTH n PLUS one  \n        SET dp1 TO a list of zeros with LENGTH n PLUS one  \n        \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder of the sum of element at position i MINUS one of dp PLUS element at position i MINUS two of dp PLUS two MULTIPLIED BY element at position i MINUS one of dp1 when divided by MOD  \n            SET element at position i of dp1 TO the remainder of the sum of element at position i MINUS two of dp PLUS element at position i MINUS one of dp1 when divided by MOD  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "race-car", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION racecar(target)  \n        ASSIGN reference TO a new double ended queue containing a single tuple of zero for position one for speed and zero for steps  \n        ASSIGN reference TO a new empty set  \n        ADD a tuple of zero for position and one for speed TO the set  \n        \n        WHILE the queue is not empty  \n            REMOVE and ASSIGN a tuple from the left side of the queue TO position speed and steps  \n            \n            IF position EQUALS target  \n                RETURN steps  \n            END IF  \n            \n            SET next_position TO position PLUS speed  \n            SET next_speed TO speed MULTIPLIED BY two  \n            IF the tuple of next_position and next_speed NOT IN the set AND next_position IS GREATER THAN OR EQUAL TO zero AND next_position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of next_position and next_speed TO the set  \n                APPEND the tuple of next_position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n            \n            IF speed IS GREATER THAN zero  \n                SET next_speed TO negative one  \n            ELSE  \n                SET next_speed TO one  \n            END IF  \n            IF the tuple of position and next_speed NOT IN the set AND position IS GREATER THAN OR EQUAL TO zero AND position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of position and next_speed TO the set  \n                APPEND the tuple of position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "new-21-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION new21Game(n INTEGER PARAMETER k INTEGER PARAMETER maxPts INTEGER PARAMETER) RETURNS FLOAT  \n        FUNCTION dfs(i INTEGER PARAMETER) RETURNS FLOAT  \n            IF i GREATER THAN OR EQUAL TO k THEN  \n                IF i LESS THAN OR EQUAL TO n THEN  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF i EQUALS k MINUS one THEN  \n                IF n MINUS k PLUS one LESS THAN maxPts THEN  \n                    RETURN (n MINUS k PLUS one) DIVIDED BY maxPts  \n                ELSE  \n                    RETURN one  \n                END IF  \n            END IF  \n            SET first_call TO dfs(i PLUS one)  \n            SET second_call TO dfs(i PLUS maxPts PLUS one)  \n            SET result TO first_call PLUS (first_call MINUS second_call) DIVIDED BY maxPts  \n            RETURN result  \n        END FUNCTION  \n        RETURN dfs(zero)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "magic-squares-in-grid", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numMagicSquaresInside(grid)  \n        FUNCTION is_magic(i, j)  \n            IF element at position i of grid at position j NOT EQUALS five  \n                RETURN False  \n            END IF  \n            SET numbers TO empty set  \n            FOR x FROM i MINUS one TO i PLUS one  \n                FOR y FROM j MINUS one TO j PLUS one  \n                    IF element at position x of grid at position y LESS THAN one OR element at position x of grid at position y GREATER THAN nine OR element at position x of grid at position y IN numbers  \n                        RETURN False  \n                    END IF  \n                    ADD element at position x of grid at position y TO numbers  \n                END FOR  \n            END FOR  \n            FOR start FROM i MINUS one TO i PLUS one  \n                IF sum of element at position start of grid at position j MINUS one PLUS element at position start of grid at position j PLUS element at position start of grid at position j PLUS one NOT EQUALS fifteen OR sum of element at position i MINUS one of grid at position start PLUS element at position i of grid at position start PLUS element at position i PLUS one of grid at position start NOT EQUALS fifteen  \n                    RETURN False  \n                END IF  \n            END FOR  \n            IF sum of element at position i MINUS one of grid at position j MINUS one PLUS element at position i of grid at position j PLUS element at position i PLUS one of grid at position j PLUS one NOT EQUALS fifteen OR sum of element at position i MINUS one of grid at position j PLUS one PLUS element at position i of grid at position j PLUS element at position i PLUS one of grid at position j MINUS one NOT EQUALS fifteen  \n                RETURN False  \n            END IF  \n            RETURN True  \n        END FUNCTION  \n        SET count TO zero  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        FOR i FROM one TO rows MINUS one  \n            FOR j FROM one TO cols MINUS one  \n                IF is_magic(i, j)  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "car-fleet", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION carFleet(target position speed)  \n        SET paired_list TO the list of elements obtained by pairing each element at each position in position WITH the element at the corresponding position in speed  \n        SORT paired_list in order from the greatest element of the first component to the smallest element of the first component  \n\n        SET time_to_target TO an empty list  \n        FOR each pair IN paired_list  \n            SET p TO the first component of pair  \n            SET s TO the second component of pair  \n            SET time TO target MINUS p DIVIDED BY s  \n            APPEND time TO time_to_target  \n        END FOR  \n\n        SET fleets TO zero  \n        SET current_max_time TO zero  \n\n        FOR each time IN time_to_target  \n            IF time GREATER THAN current_max_time  \n                INCREMENT fleets BY one  \n                SET current_max_time TO time  \n            END IF  \n        END FOR  \n\n        RETURN fleets  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "shortest-path-to-get-all-keys", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO the list of pairs representing movement right one step left one step down one step and up one step  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO no value assigned  \n        SET num_keys TO zero  \n        FOR i FROM zero TO the value m MINUS one  \n            FOR j FROM zero TO the value n MINUS one  \n                IF element at position i of grid at position j EQUALS the character at sign at symbol  \n                    SET start TO the pair of values i and j  \n                ELSE IF element at position i of grid at position j IS a lowercase letter  \n                    INCREMENT num_keys BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET queue TO a new double ended queue containing the single element of the tuple of value at position zero of start value at position one of start zero zero  \n        SET visited TO a new set containing the single element of the tuple of value at position zero of start value at position one of start zero  \n        WHILE queue is not empty  \n            SET x y keys steps TO the tuple removed from the front of queue  \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid at position ny  \n                    IF cell EQUALS the hash symbol  \n                        CONTINUE to next iteration of FOR loop  \n                    END IF  \n                    IF cell IS an uppercase letter  \n                        SET key_needed TO one SHIFTED LEFT BY the Unicode code point of the lowercase form of cell MINUS the Unicode code point of letter a  \n                        IF the result of keys AND key_needed EQUALS zero  \n                            CONTINUE to next iteration of FOR loop  \n                        END IF  \n                    END IF  \n                    IF cell IS a lowercase letter  \n                        SET new_keys TO the result of keys OR one SHIFTED LEFT BY the Unicode code point of cell MINUS the Unicode code point of letter a  \n                        IF new_keys EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                    IF the tuple nx ny new_keys IS NOT in visited  \n                        ADD the tuple nx ny new_keys TO visited  \n                        APPEND the tuple nx ny new_keys steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "super-egg-drop", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        SET dp TO a list of zeros with length k PLUS one  \n        SET moves TO zero  \n        WHILE element at position k of dp LESS THAN n holds  \n            INCREMENT moves BY one  \n            FOR eggs FROM k DOWN TO one  \n                SET element at position eggs of dp TO one PLUS element at position eggs MINUS one of dp PLUS element at position eggs of dp  \n            END FOR  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "numbers-at-most-n-given-digit-set", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION count_numbers_with_length(length)  \n            RETURN the LENGTH OF digits RAISED TO THE POWER OF length  \n        END FUNCTION  \n        \n        FUNCTION count_numbers_up_to_n(n)  \n            SET str_n TO the string representation of n  \n            SET length TO the LENGTH OF str_n  \n            SET count TO zero  \n            \n            FOR l FROM one TO length MINUS one  \n                INCREMENT count BY count_numbers_with_length(l)  \n            END FOR  \n            \n            FOR i FROM zero TO length MINUS one  \n                SET current_digit TO the integer value of the element at position i of str_n  \n                FOR each digit IN digits  \n                    IF the integer value of digit LESS THAN current_digit THEN  \n                        INCREMENT count BY count_numbers_with_length(length MINUS i MINUS one)  \n                    ELSE IF the integer value of digit EQUALS current_digit THEN  \n                        IF i EQUALS length MINUS one THEN  \n                            INCREMENT count BY one  \n                        END IF  \n                    ELSE IF the integer value of digit GREATER THAN current_digit THEN  \n                        BREAK the inner loop  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN count_numbers_up_to_n(n)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "least-operators-to-express-number", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION leastOpsExpressTarget(x, target)  \n        FUNCTION dp(target_inner)  \n            IF target_inner EQUALS zero  \n                RETURN negative one  \n            END IF  \n            \n            IF target_inner LESS THAN x  \n                RETURN the minimum BETWEEN the expression two MULTIPLIED BY target_inner MINUS one AND the expression two MULTIPLIED BY the difference BETWEEN x MINUS target_inner  \n            END IF  \n            \n            SET power TO one  \n            WHILE x RAISED TO power IS LESS THAN OR EQUAL TO target_inner  \n                INCREMENT power BY one  \n            END WHILE  \n            DECREMENT power BY one  \n            \n            SET result TO the value returned BY dp WITH the argument target_inner MINUS x RAISED TO power PLUS power  \n            \n            IF the expression x RAISED TO the sum OF power PLUS one MINUS target_inner IS LESS THAN target_inner  \n                SET result TO the minimum BETWEEN result AND the value returned BY dp WITH the argument x RAISED TO the sum OF power PLUS one MINUS target_inner PLUS power PLUS one  \n            END IF  \n            \n            RETURN result  \n        END FUNCTION  \n        \n        RETURN the value returned BY dp WITH the argument target  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "equal-rational-numbers", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean  \n        SET ratios TO a list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number  \n            IF position of opening parenthesis in s EQUALS negative one  \n                RETURN the conversion of s TO a floating point number  \n            END IF  \n\n            SET leftParenIndex TO position of opening parenthesis in s  \n            SET rightParenIndex TO position of closing parenthesis in s  \n            SET dotIndex TO position of decimal point in s  \n\n            SET integerAndNonRepeating TO the conversion TO floating point number OF the substring of s from the start TO the position leftParenIndex minus one  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the conversion TO integer OF the substring of s from position leftParenIndex PLUS one TO position rightParenIndex MINUS one  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY the number one DIVIDED BY ten RAISED TO the power of nonRepeatingLength MULTIPLIED BY element at position repeatingLength OF the list ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of valueOf of s MINUS valueOf of t LESS THAN one DIVIDED BY ten RAISED TO the power of nine  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "divide-chocolate", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximizeSweetness(sweetness list OF integer k integer) RETURNS integer  \n        FUNCTION canDivide(min_sweet integer) RETURNS boolean  \n            SET pieces TO zero  \n            SET current_sweet TO zero  \n            FOR each sweet IN sweetness  \n                SET current_sweet TO current_sweet PLUS sweet  \n                IF current_sweet GREATER THAN OR EQUAL TO min_sweet  \n                    INCREMENT pieces BY one  \n                    SET current_sweet TO zero  \n                    IF pieces GREATER THAN k  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN pieces GREATER THAN k  \n        END FUNCTION  \n\n        SET left TO the smallest element IN sweetness  \n        SET right TO the total sum OF all elements IN sweetness DIVIDED BY the value of k PLUS one  \n        SET result TO zero  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the integer value of left PLUS right DIVIDED BY two  \n            IF canDivide(mid) IS True  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reverse-subarray-to-maximize-array-value", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxValueAfterReverse(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS two  \n            RETURN the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position one of nums  \n        END IF  \n        \n        SET initial_value TO zero  \n        FOR i FROM one TO n MINUS one  \n            INCREMENT initial_value BY the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n        END FOR  \n        \n        SET max_edge_gain TO zero  \n        FOR i FROM one TO n MINUS one  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position n MINUS one of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i PLUS one of nums MINUS element at position i of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        SET min_pair TO the MINIMUM VALUE among for each i FROM zero TO n MINUS two the MAXIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        SET max_pair TO the MAXIMUM VALUE among for each i FROM zero TO n MINUS two the MINIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        \n        SET general_gain TO the MAXIMUM VALUE between zero AND two MULTIPLIED BY the DIFFERENCE between max_pair AND min_pair  \n        \n        RETURN initial_value PLUS the MAXIMUM VALUE between max_edge_gain AND general_gain  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "largest-multiple-of-three", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO the frequency counter of digits  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder after dividing total_sum BY three  \n        IF remainder EQUALS one  \n            FOR each digit d IN the list consisting of one four seven  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of two five eight  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit d IN the list consisting of two five eight  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of one four seven  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        SET result TO an empty list  \n        FOR each digit d FROM nine DOWN TO zero  \n            APPEND the string representation of digit d REPEATED frequency count of digit d times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF the length of final_number IS GREATER THAN zero AND the element at position zero of final_number EQUALS zero  \n            RETURN the string zero  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "cherry-pickup-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dp(r c1 c2)  \n            IF c1 LESS THAN zero OR c1 GREATER THAN OR EQUAL TO cols OR c2 LESS THAN zero OR c2 GREATER THAN OR EQUAL TO cols THEN  \n                RETURN zero  \n            END IF  \n            \n            IF c1 EQUALS c2 THEN  \n                SET cherries TO element at position r of grid element at position c1  \n            ELSE  \n                SET cherries TO element at position r of grid element at position c1 PLUS element at position r of grid element at position c2  \n            END IF  \n            \n            IF r EQUALS rows MINUS one THEN  \n                RETURN cherries  \n            END IF  \n            \n            SET max_cherries TO zero  \n            FOR each dc1 IN list containing negative one zero and one  \n                FOR each dc2 IN list containing negative one zero and one  \n                    SET possible TO dp(r PLUS one c1 PLUS dc1 c2 PLUS dc2)  \n                    IF possible GREATER THAN max_cherries THEN  \n                        SET max_cherries TO possible  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN cherries PLUS max_cherries  \n        END FUNCTION  \n        \n        RETURN dp(zero zero cols MINUS one)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "best-position-for-a-service-centre", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION getMinDistSum(positions)  \n        SET n TO the LENGTH OF positions  \n        SET x TO zero  \n        SET y TO zero  \n        FOR each position IN positions  \n            SET x1 TO the first element AT position  \n            SET y1 TO the second element AT position  \n            INCREMENT x BY x1  \n            INCREMENT y BY y1  \n        END FOR  \n        SET x TO x DIVIDED BY n  \n        SET y TO y DIVIDED BY n  \n        SET decay TO zero POINT nine nine nine  \n        SET eps TO zero POINT zero zero zero zero zero one  \n        SET alpha TO zero POINT five  \n        WHILE TRUE  \n            SET grad_x TO zero  \n            SET grad_y TO zero  \n            SET dist TO zero  \n            FOR each position IN positions  \n                SET x1 TO the first element AT position  \n                SET y1 TO the second element AT position  \n                SET a TO x MINUS x1  \n                SET b TO y MINUS y1  \n                SET c TO the square root of a MULTIPLIED BY a PLUS b MULTIPLIED BY b  \n                INCREMENT grad_x BY a DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT grad_y BY b DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT dist BY c  \n            END FOR  \n            SET dx TO grad_x MULTIPLIED BY alpha  \n            SET dy TO grad_y MULTIPLIED BY alpha  \n            DECREMENT x BY dx  \n            DECREMENT y BY dy  \n            MULTIPLY alpha BY decay  \n            IF the absolute value of dx IS LESS THAN OR EQUAL TO eps AND the absolute value of dy IS LESS THAN OR EQUAL TO eps  \n                RETURN dist  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "create-sorted-array-through-instructions", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET MAX TO the maximum element of instructions PLUS one  \n        SET bit TO a list of zeros with length MAX  \n\n        FUNCTION update(idx val)  \n            WHILE idx LESS THAN MAX holds  \n                INCREMENT element at position idx of bit BY val  \n                INCREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            SET total TO zero  \n            WHILE idx GREATER THAN zero holds  \n                INCREMENT total BY element at position idx of bit  \n                DECREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n            RETURN total  \n        END FUNCTION  \n\n        SET total_cost TO zero  \n        FOR each pair of i num IN the enumeration of instructions  \n            SET less_than TO the result of query with argument num MINUS one  \n            SET greater_than TO i MINUS the result of query with argument num  \n            IF less_than LESS THAN OR EQUAL TO greater_than holds  \n                SET cost TO less_than  \n            ELSE  \n                SET cost TO greater_than  \n            END IF  \n            SET total_cost TO the remainder of total_cost PLUS cost DIVIDED BY MOD  \n            CALL update with arguments num and one  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-special-evenly-spaced-elements-in-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION solve(nums list OF integers queries list OF list OF integers) RETURNS list OF integers  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF nums  \n        SET max_y TO the HIGHEST y VALUE FROM each pair IN queries  \n        SET prefix_sums TO a list CONTAINING max_y PLUS one ELEMENTS each BEING a list OF n zeroes  \n        \n        FOR y FROM one TO max_y  \n            FOR i FROM n MINUS one DOWN TO zero  \n                IF i PLUS y LESS THAN n THEN  \n                    SET element at position i of element at position y of prefix_sums TO element at position i of nums PLUS element at position i PLUS y of element at position y of prefix_sums  \n                ELSE  \n                    SET element at position i of element at position y of prefix_sums TO element at position i of nums  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET answer TO an empty list  \n        FOR each pair x y IN queries  \n            APPEND element at position x of element at position y of prefix_sums MODULO MOD TO answer  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "cat-and-mouse-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the LIST of MINUS one zero ONE zero MINUS one  \n        SET g_mouse TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n        SET g_cat TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n\n        FOR each index i AND element row IN the ENUMERATION OF grid  \n            FOR each index j AND element c IN the ENUMERATION OF row  \n                IF c EQUALS the character representing a HASH  \n                    CONTINUE  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character representing uppercase C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character representing uppercase M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character representing uppercase F  \n                    SET food TO v  \n                END IF  \n                FOR each element a AND next element b IN consecutive pairs of dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the RESULT OF calling calc WITH g_mouse, g_cat, mouse_start, cat_start, food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            SET m TO element at position zero of state  \n            SET c TO element at position one of state  \n            SET t TO element at position two of state  \n            SET pt TO the EXCLUSIVE OR of t AND one  \n            SET pre TO an empty LIST  \n            IF pt EQUALS one  \n                FOR each pc IN element at position c of g_cat  \n                    IF element at position m AND position pc AND position one of ans EQUALS zero  \n                        APPEND the TUPLE of m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN element at position m of g_mouse  \n                    IF element at position pm AND position c AND position zero of ans EQUALS zero  \n                        APPEND the TUPLE of pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET element at position zero of element at position j of element at position i of degree TO the LENGTH OF element at position i of g_mouse  \n                SET element at position one of element at position j of element at position i of degree TO the LENGTH OF element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position hole AND position i AND position one of ans TO one  \n            SET element at position i AND position hole AND position zero of ans TO two  \n            SET element at position i AND position i AND position one of ans TO two  \n            SET element at position i AND position i AND position zero of ans TO two  \n            ADD the TUPLE of hole i one TO the end of q  \n            ADD the TUPLE of i hole zero TO the end of q  \n            ADD the TUPLE of i i zero TO the end of q  \n            ADD the TUPLE of i i one TO the end of q  \n        END FOR  \n        WHILE q is not empty  \n            REMOVE the element from the front of q AND ASSIGN to state  \n            SET t TO element at position zero AND position one AND position two of ans ACCORDING TO state  \n            FOR each prev_state IN get_prev_states WITH state  \n                SET pm TO element at position zero of prev_state  \n                SET pc TO element at position one of prev_state  \n                SET pt TO element at position two of prev_state  \n                IF pt EQUALS t MINUS one  \n                    SET element at position pm AND position pc AND position pt of ans TO t  \n                    ADD prev_state TO the end of q  \n                ELSE  \n                    DECREMENT element at position pm AND position pc AND position pt of degree BY one  \n                    IF element at position pm AND position pc AND position pt of degree EQUALS zero  \n                        SET element at position pm AND position pc AND position pt of ans TO t  \n                        ADD prev_state TO the end of q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN element at position mouse_start AND position cat_start AND position zero of ans  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "number-of-different-subsequences-gcds", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET max_num TO the maximum value in nums  \n        SET num_set TO the set of elements in nums  \n        SET count TO zero  \n        FOR g FROM one TO max_num INCLUSIVE  \n            SET gcd_val TO zero  \n            FOR m FROM g TO max_num INCLUSIVE IN STEPS OF g  \n                IF element at position m of num_set IS PRESENT  \n                    SET gcd_val TO the greatest common divisor of gcd_val AND m  \n                    IF gcd_val EQUALS g  \n                        INCREMENT count BY one  \n                        BREAK out of inner loop  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-floored-pairs", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET max_num TO the maximum element in nums  \n        SET count TO a mapping from elements in nums to their frequencies  \n        SET prefix_sum TO a list of zeroes with length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num in count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the integer division of max_num BY num  \n                SET start TO num MULTIPLIED BY multiple  \n                IF num MULTIPLIED BY the sum of multiple PLUS one MINUS one LESS THAN OR EQUAL TO max_num  \n                    SET end TO num MULTIPLIED BY multiple PLUS one MINUS one  \n                ELSE  \n                    SET end TO max_num  \n                END IF  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num in count  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter of list of integers k parameter of integer) RETURNS integer  \n        SET total_sum TO the sum of all elements of nums  \n        SET n TO the length of nums  \n        \n        CREATE left_diff as a dictionary with default integer zero  \n        CREATE right_diff as a dictionary with default integer zero  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value associated with diff in right_diff BY one  \n        END FOR  \n        \n        SET max_ways TO the value associated with zero in right_diff  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            \n            SET diff_change TO k MINUS the element at position i of nums  \n            \n            SET new_ways TO the value associated with negative diff_change in left_diff PLUS the value associated with diff_change in right_diff  \n            \n            IF new_ways GREATER THAN max_ways  \n                SET max_ways TO new_ways  \n            END IF  \n            \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value associated with diff in right_diff BY one  \n            INCREMENT the value associated with diff in left_diff BY one  \n        END FOR  \n        \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "partition-array-into-two-arrays-to-minimize-sum-difference", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDifference(nums)  \n        SET n TO the LENGTH OF nums DIVIDED BY two  \n        SET total_sum TO the SUM OF nums  \n        SET target TO total_sum DIVIDED BY two  \n        SET min_diff TO positive infinity  \n        \n        SET left_half TO the first n elements of nums  \n        SET right_half TO the elements of nums from position n plus one TO the end  \n        \n        SET left_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        SET right_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        \n        FOR i FROM zero TO n  \n            FOR each combination of i elements IN left_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN left_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN left_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN left_sums at position i BY one  \n            END FOR  \n            \n            FOR each combination of i elements IN right_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN right_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN right_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN right_sums at position i BY one  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO n  \n            SET left_values TO the keys of left_sums at position i SORTED in ascending order  \n            SET right_values TO the keys of right_sums at position n MINUS i SORTED in ascending order  \n            \n            SET j TO zero  \n            SET k TO the LENGTH OF right_values MINUS one  \n            \n            WHILE j LESS THAN the LENGTH OF left_values AND k GREATER THAN OR EQUAL TO zero  \n                SET current_sum TO the element at position j of left_values PLUS the element at position k of right_values  \n                SET diff_candidate TO total_sum MINUS two MULTIPLIED BY current_sum  \n                IF diff_candidate IS LESS THAN zero  \n                    SET diff_candidate TO the NEGATIVE of diff_candidate  \n                END IF  \n                IF diff_candidate LESS THAN min_diff  \n                    SET min_diff TO diff_candidate  \n                END IF  \n                \n                IF current_sum LESS THAN target  \n                    INCREMENT j BY one  \n                ELSE IF current_sum GREATER THAN target  \n                    DECREMENT k BY one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits AS list of list of integers, startPos AS integer, k AS integer) RETURNS integer  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        \n        FOR right FROM zero TO the length of fruits MINUS one  \n            SET position TO the element at position zero of the element at position right of fruits  \n            SET amount TO the element at position one of the element at position right of fruits  \n            INCREMENT total_fruits BY amount  \n            \n            WHILE left LESS THAN OR EQUAL TO right AND NOT  \n                (startPos MINUS k LESS THAN OR EQUAL TO the element at position zero of the element at position left of fruits AND  \n                the element at position zero of the element at position left of fruits LESS THAN OR EQUAL TO startPos PLUS k AND  \n                startPos MINUS k LESS THAN OR EQUAL TO the element at position zero of the element at position right of fruits AND  \n                the element at position zero of the element at position right of fruits LESS THAN OR EQUAL TO startPos PLUS k AND  \n                the minimum value of the absolute value of the element at position zero of the element at position right of fruits MINUS startPos AND the absolute value of the element at position zero of the element at position left of fruits MINUS startPos PLUS the element at position zero of the element at position right of fruits MINUS the element at position zero of the element at position left of fruits) LESS THAN OR EQUAL TO k  \n            DO  \n                DECREMENT total_fruits BY the element at position one of the element at position left of fruits  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            IF max_fruits LESS THAN total_fruits  \n                SET max_fruits TO total_fruits  \n            END IF  \n        END FOR  \n        \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "recover-the-original-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION recoverArray(nums)  \n        SORT the elements of nums in ascending order  \n        SET n TO the LENGTH OF nums  \n        SET first TO the element at position zero of nums  \n        FOR i FROM one TO n MINUS one  \n            SET k TO the element at position i of nums MINUS first DIVIDED BY two  \n            IF k LESS THAN OR EQUAL TO zero OR first PLUS two MULTIPLIED BY k NOT EQUALS the element at position i of nums  \n                CONTINUE to the next iteration  \n            END IF  \n            SET count TO a mapping of each element of nums to its frequency  \n            SET arr TO an empty list  \n            FOR each element x IN nums  \n                IF the value at key x in count EQUALS zero  \n                    CONTINUE to the next iteration  \n                END IF  \n                IF the value at key the sum of x PLUS two MULTIPLIED BY k in count EQUALS zero  \n                    BREAK out of the loop  \n                END IF  \n                APPEND the sum of x PLUS k TO arr  \n                DECREMENT the value at key x in count BY one  \n                DECREMENT the value at key the sum of x PLUS two MULTIPLIED BY k in count BY one  \n            END FOR  \n            IF the LENGTH OF arr EQUALS n DIVIDED BY two  \n                RETURN arr  \n            END IF  \n        END FOR  \n        RETURN an empty list  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-substring-with-given-hash-value", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION subStrHash(s string power integer modulo integer k integer hashValue integer) RETURNS string  \n        FUNCTION val(c character) RETURNS integer  \n            RETURN the unicode code of character c MINUS the unicode code of character a PLUS one  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF string s  \n        SET current_hash TO zero  \n        SET p_pow TO one  \n\n        FOR i FROM n MINUS k TO n MINUS one  \n            SET current_hash TO current_hash PLUS val(the element at position i of s) MULTIPLIED BY p_pow MODULO modulo  \n            IF i LESS THAN n MINUS one  \n                SET p_pow TO p_pow MULTIPLIED BY power MODULO modulo  \n            END IF  \n        END FOR  \n\n        SET start_index TO n MINUS k  \n        IF current_hash EQUALS hashValue  \n            RETURN the substring from position start_index TO the position one LESS THAN n of s  \n        END IF  \n\n        SET p_pow_k_minus_1 TO p_pow  \n\n        FOR i FROM n MINUS k MINUS one DOWN TO zero  \n            SET current_hash TO current_hash MINUS val(the element at position i PLUS k of s) MULTIPLIED BY p_pow_k_minus_1 MODULO modulo  \n            SET current_hash TO current_hash MULTIPLIED BY power PLUS val(the element at position i of s) MODULO modulo  \n\n            IF current_hash EQUALS hashValue  \n                SET start_index TO i  \n            END IF  \n        END FOR  \n\n        RETURN the substring from position start_index TO the position start_index PLUS k MINUS one of s  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-and-sum-of-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumANDSum(nums numSlots)  \n        FUNCTION dp(index slots)  \n            IF index EQUALS LENGTH OF nums  \n                RETURN zero  \n            END IF  \n              \n            SET max_and_sum TO zero  \n            SET slots_list TO list converted from slots  \n              \n            FOR i FROM zero TO numSlots MINUS one  \n                IF element at position i of slots_list LESS THAN two  \n                    INCREMENT element at position i of slots_list BY one  \n                    SET and_sum TO bitwise AND of element at position index of nums AND i PLUS one PLUS dp function called with index PLUS one AND tuple converted from slots_list  \n                    IF and_sum GREATER THAN max_and_sum  \n                        SET max_and_sum TO and_sum  \n                    END IF  \n                    DECREMENT element at position i of slots_list BY one  \n                END IF  \n            END FOR  \n              \n            RETURN max_and_sum  \n        END FUNCTION  \n          \n        SET initial_slots TO tuple consisting of zero repeated numSlots times  \n        RETURN dp function called with zero AND initial_slots  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "longest-substring-of-one-repeating-character", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestRepeating(s queryCharacters queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF the character element at position three of element at position i of intervals EQUALS the character element at position three of element at position i PLUS one of intervals  \n                    SET element at position i of intervals TO a tuple consisting of element at position one of element at position i of intervals COMMA element at position two of element at position i PLUS one of intervals COMMA character element at position three of element at position i of intervals  \n                    REMOVE element at position i PLUS one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n        \n        SET intervals TO an empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple consisting of start COMMA i MINUS one COMMA element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple consisting of start COMMA n MINUS one COMMA element at position start of s TO intervals  \n        \n        SET results TO an empty list  \n        SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n        \n        FOR each char idx IN the corresponding pairs of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start end c TO the tuple element at position i of intervals  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF idx GREATER THAN start  \n                INSERT a tuple consisting of start COMMA idx MINUS one COMMA c AT position i OF intervals  \n                SET element at position i PLUS one of intervals TO a tuple consisting of idx COMMA end COMMA c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT a tuple consisting of idx PLUS one COMMA end COMMA c AT position i PLUS one OF intervals  \n                SET element at position i of intervals TO a tuple consisting of start COMMA idx COMMA c  \n            END IF  \n            \n            SET element at position i of intervals TO a tuple consisting of the first element of element at position i of intervals COMMA the second element of element at position i of intervals COMMA char  \n            \n            CALL merge_intervals()  \n            \n            SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n            APPEND longest TO results  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-total-beauty-of-the-gardens", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET n TO the LENGTH OF flowers  \n        SET max_beauty TO zero  \n        SET prefix_sum TO A LIST OF ZEROS WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at POSITION i PLUS one OF prefix_sum TO element at POSITION i OF prefix_sum PLUS element at POSITION i OF flowers  \n        END FOR  \n        SET complete_gardens TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at POSITION i OF flowers GREATER THAN OR EQUAL TO target THEN  \n                INCREMENT complete_gardens BY one  \n            ELSE  \n                BREAK  \n            END IF  \n        END FOR  \n        SET remaining_flowers TO newFlowers  \n        SET max_incomplete_flowers TO zero  \n        FOR i FROM complete_gardens TO n  \n            IF i GREATER THAN zero THEN  \n                DECREMENT remaining_flowers BY target MINUS element at POSITION n MINUS i OF flowers  \n                IF remaining_flowers LESS THAN zero THEN  \n                    BREAK  \n                END IF  \n            END IF  \n            SET left TO zero  \n            SET right TO n MINUS i MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n                SET cost TO element at POSITION mid OF flowers MULTIPLIED BY mid PLUS one MINUS element at POSITION mid PLUS one OF prefix_sum  \n                IF cost GREATER THAN remaining_flowers THEN  \n                    DECREMENT right BY one PLUS mid MINUS right  \n                ELSE  \n                    INCREMENT left BY one PLUS mid MINUS left  \n                END IF  \n            END WHILE  \n            IF right GREATER THAN OR EQUAL TO zero THEN  \n                SET max_incomplete_flowers TO element at POSITION right OF flowers PLUS remaining_flowers MINUS element at POSITION right OF flowers MULTIPLIED BY right PLUS one PLUS NEGATION OF element at POSITION right PLUS one OF prefix_sum DIVIDED BY right PLUS one USING INTEGER DIVISION  \n            ELSE  \n                SET max_incomplete_flowers TO zero  \n            END IF  \n            SET total_beauty TO i MULTIPLIED BY full PLUS THE MINIMUM OF max_incomplete_flowers AND target MINUS one MULTIPLIED BY partial  \n            IF total_beauty GREATER THAN max_beauty THEN  \n                SET max_beauty TO total_beauty  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "check-if-there-is-a-valid-parentheses-string-path", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF the sum of m PLUS n MINUS one MODULO two NOT EQUALS zero  \n            RETURN false  \n        END IF  \n        \n        SET dp TO a three dimensional collection of size m PLUS one BY n PLUS one BY m PLUS n PLUS one FILLED WITH false  \n        \n        SET element at position zero of element at position one of dp TO true  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                FOR k FROM zero TO m PLUS n  \n                    IF element at position i of element at position j PLUS one of dp at position k OR element at position i PLUS one of element at position j of dp at position k  \n                        IF element at position i of element at position j of grid EQUALS the opening parenthesis AND k PLUS one LESS THAN m PLUS n PLUS one  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k PLUS one TO true  \n                        ELSE IF element at position i of element at position j of grid EQUALS the closing parenthesis AND k MINUS one GREATER THAN OR EQUAL TO zero  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k MINUS one TO true  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m of element at position n of dp at position zero  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "valid-number", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        SET number pattern TO a string matching an optional plus or minus sign followed by either one or more digits optionally followed by a decimal point and zero or more digits or a decimal point followed by one or more digits and optionally followed by an exponent part consisting of the letter e followed by an optional plus or minus sign and one or more digits  \n        RETURN the result of matching the entire string s to the number pattern is not equal to nothing  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "non-decreasing-subsequences", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(u, last, t)  \n            IF u EQUALS the LENGTH OF nums  \n                IF the LENGTH OF t GREATER THAN one  \n                    APPEND a copy of t TO ans  \n                END IF  \n                RETURN  \n            END IF  \n            IF element at position u of nums GREATER THAN OR EQUAL TO last  \n                APPEND element at position u of nums TO t  \n                CALL dfs with arguments u PLUS one, element at position u of nums, t  \n                REMOVE last element FROM t  \n            END IF  \n            IF element at position u of nums NOT EQUALS last  \n                CALL dfs with arguments u PLUS one, last, t  \n            END IF  \n        END FUNCTION  \n        SET ans TO an empty list  \n        CALL dfs with arguments zero, negative one thousand, an empty list  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "shopping-offers", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION shoppingOffers(price, special, needs)  \n        SET special TO an empty list  \n        FOR each offer IN the original special list  \n            IF the sum of elements at all positions except the last in offer IS GREATER THAN zero AND  \n               the last element of offer IS LESS THAN the sum of the product of corresponding elements of price and offer except the last element  \n                APPEND offer TO special  \n            END IF  \n        END FOR  \n        \n        FUNCTION dfs(needs)  \n            SET min_cost TO zero  \n            FOR each element at position index FROM zero TO the length of price MINUS one  \n                INCREMENT min_cost BY the element at position index of price MULTIPLIED BY the element at position index of needs  \n            END FOR  \n            \n            FOR each offer IN special  \n                SET new_needs TO an empty list  \n                FOR each index FROM zero TO the length of needs MINUS one  \n                    APPEND to new_needs the element at position index of needs MINUS the element at position index of offer  \n                END FOR  \n                \n                SET can_use_offer TO true  \n                FOR each element n IN new_needs  \n                    IF n IS LESS THAN zero  \n                        SET can_use_offer TO false  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n                \n                IF can_use_offer EQUALS true  \n                    SET possible_cost TO the last element of offer PLUS dfs(the tuple version of new_needs)  \n                    IF possible_cost IS LESS THAN min_cost  \n                        SET min_cost TO possible_cost  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dfs(the tuple version of needs)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS an opening parenthesis OR element e EQUALS an ampersand OR element e EQUALS a vertical bar  \n                APPEND a tuple containing element e AND zero TO stack  \n                CONTINUE to the next iteration  \n            ELSE IF element e EQUALS a closing parenthesis  \n                SET lastPair TO the result of removing and returning the last element from stack  \n                REMOVE and discard the last element from stack corresponding to an opening parenthesis  \n            ELSE  \n                SET lastPair TO a tuple containing element e AND one  \n            END IF  \n            IF the length of stack IS GREATER THAN zero AND the first item of the last tuple in stack IS EQUAL TO an ampersand OR a vertical bar  \n                SET op TO the first element of the result of removing and returning the last tuple from stack  \n                SET a AND costA TO the elements of the result of removing and returning the last tuple from stack  \n                SET b AND costB TO the elements of lastPair  \n                IF op EQUALS an ampersand  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one PLUS the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND the smaller of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND one PLUS the smaller of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last tuple in stack  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-and-replace-in-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findReplaceString(s parameter, indices parameter, sources parameter, targets parameter)  \n        SET replacements TO list of tuples made of element at same position of indices parameter AND sources parameter AND targets parameter sorted by the first element of each tuple  \n        SET result TO empty list  \n        SET prev_end TO zero  \n        FOR each tuple composed of index variable AND source variable AND target variable IN replacements  \n            APPEND substring of s parameter from position prev_end TO position index MINUS one to result  \n            IF substring of s parameter from position index TO position index PLUS the LENGTH OF source variable MINUS one EQUALS source variable  \n                APPEND target variable TO result  \n            ELSE  \n                APPEND substring of s parameter from position index TO position index PLUS the LENGTH OF source variable MINUS one TO result  \n            END IF  \n            SET prev_end TO index PLUS the LENGTH OF source variable  \n        END FOR  \n        APPEND substring of s parameter from position prev_end TO the end TO result  \n        RETURN concatenation of all elements IN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(i, j, diff)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i of balls INCLUSIVE  \n                IF x EQUALS element at position i of balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO minus one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS dfs(i PLUS one, j MINUS x, diff PLUS y) MULTIPLIED BY combination of element at position i of balls CHOOSE x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO LENGTH OF balls  \n        RETURN dfs(zero, n, zero) DIVIDED BY combination of n PLUS n CHOOSE n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "kth-smallest-product-of-two-sorted-arrays", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)  \n        \n        FUNCTION count(p PARAMETER)  \n            SET cnt TO zero  \n            SET n TO the LENGTH OF nums2  \n            FOR each element x IN nums1  \n                IF x GREATER THAN zero  \n                    INCREMENT cnt BY the POSITION TO THE RIGHT IN nums2 OF the value p DIVIDED BY x  \n                ELSE IF x LESS THAN zero  \n                    INCREMENT cnt BY n MINUS the POSITION TO THE LEFT IN nums2 OF the value p DIVIDED BY x  \n                ELSE  \n                    INCREMENT cnt BY n MULTIPLIED BY the LOGICAL VALUE OF p GREATER THAN OR EQUAL TO zero  \n                END IF  \n            END FOR  \n            RETURN cnt  \n        END FUNCTION  \n        \n        SET mx TO the MAXIMUM OF the ABSOLUTE VALUE OF the element at POSITION zero OF nums1 AND the ABSOLUTE VALUE OF the element at the LAST POSITION OF nums1 MULTIPLIED BY the MAXIMUM OF the ABSOLUTE VALUE OF the element at POSITION zero OF nums2 AND the ABSOLUTE VALUE OF the element at the LAST POSITION OF nums2  \n        RETURN the POSITION TO THE LEFT WITHIN THE RANGE FROM NEGATIVE mx TO mx PLUS one OF the value k WHERE the KEY FUNCTION IS count MINUS mx  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
