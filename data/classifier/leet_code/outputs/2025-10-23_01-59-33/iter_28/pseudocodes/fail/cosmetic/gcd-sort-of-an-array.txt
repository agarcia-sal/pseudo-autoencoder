CLASS UnionFind  
  FUNCTION __init__(self, size)  
    LET ancestry_list BE empty list  
    LET hierarchy_levels BE empty list  
    LET index_counter BE 0  
    WHILE index_counter LESS THAN OR EQUAL TO size MINUS 1  
      APPEND index_counter TO ancestry_list  
      INCREMENT index_counter BY 1  
    END WHILE  
    LET copy_counter BE 0  
    WHILE copy_counter LESS THAN size  
      APPEND 1 TO hierarchy_levels  
      INCREMENT copy_counter BY 1  
    END WHILE  
    ASSIGN self.parent TO ancestry_list  
    ASSIGN self.rank TO hierarchy_levels  
  END FUNCTION  
  
  FUNCTION find(self, p)  
    IF self.parent[p] IS NOT EQUAL TO p  
      ASSIGN self.parent[p] TO self.find(self.parent[p])  
    END IF  
    RETURN self.parent[p]  
  END FUNCTION  
  
  FUNCTION union(self, p, q)  
    LET rootA BE self.find(p)  
    LET rootB BE self.find(q)  
    IF NOT (rootA IS NOT rootB)  
      RETURN False  
    END IF  
    IF self.rank[rootA] GREATER THAN self.rank[rootB]  
      ASSIGN self.parent[rootB] TO rootA  
    ELSE IF NOT (self.rank[rootA] GREATER THAN OR EQUAL TO self.rank[rootB])  
      ASSIGN self.parent[rootA] TO rootB  
    ELSE  
      ASSIGN self.parent[rootB] TO rootA  
      LET current_rank BE self.rank[rootA]  
      LET updated_rank BE current_rank PLUS 1  
      ASSIGN self.rank[rootA] TO updated_rank  
    END IF  
    RETURN True  
  END FUNCTION  
END CLASS  
  
CLASS Solution  
  FUNCTION gcdSort(self, nums)  
    LET ordered_nums BE new list of elements of nums sorted by ascending order  
    LET peak_value BE nums[0]  
    LET idx_check BE 1  
    WHILE idx_check LESS THAN LENGTH of nums  
      IF nums[idx_check] GREATER THAN peak_value  
        ASSIGN peak_value TO nums[idx_check]  
      END IF  
      INCREMENT idx_check BY 1  
    END WHILE  
  
    LET union_struct BE UnionFind(peak_value PLUS 1)  
  
    LET outer_pos BE 0  
    WHILE outer_pos LESS THAN LENGTH of nums  
      LET current_element BE nums[outer_pos]  
      LET factor_check BE 2  
      LET limit_factor BE INTEGER(SQRT(current_element)) PLUS 1  
      WHILE factor_check LESS THAN limit_factor  
        LET division_remainder BE (current_element MINUS factor_check * (current_element DIV factor_check))  
        IF division_remainder IS EQUAL TO 0  
          union_struct.union(current_element, factor_check)  
          union_struct.union(current_element, current_element DIV factor_check)  
        END IF  
        INCREMENT factor_check BY 1  
      END WHILE  
      INCREMENT outer_pos BY 1  
    END WHILE  
  
    LET compare_index BE 0  
    WHILE compare_index LESS THAN LENGTH of nums  
      LET original_parent BE union_struct.find(nums[compare_index])  
      LET sorted_parent BE union_struct.find(ordered_nums[compare_index])  
      IF original_parent IS NOT EQUAL TO sorted_parent  
        RETURN False  
      END IF  
      INCREMENT compare_index BY 1  
    END WHILE  
  
    RETURN True  
  END FUNCTION  
END CLASS