{"task_id": "majority-element-ii", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each m IN nums  \n            IF m EQUALS m1  \n                INCREMENT n1 BY one  \n            ELSE IF m EQUALS m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE count of m in nums GREATER THAN length of nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS", "score": 0.9285714285714286, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpq6epnpw3/solution_0.py\", line 37, in <module>\\n    print(Solution().majorityElement(nums = [2,2,1,3]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'majorityElement\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each m IN nums  \n            IF m EQUALS m1  \n                INCREMENT n1 BY one  \n            ELSE IF m EQUALS m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements FROM the list containing m1 AND m2 WHERE the count of element IN nums GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-iii", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n\n        FUNCTION generate_strobogrammatic(current_length  \n                                         target_length)  \n            IF current_length EQUALS 0  \n                RETURN a list with an empty string element  \n            ELSE IF current_length EQUALS 1  \n                RETURN a list with elements: \"0\", \"1\", \"8\"  \n            ELSE  \n                DECLARE inner_results AS the result of generate_strobogrammatic(current_length MINUS 2, target_length)  \n                DECLARE collection AS an empty list  \n                FOR each inner_string IN inner_results  \n                    IF current_length NOT EQUAL TO target_length  \n                        ADD \"0\" CONCATENATED WITH inner_string CONCATENATED WITH \"0\" TO collection  \n                    END IF  \n                    ADD \"1\" CONCATENATED WITH inner_string CONCATENATED WITH \"1\" TO collection  \n                    ADD \"6\" CONCATENATED WITH inner_string CONCATENATED WITH \"9\" TO collection  \n                    ADD \"8\" CONCATENATED WITH inner_string CONCATENATED WITH \"8\" TO collection  \n                    ADD \"9\" CONCATENATED WITH inner_string CONCATENATED WITH \"6\" TO collection  \n                END FOR  \n                RETURN collection  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            DECLARE total AS 0  \n            DECLARE low_length AS LENGTH OF low  \n            DECLARE high_length AS LENGTH OF high  \n\n            DEFINE FUNCTION count_for_length(current_len)  \n                IF current_len GREATER THAN high_length  \n                    RETURN 0  \n                ELSE  \n                    DECLARE total_for_current AS 0  \n                    DECLARE sequences AS generate_strobogrammatic(current_len, current_len)  \n                    DECLARE idx AS 0  \n                    FUNCTION inner_count()  \n                        IF idx EQUALS LENGTH OF sequences  \n                            RETURN 0  \n                        ELSE  \n                            DECLARE candidate AS sequences[idx]  \n                            SET idx TO idx + 1  \n                            IF (current_len EQUALS low_length AND candidate LESS THAN low) OR (current_len EQUALS high_length AND candidate GREATER THAN high)  \n                                RETURN inner_count()  \n                            ELSE  \n                                RETURN 1 + inner_count()  \n                            END IF  \n                        END IF  \n                    END FUNCTION  \n                    total_for_current = inner_count()  \n                    RETURN total_for_current + count_for_length(current_len + 1)  \n                END IF  \n            END FUNCTION  \n\n            total = count_for_length(low_length)  \n            RETURN total  \n        END FUNCTION  \n\n        RETURN count_strobogrammatic(low, high)  \n    END FUNCTION  \nEND CLASS", "score": 0.9565217391304348, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpflciutp8/solution_0.py\", line 48, in <module>\\n    print(Solution().strobogrammaticInRange(low = \"50\", high = \"100\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'strobogrammaticInRange\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low, high)  \n        FUNCTION generate_strobogrammatic(n, final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            IF n EQUALS one  \n                RETURN a list containing the strings zero one and eight  \n            END IF  \n            SET middles TO the result of generate_strobogrammatic of n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero concatenated with middle concatenated with zero TO result  \n                END IF  \n                APPEND the string one concatenated with middle concatenated with one TO result  \n                APPEND the string six concatenated with middle concatenated with nine TO result  \n                APPEND the string eight concatenated with middle concatenated with eight TO result  \n                APPEND the string nine concatenated with middle concatenated with six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        FUNCTION count_strobogrammatic(low, high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN generate_strobogrammatic of length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN count_strobogrammatic of low and high  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-word-lengths", "label": "near_miss", "pseudocode": "CLASS Solution\n  FUNCTION maxProduct(words)\n    INITIALIZE char_groups AS an empty queue\n    FOR index IN RANGE 0 TO LENGTH(words) - 1 DO\n      ENQUEUE the unique characters from words[index] INTO char_groups\n    END FOR\n\n    INITIALIZE highest_product TO 0\n\n    FOR outer_idx IN RANGE 0 TO LENGTH(words) - 1 DO\n      FOR inner_idx IN RANGE outer_idx + 1 TO LENGTH(words) - 1 DO\n        SWITCH\n          CASE char_groups[outer_idx] HAS NO COMMON ELEMENTS WITH char_groups[inner_idx]:\n            DECLARE candidate_product AS 0\n            candidate_product = LENGTH(words[outer_idx])\n            MULTIPLY candidate_product BY LENGTH(words[inner_idx])\n\n            IF candidate_product <= highest_product THEN\n              BREAK\n            ELSE\n              highest_product = candidate_product\n            END IF\n          DEFAULT:\n            CONTINUE\n        END SWITCH\n      END FOR\n    END FOR\n\n    RETURN highest_product\n  END FUNCTION\nEND CLASS", "score": 0.8653846153846154, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmppn4x84yq/solution_0.py\", line 59, in <module>\\n    print(Solution().maxProduct(words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]))\\n          ^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'maxProduct\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters in word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the set at position i of word_sets has NO COMMON ELEMENTS WITH the set at position j of word_sets  \n                    SET product TO the LENGTH OF the element at position i of words MULTIPLIED BY the LENGTH OF the element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-jump", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS empty OR the LENGTH OF stones LESS THAN two THEN  \n            RETURN False  \n        END IF  \n        \n        SET stone_set TO the SET OF stones  \n        SET memo TO an EMPTY dictionary  \n        \n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS element at the last position of stones THEN  \n                RETURN True  \n            END IF  \n            \n            IF the PAIR of position AND jump IS IN memo THEN  \n                RETURN the VALUE ASSOCIATED WITH the PAIR of position AND jump IN memo  \n            END IF  \n            \n            FOR next_jump FROM jump MINUS one TO jump PLUS one DO  \n                IF next_jump GREATER THAN zero AND the SUM OF position AND next_jump IS IN stone_set THEN  \n                    IF can_jump_to(the SUM OF position AND next_jump, next_jump) THEN  \n                        SET the VALUE ASSOCIATED WITH the PAIR of position AND jump IN memo TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the VALUE ASSOCIATED WITH the PAIR of position AND jump IN memo TO False  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_jump_to(element at position one of stones, zero)  \n    END FUNCTION  \nEND CLASS", "score": 0.8235294117647058, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp2yui3du7/solution_0.py\", line 149, in <module>\\n    print(Solution().canCross(stones = [0,1,4,5,6,8,9,11]))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'canCross\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS an empty list OR the LENGTH OF stones LESS THAN two THEN  \n            RETURN False  \n        END IF  \n        \n        SET stone_set TO a new empty set  \n        FOR each stone IN stones  \n            ADD stone TO stone_set  \n        END FOR  \n        \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the last element of stones THEN  \n                RETURN True  \n            END IF  \n            \n            IF the tuple of position and jump IS IN memo THEN  \n                RETURN the value from memo with key tuple of position and jump  \n            END IF  \n            \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the sum of position PLUS next_jump IS IN stone_set THEN  \n                    IF can_jump_to(the sum of position PLUS next_jump, next_jump) THEN  \n                        SET the value in memo with key tuple of position and jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value in memo with key tuple of position and jump TO False  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_jump_to(the first element of stones, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-closest-palindrome", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            CONVERT n TO an INTEGER  \n            SET result_number TO that INTEGER MINUS one  \n            CONVERT result_number TO a STRING  \n            RETURN that STRING  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        COMPUTE ten_power_length PLUS one AS ten RAISED TO THE POWER OF length PLUS one  \n        ADD ten_power_length PLUS one TO candidates  \n        \n        COMPUTE ten_power_length_minus_one MINUS one AS ten RAISED TO THE POWER OF length MINUS one MINUS one  \n        ADD ten_power_length_minus_one MINUS one TO candidates  \n        \n        COMPUTE prefix_length AS integer division OF length PLUS one BY two  \n        EXTRACT substring of n FROM position one TO prefix_length  \n        CONVERT substring TO an INTEGER AND SET TO prefix  \n        \n        FOR i FROM negative one TO positive one  \n            COMPUTE new_prefix_number AS prefix PLUS i  \n            CONVERT new_prefix_number TO a STRING AND SET TO new_prefix  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSE OF new_prefix  \n                SET candidate_string TO CONCATENATION OF new_prefix AND reversed_part  \n            ELSE  \n                SET reversed_part TO the REVERSE OF substring of new_prefix FROM position one TO position length of new_prefix MINUS one  \n                SET candidate_string TO CONCATENATION OF new_prefix AND reversed_part  \n            END IF  \n            \n            CONVERT candidate_string TO an INTEGER AND ADD TO candidates  \n        END FOR  \n        \n        CONVERT n TO an INTEGER AND SET TO original_number  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO an ELEMENT OF candidates THAT MINIMIZES A PAIR composed of the ABSOLUTE VALUE OF element MINUS original_number AND element ITSELF  \n        \n        CONVERT closest TO a STRING  \n        RETURN closest  \n    END FUNCTION  \nEND CLASS", "score": 0.875, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp4xzbec4v/solution_0.py\", line 57, in <module>\\n    print(Solution().nearestPalindromic(n = \"123\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'nearestPalindromic\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION nearestPalindromic WITH PARAMETER n  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            RETURN the STRING REPRESENTATION OF the INTEGER VALUE OF n MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        ADD the INTEGER VALUE OF ten RAISED TO THE POWER OF length PLUS one TO candidates  \n        ADD the INTEGER VALUE OF ten RAISED TO THE POWER OF length MINUS one MINUS one TO candidates  \n        \n        SET prefix TO the INTEGER VALUE OF the SUBSTRING from position zero TO the INTEGER VALUE of the FLOOR of the DIVISION of length PLUS one BY two OF n  \n        FOR i FROM negative one TO one  \n            SET new_prefix TO the STRING REPRESENTATION OF prefix PLUS i  \n            IF the REMAINDER OF the DIVISION OF length BY two EQUALS zero  \n                SET candidate TO the CONCATENATION OF new_prefix AND the REVERSE OF new_prefix  \n            ELSE  \n                SET candidate TO the CONCATENATION OF new_prefix AND the REVERSE OF the SUBSTRING of new_prefix from the position of the SECOND TO LAST CHARACTER TO the FIRST CHARACTER  \n            END IF  \n            ADD the INTEGER VALUE OF candidate TO candidates  \n        END FOR  \n        \n        SET original_number TO the INTEGER VALUE OF n  \n        REMOVE original_number FROM candidates IF IT IS IN candidates  \n        \n        SET closest TO the ELEMENT OF candidates WITH THE MINIMUM VALUE ACCORDING TO THE CRITERION OF THE ABSOLUTE VALUE OF the ELEMENT MINUS original_number FOLLOWED BY the ELEMENT ITSELF  \n        \n        RETURN the STRING REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION longestWord(words)\n        CALL words SORTED BY (element -> LENGTH OF element, element) RETURNING sorted_words\n        CREATE valid_words AS new set\n        ASSIGN \"\" TO longest_word\n        DEFINE FUNCTION process_words(index)\n            IF NOT (index < LENGTH OF sorted_words) THEN RETURN\n            ASSIGN sorted_words[index] TO current_str\n            ASSIGN LENGTH OF current_str TO length_curr\n            IF NOT (length_curr == 1 OR SUBSTRING current_str FROM 0 TO length_curr - 1 IS IN valid_words) THEN\n                CALL process_words(index + 1)\n                RETURN\n            END IF\n            CALL valid_words INSERT current_str\n            IF NOT (length_curr <= LENGTH OF longest_word) THEN\n                ASSIGN current_str TO longest_word\n            END IF\n            CALL process_words(index + 1)\n        END FUNCTION\n        CALL process_words(0)\n        RETURN longest_word\n    END FUNCTION\nEND CLASS", "score": 0.9215686274509803, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpx1x371ju/solution_0.py\", line 40, in <module>\\n    print(Solution().longestWord(words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]))\\n          ^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'longestWord\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN alphabetical ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO the empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from the first character TO the character before the last character IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "soup-servings", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION soupServings(n)\n        IF NOT (n <= 4800) THEN\n            RETURN 1.0\n        END IF\n        LET m = (n + 24) // 25\n        LET cache = {}\n        FUNCTION dp(x, y)\n            IF cache CONTAINS KEY (x, y) THEN\n                RETURN cache[(x, y)]\n            END IF\n            IF x > 0 OR y > 0 THEN\n                IF x > 0 AND y <= 0 THEN\n                    RETURN 0.0\n                ELSIF y > 0 AND x <= 0 THEN\n                    RETURN 1.0\n                END IF\n                IF y <= 0 AND x <= 0 THEN\n                    RETURN 0.5\n                END IF\n            ELSE\n                RETURN 0.5\n            END IF\n\n            LET outcomes = [\n                dp(x-4, y),\n                dp(x-3, y-1),\n                dp(x-2, y-2),\n                dp(x-1, y-3)\n            ]\n            LET result = 0.25 * (outcomes[0] + outcomes[1] + outcomes[2] + outcomes[3])\n            cache[(x, y)] = result\n            RETURN result\n        END FUNCTION\n\n        RETURN dp(m, m)\n    END FUNCTION\nEND CLASS", "score": 0.8, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpehwoeq60/solution_0.py\", line 54, in <module>\\n    print(Solution().soupServings(n = 0))\\n          ^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'soupServings\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred  \n            RETURN one  \n        END IF  \n        \n        SET n TO n PLUS twenty four DIVIDED BY twenty five rounded down to the nearest integer greater than or equal to the result  \n        \n        SET memo TO an empty collection mapping pairs to probabilities  \n        \n        FUNCTION dp(a b)  \n            IF the pair of a and b EXISTS AS A KEY IN memo  \n                RETURN the value FROM memo FOR the pair of a and b  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero  \n                RETURN zero point five  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero  \n                RETURN one  \n            END IF  \n            \n            IF b LESS THAN OR EQUAL TO zero  \n                RETURN zero  \n            END IF  \n            \n            SET prob TO zero point two five MULTIPLIED BY the sum of dp of a MINUS four b, dp of a MINUS three b MINUS one, dp of a MINUS two b MINUS two, and dp of a MINUS one b MINUS three  \n            \n            SET the value in memo FOR the pair of a and b TO prob  \n            RETURN prob  \n        END FUNCTION  \n        \n        RETURN dp WITH parameters n and n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-to-get-all-keys", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET delta_coordinates TO [(1, 0), (-1, 0), (0, 1), (0, -1)]  \n        SET height TO LENGTH OF grid  \n        SET width TO LENGTH OF grid AT ZERO  \n        SET initial_position TO null  \n        SET total_keys TO 0  \n\n        FUNCTION scan_positions(row_index)  \n            IF row_index EQUALS height  \n                RETURN  \n            END IF  \n            FUNCTION scan_columns(col_index)  \n                IF col_index EQUALS width  \n                    RETURN  \n                END IF  \n                SET cell_char TO grid AT row_index AT col_index  \n                SWITCH cell_char  \n                    CASE '@':  \n                        SET initial_position TO (row_index, col_index)  \n                    CASE 'a', 'b', 'c', 'd', 'e', 'f':  \n                        INCREMENT total_keys BY 1  \n                    DEFAULT:  \n                        NO OPERATION  \n                END SWITCH  \n                scan_columns(col_index + 1)  \n            END FUNCTION  \n            scan_columns(0)  \n            scan_positions(row_index + 1)  \n        END FUNCTION  \n        scan_positions(0)  \n\n        SET exploration_queue TO a double ended queue containing (initial_position AT ZERO, initial_position AT ONE, 0, 0)  \n        SET seen_states TO a set containing (initial_position AT ZERO, initial_position AT ONE, 0)  \n\n        FUNCTION process_queue()  \n            IF exploration_queue IS EMPTY  \n                RETURN -1  \n            END IF  \n            SET current_x, current_y, collected_keys, distance_traveled TO POP FRONT OF exploration_queue  \n\n            FOR EACH (delta_x, delta_y) IN delta_coordinates  \n                SET new_x TO current_x + delta_x  \n                SET new_y TO current_y + delta_y  \n                IF 0 <= new_x < height AND 0 <= new_y < width  \n                    SET grid_cell TO grid AT new_x AT new_y  \n                    IF grid_cell EQUALS '#'  \n                        CONTINUE  \n                    END IF  \n                    IF 'A' <= grid_cell <= 'F'  \n                        SET required_key_mask TO 1 LEFT SHIFT (UNICODE OF LOWERCASE(grid_cell) MINUS UNICODE OF 'a')  \n                        IF (collected_keys BITWISE AND required_key_mask) EQUALS 0  \n                            CONTINUE  \n                        END IF  \n                    END IF  \n\n                    IF 'a' <= grid_cell <= 'f'  \n                        SET updated_keys TO collected_keys BITWISE OR (1 LEFT SHIFT (UNICODE OF grid_cell MINUS UNICODE OF 'a'))  \n                        IF updated_keys EQUALS (1 LEFT SHIFT total_keys) - 1  \n                            RETURN distance_traveled + 1  \n                        END IF  \n                    ELSE  \n                        SET updated_keys TO collected_keys  \n                    END IF  \n\n                    IF (new_x, new_y, updated_keys) NOT IN seen_states  \n                        ADD (new_x, new_y, updated_keys) TO seen_states  \n                        ADD (new_x, new_y, updated_keys, distance_traveled + 1) TO exploration_queue  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN process_queue()  \n        END FUNCTION  \n        RETURN process_queue()  \n    END FUNCTION  \nEND CLASS", "score": 0.8461538461538461, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp3dn14wla/solution_0.py\", line 50, in <module>\\n    print(Solution().shortestPathAllKeys(grid = [\"@.a..\",\"###.#\",\"b.A.B\"]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'shortestPathAllKeys\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO list of pairs of zero and one zero and minus one one and zero minus one and zero  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO none  \n        SET num_keys TO zero  \n          \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid IS EQUALS the character at position j  \n                    IF character at position j EQUALS the character AT POSITION symbol at position corresponding to at sign  \n                        SET start TO pair of i AND j  \n                    ELSE IF character at position j IS LOWERCASE LETTER  \n                        INCREMENT num_keys BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        SET queue TO a new double ended queue containing a tuple of element at position zero of start AND element at position one of start AND zero AND zero  \n        SET visited TO a new set containing a tuple of element at position zero of start AND element at position one of start AND zero  \n          \n        WHILE queue is not empty  \n            SET x, y, keys, steps TO the elements dequeued from the left of queue  \n              \n            FOR each dx, dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid element at position ny  \n                      \n                    IF cell IS EQUALS wall symbol  \n                        CONTINUE to next iteration  \n                    END IF  \n                      \n                    IF cell IS UPPERCASE LETTER  \n                        SET key_needed TO one SHIFTED LEFT BY the position of lowercase of cell MINUS position of letter a  \n                        IF keys AND key_needed IS EQUALS zero  \n                            CONTINUE to next iteration  \n                        END IF  \n                    END IF  \n                      \n                    IF cell IS LOWERCASE LETTER  \n                        SET new_keys TO keys OR one SHIFTED LEFT BY the position of cell MINUS position of letter a  \n                        IF new_keys IS EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                      \n                    IF tuple of nx, ny, new_keys NOT IN visited  \n                        ADD tuple of nx, ny, new_keys TO visited  \n                        APPEND tuple of nx, ny, new_keys, steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-subsequence-widths", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MODULO TO ten raised to the power of nine PLUS one  \n        SORT the list nums in ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        INITIALIZE list power WITH n elements all equal to one  \n        \n        FOR index i FROM one TO n MINUS one  \n            SET element at position i of power TO element at position i MINUS one of power MULTIPLIED BY two MODULO MODULO  \n        END FOR  \n        \n        FOR index i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS element at position i of nums MULTIPLIED BY element at position i of power MINUS element at position n MINUS i MINUS one of power  \n            SET total_sum TO total_sum MODULO MODULO  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS", "score": 0.9574468085106383, "error": "", "error_string": "['  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpfd6cy_ed/solution_0.py\", line 37\\n    nonlocal longest_word\\n    ^^^^^^^^^^^^^^^^^^^^^\\nSyntaxError: name \\'longest_word\\' is used prior to nonlocal declaration\\n']", "true_positive": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MODULO TO ten POWERED BY nine PLUS one  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list WITH n elements EACH EQUAL TO one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO the element at position i MINUS one of power MULTIPLIED BY two MODULO MODULO  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS the element at position i of nums MULTIPLIED BY the element at position i of power MINUS the element at position n MINUS i MINUS one of power MODULO MODULO  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences-ii", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET n TO the LENGTH OF s  \n        SET dp TO a list of zeros with the LENGTH OF n PLUS one  \n        SET element at position zero of dp TO one  \n        SET last TO an empty dictionary  \n        FOR i FROM one TO n  \n            SET char TO element at position i MINUS one of s  \n            SET element at position i of dp TO element at position i MINUS one of dp MULTIPLIED BY two MODULO MOD  \n            IF char IS A KEY IN last  \n                SET element at position i of dp TO element at position i of dp MINUS element at position last of char MINUS one of dp PLUS MODULO MOD  \n            END IF  \n            SET value at key char in last TO i  \n        END FOR  \n        RETURN element at position n of dp MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 0.9534883720930233, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpx17111mu/solution_0.py\", line 61, in <module>\\n    print(Solution().distinctSubseqII(s = \"abc\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'distinctSubseqII\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION distinctSubseqII WITH parameter s  \n        SET MODULO TO ten RAISED TO THE power of nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of zeros WITH LENGTH n PLUS one  \n        SET element at position zero of dp TO one  \n        INITIALIZE last AS an empty dictionary  \n        FOR i FROM one TO n  \n            SET character TO element at position i MINUS one of s  \n            SET element at position i of dp TO the value of element at position i MINUS one of dp MULTIPLIED BY two MODULO MODULO  \n            IF character IS a key in last  \n                SET element at position i of dp TO element at position i of dp MINUS element at position last of character MINUS one of dp PLUS MODULO MODULO MODULO  \n            END IF  \n            ASSIGN i TO last at character  \n        END FOR  \n        RETURN element at position n of dp MINUS one MODULO MODULO  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-rational-numbers", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION isRationalEqual(string s, string t) RETURNS boolean\n        SET ratios TO list containing one followed by one DIVIDED BY nine followed by one DIVIDED BY ninety nine followed by one DIVIDED BY nine hundred ninety nine followed by one DIVIDED BY nine thousand nine hundred ninety nine\n\n        FUNCTION valueOf(string s) RETURNS float\n            IF the POSITION OF character open parenthesis IN s IS EQUALS TO negative one\n                RETURN the FLOATING POINT REPRESENTATION OF s\n            END IF\n            SET leftParenIndex TO the POSITION OF character open parenthesis IN s\n            SET rightParenIndex TO the POSITION OF character close parenthesis IN s\n            SET dotIndex TO the POSITION OF character dot IN s\n            SET integerAndNonRepeating TO the FLOATING POINT REPRESENTATION OF the SUBSTRING from POSITION zero TO leftParenIndex of s\n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one\n            SET repeating TO the INTEGER REPRESENTATION OF the SUBSTRING from POSITION leftParenIndex PLUS one TO rightParenIndex of s\n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one\n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY the POWER of ten TO THE MINUS nonRepeatingLength MULTIPLIED BY the element at POSITION repeatingLength OF ratios\n        END FUNCTION\n\n        RETURN the ABSOLUTE VALUE OF valueOf CALLED WITH parameter s MINUS valueOf CALLED WITH parameter t IS LESS THAN one TIMES ten TO THE MINUS nine\n    END FUNCTION\nEND CLASS", "score": 0.9795918367346939, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpl1qyabzn/solution_0.py\", line 37, in <module>\\n    print(Solution().isRationalEqual(s = \"1.\", t = \"1\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isRationalEqual\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION isRationalEqual(s, t)  \n        SET ratios TO list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf(s)  \n            IF the position of the opening parenthesis character in s EQUALS negative one THEN  \n                RETURN the floating point conversion of s  \n            END IF  \n\n            SET leftParenIndex TO the position of the opening parenthesis character in s  \n            SET rightParenIndex TO the position of the closing parenthesis character in s  \n            SET dotIndex TO the position of the decimal point character in s  \n\n            SET integerAndNonRepeating TO the floating point conversion of the substring from the start of s TO the position before leftParenIndex of s  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the integer conversion of the substring from the position after leftParenIndex TO the position before rightParenIndex of s  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY zero POINT one RAISED TO THE POWER OF nonRepeatingLength MULTIPLIED BY the element at position repeatingLength of ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of the result of valueOf applied to s MINUS the result of valueOf applied to t LESS THAN one TIMES ten RAISED TO THE POWER OF negative nine  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-transforms-into-another-string", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF NOT (str1 NOT EQUALS str2)  \n            RETURN True  \n        END IF  \n        ASSIGN an empty dictionary TO trans_dict  \n        ASSIGN 0 TO idx  \n        WHILE idx LESS THAN LENGTH OF str1  \n            ASSIGN str1 AT idx TO key_char  \n            ASSIGN str2 AT idx TO val_char  \n            IF key_char EXISTS IN trans_dict  \n                IF trans_dict AT key_char NOT EQUALS val_char  \n                    RETURN False  \n                END IF  \n            ELSE  \n                ASSIGN val_char TO trans_dict AT key_char  \n            END IF  \n            INCREMENT idx BY 1  \n        END WHILE  \n        ASSIGN an empty set TO val_set  \n        FOR EACH k IN trans_dict KEYS  \n            ADD trans_dict AT k TO val_set  \n        END FOR  \n        IF LENGTH OF val_set GREATER THAN OR EQUAL TO 26  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 0.9361702127659575, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpyog3usum/solution_0.py\", line 35, in <module>\\n    print(Solution().canConvert(str1 = \"aabcc\", str2 = \"ccdee\"))\\n          ^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'canConvert\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION canConvert(str1 str2)  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO empty mapping  \n        FOR each pair of char1 AND char2 IN corresponding elements of str1 AND str2  \n            IF char1 IN keys of conversion_map  \n                IF value at key char1 of conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET value at key char1 of conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the LENGTH OF the set of all unique characters in str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-vowels-permutation", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION countVowelPermutation(n)\n        DEFINE CONSTANT MODULUS AS 1000000007\n        FUNCTION recurse(position, counts_map)\n            IF position EQUALS n + 1 THEN\n                RETURN (counts_map['a'] + counts_map['e'] + counts_map['i'] + counts_map['o'] + counts_map['u']) MOD MODULUS\n            END IF\n\n            DEFINE new_counts AS MAP FROM STRING TO INTEGER\n            SET new_counts['a'] TO (counts_map['e'] + counts_map['i'] + counts_map['u']) MOD MODULUS\n            SET new_counts['e'] TO (counts_map['a'] + counts_map['i']) MOD MODULUS\n            SET new_counts['i'] TO (counts_map['e'] + counts_map['o']) MOD MODULUS\n            SET new_counts['o'] TO counts_map['i'] MOD MODULUS\n            SET new_counts['u'] TO (counts_map['i'] + counts_map['o']) MOD MODULUS\n\n            RETURN recurse(position + 1, new_counts)\n        END FUNCTION\n\n        DEFINE initial_counts AS MAP FROM STRING TO INTEGER WITH ENTRIES {'a':1, 'e':1, 'i':1, 'o':1, 'u':1}\n        RETURN recurse(2, initial_counts)\n    END FUNCTION\nEND CLASS", "score": 0.8636363636363636, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpt2hpyvpy/solution_0.py\", line 52, in <module>\\n    print(Solution().countVowelPermutation(n = 1))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'countVowelPermutation\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION countVowelPermutation WITH PARAMETER n  \n        SET MOD TO ten RAISED TO THE POWER OF nine PLUS one  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each number FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder of a_next DIVIDED BY MOD  \n            SET e TO the remainder of e_next DIVIDED BY MOD  \n            SET i TO the remainder of i_next DIVIDED BY MOD  \n            SET o TO the remainder of o_next DIVIDED BY MOD  \n            SET u TO the remainder of u_next DIVIDED BY MOD  \n        END FOR  \n        SET result TO the remainder of a PLUS e PLUS i PLUS o PLUS u DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-multiple-of-three", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO a mapping of digit frequencies in digits  \n        SET total_sum TO the sum of all digits  \n        SET remainder TO the remainder of total_sum DIVIDED BY three  \n        \n        IF remainder EQUALS one  \n            FOR each digit d IN the list of digits one four seven  \n                IF the frequency of digit d in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit d in count BY one  \n                    BREAK out of the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list of digits two five eight  \n                    IF the frequency of digit d in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit d in count BY two  \n                        BREAK out of the loop  \n                    END IF  \n                END FOR  \n        END IF  \n        \n        IF remainder EQUALS two  \n            FOR each digit d IN the list of digits two five eight  \n                IF the frequency of digit d in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit d in count BY one  \n                    BREAK out of the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list of digits one four seven  \n                    IF the frequency of digit d in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit d in count BY two  \n                        BREAK out of the loop  \n                    END IF  \n                END FOR  \n        END IF  \n        \n        SET result TO an empty list  \n        FOR each digit d FROM nine DOWN TO zero  \n            SET string_of_digit TO the textual representation of digit d repeated the frequency of digit d in count times  \n            APPEND string_of_digit TO result  \n        END FOR  \n        \n        SET final_number TO the concatenation of all elements in result  \n        \n        IF final_number IS empty OR the first element of final_number EQUALS zero  \n            RETURN the string zero  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 0.9791666666666666, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpxl9whcmk/solution_0.py\", line 28, in <module>\\n    print(Solution().largestMultipleOfThree(digits = [8,1,9]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'largestMultipleOfThree\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO a mapping of digits to their frequencies  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder when total_sum is divided by three  \n        IF remainder EQUALS one  \n            FOR each digit IN the list containing one four seven  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing two five eight  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit IN the list containing two five eight  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing one four seven  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        SET result TO an empty list  \n        FOR digit FROM nine DOWN TO zero  \n            APPEND the string form of digit repeated frequency of digit in count times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF final_number IS NOT empty AND the element at position one of final_number EQUALS zero  \n            RETURN zero as string  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-cut-a-stick", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO the SORTED RESULT OF THE UNION OF cuts AND the LIST CONTAINING zero AND n  \n        \n        FUNCTION dp(left, right)  \n            IF the DIFFERENCE OF right MINUS left IS LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO positive infinity  \n            FOR index FROM left PLUS one TO right MINUS one  \n                SET cost TO the ELEMENT AT POSITION right OF cuts MINUS the ELEMENT AT POSITION left OF cuts PLUS the RESULT OF dp WITH PARAMETERS left AND index PLUS the RESULT OF dp WITH PARAMETERS index AND right  \n                IF cost IS LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN the RESULT OF dp WITH PARAMETERS zero AND the LENGTH OF cuts MINUS one  \nEND CLASS", "score": 0.9591836734693877, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpustwqyj5/solution_0.py\", line 89, in <module>\\n    print(Solution().minCost(n = 7, cuts = [1,3,4,5]))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'minCost\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO the sorted result of appending zero and n to cuts  \n        \n        FUNCTION dp(left, right)  \n            IF the result of right MINUS left is LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing infinity  \n            FOR i FROM the result of left PLUS one TO the result of right MINUS one  \n                SET cost TO the element at position right of cuts MINUS the element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost IS LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the result of the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-connect-two-groups-of-points", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION connectTwoGroups(cost)  \n        SET size1 TO the LENGTH OF cost  \n        SET size2 TO the LENGTH OF element at position zero of cost  \n        \n        INITIALIZE dp AS a list of size size1 PLUS one, where each element is a list of size two RAISED TO THE POWER OF size2, each initialized TO infinity  \n        \n        SET element at position zero of element at position zero of dp TO zero  \n        \n        FOR i FROM zero TO size1 MINUS one  \n            FOR mask FROM zero TO two RAISED TO THE POWER OF size2 MINUS one  \n                \n                FOR j FROM zero TO size2 MINUS one  \n                    SET index_mask_union TO mask OR two RAISED TO THE POWER OF j  \n                    SET element at position index_mask_union of element at position i PLUS one of dp TO the MINIMUM OF element at position index_mask_union of element at position i PLUS one of dp AND element at position mask of element at position i of dp PLUS element at position i of element at position j of cost  \n                END FOR  \n                \n                FOR j FROM zero TO size2 MINUS one  \n                    IF bitwise AND of mask AND two RAISED TO THE POWER OF j IS NOT EQUAL TO zero  \n                        SET element at position mask of element at position i PLUS one of dp TO the MINIMUM OF element at position mask of element at position i PLUS one of dp AND element at position bitwise XOR of mask AND two RAISED TO THE POWER OF j of element at position i PLUS one of dp PLUS element at position i of element at position j of cost  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position size1 of element at position two RAISED TO THE POWER OF size2 MINUS one of dp  \n    END FUNCTION  \nEND CLASS", "score": 0.8076923076923077, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpyv7k6jqr/solution_0.py\", line 59, in <module>\\n    print(Solution().connectTwoGroups(cost = [[15, 96], [36, 2]]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'connectTwoGroups\\'\\n']", "true_positive": "CLASS Solution\n    FUNCTION connectTwoGroups(cost)\n        SET size one TO the LENGTH OF cost\n        SET size two TO the LENGTH OF the element at position zero OF cost\n\n        SET dp_table TO a list of lists WHERE EACH inner list CONTAINS the INFINITY value REPEATED a number of times EQUAL TO TWO RAISED TO the POWER OF size two\n        AND the number of such lists IS size one PLUS one\n\n        SET the element at position zero OF the element at position zero OF dp_table TO zero\n\n        FOR index i FROM zero TO size one MINUS one INCLUSIVE\n            FOR index mask FROM zero TO TWO RAISED TO the POWER OF size two MINUS one INCLUSIVE\n                FOR index j FROM zero TO size two MINUS one INCLUSIVE\n                    SET dp_table at position i PLUS one at position mask OR TWO RAISED TO the POWER OF j TO the LESSER OF\n                        the current value at dp_table at position i PLUS one at position mask OR TWO RAISED TO the POWER OF j\n                        AND the sum of dp_table at position i at position mask PLUS the element at position i at position j OF cost\n                END FOR\n\n                FOR index j FROM zero TO size two MINUS one INCLUSIVE\n                    IF the bitwise AND of mask AND TWO RAISED TO the POWER OF j HOLDS TRUE\n                        SET dp_table at position i PLUS one at position mask TO the LESSER OF\n                            the current value at dp_table at position i PLUS one at position mask\n                            AND the sum of dp_table at position i PLUS one at position mask with the bitwise exclusive OR of mask AND TWO RAISED TO the POWER OF j PLUS the element at position i at position j OF cost\n                    END IF\n                END FOR\n            END FOR\n        END FOR\n\n        RETURN the element at position size one at position TWO RAISED TO the POWER OF size two MINUS one OF dp_table\n    END FUNCTION\nEND CLASS"}
{"task_id": "minimum-incompatibility", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET integer_n TO the LENGTH OF nums  \n        SET integer_subset_size TO integer_n DIVIDED BY k  \n        \n        FUNCTION all_numbers_appear_no_more_than_k_times(list_of_numbers max_count)  \n            CREATE a COUNTER_OBJECT FOR list_of_numbers  \n            FOR each count_value IN the VALUES OF the COUNTER_OBJECT  \n                IF count_value GREATER THAN max_count  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        IF all_numbers_appear_no_more_than_k_times(nums k) IS false  \n            RETURN negative one  \n        END IF  \n        \n        CREATE empty MAPPING subset_incompatibility WITH KEYS AS integer MASKS AND VALUES AS integer INCOMPATIBILITY  \n        \n        FUNCTION count_number_of_set_bits_in_integer(integer_value)  \n            SET bit_count TO zero  \n            SET working_value TO integer_value  \n            WHILE working_value GREATER THAN zero  \n                SET bit_count TO bit_count PLUS (working_value MODULO two)  \n                SET working_value TO working_value DIVIDED BY two  \n            END WHILE  \n            RETURN bit_count  \n        END FUNCTION  \n        \n        SET total_mask_limit TO two POWERED BY integer_n  \n        \n        FOR mask FROM zero TO total_mask_limit MINUS one  \n            IF count_number_of_set_bits_in_integer(mask) EQUALS integer_subset_size  \n                CREATE empty LIST current_elements  \n                FOR index FROM zero TO integer_n MINUS one  \n                    IF the bit at position index OF mask IS one  \n                        APPEND the element at position index OF nums TO current_elements  \n                    END IF  \n                END FOR  \n                FUNCTION all_elements_unique(list_of_elements)  \n                    SET unique_elements_count TO the LENGTH OF the SET OF list_of_elements  \n                    SET elements_count TO the LENGTH OF list_of_elements  \n                    RETURN unique_elements_count EQUALS elements_count  \n                END FUNCTION  \n                IF all_elements_unique(current_elements)  \n                    SET maximum_element TO the maximum VALUE IN current_elements  \n                    SET minimum_element TO the minimum VALUE IN current_elements  \n                    SET incompatibility_value TO maximum_element MINUS minimum_element  \n                    ASSIGN incompatibility_value TO subset_incompatibility AT KEY mask  \n                END IF  \n            END IF  \n        END FOR  \n        \n        CREATE LIST dp OF SIZE total_mask_limit WITH EVERY ELEMENT INITIALIZED TO positive infinity  \n        SET the element at position zero OF dp TO zero  \n        \n        FUNCTION minimum_of_two_numbers(first_number second_number)  \n            IF first_number LESS THAN second_number  \n                RETURN first_number  \n            ELSE  \n                RETURN second_number  \n            END IF  \n        END FUNCTION  \n        \n        FOR mask FROM zero TO total_mask_limit MINUS one  \n            IF (count_number_of_set_bits_in_integer(mask) MODULO integer_subset_size) NOT EQUAL TO zero  \n                CONTINUE TO NEXT ITERATION  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                FUNCTION is_subset(subset main_set)  \n                    RETURN (subset BITWISE_AND main_set) EQUALS subset  \n                END FUNCTION  \n                IF is_subset(subset_mask mask)  \n                    SET candidate_value TO dp AT POSITION (mask BITWISE_EXCLUSIVE_OR subset_mask) PLUS subset_incompatibility AT KEY subset_mask  \n                    SET dp AT POSITION mask TO minimum_of_two_numbers(dp AT POSITION mask candidate_value)  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET final_mask TO total_mask_limit MINUS one  \n        IF dp AT POSITION final_mask NOT EQUAL TO positive infinity  \n            RETURN dp AT POSITION final_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 0.9523809523809523, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpou3vkwg0/solution_0.py\", line 46, in <module>\\n    print(Solution().minimumIncompatibility(nums = [1,2,1,4], k = 2))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'minimumIncompatibility\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        \n        IF there EXISTS a count of any number in nums WHERE the count GREATER THAN k  \n            RETURN negative one  \n        END IF  \n        \n        SET subset_incompatibility TO an empty mapping  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF bit_count EQUALS subset_size  \n                SET elements TO an empty list  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BIT AT position i OF mask EQUALS one  \n                        APPEND the element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                \n                IF the NUMBER OF UNIQUE elements IN elements EQUALS subset_size  \n                    SET incompatibility TO the MAXIMUM OF elements MINUS the MINIMUM OF elements  \n                    ASSIGN incompatibility TO the ENTRY of mask IN subset_incompatibility  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET dp TO a list of LENGTH two RAISED TO THE POWER OF n FILLED WITH positive infinity  \n        SET the ELEMENT AT position zero OF dp TO zero  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF the REMAINDER of bit_count DIVIDED BY subset_size NOT EQUAL TO zero  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BINARY AND OF mask AND subset_mask EQUALS subset_mask  \n                    SET dp AT position mask TO the MINIMUM OF the CURRENT dp AT position mask AND the dp AT position of the BINARY XOR OF mask AND subset_mask PLUS the VALUE of subset_mask IN subset_incompatibility  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET full_mask TO two RAISED TO THE POWER OF n MINUS one  \n        IF the ELEMENT AT position full_mask OF dp NOT EQUAL TO positive infinity  \n            RETURN the ELEMENT AT position full_mask OF dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-special-evenly-spaced-elements-in-array", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION solve(nums, queries)\n        SET MOD TO ten raised to the power of nine PLUS one\n        SET n TO the LENGTH OF nums\n\n        SET max_y TO the maximum y VALUE FROM each pair IN queries\n\n        SET prefix_sums TO a list CONTAINING max_y PLUS one ELEMENTS EACH BEING a list OF zeroes OF LENGTH n\n\n        FOR y FROM one TO max_y INCLUSIVE\n            FOR i FROM n MINUS one DOWN TO zero INCLUSIVE\n                IF i PLUS y LESS THAN n THEN\n                    SET element at position i OF element at position y OF prefix_sums TO element at position i OF nums PLUS element at position i PLUS y OF element at position y OF prefix_sums\n                ELSE\n                    SET element at position i OF element at position y OF prefix_sums TO element at position i OF nums\n                END IF\n            END FOR\n        END FOR\n\n        SET answer TO an empty list\n\n        FOR each pair x AND y IN queries\n            APPEND the remainder AFTER DIVIDING element at position x OF element at position y OF prefix_sums BY MOD TO answer\n        END FOR\n\n        RETURN answer\n    END FUNCTION\nEND CLASS", "score": 0.9333333333333333, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpag9tti4d/solution_0.py\", line 44, in <module>\\n    print(Solution().solve(nums = [0,1,2,3,4,5,6,7], queries = [[0,3],[5,1],[4,2]]))\\n          ^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'solve\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION solve(nums parameters LIST OF INTEGER, queries parameters LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF nums  \n        SET max_y TO the MAXIMUM VALUE OF the second element in each pair OF queries  \n        INITIALIZE prefix_sums AS a LIST containing max_y PLUS one ELEMENTS each being a LIST of zeroes with LENGTH n  \n        FOR y FROM one TO max_y  \n            FOR i FROM n MINUS one DOWN TO zero  \n                IF i PLUS y LESS THAN n THEN  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums PLUS element at position i PLUS y of prefix_sums at position y  \n                ELSE  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums  \n                END IF  \n            END FOR  \n        END FOR  \n        INITIALIZE answer AS an empty LIST  \n        FOR each pair x and y IN queries  \n            APPEND to answer the element at position x of prefix_sums at position y MODULO MOD  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse-ii", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION canMouseWin(grid, catJump, mouseJump)\n        SET m TO LENGTH OF grid\n        SET n TO LENGTH OF grid[0]\n        SET cat_start TO 0\n        SET mouse_start TO 0\n        SET food TO 0\n        SET dirs TO (-1, 0, 1, 0, -1)\n        SET g_mouse TO LIST OF EMPTY LISTS OF SIZE m * n\n        SET g_cat TO LIST OF EMPTY LISTS OF SIZE m * n\n\n        FOR i FROM 0 TO m - 1\n            FOR j FROM 0 TO n - 1\n                IF grid[i][j] IS \"#\"\n                    CONTINUE\n                SET v TO i * n + j\n                IF grid[i][j] IS \"C\"\n                    SET cat_start TO v\n                ELSE IF grid[i][j] IS \"M\"\n                    SET mouse_start TO v\n                ELSE IF grid[i][j] IS \"F\"\n                    SET food TO v\n                FOR a, b IN PAIRWISE(dirs)\n                    FOR k FROM 0 TO mouseJump\n                        SET x TO i + k * a\n                        SET y TO j + k * b\n                        IF x NOT IN [0, m - 1] OR y NOT IN [0, n - 1] OR grid[x][y] IS \"#\"\n                            BREAK\n                        APPEND x * n + y TO g_mouse[v]\n                    FOR k FROM 0 TO catJump\n                        SET x TO i + k * a\n                        SET y TO j + k * b\n                        IF x NOT IN [0, m - 1] OR y NOT IN [0, n - 1] OR grid[x][y] IS \"#\"\n                            BREAK\n                        APPEND x * n + y TO g_cat[v]\n\n        RETURN self.calc(g_mouse, g_cat, mouse_start, cat_start, food) EQUALS 1\n    END FUNCTION\n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)\n        FUNCTION get_prev_states(state)\n            SET m, c, t TO state\n            SET pt TO t XOR 1\n            SET pre TO EMPTY LIST\n            IF pt EQUALS 1\n                FOR pc IN g_cat[c]\n                    IF ans[m][pc][1] EQUALS 0\n                        APPEND (m, pc, pt) TO pre\n            ELSE\n                FOR pm IN g_mouse[m]\n                    IF ans[pm][c][0] EQUALS 0\n                        APPEND (pm, c, 0) TO pre\n            RETURN pre\n        END FUNCTION\n\n        SET n TO LENGTH OF g_mouse\n        SET degree TO THREE-DIMENSIONAL LIST OF SIZE [n][n][2] FILLED WITH ZEROS\n        FOR i FROM 0 TO n - 1\n            FOR j FROM 0 TO n - 1\n                SET degree[i][j][0] TO LENGTH OF g_mouse[i]\n                SET degree[i][j][1] TO LENGTH OF g_cat[j]\n\n        SET ans TO THREE-DIMENSIONAL LIST OF SIZE [n][n][2] FILLED WITH ZEROS\n        SET q TO EMPTY QUEUE\n        FOR i FROM 0 TO n - 1\n            SET ans[hole][i][1] TO 1\n            SET ans[i][hole][0] TO 2\n            SET ans[i][i][1] TO 2\n            SET ans[i][i][0] TO 2\n            ENQUEUE (hole, i, 1) TO q\n            ENQUEUE (i, hole, 0) TO q\n            ENQUEUE (i, i, 0) TO q\n            ENQUEUE (i, i, 1) TO q\n\n        WHILE q IS NOT EMPTY\n            SET state TO DEQUEUE FROM q\n            SET t TO ans[state[0]][state[1]][state[2]]\n            FOR prev_state IN get_prev_states(state)\n                SET pm, pc, pt TO prev_state\n                IF pt EQUALS t - 1\n                    SET ans[pm][pc][pt] TO t\n                    ENQUEUE prev_state TO q\n                ELSE\n                    DECREMENT degree[pm][pc][pt] BY 1\n                    IF degree[pm][pc][pt] EQUALS 0\n                        SET ans[pm][pc][pt] TO t\n                        ENQUEUE prev_state TO q\n\n        RETURN ans[mouse_start][cat_start][0]\n    END FUNCTION\nEND CLASS", "score": 0.9777777777777777, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpzs5gd21q/solution_0.py\", line 58, in <module>\\n    print(Solution().canMouseWin(grid = [\"........\",\".F......\",\"#.......\",\"C.......\",\"M.......\"], catJump = 1, mouseJump = 2))\\n          ^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'canMouseWin\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the sequence of negative one zero one zero negative one  \n        SET g_mouse TO a list containing m MULTIPLIED BY n empty lists  \n        SET g_cat TO a list containing m MULTIPLIED BY n empty lists  \n        FOR each pair of index i AND element row IN grid WITH enumeration  \n            FOR each pair of index j AND element c IN row WITH enumeration  \n                IF c EQUALS the character hash  \n                    CONTINUE to next iteration  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character F  \n                    SET food TO v  \n                END IF  \n                FOR each pair of consecutive elements a AND b IN dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the result of the FUNCTION calc WITH parameters g_mouse g_cat mouse_start cat_start food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            DECOMPOSE state INTO m c t  \n            SET pt TO t XOR one  \n            SET pre TO empty list  \n            IF pt EQUALS one  \n                FOR each pc IN the element at position c of g_cat  \n                    IF the element at position m THEN at position pc THEN at position one OF ans EQUALS zero  \n                        APPEND the tuple m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN the element at position m of g_mouse  \n                    IF the element at position pm THEN at position c THEN at position zero OF ans EQUALS zero  \n                        APPEND the tuple pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a three dimensional list of zeros with dimensions n by n by two  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET the element at position zero of the element at position j of the element at position i of degree TO the LENGTH OF the element at position i of g_mouse  \n                SET the element at position one of the element at position j of the element at position i of degree TO the LENGTH OF the element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a three dimensional list of zeros with dimensions n by n by two  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET the element at position one of the element at position i of the element at position hole of ans TO one  \n            SET the element at position zero of the element at position hole of the element at position i of ans TO two  \n            SET the element at position one of the element at position i of the element at position i of ans TO two  \n            SET the element at position zero of the element at position i of the element at position i of ans TO two  \n            APPEND the tuple hole i one TO q  \n            APPEND the tuple i hole zero TO q  \n            APPEND the tuple i i zero TO q  \n            APPEND the tuple i i one TO q  \n        END FOR  \n\n        WHILE q is not empty  \n            SET state TO the element removed from the left of q  \n            SET t TO the element at position two OF ans at dimension positions state at zero state at one state at two  \n            FOR each prev_state IN the result of calling get_prev_states WITH state  \n                DECOMPOSE prev_state INTO pm pc pt  \n                IF pt EQUALS t MINUS one  \n                    SET the element at position pt OF ans at dimension positions pm pc TO t  \n                    APPEND prev_state TO q  \n                ELSE  \n                    DECREMENT the element at position pt OF degree at dimension positions pm pc BY one  \n                    IF the element at position pt OF degree at dimension positions pm pc EQUALS zero  \n                        SET the element at position pt OF ans at dimension positions pm pc TO t  \n                        APPEND prev_state TO q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the element at position zero OF ans at dimension positions mouse_start cat_start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-floored-pairs", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION sumOfFlooredPairs(nums)\n        SET MOD TO 1000000000 + 1\n        SET max_val TO -1\n        SET freq_map TO empty mapping\n        SET idx1 TO 0\n\n        WHILE idx1 < LENGTH(nums)\n            SET val TO nums[idx1]\n            IF val > max_val THEN\n                SET max_val TO val\n            END IF\n            IF freq_map CONTAINS KEY val THEN\n                SET freq_map[val] TO freq_map[val] + 1\n            ELSE\n                SET freq_map[val] TO 1\n            END IF\n            SET idx1 TO idx1 + 1\n        END WHILE\n\n        SET prefix_arr TO list of zeros with length max_val + 1\n\n        SET keys_list TO empty list\n        FOR key IN freq_map\n            APPEND key TO keys_list\n        END FOR\n\n        SET idx2 TO 0\n        WHILE idx2 < LENGTH(keys_list)\n            SET k TO keys_list[idx2]\n            SET prefix_arr[k] TO prefix_arr[k] + freq_map[k]\n            SET idx2 TO idx2 + 1\n        END WHILE\n\n        SET curr_idx TO 1\n        FUNCTION buildPrefix(ps, mx, ci)\n            IF ci > mx THEN RETURN END IF\n            SET ps[ci] TO ps[ci] + ps[ci - 1]\n            CALL buildPrefix(ps, mx, ci + 1)\n        END FUNCTION\n        CALL buildPrefix(prefix_arr, max_val, curr_idx)\n\n        SET result_acc TO 0\n\n        FUNCTION processNum(num_list, pos)\n            IF pos >= LENGTH(num_list) THEN RETURN END IF\n            SET curr_num TO num_list[pos]\n            SET multiple_count TO max_val DIV curr_num\n\n            FUNCTION processMultiple(mul, max_m, n)\n                IF mul > max_m THEN RETURN END IF\n                SET start_pos TO n * mul\n                SET end_pos TO 0\n                IF n * (mul + 1) - 1 <= max_val THEN\n                    SET end_pos TO n * (mul + 1) - 1\n                ELSE\n                    SET end_pos TO max_val\n                END IF\n                SET count_sub TO prefix_arr[end_pos] - prefix_arr[start_pos - 1]\n                SET result_delta TO count_sub * mul * freq_map[n]\n                SET nonlocal result_acc TO (result_acc + result_delta) MOD MOD\n                CALL processMultiple(mul + 1, max_m, n)\n            END FUNCTION\n\n            CALL processMultiple(1, multiple_count, curr_num)\n            CALL processNum(num_list, pos + 1)\n        END FUNCTION\n\n        CALL processNum(keys_list, 0)\n\n        RETURN result_acc\n    END FUNCTION\nEND CLASS", "score": 0.8095238095238095, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmph5q8yefi/solution_0.py\", line 44, in <module>\\n    print(Solution().sumOfFlooredPairs(nums = [2,5,9]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'sumOfFlooredPairs\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO one billion PLUS seven  \n        SET max_num TO the maximum value IN nums  \n        SET count TO a mapping of each unique element IN nums TO its frequency  \n        SET prefix_sum TO a list of zeros WITH length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num IN count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the division of max_num BY num rounded down to nearest integer  \n                SET start TO num MULTIPLIED BY multiple  \n                SET end TO the smaller value BETWEEN num MULTIPLIED BY the sum of multiple PLUS one MINUS one AND max_num  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num IN count  \n                SET result TO the remainder of result DIVIDED BY MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-of-one-repeating-character", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION longestRepeating WITH PARAMETERS s AND queryCharacters AND queryIndices  \n        FUNCTION merge_intervals  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one HOLDS  \n                IF character at position two of tuple at position i of intervals EQUALS character at position two of tuple at position i PLUS one of intervals  \n                    SET tuple at position i of intervals TO a tuple CONSISTING OF start FROM tuple at position i OF intervals AND end FROM tuple at position i PLUS one OF intervals AND character FROM tuple at position i OF intervals  \n                    REMOVE element at position i PLUS one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n\n        SET intervals TO empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n\n        FOR i FROM one TO n MINUS one  \n            IF character at position i OF string s NOT EQUALS character at position start OF string s  \n                APPEND a tuple CONSISTING OF start AND i MINUS one AND character at position start OF string s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n\n        APPEND a tuple CONSISTING OF start AND n MINUS one AND character at position start OF string s TO intervals  \n        SET results TO empty list  \n        SET longest TO the GREATEST VALUE OF end MINUS start PLUS one FOR each tuple CONSISTING OF start AND end AND character IN intervals  \n\n        FOR each pair of char FROM queryCharacters AND idx FROM queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals HOLDS  \n                SET start TO the first element OF tuple at position i OF intervals  \n                SET end TO the second element OF tuple at position i OF intervals  \n                SET c TO the third element OF tuple at position i OF intervals  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK THE LOOP  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n\n            IF idx GREATER THAN start  \n                INSERT a tuple CONSISTING OF start AND idx MINUS one AND c INTO intervals AT POSITION i  \n                SET tuple at position i PLUS one OF intervals TO a tuple CONSISTING OF idx AND end AND c  \n            END IF  \n\n            IF idx LESS THAN end  \n                INSERT a tuple CONSISTING OF idx PLUS one AND end AND c INTO intervals AT POSITION i PLUS one  \n                SET tuple at position i OF intervals TO a tuple CONSISTING OF start AND idx AND c  \n            END IF  \n\n            SET tuple at position i OF intervals TO a tuple CONSISTING OF first element OF tuple at position i OF intervals AND second element OF tuple at position i OF intervals AND char  \n            CALL merge_intervals  \n            SET longest TO the GREATEST VALUE OF end MINUS start PLUS one FOR each tuple CONSISTING OF start AND end AND character IN intervals  \n            APPEND longest TO results  \n        END FOR  \n\n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 0.85, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpwtarut8x/solution_0.py\", line 77, in <module>\\n    print(Solution().longestRepeating(s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'longestRepeating\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION longestRepeating(s, queryCharacters, queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF element at position i of intervals at position two EQUALS element at position i plus one of intervals at position two  \n                    SET element at position i of intervals TO a tuple with first element as element at position i of intervals at position zero second element as element at position i plus one of intervals at position one third element as element at position i of intervals at position two  \n                    REMOVE element at position i plus one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n      \n        SET intervals TO empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple with first element start second element i MINUS one third element element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple with first element start second element n MINUS one third element element at position start of s TO intervals  \n      \n        SET results TO empty list  \n        SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n      \n        FOR each pair of char and idx in the parallel elements of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start TO element at position i of intervals at position zero  \n                SET end TO element at position i of intervals at position one  \n                SET c TO element at position i of intervals at position two  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK the loop  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n      \n            IF idx GREATER THAN start  \n                INSERT at position i a tuple with first element start second element idx MINUS one third element c INTO intervals  \n                SET element at position i plus one of intervals TO a tuple with first element idx second element end third element c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT at position i plus one a tuple with first element idx PLUS one second element end third element c INTO intervals  \n                SET element at position i of intervals TO a tuple with first element start second element idx third element c  \n            END IF  \n      \n            SET element at position i of intervals TO a tuple with first element element at position i of intervals at position zero second element element at position i of intervals at position one third element char  \n      \n            CALL merge_intervals()  \n      \n            SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n            APPEND longest TO results  \n        END FOR  \n      \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-number", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        IMPORT module named re  \n        SET pattern TO string describing the start of string followed by an optional plus or minus sign followed by either one or more digits optionally followed by a decimal point and zero or more digits or a decimal point followed by one or more digits followed optionally by an exponent part consisting of the letter e followed by an optional plus or minus sign followed by one or more digits followed by end of string  \n        RETURN the result of matching the entire string s against pattern using full match method does not equal none  \n    END FUNCTION  \nEND CLASS", "score": 0.9629629629629629, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpwvkhofl3/solution_0.py\", line 65, in <module>\\n    print(Solution().isNumber(s = \"0\"))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isNumber\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        RETURN the RESULT OF matching the ENTIRE string s AGAINST the REGULAR expression representing optional plus or minus SIGN followed BY either one or more digits FOLLOWED BY an optional decimal POINT FOLLOWED BY zero or more digits OR a decimal POINT FOLLOWED BY one or more digits FOLLOWED optionally BY the letter e FOLLOWED optionally BY plus or minus SIGN FOLLOWED BY one or more digits IS NOT EQUAL TO no match  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n\n        FOR each element e IN expression  \n            IF element e EQUALS open parenthesis OR element e EQUALS ampersand OR element e EQUALS vertical bar  \n                APPEND pair of element e AND zero TO stack  \n                CONTINUE to next iteration  \n            END IF  \n            IF element e EQUALS close parenthesis  \n                SET lastPair TO the last element removed FROM stack  \n                REMOVE last element FROM stack  \n            ELSE  \n                SET lastPair TO pair of element e AND one  \n            END IF  \n            IF stack is not empty AND the first element of the last element in stack EQUALS ampersand OR vertical bar  \n                SET op TO the first element removed FROM last element in stack  \n                SET a TO the first element removed FROM last element in stack  \n                SET costA TO the second element removed FROM last element in stack  \n                SET b TO the first element in lastPair  \n                SET costB TO the second element in lastPair  \n                IF op EQUALS ampersand  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO pair of zero AND one PLUS the lesser of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO pair of zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO pair of zero AND one  \n                    ELSE  \n                        SET lastPair TO pair of one AND the lesser of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO pair of zero AND the lesser of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO pair of one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO pair of one AND one  \n                    ELSE  \n                        SET lastPair TO pair of one AND one PLUS the lesser of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n\n        RETURN the second element of the last element in stack  \n    END FUNCTION  \nEND CLASS", "score": 0.875, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmptn7trk0g/solution_0.py\", line 48, in <module>\\n    print(Solution().minOperationsToFlip(expression = \"(1|0)&(0|1)\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'minOperationsToFlip\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS one of open parenthesis AND sign AND vertical bar  \n                APPEND a pair of element e AND zero TO stack  \n                CONTINUE to next iteration  \n            ELSE IF element e EQUALS closing parenthesis  \n                SET lastPair TO the last element REMOVED FROM stack  \n                REMOVE the last element FROM stack  \n            ELSE  \n                SET lastPair TO a pair of element e AND one  \n            END IF  \n            IF stack is not empty AND the last element in stack AT position zero EQUALS one of sign AND vertical bar  \n                SET op TO the last element AT position zero REMOVED FROM stack  \n                SET a AND costA TO the last pair REMOVED FROM stack  \n                SET b AND costB TO lastPair  \n                IF op EQUALS sign  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND one INCREMENTED BY the minimum of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a pair of zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND one  \n                    ELSE  \n                        SET lastPair TO a pair of one AND the minimum of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND the minimum of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a pair of one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a pair of one AND one  \n                    ELSE  \n                        SET lastPair TO a pair of one AND one INCREMENTED BY the minimum of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last element in stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands-ii", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero of grid OR element at position x of grid at position y EQUALS zero  \n                RETURN  \n            END IF  \n            SET element at position x of grid at position y TO zero  \n            APPEND pair of x AND y TO island  \n            CALL dfs WITH x PLUS one AND y AND island  \n            CALL dfs WITH x MINUS one AND y AND island  \n            CALL dfs WITH x AND y PLUS one AND island  \n            CALL dfs WITH x AND y MINUS one AND island  \n        END FUNCTION  \n\n        FUNCTION normalize(island)  \n            SET shapes TO empty list  \n            FOR each pair dx AND dy IN list of pairs ONE AND ONE AND ONE AND MINUS ONE AND MINUS ONE AND ONE AND MINUS ONE AND MINUS ONE  \n                SET new_island TO empty list  \n                FOR each pair x AND y IN island  \n                    APPEND pair of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island  \n                END FOR  \n                SORT new_island IN ascending order  \n                SET min_x TO the minimum x value among pairs in new_island  \n                SET min_y TO the minimum y value among pairs in new_island  \n                APPEND tuple of pairs where each pair is x MINUS min_x AND y MINUS min_y IN new_island TO shapes  \n            END FOR  \n            FOR i FROM zero TO the LENGTH OF shapes MINUS one  \n                APPEND tuple of pairs where each pair is y AND MINUS x FROM pairs in element at position i of shapes TO shapes  \n            END FOR  \n            RETURN the minimum element in shapes according to ordering  \n        END FUNCTION  \n\n        SET islands TO empty set  \n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET island TO empty list  \n                    CALL dfs WITH i AND j AND island  \n                    ADD the result of normalize called with island TO islands  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the LENGTH OF islands  \n    END FUNCTION  \nEND CLASS", "score": 0.9795918367346939, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpne_0ubz_/solution_0.py\", line 73, in <module>\\n    print(Solution().numDistinctIslands2(grid = [[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'numDistinctIslands2\\'\\n']", "true_positive": "CLASS Solution\n    FUNCTION numDistinctIslands2(grid)\n        FUNCTION dfs(x, y, island)\n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero OF grid OR element at position x OF grid AT position y EQUALS zero\n                RETURN\n            END IF\n            SET element at position x OF grid AT position y TO zero\n            APPEND tuple of x AND y TO island\n            CALL dfs WITH x PLUS one, y, AND island\n            CALL dfs WITH x MINUS one, y, AND island\n            CALL dfs WITH x, y PLUS one, AND island\n            CALL dfs WITH x, y MINUS one, AND island\n        END FUNCTION\n\n        FUNCTION normalize(island)\n            SET shapes TO empty list\n            FOR each pair dx AND dy IN list of pairs consisting of one and one, one and negative one, negative one and one, negative one and negative one\n                SET new_island TO empty list\n                FOR each pair x AND y IN island\n                    APPEND tuple of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island\n                END FOR\n                SORT new_island IN ascending order\n                SET min_x TO the minimum x value FOR all pairs x AND y IN new_island\n                SET min_y TO the minimum y value FOR all pairs x AND y IN new_island\n                APPEND tuple of pairs where each pair is x MINUS min_x AND y MINUS min_y FOR each pair x AND y IN new_island TO shapes\n            END FOR\n            FOR index i FROM zero TO the LENGTH OF shapes MINUS one INCLUSIVE\n                APPEND tuple of pairs where each pair is y AND negative x FOR each pair x AND y IN element at position i OF shapes TO shapes\n            END FOR\n            RETURN the minimum element IN shapes\n        END FUNCTION\n\n        SET islands TO empty set\n        FOR index i FROM zero TO the LENGTH OF grid MINUS one INCLUSIVE\n            FOR index j FROM zero TO the LENGTH OF element at position zero OF grid MINUS one INCLUSIVE\n                IF element at position i OF grid AT position j EQUALS one\n                    SET island TO empty list\n                    CALL dfs WITH i, j, AND island\n                    ADD normalize(island) TO islands\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the LENGTH OF islands\n    END FUNCTION\nEND CLASS"}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(i j diff)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i of balls PLUS one MINUS one  \n                IF x EQUALS element at position i of balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO negative one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS result of dfs with arguments i PLUS one j MINUS x diff PLUS y MULTIPLIED BY combination of element at position i of balls AND x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n\n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO length of balls  \n        RETURN result of dfs with arguments zero n zero DIVIDED BY combination of n MULTIPLIED BY two AND n  \n    END FUNCTION  \nEND CLASS", "score": 0.9354838709677419, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpl35ey27p/solution_0.py\", line 86, in <module>\\n    print(Solution().getProbability(balls = [1,1]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'getProbability\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION getProbability WITH PARAMETER balls  \n        FUNCTION dfs WITH PARAMETERS i, j, diff  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i OF balls INCLUSIVE  \n                IF x EQUALS element at position i OF balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO negative one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS dfs WITH ARGUMENTS i PLUS one, j MINUS x, diff PLUS y MULTIPLIED BY combination of element at position i OF balls AND x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO length of balls  \n        RETURN dfs WITH ARGUMENTS zero, n, zero DIVIDED BY combination of n MULTIPLIED BY two AND n  \n    END FUNCTION  \nEND CLASS"}
