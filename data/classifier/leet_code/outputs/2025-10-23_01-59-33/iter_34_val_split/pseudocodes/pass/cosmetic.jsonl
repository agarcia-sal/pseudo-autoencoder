{"task_id": "majority-element-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        ASSIGN 0 TO countA  \n        ASSIGN 0 TO countB  \n        ASSIGN 0 TO candidateA  \n        ASSIGN 1 TO candidateB  \n        ASSIGN 0 TO idx  \n        WHILE idx LESS THAN LENGTH OF nums DO  \n            ASSIGN nums[idx] TO currentItem  \n            IF currentItem EQUALS candidateA THEN  \n                countA ← countA + 1  \n            ELSE IF currentItem EQUALS candidateB THEN  \n                countB ← countB + 1  \n            ELSE  \n                IF NOT (countA NOT EQUAL TO 0) THEN  \n                    candidateA ← currentItem  \n                    countA ← 1  \n                ELSE IF countB EQUALS 0 THEN  \n                    candidateB ← currentItem  \n                    countB ← 1  \n                ELSE  \n                    countA ← countA - 1  \n                    countB ← countB - 1  \n                END IF  \n            END IF  \n            idx ← idx + 1  \n        END WHILE  \n        ASSIGN emptyList TO resultList  \n        ASSIGN LENGTH OF nums DIVIDED BY 3 TO threshold  \n        ASSIGN 0 TO resultIndex  \n        WHILE resultIndex LESS THAN 2 DO  \n            ASSIGN (candidateA, candidateB)[resultIndex] TO tempCandidate  \n            ASSIGN 0 TO tally  \n            ASSIGN 0 TO scanIndex  \n            WHILE scanIndex LESS THAN LENGTH OF nums DO  \n                IF nums[scanIndex] EQUALS tempCandidate THEN  \n                    tally ← tally + 1  \n                END IF  \n                scanIndex ← scanIndex + 1  \n            END WHILE  \n            IF tally GREATER THAN threshold THEN  \n                APPEND tempCandidate TO resultList  \n            END IF  \n            resultIndex ← resultIndex + 1  \n        END WHILE  \n        RETURN resultList  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each m IN nums  \n            IF m EQUALS m1  \n                INCREMENT n1 BY one  \n            ELSE IF m EQUALS m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements FROM the list containing m1 AND m2 WHERE the count of element IN nums GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        ASSIGN (amount + 1) TO limitValue  \n        INITIALIZE dpList AS array OF size limitValue FILLED WITH limitValue  \n        SET dpList[0] TO 0  \n        INITIALIZE indexA TO 1  \n        WHILE indexA <= amount DO  \n            INITIALIZE idxCoin TO 0  \n            WHILE idxCoin < LENGTH(coins) DO  \n                ASSIGN (indexA - coins[idxCoin]) TO diffVal  \n                IF NOT (diffVal < 0) THEN  \n                    ASSIGN MIN(dpList[indexA], dpList[diffVal] + 1) TO dpList[indexA]  \n                END IF  \n                INCREMENT idxCoin BY 1  \n            END WHILE  \n            INCREMENT indexA BY 1  \n        END WHILE  \n        IF dpList[amount] != limitValue THEN   \n            RETURN dpList[amount]  \n        END IF  \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION coinChange(coins AS list of integers, amount AS integer) RETURNS integer  \n        SET dp TO a list with the length of amount PLUS one where each element is amount PLUS one  \n        SET element at position zero of dp TO zero  \n        \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET element at position a of dp TO the smaller value BETWEEN element at position a of dp AND element at position a MINUS coin of dp PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF element at position amount of dp IS NOT EQUALS TO amount PLUS one  \n            RETURN element at position amount of dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        ASSIGN a dictionary of character counts in s TO freqMap  \n        ASSIGN a list with ten zeros TO numCounts  // indices 0 through 9  \n        \n        ASSIGN freqMap['z'] OR 0 TO numCounts[0]  \n        ASSIGN freqMap['w'] OR 0 TO numCounts[2]  \n        ASSIGN freqMap['u'] OR 0 TO numCounts[4]  \n        ASSIGN freqMap['x'] OR 0 TO numCounts[6]  \n        ASSIGN freqMap['g'] OR 0 TO numCounts[8]  \n        \n        ASSIGN (freqMap['h'] OR 0) - numCounts[8] TO numCounts[3]  \n        ASSIGN (freqMap['f'] OR 0) - numCounts[4] TO numCounts[5]  \n        ASSIGN (freqMap['s'] OR 0) - numCounts[6] TO numCounts[7]  \n        \n        ASSIGN (freqMap['i'] OR 0) - numCounts[5] - numCounts[6] - numCounts[8] TO numCounts[9]  \n        ASSIGN (freqMap['o'] OR 0) - numCounts[0] - numCounts[2] - numCounts[4] TO numCounts[1]  \n        \n        ASSIGN an empty list TO outputList  \n        \n        ASSIGN 0 TO outerIdx  \n        WHILE outerIdx < 10 DO  \n            ASSIGN 0 TO innerIdx  \n            WHILE innerIdx < numCounts[outerIdx] DO  \n                ADD string version of outerIdx TO outputList END_STATEMENT  \n                ASSIGN innerIdx + 1 TO innerIdx  \n            END WHILE  \n            ASSIGN outerIdx + 1 TO outerIdx  \n        END WHILE  \n        \n        ASSIGN concatenation of all strings in outputList TO resultString  \n        RETURN resultString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO mapping of character frequencies in s  \n        SET digits TO list of zero FOR each position FROM zero TO nine  \n        SET digit at position zero TO the frequency of character z in count  \n        SET digit at position two TO the frequency of character w in count  \n        SET digit at position four TO the frequency of character u in count  \n        SET digit at position six TO the frequency of character x in count  \n        SET digit at position eight TO the frequency of character g in count  \n        SET digit at position three TO the frequency of character h in count MINUS digit at position eight  \n        SET digit at position five TO the frequency of character f in count MINUS digit at position four  \n        SET digit at position seven TO the frequency of character s in count MINUS digit at position six  \n        SET digit at position nine TO the frequency of character i in count MINUS digit at position five MINUS digit at position six MINUS digit at position eight  \n        SET digit at position one TO the frequency of character o in count MINUS digit at position zero MINUS digit at position two MINUS digit at position four  \n        SET result TO empty list  \n        FOR index FROM zero TO nine  \n            FOR count_index FROM one TO digit at position index  \n                APPEND index converted to string TO result  \n            END FOR  \n        END FOR  \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-closest-palindrome", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION nearestPalindromic(n)\n        ASSIGN LENGTH(n) TO lenVal\n        IF NOT (lenVal - 1) THEN\n            ASSIGN TO numVal THE CONVERSION OF n TO INTEGER\n            RETURN CONVERT numVal - 1 TO STRING\n        END IF\n\n        INITIALIZE candidates AS EMPTY LIST\n\n        ASSIGN 10 EXP lenVal TO tenPowLen\n        ASSIGN 10 EXP (lenVal - 1) TO tenPowLenMinusOne\n\n        APPEND tenPowLen + 1 TO candidates\n        APPEND tenPowLenMinusOne - 1 TO candidates\n\n        ASSIGN SUBSTRING n FROM 0 TO ((lenVal + 1) DIV 2) TO prefixStr\n        ASSIGN CONVERT prefixStr TO INTEGER TO prefixNum\n\n        SET iterator TO -1\n        WHILE iterator <= 1 DO\n            ASSIGN prefixNum + iterator TO adjustedPrefixNum\n            ASSIGN CONVERT adjustedPrefixNum TO STRING TO adjustedPrefixStr\n\n            IF lenVal MOD 2 THEN\n                ASSIGN SUBSTRING adjustedPrefixStr FROM 0 TO LENGTH(adjustedPrefixStr) - 1 TO trimStr\n                ASSIGN REVERSE(trimStr) TO revSub\n                ASSIGN CONCATENATE adjustedPrefixStr WITH revSub TO candidateStr\n            ELSE\n                ASSIGN REVERSE(adjustedPrefixStr) TO revFull\n                ASSIGN CONCATENATE adjustedPrefixStr WITH revFull TO candidateStr\n            END IF\n\n            ASSIGN CONVERT candidateStr TO INTEGER TO candidateInt\n            APPEND candidateInt TO candidates\n            INCREMENT iterator BY 1\n        END WHILE\n\n        ASSIGN CONVERT n TO INTEGER TO origNum\n\n        IF origNum IN candidates THEN\n            REMOVE origNum FROM candidates\n        END IF\n\n        ASSIGN NULL TO closestNum\n        ASSIGN POSITIVE_INFINITY TO minDiff\n\n        FOR index FROM 0 TO LENGTH(candidates) - 1 DO\n            ASSIGN candidates[index] TO currNum\n            ASSIGN ABS(currNum - origNum) TO currDiff\n\n            IF (currDiff < minDiff) OR ((currDiff = minDiff) AND (currNum < closestNum OR closestNum IS NULL)) THEN\n                ASSIGN currNum TO closestNum\n                ASSIGN currDiff TO minDiff\n            END IF\n        END FOR\n\n        RETURN CONVERT closestNum TO STRING\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION nearestPalindromic WITH PARAMETER n  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            RETURN the STRING REPRESENTATION OF the INTEGER VALUE OF n MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        ADD the INTEGER VALUE OF ten RAISED TO THE POWER OF length PLUS one TO candidates  \n        ADD the INTEGER VALUE OF ten RAISED TO THE POWER OF length MINUS one MINUS one TO candidates  \n        \n        SET prefix TO the INTEGER VALUE OF the SUBSTRING from position zero TO the INTEGER VALUE of the FLOOR of the DIVISION of length PLUS one BY two OF n  \n        FOR i FROM negative one TO one  \n            SET new_prefix TO the STRING REPRESENTATION OF prefix PLUS i  \n            IF the REMAINDER OF the DIVISION OF length BY two EQUALS zero  \n                SET candidate TO the CONCATENATION OF new_prefix AND the REVERSE OF new_prefix  \n            ELSE  \n                SET candidate TO the CONCATENATION OF new_prefix AND the REVERSE OF the SUBSTRING of new_prefix from the position of the SECOND TO LAST CHARACTER TO the FIRST CHARACTER  \n            END IF  \n            ADD the INTEGER VALUE OF candidate TO candidates  \n        END FOR  \n        \n        SET original_number TO the INTEGER VALUE OF n  \n        REMOVE original_number FROM candidates IF IT IS IN candidates  \n        \n        SET closest TO the ELEMENT OF candidates WITH THE MINIMUM VALUE ACCORDING TO THE CRITERION OF THE ABSOLUTE VALUE OF the ELEMENT MINUS original_number FOLLOWED BY the ELEMENT ITSELF  \n        \n        RETURN the STRING REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean\n        DEFINE FUNCTION loop_step(current_tx, current_ty) RETURNS boolean\n            IF NOT (current_tx >= sx AND current_ty >= sy) THEN\n                RETURN False\n            END IF\n            IF current_tx = sx AND current_ty = sy THEN\n                RETURN True\n            END IF\n            IF current_tx > current_ty THEN\n                IF current_ty > sy THEN\n                    LET mod_tx BE current_tx MOD current_ty\n                    RETURN loop_step(mod_tx, current_ty)\n                ELSE\n                    LET diff_tx BE current_tx - sx\n                    LET remainder_tx BE diff_tx MOD current_ty\n                    RETURN remainder_tx = 0\n                END IF\n            ELSE\n                IF current_tx > sx THEN\n                    LET mod_ty BE current_ty MOD current_tx\n                    RETURN loop_step(current_tx, mod_ty)\n                ELSE\n                    LET diff_ty BE current_ty - sy\n                    LET remainder_ty BE diff_ty MOD current_tx\n                    RETURN remainder_ty = 0\n                END IF\n            END IF\n        END FUNCTION\n\n        RETURN loop_step(tx, ty)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION reachingPoints(sx sy tx ty)  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of the difference of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of the difference of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numTilings(n)\n        ASSIGN 1000000007 TO MODULO\n\n        ALLOCATE dp AS ARRAY OF SIZE (n + 1) FILLED WITH 0\n        ALLOCATE dp1 AS ARRAY OF SIZE (n + 1) FILLED WITH 0\n\n        ASSIGN 1 TO dp[0]\n        ASSIGN 1 TO dp[1]\n        IF NOT (n < 2) THEN\n            ASSIGN 2 TO dp[2]\n            ASSIGN 1 TO dp1[2]\n        END IF\n\n        ASSIGN counter TO 3\n        WHILE counter <= n DO\n            ASSIGN ((dp[counter - 1] + dp[counter - 2] + (dp1[counter - 1] << 1)) MOD MODULO) TO dp[counter]\n            ASSIGN ((dp[counter - 2] + dp1[counter - 1]) MOD MODULO) TO dp1[counter]\n            SET counter TO counter + 1\n        END WHILE\n\n        RETURN dp[n]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO one billion plus seven  \n        SET dp TO a list of zeros of length n plus one  \n        SET dp1 TO a list of zeros of length n plus one  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder after division by MOD of the sum of element at position i minus one of dp PLUS element at position i minus two of dp PLUS two MULTIPLIED BY element at position i minus one of dp1  \n            SET element at position i of dp1 TO the remainder after division by MOD of the sum of element at position i minus two of dp PLUS element at position i minus one of dp1  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "soup-servings", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION soupServings(n)\n        IF NOT (n LESS OR EQUAL TO 4800) THEN\n            GIVE BACK 1.0\n        END IF\n\n        ASSIGN FLOOR((n + 24) / 25) TO scaledN\n        DECLARE memoMap AS NEW hash map\n\n        FUNCTION dp(a, b)\n            IF (a, b) IS IN memoMap THEN\n                GIVE BACK memoMap[(a, b)]\n            END IF\n\n            IF a > 0 OR b > 0 THEN\n                IF b <= 0 THEN\n                    GIVE BACK 0.0\n                ELSE IF a <= 0 THEN\n                    GIVE BACK 1.0\n                END IF\n            ELSE\n                GIVE BACK 0.5\n            END IF\n\n            ASSIGN 0.25 * (\n                dp(a - 4, b) + \n                dp(a - 3, b - 1) + \n                dp(a - 2, b - 2) + \n                dp(a - 1, b - 3)\n            ) TO resultProb\n\n            STORE resultProb IN memoMap[(a, b)]\n            GIVE BACK resultProb\n        END FUNCTION\n\n        GIVE BACK dp(scaledN, scaledN)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred  \n            RETURN one  \n        END IF  \n        \n        SET n TO n PLUS twenty four DIVIDED BY twenty five rounded down to the nearest integer greater than or equal to the result  \n        \n        SET memo TO an empty collection mapping pairs to probabilities  \n        \n        FUNCTION dp(a b)  \n            IF the pair of a and b EXISTS AS A KEY IN memo  \n                RETURN the value FROM memo FOR the pair of a and b  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero  \n                RETURN zero point five  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero  \n                RETURN one  \n            END IF  \n            \n            IF b LESS THAN OR EQUAL TO zero  \n                RETURN zero  \n            END IF  \n            \n            SET prob TO zero point two five MULTIPLIED BY the sum of dp of a MINUS four b, dp of a MINUS three b MINUS one, dp of a MINUS two b MINUS two, and dp of a MINUS one b MINUS three  \n            \n            SET the value in memo FOR the pair of a and b TO prob  \n            RETURN prob  \n        END FUNCTION  \n        \n        RETURN dp WITH parameters n and n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-to-get-all-keys", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        ASSIGN [(0,1), (0,-1), (1,0), (-1,0)] TO directions_list  \n        ASSIGN LENGTH(grid) TO rows_count  \n        ASSIGN LENGTH(grid[0]) TO cols_count  \n        ASSIGN NULL TO start_position  \n        ASSIGN 0 TO total_keys  \n        SET outer_index TO 0  \n        WHILE outer_index < rows_count  \n            SET inner_index TO 0  \n            WHILE inner_index < cols_count  \n                IF grid[outer_index][inner_index] == '@' THEN  \n                    ASSIGN (outer_index, inner_index) TO start_position  \n                ELSE IF grid[outer_index][inner_index] >= 'a' AND grid[outer_index][inner_index] <= 'z' THEN  \n                    total_keys = total_keys + 1  \n                END IF  \n                inner_index = inner_index + 1  \n            END WHILE  \n            outer_index = outer_index + 1  \n        END WHILE  \n        ASSIGN deque([(start_position[0], start_position[1], 0, 0)]) TO queue_container  \n        ASSIGN set({(start_position[0], start_position[1], 0)}) TO visited_states  \n        LOOP WHILE queue_container IS NOT EMPTY  \n            ASSIGN queue_container.POP_LEFT() TO (curr_x, curr_y, curr_keys, curr_steps)  \n            SET index_dir TO 0  \n            WHILE index_dir < LENGTH(directions_list)  \n                ASSIGN directions_list[index_dir] TO (delta_x, delta_y)  \n                ASSIGN curr_x + delta_x TO next_x  \n                ASSIGN curr_y + delta_y TO next_y  \n                IF next_x >= 0 AND next_x < rows_count AND next_y >= 0 AND next_y < cols_count THEN  \n                    ASSIGN grid[next_x][next_y] TO current_cell  \n                    IF current_cell == '#' THEN  \n                        index_dir = index_dir + 1  \n                        CONTINUE  \n                    END IF  \n                    IF current_cell >= 'A' AND current_cell <= 'Z' THEN  \n                        ASSIGN (1 << (ORD(LOWER(current_cell)) - ORD('a'))) TO required_key  \n                        IF (curr_keys & required_key) == 0 THEN  \n                            index_dir = index_dir + 1  \n                            CONTINUE  \n                        END IF  \n                    END IF  \n                    IF current_cell >= 'a' AND current_cell <= 'z' THEN  \n                        ASSIGN curr_keys | (1 << (ORD(current_cell) - ORD('a'))) TO updated_keys  \n                        IF updated_keys == (1 << total_keys) - 1 THEN  \n                            RETURN curr_steps + 1  \n                        END IF  \n                    ELSE  \n                        ASSIGN curr_keys TO updated_keys  \n                    END IF  \n                    IF NOT (next_x, next_y, updated_keys) IN visited_states THEN  \n                        visited_states.ADD((next_x, next_y, updated_keys))  \n                        queue_container.APPEND((next_x, next_y, updated_keys, curr_steps + 1))  \n                    END IF  \n                END IF  \n                index_dir = index_dir + 1  \n            END WHILE  \n        END LOOP  \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO list of pairs of zero and one zero and minus one one and zero minus one and zero  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO none  \n        SET num_keys TO zero  \n          \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid IS EQUALS the character at position j  \n                    IF character at position j EQUALS the character AT POSITION symbol at position corresponding to at sign  \n                        SET start TO pair of i AND j  \n                    ELSE IF character at position j IS LOWERCASE LETTER  \n                        INCREMENT num_keys BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        SET queue TO a new double ended queue containing a tuple of element at position zero of start AND element at position one of start AND zero AND zero  \n        SET visited TO a new set containing a tuple of element at position zero of start AND element at position one of start AND zero  \n          \n        WHILE queue is not empty  \n            SET x, y, keys, steps TO the elements dequeued from the left of queue  \n              \n            FOR each dx, dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid element at position ny  \n                      \n                    IF cell IS EQUALS wall symbol  \n                        CONTINUE to next iteration  \n                    END IF  \n                      \n                    IF cell IS UPPERCASE LETTER  \n                        SET key_needed TO one SHIFTED LEFT BY the position of lowercase of cell MINUS position of letter a  \n                        IF keys AND key_needed IS EQUALS zero  \n                            CONTINUE to next iteration  \n                        END IF  \n                    END IF  \n                      \n                    IF cell IS LOWERCASE LETTER  \n                        SET new_keys TO keys OR one SHIFTED LEFT BY the position of cell MINUS position of letter a  \n                        IF new_keys IS EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                      \n                    IF tuple of nx, ny, new_keys NOT IN visited  \n                        ADD tuple of nx, ny, new_keys TO visited  \n                        APPEND tuple of nx, ny, new_keys, steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-subsequence-widths", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION sumSubseqWidths(nums)\n        ASSIGN MOD TO (1_000_000_000 + 7)\n        SORT nums BY ascending order\n        ASSIGN count TO LENGTH OF nums\n        ASSIGN aggregate TO 0\n        ASSIGN expList TO ARRAY OF size count FILLED WITH 1\n\n        SET idx TO 1\n        WHILE idx < count DO\n            LET prevVal BE expList[idx - 1]\n            LET doubled BE (prevVal * 2) MOD MOD\n            ASSIGN expList[idx] TO doubled\n            INCREMENT idx BY 1\n        END WHILE\n\n        LET pos TO 0\n        WHILE pos < count DO\n            LET valueAtPos BE nums[pos]\n            LET powLeft BE expList[pos]\n            LET powRight BE expList[count - pos - 1]\n            LET diffProd BE valueAtPos * (powLeft - powRight)\n            ASSIGN aggregate TO (aggregate + diffProd) MOD MOD\n            INCREMENT pos BY 1\n        END WHILE\n\n        RETURN aggregate\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MODULO TO ten POWERED BY nine PLUS one  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list WITH n elements EACH EQUAL TO one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO the element at position i MINUS one of power MULTIPLIED BY two MODULO MODULO  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS the element at position i of nums MULTIPLIED BY the element at position i of power MINUS the element at position n MINUS i MINUS one of power MODULO MODULO  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        ASSIGN (10^9 + 7) TO MOD  \n        ASSIGN LENGTH OF s TO lengthVar  \n        CREATE A list dpList WITH (lengthVar + 1) zeroes  \n        ASSIGN 1 TO dpList[0]  \n        CREATE an empty map charRecentIndex  \n        \n        ASSIGN 1 TO idx  \n        WHILE idx <= lengthVar  \n            ASSIGN s[idx - 1] TO currentSymbol  \n            ASSIGN (dpList[idx - 1] * 2) TO dpList[idx]  \n            ASSIGN dpList[idx] MODULO MOD TO dpList[idx]  \n            \n            IF currentSymbol IS IN charRecentIndex KEYS THEN\n                ASSIGN (dpList[idx] - dpList[ charRecentIndex[currentSymbol] - 1 ] + MOD) TO dpList[idx]  \n                ASSIGN dpList[idx] MODULO MOD TO dpList[idx]  \n            END IF  \n            \n            ASSIGN idx TO charRecentIndex[currentSymbol]  \n            INCREMENT idx BY 1  \n        END WHILE  \n        \n        RETURN (dpList[lengthVar] - 1) MOD MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION distinctSubseqII WITH parameter s  \n        SET MODULO TO ten RAISED TO THE power of nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of zeros WITH LENGTH n PLUS one  \n        SET element at position zero of dp TO one  \n        INITIALIZE last AS an empty dictionary  \n        FOR i FROM one TO n  \n            SET character TO element at position i MINUS one of s  \n            SET element at position i of dp TO the value of element at position i MINUS one of dp MULTIPLIED BY two MODULO MODULO  \n            IF character IS a key in last  \n                SET element at position i of dp TO element at position i of dp MINUS element at position last of character MINUS one of dp PLUS MODULO MODULO MODULO  \n            END IF  \n            ASSIGN i TO last at character  \n        END FOR  \n        RETURN element at position n of dp MINUS one MODULO MODULO  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-floored-pairs", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        ASSIGN (10^9)+1 TO MOD  \n        ASSIGN the largest value in nums TO max_val  \n        ASSIGN a dictionary mapping elements of nums to their counts TO freq_map  \n        ASSIGN an array of zeroes with length max_val+1 TO cumulative_freq  \n        \n        SET iterator1 TO an iterator over keys in freq_map  \n        WHILE true  \n            TRY  \n                ASSIGN next element from iterator1 TO elem  \n            CATCH StopIteration  \n                BREAK  \n            END TRY  \n            INCREASE cumulative_freq[elem] BY freq_map[elem]  \n        END WHILE  \n        \n        SET idx TO 1  \n        WHILE idx <= max_val  \n            INCREASE cumulative_freq[idx] BY cumulative_freq[idx - 1]  \n            INCREMENT idx BY 1  \n        END WHILE  \n        \n        ASSIGN 0 TO total_sum  \n        \n        SET iterator2 TO an iterator over keys in freq_map  \n        WHILE true  \n            TRY  \n                ASSIGN next element from iterator2 TO base_num  \n            CATCH StopIteration  \n                BREAK  \n            END TRY  \n            SET multiplier TO 1  \n            WHILE multiplier <= FLOOR(max_val / base_num)  \n                ASSIGN base_num * multiplier TO start_pos  \n                ASSIGN base_num * (multiplier + 1) - 1 TO potential_end  \n                IF potential_end > max_val THEN  \n                    ASSIGN max_val TO end_pos  \n                ELSE  \n                    ASSIGN potential_end TO end_pos  \n                END IF  \n                ASSIGN cumulative_freq[end_pos] - cumulative_freq[start_pos - 1] TO segment_freq  \n                INCREASE total_sum BY segment_freq * multiplier * freq_map[base_num]  \n                ASSIGN total_sum MOD MOD TO total_sum  \n                INCREMENT multiplier BY 1  \n            END WHILE  \n        END WHILE  \n        \n        GIVE BACK total_sum  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO one billion PLUS seven  \n        SET max_num TO the maximum value IN nums  \n        SET count TO a mapping of each unique element IN nums TO its frequency  \n        SET prefix_sum TO a list of zeros WITH length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num IN count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the division of max_num BY num rounded down to nearest integer  \n                SET start TO num MULTIPLIED BY multiple  \n                SET end TO the smaller value BETWEEN num MULTIPLIED BY the sum of multiple PLUS one MINUS one AND max_num  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num IN count  \n                SET result TO the remainder of result DIVIDED BY MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION waysToPartition(nums parameter of list of integers k parameter of integer) RETURNS integer\n        ASSIGN totalSum ← 0\n        FOR each element val IN nums DO\n            totalSum ← totalSum + val\n        END FOR\n\n        ASSIGN length ← SIZE OF nums\n\n        INITIALIZE leftMap AS dictionary with default 0\n        INITIALIZE rightMap AS dictionary with default 0\n\n        ASSIGN prefixSum ← 0\n        ASSIGN upperBound ← length - 1\n        ASSIGN pos ← 0\n        WHILE pos < upperBound DO\n            prefixSum ← prefixSum + nums[pos]\n            ASSIGN difference ← totalSum - 2 * prefixSum\n            rightMap[difference] ← rightMap[difference] + 1\n            pos ← pos + 1\n        END WHILE\n\n        ASSIGN maximumWays ← rightMap[0]\n\n        ASSIGN prefixSum ← 0\n        FOR idx FROM 0 TO length - 1 DO\n            prefixSum ← prefixSum + nums[idx]\n\n            ASSIGN delta ← k - nums[idx]\n\n            ASSIGN candidateWays ← leftMap[-delta] + rightMap[delta]\n\n            IF candidateWays > maximumWays THEN\n                maximumWays ← candidateWays\n            END IF\n\n            ASSIGN currentDiff ← totalSum - 2 * prefixSum\n            rightMap[currentDiff] ← rightMap[currentDiff] - 1\n            leftMap[currentDiff] ← leftMap[currentDiff] + 1\n        END FOR\n\n        RETURN maximumWays\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter the list of integers k parameter the integer) RETURNS integer  \n        SET total_sum TO the sum of all elements in nums  \n        SET n TO the length of nums  \n        CREATE an empty dictionary left_diff that returns zero for missing keys  \n        CREATE an empty dictionary right_diff that returns zero for missing keys  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value at key diff of right_diff BY one  \n        END FOR  \n        SET max_ways TO the value at key zero of right_diff  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff_change TO k MINUS the element at position i of nums  \n            SET new_ways TO the sum of the value at key the negative of diff_change of left_diff AND the value at key diff_change of right_diff  \n            IF max_ways LESS THAN new_ways THEN  \n                SET max_ways TO new_ways  \n            END IF  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value at key diff of right_diff BY one  \n            INCREMENT the value at key diff of left_diff BY one  \n        END FOR  \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS"}
