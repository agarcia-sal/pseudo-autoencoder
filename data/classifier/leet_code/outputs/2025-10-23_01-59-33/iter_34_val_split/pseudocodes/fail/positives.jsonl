{"task_id": "reverse-words-in-a-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords WITH PARAMETER s  \n        SET words TO the result of splitting s BY spaces handling multiple spaces implicitly  \n        REVERSE the order of words  \n        SET reversed_string TO the concatenation of words JOINED BY a single space  \n        RETURN reversed_string  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "majority-element-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each m IN nums  \n            IF m EQUALS m1  \n                INCREMENT n1 BY one  \n            ELSE IF m EQUALS m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements FROM the list containing m1 AND m2 WHERE the count of element IN nums GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "strobogrammatic-number-iii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low, high)  \n        FUNCTION generate_strobogrammatic(n, final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            IF n EQUALS one  \n                RETURN a list containing the strings zero one and eight  \n            END IF  \n            SET middles TO the result of generate_strobogrammatic of n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero concatenated with middle concatenated with zero TO result  \n                END IF  \n                APPEND the string one concatenated with middle concatenated with one TO result  \n                APPEND the string six concatenated with middle concatenated with nine TO result  \n                APPEND the string eight concatenated with middle concatenated with eight TO result  \n                APPEND the string nine concatenated with middle concatenated with six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        FUNCTION count_strobogrammatic(low, high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN generate_strobogrammatic of length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN count_strobogrammatic of low and high  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-closest-palindrome", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic WITH PARAMETER n  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            RETURN the STRING REPRESENTATION OF the INTEGER VALUE OF n MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        ADD the INTEGER VALUE OF ten RAISED TO THE POWER OF length PLUS one TO candidates  \n        ADD the INTEGER VALUE OF ten RAISED TO THE POWER OF length MINUS one MINUS one TO candidates  \n        \n        SET prefix TO the INTEGER VALUE OF the SUBSTRING from position zero TO the INTEGER VALUE of the FLOOR of the DIVISION of length PLUS one BY two OF n  \n        FOR i FROM negative one TO one  \n            SET new_prefix TO the STRING REPRESENTATION OF prefix PLUS i  \n            IF the REMAINDER OF the DIVISION OF length BY two EQUALS zero  \n                SET candidate TO the CONCATENATION OF new_prefix AND the REVERSE OF new_prefix  \n            ELSE  \n                SET candidate TO the CONCATENATION OF new_prefix AND the REVERSE OF the SUBSTRING of new_prefix from the position of the SECOND TO LAST CHARACTER TO the FIRST CHARACTER  \n            END IF  \n            ADD the INTEGER VALUE OF candidate TO candidates  \n        END FOR  \n        \n        SET original_number TO the INTEGER VALUE OF n  \n        REMOVE original_number FROM candidates IF IT IS IN candidates  \n        \n        SET closest TO the ELEMENT OF candidates WITH THE MINIMUM VALUE ACCORDING TO THE CRITERION OF THE ABSOLUTE VALUE OF the ELEMENT MINUS original_number FOLLOWED BY the ELEMENT ITSELF  \n        \n        RETURN the STRING REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "non-decreasing-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR index i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "soup-servings", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred  \n            RETURN one  \n        END IF  \n        \n        SET n TO n PLUS twenty four DIVIDED BY twenty five rounded down to the nearest integer greater than or equal to the result  \n        \n        SET memo TO an empty collection mapping pairs to probabilities  \n        \n        FUNCTION dp(a b)  \n            IF the pair of a and b EXISTS AS A KEY IN memo  \n                RETURN the value FROM memo FOR the pair of a and b  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero  \n                RETURN zero point five  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero  \n                RETURN one  \n            END IF  \n            \n            IF b LESS THAN OR EQUAL TO zero  \n                RETURN zero  \n            END IF  \n            \n            SET prob TO zero point two five MULTIPLIED BY the sum of dp of a MINUS four b, dp of a MINUS three b MINUS one, dp of a MINUS two b MINUS two, and dp of a MINUS one b MINUS three  \n            \n            SET the value in memo FOR the pair of a and b TO prob  \n            RETURN prob  \n        END FUNCTION  \n        \n        RETURN dp WITH parameters n and n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "rectangle-area-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION rectangleArea(rectangles)  \n        SET MOD TO ten TO THE POWER OF nine PLUS one  \n        SET y_coords TO an empty set  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            ADD y1 TO y_coords  \n            ADD y2 TO y_coords  \n        END FOR  \n        \n        SET y_coords TO the sorted list of elements of y_coords  \n        SET y_index TO an empty dictionary  \n        FOR each index AND y IN the enumeration of y_coords  \n            ASSIGN y_index at key y TO index  \n        END FOR  \n        \n        SET count TO a list of zeros with the length equal to the length of y_coords  \n        SET events TO an empty list  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            APPEND a tuple containing x1 PLUS one PLUS y1 PLUS y2 TO events  \n            APPEND a tuple containing x2 MINUS one PLUS y1 PLUS y2 TO events  \n        END FOR  \n        \n        SORT events by the first element of each tuple in ascending order  \n        \n        SET prev_x TO zero  \n        SET area TO zero  \n        \n        FOR each event IN events  \n            SET x TO element at position zero of event  \n            SET eventType TO element at position one of event  \n            SET y1 TO element at position two of event  \n            SET y2 TO element at position three of event  \n            \n            SET current_length TO zero  \n            FOR index FROM one TO the length of count MINUS one  \n                IF element at position index MINUS one of count GREATER THAN zero THEN  \n                    INCREMENT current_length BY the difference between element at position index of y_coords AND element at position index MINUS one of y_coords  \n                END IF  \n            END FOR  \n            \n            INCREMENT area BY current_length MULTIPLIED BY the difference between x AND prev_x  \n            SET area TO area MODULO MOD  \n            \n            IF eventType EQUALS one THEN  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    INCREMENT element at position index of count BY one  \n                END FOR  \n            ELSE  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    DECREMENT element at position index of count BY one  \n                END FOR  \n            END IF  \n            \n            SET prev_x TO x  \n        END FOR  \n        \n        RETURN area  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "shortest-path-to-get-all-keys", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO list of pairs of zero and one zero and minus one one and zero minus one and zero  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO none  \n        SET num_keys TO zero  \n          \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid IS EQUALS the character at position j  \n                    IF character at position j EQUALS the character AT POSITION symbol at position corresponding to at sign  \n                        SET start TO pair of i AND j  \n                    ELSE IF character at position j IS LOWERCASE LETTER  \n                        INCREMENT num_keys BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        SET queue TO a new double ended queue containing a tuple of element at position zero of start AND element at position one of start AND zero AND zero  \n        SET visited TO a new set containing a tuple of element at position zero of start AND element at position one of start AND zero  \n          \n        WHILE queue is not empty  \n            SET x, y, keys, steps TO the elements dequeued from the left of queue  \n              \n            FOR each dx, dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid element at position ny  \n                      \n                    IF cell IS EQUALS wall symbol  \n                        CONTINUE to next iteration  \n                    END IF  \n                      \n                    IF cell IS UPPERCASE LETTER  \n                        SET key_needed TO one SHIFTED LEFT BY the position of lowercase of cell MINUS position of letter a  \n                        IF keys AND key_needed IS EQUALS zero  \n                            CONTINUE to next iteration  \n                        END IF  \n                    END IF  \n                      \n                    IF cell IS LOWERCASE LETTER  \n                        SET new_keys TO keys OR one SHIFTED LEFT BY the position of cell MINUS position of letter a  \n                        IF new_keys IS EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                      \n                    IF tuple of nx, ny, new_keys NOT IN visited  \n                        ADD tuple of nx, ny, new_keys TO visited  \n                        APPEND tuple of nx, ny, new_keys, steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-subsequence-widths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MODULO TO ten POWERED BY nine PLUS one  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list WITH n elements EACH EQUAL TO one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO the element at position i MINUS one of power MULTIPLIED BY two MODULO MODULO  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS the element at position i of nums MULTIPLIED BY the element at position i of power MINUS the element at position n MINUS i MINUS one of power MODULO MODULO  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "equal-rational-numbers", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isRationalEqual(s, t)  \n        SET ratios TO list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf(s)  \n            IF the position of the opening parenthesis character in s EQUALS negative one THEN  \n                RETURN the floating point conversion of s  \n            END IF  \n\n            SET leftParenIndex TO the position of the opening parenthesis character in s  \n            SET rightParenIndex TO the position of the closing parenthesis character in s  \n            SET dotIndex TO the position of the decimal point character in s  \n\n            SET integerAndNonRepeating TO the floating point conversion of the substring from the start of s TO the position before leftParenIndex of s  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the integer conversion of the substring from the position after leftParenIndex TO the position before rightParenIndex of s  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY zero POINT one RAISED TO THE POWER OF nonRepeatingLength MULTIPLIED BY the element at position repeatingLength of ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of the result of valueOf applied to s MINUS the result of valueOf applied to t LESS THAN one TIMES ten RAISED TO THE POWER OF negative nine  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "parsing-a-boolean-expression", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each character c IN expression  \n            IF c EQUALS one of the characters representing true false negation and and or  \n                APPEND c TO stk  \n            ELSE IF c EQUALS the character representing closing parenthesis  \n                SET count_true TO zero  \n                SET count_false TO zero  \n                WHILE the last element in stk EQUALS one of the characters representing true or false  \n                    INCREMENT count_true BY one IF the last element in stk EQUALS the character representing true  \n                    INCREMENT count_false BY one IF the last element in stk EQUALS the character representing false  \n                    REMOVE the last element FROM stk  \n                END WHILE  \n                SET operator TO the last element FROM stk  \n                REMOVE the last element FROM stk  \n                IF operator EQUALS the character representing negation  \n                    SET c TO the character representing true IF count_false IS GREATER THAN zero OTHERWISE the character representing false  \n                ELSE IF operator EQUALS the character representing and  \n                    SET c TO the character representing false IF count_false IS GREATER THAN zero OTHERWISE the character representing true  \n                ELSE IF operator EQUALS the character representing or  \n                    SET c TO the character representing true IF count_true IS GREATER THAN zero OTHERWISE the character representing false  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN whether the first element of stk EQUALS the character representing true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-vowels-permutation", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation WITH PARAMETER n  \n        SET MOD TO ten RAISED TO THE POWER OF nine PLUS one  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each number FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder of a_next DIVIDED BY MOD  \n            SET e TO the remainder of e_next DIVIDED BY MOD  \n            SET i TO the remainder of i_next DIVIDED BY MOD  \n            SET o TO the remainder of o_next DIVIDED BY MOD  \n            SET u TO the remainder of u_next DIVIDED BY MOD  \n        END FOR  \n        SET result TO the remainder of a PLUS e PLUS i PLUS o PLUS u DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "largest-multiple-of-three", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO a mapping of digits to their frequencies  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder when total_sum is divided by three  \n        IF remainder EQUALS one  \n            FOR each digit IN the list containing one four seven  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing two five eight  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit IN the list containing two five eight  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing one four seven  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        SET result TO an empty list  \n        FOR digit FROM nine DOWN TO zero  \n            APPEND the string form of digit repeated frequency of digit in count times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF final_number IS NOT empty AND the element at position one of final_number EQUALS zero  \n            RETURN zero as string  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-cost-to-connect-two-groups-of-points", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION connectTwoGroups(cost)\n        SET size one TO the LENGTH OF cost\n        SET size two TO the LENGTH OF the element at position zero OF cost\n\n        SET dp_table TO a list of lists WHERE EACH inner list CONTAINS the INFINITY value REPEATED a number of times EQUAL TO TWO RAISED TO the POWER OF size two\n        AND the number of such lists IS size one PLUS one\n\n        SET the element at position zero OF the element at position zero OF dp_table TO zero\n\n        FOR index i FROM zero TO size one MINUS one INCLUSIVE\n            FOR index mask FROM zero TO TWO RAISED TO the POWER OF size two MINUS one INCLUSIVE\n                FOR index j FROM zero TO size two MINUS one INCLUSIVE\n                    SET dp_table at position i PLUS one at position mask OR TWO RAISED TO the POWER OF j TO the LESSER OF\n                        the current value at dp_table at position i PLUS one at position mask OR TWO RAISED TO the POWER OF j\n                        AND the sum of dp_table at position i at position mask PLUS the element at position i at position j OF cost\n                END FOR\n\n                FOR index j FROM zero TO size two MINUS one INCLUSIVE\n                    IF the bitwise AND of mask AND TWO RAISED TO the POWER OF j HOLDS TRUE\n                        SET dp_table at position i PLUS one at position mask TO the LESSER OF\n                            the current value at dp_table at position i PLUS one at position mask\n                            AND the sum of dp_table at position i PLUS one at position mask with the bitwise exclusive OR of mask AND TWO RAISED TO the POWER OF j PLUS the element at position i at position j OF cost\n                    END IF\n                END FOR\n            END FOR\n        END FOR\n\n        RETURN the element at position size one at position TWO RAISED TO the POWER OF size two MINUS one OF dp_table\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "sum-of-special-evenly-spaced-elements-in-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION solve(nums parameters LIST OF INTEGER, queries parameters LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF nums  \n        SET max_y TO the MAXIMUM VALUE OF the second element in each pair OF queries  \n        INITIALIZE prefix_sums AS a LIST containing max_y PLUS one ELEMENTS each being a LIST of zeroes with LENGTH n  \n        FOR y FROM one TO max_y  \n            FOR i FROM n MINUS one DOWN TO zero  \n                IF i PLUS y LESS THAN n THEN  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums PLUS element at position i PLUS y of prefix_sums at position y  \n                ELSE  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums  \n                END IF  \n            END FOR  \n        END FOR  \n        INITIALIZE answer AS an empty LIST  \n        FOR each pair x and y IN queries  \n            APPEND to answer the element at position x of prefix_sums at position y MODULO MOD  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "cat-and-mouse-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the sequence of negative one zero one zero negative one  \n        SET g_mouse TO a list containing m MULTIPLIED BY n empty lists  \n        SET g_cat TO a list containing m MULTIPLIED BY n empty lists  \n        FOR each pair of index i AND element row IN grid WITH enumeration  \n            FOR each pair of index j AND element c IN row WITH enumeration  \n                IF c EQUALS the character hash  \n                    CONTINUE to next iteration  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character F  \n                    SET food TO v  \n                END IF  \n                FOR each pair of consecutive elements a AND b IN dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the result of the FUNCTION calc WITH parameters g_mouse g_cat mouse_start cat_start food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            DECOMPOSE state INTO m c t  \n            SET pt TO t XOR one  \n            SET pre TO empty list  \n            IF pt EQUALS one  \n                FOR each pc IN the element at position c of g_cat  \n                    IF the element at position m THEN at position pc THEN at position one OF ans EQUALS zero  \n                        APPEND the tuple m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN the element at position m of g_mouse  \n                    IF the element at position pm THEN at position c THEN at position zero OF ans EQUALS zero  \n                        APPEND the tuple pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a three dimensional list of zeros with dimensions n by n by two  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET the element at position zero of the element at position j of the element at position i of degree TO the LENGTH OF the element at position i of g_mouse  \n                SET the element at position one of the element at position j of the element at position i of degree TO the LENGTH OF the element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a three dimensional list of zeros with dimensions n by n by two  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET the element at position one of the element at position i of the element at position hole of ans TO one  \n            SET the element at position zero of the element at position hole of the element at position i of ans TO two  \n            SET the element at position one of the element at position i of the element at position i of ans TO two  \n            SET the element at position zero of the element at position i of the element at position i of ans TO two  \n            APPEND the tuple hole i one TO q  \n            APPEND the tuple i hole zero TO q  \n            APPEND the tuple i i zero TO q  \n            APPEND the tuple i i one TO q  \n        END FOR  \n\n        WHILE q is not empty  \n            SET state TO the element removed from the left of q  \n            SET t TO the element at position two OF ans at dimension positions state at zero state at one state at two  \n            FOR each prev_state IN the result of calling get_prev_states WITH state  \n                DECOMPOSE prev_state INTO pm pc pt  \n                IF pt EQUALS t MINUS one  \n                    SET the element at position pt OF ans at dimension positions pm pc TO t  \n                    APPEND prev_state TO q  \n                ELSE  \n                    DECREMENT the element at position pt OF degree at dimension positions pm pc BY one  \n                    IF the element at position pt OF degree at dimension positions pm pc EQUALS zero  \n                        SET the element at position pt OF ans at dimension positions pm pc TO t  \n                        APPEND prev_state TO q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the element at position zero OF ans at dimension positions mouse_start cat_start  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sum-of-floored-pairs", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO one billion PLUS seven  \n        SET max_num TO the maximum value IN nums  \n        SET count TO a mapping of each unique element IN nums TO its frequency  \n        SET prefix_sum TO a list of zeros WITH length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num IN count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the division of max_num BY num rounded down to nearest integer  \n                SET start TO num MULTIPLIED BY multiple  \n                SET end TO the smaller value BETWEEN num MULTIPLIED BY the sum of multiple PLUS one MINUS one AND max_num  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num IN count  \n                SET result TO the remainder of result DIVIDED BY MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits, startPos, k)  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        FOR right FROM zero TO the LENGTH OF fruits MINUS one  \n            SET position TO the element at position right of fruits at position zero  \n            SET amount TO the element at position right of fruits at position one  \n            INCREMENT total_fruits BY amount  \n            WHILE left LESS THAN OR EQUAL TO right AND NOT (startPos MINUS k LESS THAN OR EQUAL TO the element at position left of fruits at position zero AND the element at position left of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND startPos MINUS k LESS THAN OR EQUAL TO the element at position right of fruits at position zero AND the element at position right of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND the MINIMUM OF the ABSOLUTE VALUE OF the element at position right of fruits at position zero MINUS startPos AND the ABSOLUTE VALUE OF the element at position left of fruits at position zero MINUS startPos PLUS the element at position right of fruits at position zero MINUS the element at position left of fruits at position zero LESS THAN OR EQUAL TO k)  \n                DECREMENT total_fruits BY the element at position left of fruits at position one  \n                INCREMENT left BY one  \n            END WHILE  \n            SET max_fruits TO the GREATER OF max_fruits AND total_fruits  \n        END FOR  \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "longest-substring-of-one-repeating-character", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestRepeating(s, queryCharacters, queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF element at position i of intervals at position two EQUALS element at position i plus one of intervals at position two  \n                    SET element at position i of intervals TO a tuple with first element as element at position i of intervals at position zero second element as element at position i plus one of intervals at position one third element as element at position i of intervals at position two  \n                    REMOVE element at position i plus one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n      \n        SET intervals TO empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple with first element start second element i MINUS one third element element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple with first element start second element n MINUS one third element element at position start of s TO intervals  \n      \n        SET results TO empty list  \n        SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n      \n        FOR each pair of char and idx in the parallel elements of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start TO element at position i of intervals at position zero  \n                SET end TO element at position i of intervals at position one  \n                SET c TO element at position i of intervals at position two  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK the loop  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n      \n            IF idx GREATER THAN start  \n                INSERT at position i a tuple with first element start second element idx MINUS one third element c INTO intervals  \n                SET element at position i plus one of intervals TO a tuple with first element idx second element end third element c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT at position i plus one a tuple with first element idx PLUS one second element end third element c INTO intervals  \n                SET element at position i of intervals TO a tuple with first element start second element idx third element c  \n            END IF  \n      \n            SET element at position i of intervals TO a tuple with first element element at position i of intervals at position zero second element element at position i of intervals at position one third element char  \n      \n            CALL merge_intervals()  \n      \n            SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n            APPEND longest TO results  \n        END FOR  \n      \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "valid-number", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        RETURN the RESULT OF matching the ENTIRE string s AGAINST the REGULAR expression representing optional plus or minus SIGN followed BY either one or more digits FOLLOWED BY an optional decimal POINT FOLLOWED BY zero or more digits OR a decimal POINT FOLLOWED BY one or more digits FOLLOWED optionally BY the letter e FOLLOWED optionally BY plus or minus SIGN FOLLOWED BY one or more digits IS NOT EQUAL TO no match  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS one of open parenthesis AND sign AND vertical bar  \n                APPEND a pair of element e AND zero TO stack  \n                CONTINUE to next iteration  \n            ELSE IF element e EQUALS closing parenthesis  \n                SET lastPair TO the last element REMOVED FROM stack  \n                REMOVE the last element FROM stack  \n            ELSE  \n                SET lastPair TO a pair of element e AND one  \n            END IF  \n            IF stack is not empty AND the last element in stack AT position zero EQUALS one of sign AND vertical bar  \n                SET op TO the last element AT position zero REMOVED FROM stack  \n                SET a AND costA TO the last pair REMOVED FROM stack  \n                SET b AND costB TO lastPair  \n                IF op EQUALS sign  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND one INCREMENTED BY the minimum of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a pair of zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND one  \n                    ELSE  \n                        SET lastPair TO a pair of one AND the minimum of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND the minimum of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a pair of one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a pair of one AND one  \n                    ELSE  \n                        SET lastPair TO a pair of one AND one INCREMENTED BY the minimum of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last element in stack  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "number-of-distinct-islands-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION numDistinctIslands2(grid)\n        FUNCTION dfs(x, y, island)\n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero OF grid OR element at position x OF grid AT position y EQUALS zero\n                RETURN\n            END IF\n            SET element at position x OF grid AT position y TO zero\n            APPEND tuple of x AND y TO island\n            CALL dfs WITH x PLUS one, y, AND island\n            CALL dfs WITH x MINUS one, y, AND island\n            CALL dfs WITH x, y PLUS one, AND island\n            CALL dfs WITH x, y MINUS one, AND island\n        END FUNCTION\n\n        FUNCTION normalize(island)\n            SET shapes TO empty list\n            FOR each pair dx AND dy IN list of pairs consisting of one and one, one and negative one, negative one and one, negative one and negative one\n                SET new_island TO empty list\n                FOR each pair x AND y IN island\n                    APPEND tuple of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island\n                END FOR\n                SORT new_island IN ascending order\n                SET min_x TO the minimum x value FOR all pairs x AND y IN new_island\n                SET min_y TO the minimum y value FOR all pairs x AND y IN new_island\n                APPEND tuple of pairs where each pair is x MINUS min_x AND y MINUS min_y FOR each pair x AND y IN new_island TO shapes\n            END FOR\n            FOR index i FROM zero TO the LENGTH OF shapes MINUS one INCLUSIVE\n                APPEND tuple of pairs where each pair is y AND negative x FOR each pair x AND y IN element at position i OF shapes TO shapes\n            END FOR\n            RETURN the minimum element IN shapes\n        END FUNCTION\n\n        SET islands TO empty set\n        FOR index i FROM zero TO the LENGTH OF grid MINUS one INCLUSIVE\n            FOR index j FROM zero TO the LENGTH OF element at position zero OF grid MINUS one INCLUSIVE\n                IF element at position i OF grid AT position j EQUALS one\n                    SET island TO empty list\n                    CALL dfs WITH i, j, AND island\n                    ADD normalize(island) TO islands\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the LENGTH OF islands\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION getProbability WITH PARAMETER balls  \n        FUNCTION dfs WITH PARAMETERS i, j, diff  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i OF balls INCLUSIVE  \n                IF x EQUALS element at position i OF balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO negative one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS dfs WITH ARGUMENTS i PLUS one, j MINUS x, diff PLUS y MULTIPLIED BY combination of element at position i OF balls AND x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO length of balls  \n        RETURN dfs WITH ARGUMENTS zero, n, zero DIVIDED BY combination of n MULTIPLIED BY two AND n  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
