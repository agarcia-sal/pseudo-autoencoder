{"task_id": "reverse-words-in-a-string", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION reverseWords(s)\n        DECLARE wordList AS empty array\n        DECLARE startIndex AS 0\n        DECLARE lengthOfString AS LENGTH(s)\n        WHILE startIndex < lengthOfString\n            WHILE startIndex < lengthOfString AND s[startIndex] = ' '\n                INCREMENT startIndex BY 1\n            END WHILE\n            IF startIndex = lengthOfString\n                EXIT WHILE\n            END IF\n            DECLARE endIndex AS startIndex\n            WHILE endIndex < lengthOfString AND s[endIndex] ≠ ' '\n                INCREMENT endIndex BY 1\n            END WHILE\n            APPEND SUBSTRING(s, startIndex, endIndex - startIndex) TO wordList\n            SET startIndex TO endIndex\n        END WHILE\n\n        DECLARE index AS LENGTH(wordList) - 1\n        DECLARE reversedList AS empty array\n        WHILE index ≥ 0\n            APPEND wordList[index] TO reversedList\n            DECREMENT index BY 1\n        END WHILE\n\n        DECLARE resultString AS EMPTY STRING\n        DECLARE reverseIndex AS 0\n        DECLARE totalWords AS LENGTH(reversedList)\n        WHILE reverseIndex < totalWords\n            APPEND reversedList[reverseIndex] TO resultString\n            IF reverseIndex ≠ totalWords - 1 THEN\n                APPEND ' ' TO resultString\n            END IF\n            INCREMENT reverseIndex BY 1\n        END WHILE\n\n        RETURN resultString\n    END FUNCTION\nEND CLASS", "score": 0.9545454545454546, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpa35_vybe/solution_0.py\", line 83, in <module>\\n    print(Solution().reverseWords(s = \"the sky is blue\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'reverseWords\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION reverseWords WITH PARAMETER s  \n        SET words TO the result of splitting s BY spaces handling multiple spaces implicitly  \n        REVERSE the order of words  \n        SET reversed_string TO the concatenation of words JOINED BY a single space  \n        RETURN reversed_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        DEFINE dp AS map FROM integers TO integers  \n        FOR index FROM 0 TO amount  \n            ASSIGN dp[index] = amount + 1  \n        END FOR  \n        ASSIGN dp[0] = 0  \n\n        PROCEDURE updateAmount(current)  \n            IF current > amount THEN  \n                RETURN  \n            END IF  \n            FOR EACH c IN coins  \n                LET previous = current - c  \n                IF previous >= 0 THEN  \n                    LET candidate = dp[previous] + 1  \n                    IF candidate < dp[current] THEN  \n                        ASSIGN dp[current] = candidate  \n                    END IF  \n                END IF  \n            END FOR  \n            CALL updateAmount(current + 1)  \n        END PROCEDURE  \n\n        CALL updateAmount(1)  \n\n        SWITCH dp[amount]  \n            CASE amount + 1:  \n                RETURN -1  \n            DEFAULT:  \n                RETURN dp[amount]  \n        END SWITCH  \n    END FUNCTION  \nEND CLASS", "score": 0.9375, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp6e1a0xza/solution_0.py\", line 95, in <module>\\n    print(Solution().coinChange(coins = [1, 2, 5], amount = 11))\\n          ^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'coinChange\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION coinChange(coins AS list of integers, amount AS integer) RETURNS integer  \n        SET dp TO a list with the length of amount PLUS one where each element is amount PLUS one  \n        SET element at position zero of dp TO zero  \n        \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET element at position a of dp TO the smaller value BETWEEN element at position a of dp AND element at position a MINUS coin of dp PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF element at position amount of dp IS NOT EQUALS TO amount PLUS one  \n            RETURN element at position amount of dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION originalDigits(s)\n        SET freqMap TO empty map\n        SET pos TO 0\n        WHILE pos < length of s\n            SET ch TO character at position pos of s\n            IF freqMap contains ch\n                SET tempVar TO freqMap[ch]\n                SET freqMap[ch] TO tempVar + 1\n            ELSE\n                SET freqMap[ch] TO 1\n            END IF\n            SET pos TO pos + 1\n        END WHILE\n\n        SET digitCounts TO list of ten zeros\n\n        SET digitCounts[0] TO (IF freqMap contains 'z' THEN freqMap['z'] ELSE 0)\n        SET digitCounts[2] TO (IF freqMap contains 'w' THEN freqMap['w'] ELSE 0)\n        SET digitCounts[4] TO (IF freqMap contains 'u' THEN freqMap['u'] ELSE 0)\n        SET digitCounts[6] TO (IF freqMap contains 'x' THEN freqMap['x'] ELSE 0)\n        SET digitCounts[8] TO (IF freqMap contains 'g' THEN freqMap['g'] ELSE 0)\n\n        SET foundEights TO digitCounts[8]\n        SET digitCounts[3] TO (IF freqMap contains 'h' THEN freqMap['h'] ELSE 0) - foundEights\n\n        SET foundFours TO digitCounts[4]\n        SET digitCounts[5] TO (IF freqMap contains 'f' THEN freqMap['f'] ELSE 0) - foundFours\n\n        SET foundSixes TO digitCounts[6]\n        SET digitCounts[7] TO (IF freqMap contains 's' THEN freqMap['s'] ELSE 0) - foundSixes\n\n        SET foundFives TO digitCounts[5]\n        SET digitCounts[9] TO (IF freqMap contains 'i' THEN freqMap['i'] ELSE 0) - foundFives - foundSixes - foundEights\n\n        SET foundZeros TO digitCounts[0]\n        SET foundTwos TO digitCounts[2]\n        SET foundFoursCount TO digitCounts[4]\n        SET digitCounts[1] TO (IF freqMap contains 'o' THEN freqMap['o'] ELSE 0) - foundZeros - foundTwos - foundFoursCount\n\n        SET outputList TO empty list\n\n        FUNCTION appendDigits(index, count)\n            IF count = 0 THEN\n                RETURN\n            ELSE\n                APPEND string representation of index TO outputList\n                CALL appendDigits(index, count - 1)\n            END IF\n        END FUNCTION\n\n        FUNCTION processIndex(idx)\n            IF idx > 9 THEN\n                RETURN\n            ELSE\n                CALL appendDigits(idx, digitCounts[idx])\n                CALL processIndex(idx + 1)\n            END IF\n        END FUNCTION\n\n        CALL processIndex(0)\n\n        SET finalResult TO empty string\n        SET counterVar TO 0\n        WHILE counterVar < length of outputList\n            SET finalResult TO finalResult + outputList[counterVar]\n            SET counterVar TO counterVar + 1\n        END WHILE\n\n        RETURN finalResult\n    END FUNCTION\nEND CLASS", "score": 0.88, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpk064bn72/solution_0.py\", line 39, in <module>\\n    print(Solution().originalDigits(s = \"owoztneoer\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'originalDigits\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO mapping of character frequencies in s  \n        SET digits TO list of zero FOR each position FROM zero TO nine  \n        SET digit at position zero TO the frequency of character z in count  \n        SET digit at position two TO the frequency of character w in count  \n        SET digit at position four TO the frequency of character u in count  \n        SET digit at position six TO the frequency of character x in count  \n        SET digit at position eight TO the frequency of character g in count  \n        SET digit at position three TO the frequency of character h in count MINUS digit at position eight  \n        SET digit at position five TO the frequency of character f in count MINUS digit at position four  \n        SET digit at position seven TO the frequency of character s in count MINUS digit at position six  \n        SET digit at position nine TO the frequency of character i in count MINUS digit at position five MINUS digit at position six MINUS digit at position eight  \n        SET digit at position one TO the frequency of character o in count MINUS digit at position zero MINUS digit at position two MINUS digit at position four  \n        SET result TO empty list  \n        FOR index FROM zero TO nine  \n            FOR count_index FROM one TO digit at position index  \n                APPEND index converted to string TO result  \n            END FOR  \n        END FOR  \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-array", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        ASSIGN false TO flag  \n        ASSIGN 1 TO index  \n        WHILE index < (LENGTH(nums) - 1) DO  \n            IF nums[index] < nums[index - 1] THEN  \n                IF flag = true THEN  \n                    RETURN false  \n                END IF  \n                ASSIGN true TO flag  \n                IF (index < 2) OR (nums[index] >= nums[index - 2]) THEN  \n                    nums[index - 1] := nums[index]  \n                ELSE  \n                    nums[index] := nums[index - 1]  \n                END IF  \n            END IF  \n            ASSIGN index + 1 TO index  \n        END WHILE  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 0.8, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpc5pjw8p2/solution_0.py\", line 45, in <module>\\n    print(Solution().checkPossibility(nums = [4,2,3]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'checkPossibility\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR index i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean\n        SET reachable TO False\n        WHILE NOT reachable AND tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy\n            IF tx EQUALS sx THEN\n                IF ty EQUALS sy THEN\n                    ASSIGN True TO reachable\n                ELSE\n                    ASSIGN ((ty MINUS sy) MODULO tx EQUALS 0) TO reachable\n                END IF\n            ELSE IF ty EQUALS sy THEN\n                ASSIGN ((tx MINUS sx) MODULO ty EQUALS 0) TO reachable\n            ELSE IF tx GREATER THAN ty THEN\n                ASSIGN (tx MODULO ty) TO tx\n            ELSE\n                ASSIGN (ty MODULO tx) TO ty\n            END IF\n        END WHILE\n        RETURN reachable\n    END FUNCTION\nEND CLASS", "score": 0.9, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmplhojeelw/solution_0.py\", line 49, in <module>\\n    print(Solution().reachingPoints(sx = 1, sy = 1, tx = 3, ty = 5))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'reachingPoints\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION reachingPoints(sx sy tx ty)  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of the difference of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of the difference of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION numTilings(n)\n        CONSTANT M ← 1000000007\n\n        ARRAY results ← new array of size n + 1 filled with 0\n        ARRAY partials ← new array of size n + 1 filled with 0\n\n        results[0] ← 1\n        results[1] ← 1\n\n        IF n ≥ 2 THEN\n            results[2] ← 2\n            partials[2] ← 1\n        END IF\n\n        PROCEDURE loop(index)\n            IF index > n THEN\n                RETURN\n            END IF\n            results[index] ← (results[index - 1] + results[index - 2] + 2 * partials[index - 1]) MOD M\n            partials[index] ← (results[index - 2] + partials[index - 1]) MOD M\n            loop(index + 1)\n        END PROCEDURE\n\n        loop(3)\n\n        RETURN results[n]\n    END FUNCTION\nEND CLASS", "score": 0.9090909090909091, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpn6cjy4oj/solution_0.py\", line 45, in <module>\\n    print(Solution().numTilings(n = 1))\\n          ^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'numTilings\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO one billion plus seven  \n        SET dp TO a list of zeros of length n plus one  \n        SET dp1 TO a list of zeros of length n plus one  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder after division by MOD of the sum of element at position i minus one of dp PLUS element at position i minus two of dp PLUS two MULTIPLIED BY element at position i minus one of dp1  \n            SET element at position i of dp1 TO the remainder after division by MOD of the sum of element at position i minus two of dp PLUS element at position i minus one of dp1  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area-ii", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION rectangleArea(rectangles)\n        ASSIGN (10^9 + 1) TO MOD\n\n        ASSIGN an empty collection to vertical_points_set\n        FOR each quadruple x_start y_start x_end y_end IN rectangles\n            INSERT y_start INTO vertical_points_set\n            INSERT y_end INTO vertical_points_set\n        END FOR\n\n        ASSIGN a sorted array from vertical_points_set TO sorted_vertical_points\n        ASSIGN an empty map to vertical_indices_map\n        FOR index idx AND value coord IN enumeration of sorted_vertical_points\n            ASSIGN idx TO vertical_indices_map[coord]\n        END FOR\n\n        ASSIGN a list named coverage_counts filled with zeros, sized to LENGTH of sorted_vertical_points\n\n        ASSIGN an empty list named sweep_events\n        FOR each quadruple x_start y_start x_end y_end IN rectangles\n            ADD (x_start, 1, y_start, y_end) TO sweep_events\n            ADD (x_end, -1, y_start, y_end) TO sweep_events\n        END FOR\n\n        SORT sweep_events IN ascending order BY the first element of each tuple\n\n        ASSIGN 0 TO last_processed_x\n        ASSIGN 0 TO total_area\n\n        SET index_k TO 0\n        WHILE index_k < LENGTH of sweep_events\n            ASSIGN current_x, event_flag, y_lower, y_upper FROM sweep_events[index_k]\n\n            ASSIGN 0 TO covered_segment_size\n            SET index_j TO 1\n            WHILE index_j < LENGTH of coverage_counts\n                IF coverage_counts[index_j - 1] > 0 THEN\n                    ASSIGN covered_segment_size + (sorted_vertical_points[index_j] - sorted_vertical_points[index_j - 1]) TO covered_segment_size\n                END IF\n                INCREMENT index_j BY 1\n            END WHILE\n\n            ASSIGN total_area + covered_segment_size * (current_x - last_processed_x) TO total_area\n            ASSIGN total_area MOD MOD TO total_area\n\n            IF event_flag == 1 THEN\n                SET pos FROM vertical_indices_map[y_lower] TO vertical_indices_map[y_upper] - 1\n                WHILE pos <= vertical_indices_map[y_upper] - 1\n                    ASSIGN coverage_counts[pos] + 1 TO coverage_counts[pos]\n                    INCREMENT pos BY 1\n                END WHILE\n            ELSE\n                SET pos FROM vertical_indices_map[y_lower] TO vertical_indices_map[y_upper] - 1\n                WHILE pos <= vertical_indices_map[y_upper] - 1\n                    ASSIGN coverage_counts[pos] - 1 TO coverage_counts[pos]\n                    INCREMENT pos BY 1\n                END WHILE\n            END IF\n\n            ASSIGN current_x TO last_processed_x\n            INCREMENT index_k BY 1\n        END WHILE\n\n        RETURN total_area\n    END FUNCTION\nEND CLASS", "score": 0.96, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpozvwlhrr/solution_0.py\", line 65, in <module>\\n    print(Solution().rectangleArea(rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'rectangleArea\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION rectangleArea(rectangles)  \n        SET MOD TO ten TO THE POWER OF nine PLUS one  \n        SET y_coords TO an empty set  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            ADD y1 TO y_coords  \n            ADD y2 TO y_coords  \n        END FOR  \n        \n        SET y_coords TO the sorted list of elements of y_coords  \n        SET y_index TO an empty dictionary  \n        FOR each index AND y IN the enumeration of y_coords  \n            ASSIGN y_index at key y TO index  \n        END FOR  \n        \n        SET count TO a list of zeros with the length equal to the length of y_coords  \n        SET events TO an empty list  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            APPEND a tuple containing x1 PLUS one PLUS y1 PLUS y2 TO events  \n            APPEND a tuple containing x2 MINUS one PLUS y1 PLUS y2 TO events  \n        END FOR  \n        \n        SORT events by the first element of each tuple in ascending order  \n        \n        SET prev_x TO zero  \n        SET area TO zero  \n        \n        FOR each event IN events  \n            SET x TO element at position zero of event  \n            SET eventType TO element at position one of event  \n            SET y1 TO element at position two of event  \n            SET y2 TO element at position three of event  \n            \n            SET current_length TO zero  \n            FOR index FROM one TO the length of count MINUS one  \n                IF element at position index MINUS one of count GREATER THAN zero THEN  \n                    INCREMENT current_length BY the difference between element at position index of y_coords AND element at position index MINUS one of y_coords  \n                END IF  \n            END FOR  \n            \n            INCREMENT area BY current_length MULTIPLIED BY the difference between x AND prev_x  \n            SET area TO area MODULO MOD  \n            \n            IF eventType EQUALS one THEN  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    INCREMENT element at position index of count BY one  \n                END FOR  \n            ELSE  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    DECREMENT element at position index of count BY one  \n                END FOR  \n            END IF  \n            \n            SET prev_x TO x  \n        END FOR  \n        \n        RETURN area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parsing-a-boolean-expression", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each character c IN expression  \n            IF c IS one of 't', 'f', '!', '&', '|'  \n                APPEND c TO stk  \n            ELSE IF c IS ')'  \n                SET t TO 0  \n                SET f TO 0  \n                WHILE top element of stk IS 't' OR 'f'  \n                    IF top element of stk IS 't'  \n                        INCREMENT t BY 1  \n                    ELSE  \n                        INCREMENT f BY 1  \n                    REMOVE top element from stk  \n                SET op TO REMOVE top element from stk  \n                IF op IS '!'  \n                    SET c TO 't' IF f IS GREATER THAN 0 OTHERWISE 'f'  \n                ELSE IF op IS '&'  \n                    SET c TO 'f' IF f IS GREATER THAN 0 OTHERWISE 't'  \n                ELSE IF op IS '|'  \n                    SET c TO 't' IF t IS GREATER THAN 0 OTHERWISE 'f'  \n                APPEND c TO stk  \n        RETURN top element of stk IS 't'  \n    END FUNCTION  \nEND CLASS", "score": 0.9629629629629629, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp2cy77vwd/solution_0.py\", line 47, in <module>\\n    print(Solution().parseBoolExpr(expression = \"&(!(f),t)\"))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'parseBoolExpr\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each character c IN expression  \n            IF c EQUALS one of the characters representing true false negation and and or  \n                APPEND c TO stk  \n            ELSE IF c EQUALS the character representing closing parenthesis  \n                SET count_true TO zero  \n                SET count_false TO zero  \n                WHILE the last element in stk EQUALS one of the characters representing true or false  \n                    INCREMENT count_true BY one IF the last element in stk EQUALS the character representing true  \n                    INCREMENT count_false BY one IF the last element in stk EQUALS the character representing false  \n                    REMOVE the last element FROM stk  \n                END WHILE  \n                SET operator TO the last element FROM stk  \n                REMOVE the last element FROM stk  \n                IF operator EQUALS the character representing negation  \n                    SET c TO the character representing true IF count_false IS GREATER THAN zero OTHERWISE the character representing false  \n                ELSE IF operator EQUALS the character representing and  \n                    SET c TO the character representing false IF count_false IS GREATER THAN zero OTHERWISE the character representing true  \n                ELSE IF operator EQUALS the character representing or  \n                    SET c TO the character representing true IF count_true IS GREATER THAN zero OTHERWISE the character representing false  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN whether the first element of stk EQUALS the character representing true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "label": "near_miss", "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter AS list OF integers, k parameter AS integer) RETURNS integer  \n        SET total_sum TO the sum of all elements in nums  \n        SET n TO the length of nums  \n        \n        ASSIGN left_diff TO a new dictionary with default integer zero  \n        ASSIGN right_diff TO a new dictionary with default integer zero  \n        \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO n MINUS one  \n            ADD the element at position i of nums TO current_sum  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value for key diff in right_diff BY one  \n        END FOR  \n        \n        SET max_ways TO the value for key zero in right_diff  \n        \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO n MINUS one  \n            ADD the element at position i of nums TO current_sum  \n            \n            SET diff_change TO k MINUS the element at position i of nums  \n            \n            SET new_ways TO the sum of the value for key the negative of diff_change in left_diff AND the value for key diff_change in right_diff  \n            IF new_ways GREATER THAN max_ways THEN  \n                SET max_ways TO new_ways  \n            END IF  \n            \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value for key diff in right_diff BY one  \n            INCREMENT the value for key diff in left_diff BY one  \n        END FOR  \n        \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS", "score": 0.8297872340425532, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpg1edh7jk/solution_0.py\", line 61, in <module>\\n    print(Solution().waysToPartition(nums = [2,-1,2], k = 3))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'waysToPartition\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter the list of integers k parameter the integer) RETURNS integer  \n        SET total_sum TO the sum of all elements in nums  \n        SET n TO the length of nums  \n        CREATE an empty dictionary left_diff that returns zero for missing keys  \n        CREATE an empty dictionary right_diff that returns zero for missing keys  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value at key diff of right_diff BY one  \n        END FOR  \n        SET max_ways TO the value at key zero of right_diff  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff_change TO k MINUS the element at position i of nums  \n            SET new_ways TO the sum of the value at key the negative of diff_change of left_diff AND the value at key diff_change of right_diff  \n            IF max_ways LESS THAN new_ways THEN  \n                SET max_ways TO new_ways  \n            END IF  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value at key diff of right_diff BY one  \n            INCREMENT the value at key diff of left_diff BY one  \n        END FOR  \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "label": "near_miss", "pseudocode": "CLASS Solution\n    FUNCTION maxTotalFruits(fruits AS list of list of integers, startPos AS integer, k AS integer) RETURNS integer\n        SET apex TO 0\n        SET aggregate TO 0\n        SET tunnel TO 0\n\n        SET beacon TO 0\n        WHILE beacon LESS THAN LENGTH(fruits)\n            SET locale TO fruits[beacon][0]\n            SET quantity TO fruits[beacon][1]\n            ADD quantity TO aggregate\n\n            LOOP\n                IF tunnel GREATER THAN beacon THEN\n                    BREAK\n                END IF\n\n                SET leftCoord TO fruits[tunnel][0]\n                SET rightCoord TO fruits[beacon][0]\n\n                IF (startPos - k) > leftCoord OR leftCoord > (startPos + k)\n                    OR (startPos - k) > rightCoord OR rightCoord > (startPos + k) THEN\n                    // condition is false, so negate to break\n                    BREAK\n                END IF\n\n                SET distLeft TO ABS(leftCoord - startPos)\n                SET distRight TO ABS(rightCoord - startPos)\n                SET span TO rightCoord - leftCoord\n                SET minimalDistance TO MIN(distRight, distLeft) + span\n\n                IF minimalDistance GREATER THAN k THEN\n                    SET deduction TO fruits[tunnel][1]\n                    SUBTRACT deduction FROM aggregate\n                    INCREMENT tunnel BY 1\n                ELSE\n                    BREAK\n                END IF\n            END LOOP\n\n            IF apex < aggregate THEN\n                SET apex TO aggregate\n            END IF\n\n            INCREMENT beacon BY 1\n        END WHILE\n\n        OUTPUT apex\n    END FUNCTION\nEND CLASS", "score": 0.8653846153846154, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp24h91zrq/solution_0.py\", line 103, in <module>\\n    print(Solution().maxTotalFruits(fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'maxTotalFruits\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits, startPos, k)  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        FOR right FROM zero TO the LENGTH OF fruits MINUS one  \n            SET position TO the element at position right of fruits at position zero  \n            SET amount TO the element at position right of fruits at position one  \n            INCREMENT total_fruits BY amount  \n            WHILE left LESS THAN OR EQUAL TO right AND NOT (startPos MINUS k LESS THAN OR EQUAL TO the element at position left of fruits at position zero AND the element at position left of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND startPos MINUS k LESS THAN OR EQUAL TO the element at position right of fruits at position zero AND the element at position right of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND the MINIMUM OF the ABSOLUTE VALUE OF the element at position right of fruits at position zero MINUS startPos AND the ABSOLUTE VALUE OF the element at position left of fruits at position zero MINUS startPos PLUS the element at position right of fruits at position zero MINUS the element at position left of fruits at position zero LESS THAN OR EQUAL TO k)  \n                DECREMENT total_fruits BY the element at position left of fruits at position one  \n                INCREMENT left BY one  \n            END WHILE  \n            SET max_fruits TO the GREATER OF max_fruits AND total_fruits  \n        END FOR  \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS"}
