CLASS Solution  
    FUNCTION canMouseWin(grid, catJump, mouseJump)  
        ASSIGN row_count TO LENGTH OF grid  
        ASSIGN col_count TO LENGTH OF grid[0]  
        ASSIGN start_cat TO 0  
        ASSIGN start_mouse TO 0  
        ASSIGN position_food TO 0  
        ASSIGN directions TO [(-1,0),(1,0),(0,-1),(0,1)]  
  
        ASSIGN moves_mouse TO ARRAY OF EMPTY ARRAYS WITH SIZE row_count * col_count  
        ASSIGN moves_cat TO ARRAY OF EMPTY ARRAYS WITH SIZE row_count * col_count  
  
        FOR row_index, row_value IN ENUMERATE(grid) DO  
            FOR col_index, cell_value IN ENUMERATE(row_value) DO  
                IF cell_value == '#' THEN  
                    CONTINUE TO NEXT ITERATION  
                END IF  
                ASSIGN pos_linear TO row_index * col_count + col_index  
                IF cell_value == 'C' THEN  
                    start_cat = pos_linear  
                ELSE IF cell_value == 'M' THEN  
                    start_mouse = pos_linear  
                ELSE IF cell_value == 'F' THEN  
                    position_food = pos_linear  
                END IF  
  
                FOR dir_x, dir_y IN directions DO  
                    VAR step_mouse = 0  
                    WHILE step_mouse <= mouseJump DO  
                        ASSIGN new_x TO row_index + step_mouse * dir_x  
                        ASSIGN new_y TO col_index + step_mouse * dir_y  
                        IF new_x < 0 OR new_x >= row_count OR new_y < 0 OR new_y >= col_count OR grid[new_x][new_y] == '#' THEN  
                            BREAK  
                        END IF  
                        moves_mouse[pos_linear].APPEND(new_x * col_count + new_y)  
                        step_mouse = step_mouse + 1  
                    END WHILE  
  
                    VAR step_cat = 0  
                    WHILE step_cat <= catJump DO  
                        ASSIGN new_x TO row_index + step_cat * dir_x  
                        ASSIGN new_y TO col_index + step_cat * dir_y  
                        IF new_x < 0 OR new_x >= row_count OR new_y < 0 OR new_y >= col_count OR grid[new_x][new_y] == '#' THEN  
                            BREAK  
                        END IF  
                        moves_cat[pos_linear].APPEND(new_x * col_count + new_y)  
                        step_cat = step_cat + 1  
                    END WHILE  
                END FOR  
            END FOR  
        END FOR  
  
        RETURN calc(moves_mouse, moves_cat, start_mouse, start_cat, position_food) == 1  
    END FUNCTION  
  
    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  
        FUNCTION get_prev_states(state)  
            ASSIGN mouse_pos TO state[0]  
            ASSIGN cat_pos TO state[1]  
            ASSIGN turn TO state[2]  
            ASSIGN previous_turn TO turn XOR 1  
            ASSIGN result TO EMPTY LIST  
  
            IF previous_turn == 1 THEN  
                FOR cat_prev IN g_cat[cat_pos] DO  
                    IF ans[mouse_pos][cat_prev][1] == 0 THEN  
                        result.APPEND([mouse_pos, cat_prev, previous_turn])  
                    END IF  
                END FOR  
            ELSE  
                FOR mouse_prev IN g_mouse[mouse_pos] DO  
                    IF ans[mouse_prev][cat_pos][0] == 0 THEN  
                        result.APPEND([mouse_prev, cat_pos, previous_turn])  
                    END IF  
                END FOR  
            END IF  
            RETURN result  
        END FUNCTION  
  
        ASSIGN total_states TO LENGTH(g_mouse)  
        ASSIGN degree TO THREE-DIMENSIONAL ARRAY FILLED WITH 0 OF SIZE [total_states][total_states][2]  
  
        FOR i FROM 0 TO total_states - 1 DO  
            FOR j FROM 0 TO total_states - 1 DO  
                degree[i][j][0] = LENGTH(g_mouse[i])  
                degree[i][j][1] = LENGTH(g_cat[j])  
            END FOR  
        END FOR  
  
        ASSIGN ans TO THREE-DIMENSIONAL ARRAY FILLED WITH 0 OF SIZE [total_states][total_states][2]  
        ASSIGN queue TO EMPTY DEQUE  
  
        FOR idx FROM 0 TO total_states - 1 DO  
            ans[hole][idx][1] = 1  
            ans[idx][hole][0] = 2  
            ans[idx][idx][1] = 2  
            ans[idx][idx][0] = 2  
  
            queue.ADD_LAST([hole, idx, 1])  
            queue.ADD_LAST([idx, hole, 0])  
            queue.ADD_LAST([idx, idx, 0])  
            queue.ADD_LAST([idx, idx, 1])  
        END FOR  
  
        WHILE queue IS NOT EMPTY DO  
            ASSIGN current_state TO queue.REMOVE_FIRST()  
            ASSIGN current_result TO ans[current_state[0]][current_state[1]][current_state[2]]  
  
            FOR prev_state IN get_prev_states(current_state) DO  
                ASSIGN pm TO prev_state[0]  
                ASSIGN pc TO prev_state[1]  
                ASSIGN pt TO prev_state[2]  
  
                IF pt == current_result - 1 THEN  
                    ans[pm][pc][pt] = current_result  
                    queue.ADD_LAST(prev_state)  
                ELSE  
                    degree[pm][pc][pt] = degree[pm][pc][pt] - 1  
                    IF degree[pm][pc][pt] == 0 THEN  
                        ans[pm][pc][pt] = current_result  
                        queue.ADD_LAST(prev_state)  
                    END IF  
                END IF  
            END FOR  
        END WHILE  
  
        RETURN ans[mouse_start][cat_start][0]  
    END FUNCTION  
END CLASS