CLASS Solution
    FUNCTION minimumIncompatibility(nums k)
        ASSIGN length_nums ← LENGTH OF nums
        COMPUTE group_size ← length_nums DIVIDED BY k
        FORM frequency_map AS A MAPPING OF ELEMENT TO ITS OCCURRENCE COUNT IN nums

        FOR each occurrence_count IN VALUES OF frequency_map DO
            IF occurrence_count GREATER THAN k THEN
                RETURN -1
            ENDIF
        ENDFOR

        INITIATE dictionary incompatibility_map AS EMPTY

        ASSIGN upper_limit ← (2 TO THE POWER OF length_nums) - 1

        FOR candidate_subset FROM 0 TO upper_limit DO
            CALCULATE bits_set ← NUMBER OF 1 BITS IN BINARY REPRESENTATION OF candidate_subset
            IF bits_set IS EQUAL TO group_size THEN
                INITIALIZE list current_elements AS EMPTY
                FOR index FROM 0 TO length_nums - 1 DO
                    COMPUTE current_bit ← 1 LEFT SHIFTED BY index
                    IF (candidate_subset BITWISE-AND current_bit) IS NOT ZERO THEN
                        APPEND nums AT index TO current_elements
                    ENDIF
                ENDFOR

                ASSIGN unique_count ← COUNT OF UNIQUE MEMBERS IN current_elements
                IF unique_count EQUALS group_size THEN
                    CALCULATE max_val ← MAXIMUM VALUE IN current_elements
                    CALCULATE min_val ← MINIMUM VALUE IN current_elements
                    ASSIGN incompatibility_map[candidate_subset] ← max_val MINUS min_val
                ENDIF
            ENDIF
        ENDFOR

        DEFINE dp_array AS A LIST OF SIZE (2 TO THE POWER OF length_nums) FILLED WITH infinity
        SET dp_array[0] TO 0

        FOR state_mask FROM 0 TO upper_limit DO
            COMPUTE selected_bits ← NUMBER OF 1 BITS IN BINARY REPRESENTATION OF state_mask
            IF (selected_bits MODULO group_size) NOT EQUAL TO 0 THEN
                CONTINUE TO NEXT ITERATION
            ENDIF

            FOR valid_subset IN KEYS OF incompatibility_map DO
                IF (state_mask BITWISE-AND valid_subset) EQUALS valid_subset THEN
                    COMPUTE potential_score ← dp_array[state_mask - valid_subset] + incompatibility_map[valid_subset]
                    IF potential_score LESS THAN dp_array[state_mask] THEN
                        SET dp_array[state_mask] TO potential_score
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR

        ASSIGN complete_mask ← upper_limit
        IF dp_array[complete_mask] DIFFERENT FROM infinity THEN
            RETURN dp_array[complete_mask]
        ELSE
            RETURN -1
        ENDIF
    END FUNCTION
END CLASS