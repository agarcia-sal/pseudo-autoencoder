{"task_id": "jump-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "fraction-to-recurring-decimal", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-primes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "h-index", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "perfect-squares", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "coin-change", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-numbers-with-unique-digits", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n INCLUSIVE  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            SET available_digits TO available_digits MINUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sentence-screen-fitting", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        SET s TO the concatenation of all elements of sentence with a single space between each followed by a single space character  \n        SET total_length TO the LENGTH OF s  \n        SET position TO zero  \n        \n        FOR each iteration IN the range from one TO rows  \n            INCREMENT position BY cols  \n            \n            IF the element at position MODULO total_length of s EQUALS a space character  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position GREATER THAN zero AND the element at position MINUS one MODULO total_length of s NOT EQUALS a space character  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN position DIVIDED BY total_length  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "k-inverse-pairs-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kInversePairs(n, k)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a two dimensional list of zeros with dimension n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp  \n                IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                IF j GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of element at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                SET element at position j of element at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "pour-water", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN zero AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            INCREMENT element at position k of heights BY one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "swap-adjacent-in-lr-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "valid-tic-tac-toe-state", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "bus-routes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from keys to empty lists  \n        FOR each bus WITH index bus_index AND route IN routes  \n            FOR each stop IN route  \n                APPEND bus_index TO the list corresponding to stop IN stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at the source stop FROM stop_to_buses  \n            APPEND the tuple consisting of bus AND one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element FROM bus_queue AND ASSIGN the elements TO current_bus AND bus_count  \n\n            FOR each stop IN the route at position current_bus OF routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop NOT IN visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop FROM stop_to_buses  \n                        IF next_bus NOT IN visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the tuple consisting of next_bus AND bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "card-flipping-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "binary-trees-with-factors", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "string-transforms-into-another-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO an empty mapping from characters to characters  \n        FOR each pair of characters char1 and char2 FROM str1 AND str2 in order  \n            IF char1 IS IN conversion_map  \n                IF the value mapped from char1 in conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET the value mapped from char1 in conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the number of unique characters IN str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "last-substring-in-lexicographical-order", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-vowels-permutation", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each index FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder when a_next is DIVIDED BY MOD  \n            SET e TO the remainder when e_next is DIVIDED BY MOD  \n            SET i TO the remainder when i_next is DIVIDED BY MOD  \n            SET o TO the remainder when o_next is DIVIDED BY MOD  \n            SET u TO the remainder when u_next is DIVIDED BY MOD  \n        END FOR  \n        SET total_count TO the sum of a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO the remainder when total_count is DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "restore-the-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-good-people-based-on-statements", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
