CLASS Solution  
    FUNCTION minimumIncompatibility(nums k)  
        SET integer_n TO the LENGTH OF nums  
        SET integer_subset_size TO integer_n DIVIDED BY k  
        
        FUNCTION all_numbers_appear_no_more_than_k_times(list_of_numbers max_count)  
            CREATE a COUNTER_OBJECT FOR list_of_numbers  
            FOR each count_value IN the VALUES OF the COUNTER_OBJECT  
                IF count_value GREATER THAN max_count  
                    RETURN false  
                END IF  
            END FOR  
            RETURN true  
        END FUNCTION  
        
        IF all_numbers_appear_no_more_than_k_times(nums k) IS false  
            RETURN negative one  
        END IF  
        
        CREATE empty MAPPING subset_incompatibility WITH KEYS AS integer MASKS AND VALUES AS integer INCOMPATIBILITY  
        
        FUNCTION count_number_of_set_bits_in_integer(integer_value)  
            SET bit_count TO zero  
            SET working_value TO integer_value  
            WHILE working_value GREATER THAN zero  
                SET bit_count TO bit_count PLUS (working_value MODULO two)  
                SET working_value TO working_value DIVIDED BY two  
            END WHILE  
            RETURN bit_count  
        END FUNCTION  
        
        SET total_mask_limit TO two POWERED BY integer_n  
        
        FOR mask FROM zero TO total_mask_limit MINUS one  
            IF count_number_of_set_bits_in_integer(mask) EQUALS integer_subset_size  
                CREATE empty LIST current_elements  
                FOR index FROM zero TO integer_n MINUS one  
                    IF the bit at position index OF mask IS one  
                        APPEND the element at position index OF nums TO current_elements  
                    END IF  
                END FOR  
                FUNCTION all_elements_unique(list_of_elements)  
                    SET unique_elements_count TO the LENGTH OF the SET OF list_of_elements  
                    SET elements_count TO the LENGTH OF list_of_elements  
                    RETURN unique_elements_count EQUALS elements_count  
                END FUNCTION  
                IF all_elements_unique(current_elements)  
                    SET maximum_element TO the maximum VALUE IN current_elements  
                    SET minimum_element TO the minimum VALUE IN current_elements  
                    SET incompatibility_value TO maximum_element MINUS minimum_element  
                    ASSIGN incompatibility_value TO subset_incompatibility AT KEY mask  
                END IF  
            END IF  
        END FOR  
        
        CREATE LIST dp OF SIZE total_mask_limit WITH EVERY ELEMENT INITIALIZED TO positive infinity  
        SET the element at position zero OF dp TO zero  
        
        FUNCTION minimum_of_two_numbers(first_number second_number)  
            IF first_number LESS THAN second_number  
                RETURN first_number  
            ELSE  
                RETURN second_number  
            END IF  
        END FUNCTION  
        
        FOR mask FROM zero TO total_mask_limit MINUS one  
            IF (count_number_of_set_bits_in_integer(mask) MODULO integer_subset_size) NOT EQUAL TO zero  
                CONTINUE TO NEXT ITERATION  
            END IF  
            FOR each subset_mask IN the KEYS OF subset_incompatibility  
                FUNCTION is_subset(subset main_set)  
                    RETURN (subset BITWISE_AND main_set) EQUALS subset  
                END FUNCTION  
                IF is_subset(subset_mask mask)  
                    SET candidate_value TO dp AT POSITION (mask BITWISE_EXCLUSIVE_OR subset_mask) PLUS subset_incompatibility AT KEY subset_mask  
                    SET dp AT POSITION mask TO minimum_of_two_numbers(dp AT POSITION mask candidate_value)  
                END IF  
            END FOR  
        END FOR  
        
        SET final_mask TO total_mask_limit MINUS one  
        IF dp AT POSITION final_mask NOT EQUAL TO positive infinity  
            RETURN dp AT POSITION final_mask  
        ELSE  
            RETURN negative one  
        END IF  
    END FUNCTION  
END CLASS