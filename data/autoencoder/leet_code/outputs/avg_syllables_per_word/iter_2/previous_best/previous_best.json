{
  "prompt": "Given a code snippet within classes and functions, generate clear, precise, and high-level pseudocode that retains the exact class and function names and structure as in the original code. Use conventional pseudocode keywords (e.g., FUNCTION, RETURN, IF, FOR, WHILE) and natural language expressions. \n\nExpress data operations abstractly (e.g., SET variable TO value, INCREMENT variable BY amount, APPEND item TO list), avoid language-specific syntax, omit comments, summaries, explanations, or notes. Do not add any text besides the pseudocode itself. Use consistent indentation to represent code blocks. Preserve class and method organization exactly as in the original code, including class declarations and method signatures, reflecting parameters clearly.\n\nUse descriptive but concise language while maximizing readability and abstraction \u2014 avoid low-level language-specific details, expressions, or implementation minutiae. Prefer natural language terms over symbolic shorthand unless widely understood (e.g., use DIVIDED BY instead of /, MODULO instead of %). Maintain original control structures and flow as much as possible. Avoid empty lines or separators between code blocks.\n\nExample style:  \n```\nCLASS Solution\n    FUNCTION calc_average(list_of_numbers)\n        SET total_sum TO 0\n        FOR each number IN list_of_numbers\n            INCREMENT total_sum BY number\n        SET average_value TO total_sum DIVIDED BY LENGTH OF list_of_numbers\n        RETURN average_value\n    END FUNCTION\nEND CLASS\n```",
  "response": "Given a code snippet within classes and functions, generate clear, precise, and high-level pseudocode that retains the exact class and function names and structure as in the original code. Use conventional pseudocode keywords (e.g., FUNCTION, RETURN, IF, FOR, WHILE) and natural language expressions. \n\nExpress data operations abstractly (e.g., SET variable TO value, INCREMENT variable BY amount, APPEND item TO list), avoid language-specific syntax, omit comments, summaries, explanations, or notes. Do not add any text besides the pseudocode itself. Use consistent indentation to represent code blocks. Preserve class and method organization exactly as in the original code, including class declarations and method signatures, reflecting parameters clearly.\n\nUse descriptive but concise language while maximizing readability and abstraction \u2014 avoid low-level language-specific details, expressions, or implementation minutiae. Prefer natural language terms over symbolic shorthand unless widely understood (e.g., use DIVIDED BY instead of /, MODULO instead of %). Maintain original control structures and flow as much as possible. Avoid empty lines or separators between code blocks.\n\nExample style:  \n```\nCLASS Solution\n    FUNCTION calc_average(list_of_numbers)\n        SET total_sum TO 0\n        FOR each number IN list_of_numbers\n            INCREMENT total_sum BY number\n        SET average_value TO total_sum DIVIDED BY LENGTH OF list_of_numbers\n        RETURN average_value\n    END FUNCTION\nEND CLASS\n```",
  "score": 1.8436415677475022,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\nfrom typing import List\n\nclass Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Sort nums1\n        nums1.sort()\n        \n        # Create a list of tuples (value, original_index) for nums2 and sort by value\n        nums2_with_indices = sorted([(value, index) for index, value in enumerate(nums2)], reverse=True)\n        \n        # Result array to store the final permutation of nums1\n        result = [0] * len(nums1)\n        \n        # Two pointers for nums1: left and right\n        left, right = 0, len(nums1) - 1\n        \n        # Iterate over the sorted nums2_with_indices\n        for value, index in nums2_with_indices:\n            # If the largest remaining element in nums1 can beat the current element in nums2\n            if nums1[right] > value:\n\nPseudocode for Problem 1:\n```\nCLASS Solution\n    FUNCTION advantageCount(nums1: List of Integer, nums2: List of Integer) RETURNS List of Integer\n        SORT nums1 IN ASCENDING ORDER\n        SET nums2_with_indices TO LIST OF (value, index) FOR EACH index, value IN ENUMERATE(nums2)\n        SORT nums2_with_indices IN DESCENDING ORDER BY value\n\n        SET result TO LIST OF ZEROES WITH LENGTH OF nums1\n\n        SET left TO 0\n        SET right TO LENGTH OF nums1 MINUS 1\n\n        FOR EACH value, index IN nums2_with_indices\n            IF nums1[right] GREATER THAN value THEN\n                SET result[index] TO nums1[right]\n                DECREMENT right BY 1\n            ELSE\n                SET result[index] TO nums1[left]\n                INCREMENT left BY 1\n        END FOR\n\nError(s) from the decoded code for Problem 1:\n['Outputs do not match']\n\nOriginal Code for Problem 2:\nfrom typing import List\n\nclass Solution:\n    def canSeePersonsCount(self, heights: List[int]) -> List[int]:\n        n = len(heights)\n        answer = [0] * n\n        stack = []\n        \n        for i in range(n):\n            while stack and heights[stack[-1]] < heights[i]:\n                answer[stack.pop()] += 1\n            if stack:\n                answer[stack[-1]] += 1\n            stack.append(i)\n        \n        return answer\n\n\nPseudocode for Problem 2:\n```\nCLASS Solution\n    FUNCTION canSeePersonsCount(heights)\n        SET n TO LENGTH OF heights\n        SET answer TO list of zeros with length n\n        SET stack TO empty list\n\n        FOR i FROM 0 TO n - 1\n            WHILE stack IS NOT empty AND heights AT top of stack IS LESS THAN heights AT i\n                SET index TO POP from stack\n                INCREMENT answer AT index BY 1\n            IF stack IS NOT empty\n                INCREMENT answer AT top of stack BY 1\n            APPEND i TO stack\n\n        RETURN answer\n```\n\nError(s) from the decoded code for Problem 2:\n['Outputs do not match']\n\nOriginal Code for Problem 3:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nfrom typing import List, Optional\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n\nPseudocode for Problem 3:\nCLASS TreeNode\n    FUNCTION __init__(val = 0, left = None, right = None)\n        SET self.val TO val\n        SET self.left TO left\n        SET self.right TO right\n    END FUNCTION\nEND CLASS\n\nFUNCTION tree_node(values: list)\n    IF values IS EMPTY\n        RETURN None\n    SET root TO new TreeNode WITH values[0]\n    SET i TO 1\n    SET queue TO empty deque\n    APPEND root TO queue\n    WHILE queue IS NOT EMPTY\n        SET node TO queue.popleft()\n        IF i LESS THAN LENGTH OF values AND values[i] IS NOT None\n            SET node.left TO new TreeNode WITH values[i]\n            APPEND node.left TO queue\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpnd_8m08g/solution_0.py\", line 109, in <module>\\n    print(Solution().levelOrder(root = [3,9,20,null,null,15,7]))\\n                                               ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 4:\nfrom typing import List\n\nclass Solution:\n    def shiftingLetters(self, s: str, shifts: List[int]) -> str:\n        # Calculate the cumulative shifts from the end to the beginning\n        total_shifts = 0\n        for i in range(len(shifts) - 1, -1, -1):\n            total_shifts += shifts[i]\n            shifts[i] = total_shifts\n        \n        # Apply the shifts to the string\n        result = []\n        for i in range(len(s)):\n            # Calculate the new character with wrapping around using modulo 26\n            new_char = chr((ord(s[i]) - ord('a') + shifts[i]) % 26 + ord('a'))\n            result.append(new_char)\n        \n        return ''.join(result)\n\n\nPseudocode for Problem 4:\nCLASS Solution\n    FUNCTION shiftingLetters(s, shifts)\n        SET total_shifts TO 0\n        FOR i FROM LENGTH OF shifts MINUS 1 DOWNTO 0\n            INCREMENT total_shifts BY shifts[i]\n            SET shifts[i] TO total_shifts\n        SET result TO empty list\n        FOR i FROM 0 TO LENGTH OF s MINUS 1\n            SET new_char_code TO (ORDINAL VALUE OF s[i] MINUS ORDINAL VALUE OF 'a' PLUS shifts[i]) MODULO 26 PLUS ORDINAL VALUE OF 'a'\n            SET new_char TO CHARACTER REPRESENTED BY new_char_code\n            APPEND new_char TO result\n        RETURN CONCATENATION OF CHARACTERS IN result\n    END FUNCTION\nEND CLASS\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpixdf7_96/solution_22.py\", line 31, in <module>\\n    print(Solution().shiftingLetters(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\", shifts = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpixdf7_96/solution_22.py\", line 27, in shiftingLetters\\n    new_char_code = (ord(s[i]) - ord(\\'a\\') + shifts[i]) % 26 + ord(\\'a\\')\\n                                            ~~~~~~^^^\\nIndexError: list index out of range\\n']\n\nOriginal Code for Problem 5:\nfrom typing import List\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        # Create a dictionary to map cost to the largest digit\n        cost_to_digit = {c: str(i + 1) for i, c in enumerate(cost)}\n        \n        # Initialize a dp array where dp[t] is the largest number we can form with cost t\n        dp = [\"\"] + [\"-1\"] * target  # \"-1\" represents that it's not possible to form that cost\n        \n        # Fill the dp array\n        for t in range(1, target + 1):\n            for c, d in cost_to_digit.items():\n                if t >= c and dp[t - c] != \"-1\":\n                    candidate = d + dp[t - c]\n                    if dp[t] == \"-1\" or len(candidate) > len(dp[t]) or (len(candidate) == len(dp[t]) and candidate > dp[t]):\n                        dp[t] = candidate\n        \n        return dp[target] if dp[target] != \"-1\" else \"0\"\n\n\nPseudocode for Problem 5:\n```\nCLASS Solution\n    FUNCTION largestNumber(cost: List[int], target: int) RETURNS string\n        SET cost_to_digit TO DICTIONARY mapping each cost c TO string of digit (index of c in cost plus 1)\n        SET dp TO LIST with first element as empty string and rest as \"-1\" repeated target times\n        \n        FOR t FROM 1 TO target\n            FOR each (c, d) IN cost_to_digit\n                IF t >= c AND dp[t - c] IS NOT \"-1\"\n                    SET candidate TO d CONCATENATED WITH dp[t - c]\n                    IF dp[t] IS \"-1\" OR LENGTH OF candidate > LENGTH OF dp[t] OR \n                       (LENGTH OF candidate = LENGTH OF dp[t] AND candidate > dp[t])\n                        SET dp[t] TO candidate\n        \n        IF dp[target] IS NOT \"-1\"\n            RETURN dp[target]\n        ELSE\n            RETURN \"0\"\n    END FUNCTION\nEND CLASS\n\nError(s) from the decoded code for Problem 5:\n['Outputs do not match']\n\nOriginal Code for Problem 6:\nclass Solution:\n    def numberOfCombinations(self, num: str) -> int:\n        MOD = 10**9 + 7\n        n = len(num)\n        \n        # Memoization dictionary\n        memo = {}\n        \n        def dp(index, prev_len):\n            if index == n:\n                return 1\n            if (index, prev_len) in memo:\n                return memo[(index, prev_len)]\n            \n            count = 0\n            for length in range(1, n - index + 1):\n                if num[index] == '0':\n                    break  # Skip leading zeros\n                \n                current_num = num[index:index + length]\n\nPseudocode for Problem 6:\n```\nCLASS Solution\n    FUNCTION numberOfCombinations(num)\n        SET MOD TO 10^9 + 7\n        SET n TO LENGTH OF num\n        SET memo TO EMPTY DICTIONARY\n\n        FUNCTION dp(index, prev_len)\n            IF index EQUALS n THEN\n                RETURN 1\n            IF (index, prev_len) EXISTS IN memo THEN\n                RETURN memo[(index, prev_len)]\n\n            SET count TO 0\n            FOR length FROM 1 TO (n - index)\n                IF num[index] EQUALS '0' THEN\n                    BREAK\n                SET current_num TO SUBSTRING OF num FROM index TO (index + length)\n\n                IF prev_len EQUALS 0 OR current_num IS GREATER THAN OR EQUAL TO SUBSTRING OF num FROM (index - prev_len) TO index THEN\n\nError(s) from the decoded code for Problem 6:\n['Outputs do not match']\n\nOriginal Code for Problem 7:\nclass Solution:\n    def isRationalEqual(self, s: str, t: str) -> bool:\n        ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]\n\n        def valueOf(s: str) -> float:\n            if s.find('(') == -1:\n                return float(s)\n\n            # Get the indices.\n            leftParenIndex = s.find('(')\n            rightParenIndex = s.find(')')\n            dotIndex = s.find('.')\n\n            # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>\n            integerAndNonRepeating = float(s[:leftParenIndex])\n            nonRepeatingLength = leftParenIndex - dotIndex - 1\n\n            # repeating := <RepeatingPart>\n            repeating = int(s[leftParenIndex + 1:rightParenIndex])\n            repeatingLength = rightParenIndex - leftParenIndex - 1\n\nPseudocode for Problem 7:\n```\nCLASS Solution\n    FUNCTION isRationalEqual(s: string, t: string) RETURNS boolean\n        SET ratios TO list [1, 1 DIVIDED BY 9, 1 DIVIDED BY 99, 1 DIVIDED BY 999, 1 DIVIDED BY 9999]\n\n        FUNCTION valueOf(s: string) RETURNS float\n            IF s DOES NOT CONTAIN '(' THEN\n                RETURN float conversion of s\n            END IF\n\n            SET leftParenIndex TO position of '(' in s\n            SET rightParenIndex TO position of ')' in s\n            SET dotIndex TO position of '.' in s\n\n            SET integerAndNonRepeating TO float conversion of substring of s from start TO leftParenIndex\n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS 1\n\n            SET repeating TO integer conversion of substring of s from (leftParenIndex + 1) TO rightParenIndex\n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS 1\n\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpaldmlvxt/solution_41.py\", line 40, in <module>\\n    print(Solution().isRationalEqual(s = \"10(0)\", t = \"10.\"))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpaldmlvxt/solution_41.py\", line 39, in isRationalEqual\\n    return abs(valueOf(s) - valueOf(t)) < 1e-9\\n               ~~~~~~~^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpaldmlvxt/solution_41.py\", line 29, in valueOf\\n    dotIndex = s.index(\\'.\\')\\nValueError: substring not found\\n']\n\nOriginal Code for Problem 8:\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # Create a dummy node that points to the head of the list\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        \n        # Move first pointer n+1 steps ahead\n        for i in range(n + 1):\n            first = first.next\n        \n        # Move both pointers until first reaches the end\n        while first is not None:\n            first = first.next\n\nPseudocode for Problem 8:\nCLASS ListNode\n    FUNCTION __init__(val = 0, next = None)\n        SET self.val TO val\n        SET self.next TO next\n    END FUNCTION\nEND CLASS\n\nFUNCTION list_node(values)\n    IF values IS EMPTY\n        RETURN None\n    END IF\n    SET head TO ListNode(values[0])\n    SET p TO head\n    FOR each val IN values starting from second element\n        SET node TO ListNode(val)\n        SET p.next TO node\n        SET p TO node\n    END FOR\n    RETURN head\nEND FUNCTION\n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpv0i1rn_c/solution_0.py\", line 78, in <module>\\n    print(Solution().removeNthFromEnd(head = [1,2,3,4,5], n = 2))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpv0i1rn_c/solution_0.py\", line 72, in removeNthFromEnd\\n    first = first.next\\n            ^^^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'next\\'\\n']\nScore of (4*(Average syllables per word) + passing rate) for ALL the problems: 1.8436415677475022"
}