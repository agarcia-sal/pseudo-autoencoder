```
CLASS Solution
    FUNCTION canMouseWin(grid, catJump, mouseJump)
        SET m TO LENGTH OF grid
        SET n TO LENGTH OF grid AT 0
        SET cat_start TO 0
        SET mouse_start TO 0
        SET food TO 0
        SET dirs TO (-1, 0, 1, 0, -1)
        SET g_mouse TO LIST OF EMPTY LISTS WITH SIZE m * n
        SET g_cat TO LIST OF EMPTY LISTS WITH SIZE m * n

        FOR i FROM 0 TO m - 1
            SET row TO grid AT i
            FOR j FROM 0 TO n - 1
                SET c TO row AT j
                IF c EQUALS "#"
                    CONTINUE
                SET v TO i * n + j
                IF c EQUALS "C"
                    SET cat_start TO v
                ELSE IF c EQUALS "M"
                    SET mouse_start TO v
                ELSE IF c EQUALS "F"
                    SET food TO v
                FOR EACH (a, b) IN PAIRWISE OF dirs
                    FOR k FROM 0 TO mouseJump
                        SET x TO i + k * a
                        SET y TO j + k * b
                        IF x NOT IN [0, m) OR y NOT IN [0, n) OR grid[x][y] EQUALS "#"
                            BREAK
                        APPEND (x * n + y) TO g_mouse[v]
                    FOR k FROM 0 TO catJump
                        SET x TO i + k * a
                        SET y TO j + k * b
                        IF x NOT IN [0, m) OR y NOT IN [0, n) OR grid[x][y] EQUALS "#"
                            BREAK
                        APPEND (x * n + y) TO g_cat[v]
        RETURN self.calc(g_mouse, g_cat, mouse_start, cat_start, food) EQUALS 1
    END FUNCTION

    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)
        FUNCTION get_prev_states(state)
            SET m TO state AT 0
            SET c TO state AT 1
            SET t TO state AT 2
            SET pt TO t XOR 1
            SET pre TO EMPTY LIST
            IF pt EQUALS 1
                FOR EACH pc IN g_cat[c]
                    IF ans[m][pc][1] EQUALS 0
                        APPEND (m, pc, pt) TO pre
            ELSE
                FOR EACH pm IN g_mouse[m]
                    IF ans[pm][c][0] EQUALS 0
                        APPEND (pm, c, 0) TO pre
            RETURN pre
        END FUNCTION

        SET n TO LENGTH OF g_mouse
        SET degree TO 3D LIST OF SIZE [n][n][2] WITH ALL VALUES 0
        FOR i FROM 0 TO n - 1
            FOR j FROM 0 TO n - 1
                SET degree[i][j][0] TO LENGTH OF g_mouse[i]
                SET degree[i][j][1] TO LENGTH OF g_cat[j]

        SET ans TO 3D LIST OF SIZE [n][n][2] WITH ALL VALUES 0
        SET q TO EMPTY DEQUE
        FOR i FROM 0 TO n - 1
            SET ans[hole][i][1] TO 1
            SET ans[i][hole][0] TO 2
            SET ans[i][i][1] TO 2
            SET ans[i][i][0] TO 2
            APPEND (hole, i, 1) TO q
            APPEND (i, hole, 0) TO q
            APPEND (i, i, 0) TO q
            APPEND (i, i, 1) TO q

        WHILE q IS NOT EMPTY
            SET state TO POP LEFT FROM q
            SET t TO ans[state AT 0][state AT 1][state AT 2]
            FOR EACH prev_state IN get_prev_states(state)
                SET pm TO prev_state AT 0
                SET pc TO prev_state AT 1
                SET pt TO prev_state AT 2
                IF pt EQUALS t - 1
                    SET ans[pm][pc][pt] TO t
                    APPEND prev_state TO q
                ELSE
                    DECREMENT degree[pm][pc][pt] BY 1
                    IF degree[pm][pc][pt] EQUALS 0
                        SET ans[pm][pc][pt] TO t
                        APPEND prev_state TO q
        RETURN ans[mouse_start][cat_start][0]
    END FUNCTION
END CLASS
```