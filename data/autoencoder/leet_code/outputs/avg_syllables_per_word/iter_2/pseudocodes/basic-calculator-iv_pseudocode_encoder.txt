CLASS Term
    FUNCTION __init__(self, coefficient: int, variables: List of strings)
        SET self.coefficient TO coefficient
        SET self.variables TO variables
    END FUNCTION

    FUNCTION __lt__(self, other)
        IF LENGTH OF self.variables NOT EQUAL LENGTH OF other.variables THEN
            RETURN LENGTH OF self.variables GREATER THAN LENGTH OF other.variables
        END IF
        RETURN STRING JOIN self.variables WITH '*' LESS THAN STRING JOIN other.variables WITH '*'
    END FUNCTION

    FUNCTION __repr__(self)
        IF self.variables IS EMPTY THEN
            RETURN STRING REPRESENTATION OF self.coefficient
        END IF
        RETURN STRING CONCATENATION OF self.coefficient, '*', AND JOINED self.variables WITH '*'
    END FUNCTION
END CLASS

CLASS Expression
    FUNCTION __init__(self)
        SET self.terms TO DEFAULT DICTIONARY WITH DEFAULT VALUE 0
    END FUNCTION

    FUNCTION add_term(self, term: Term)
        SET key TO SORTED TUPLE OF term.variables
        INCREMENT self.terms[key] BY term.coefficient
    END FUNCTION

    FUNCTION multiply(self, other)
        CREATE result AS NEW Expression
        FOR EACH vars1, coeff1 IN self.terms
            FOR EACH vars2, coeff2 IN other.terms
                SET combined_vars TO SORTED LIST OF vars1 CONCATENATED WITH vars2
                CALL result.add_term WITH NEW Term(coeff1 MULTIPLIED BY coeff2, combined_vars)
            END FOR
        END FOR
        RETURN result
    END FUNCTION

    FUNCTION add(self, other)
        FOR EACH vars, coeff IN other.terms
            CALL self.add_term WITH NEW Term(coeff, LIST OF vars)
        END FOR
        RETURN self
    END FUNCTION

    FUNCTION subtract(self, other)
        FOR EACH vars, coeff IN other.terms
            CALL self.add_term WITH NEW Term(NEGATIVE coeff, LIST OF vars)
        END FOR
        RETURN self
    END FUNCTION

    FUNCTION evaluate(self, var_map)
        CREATE result AS NEW Expression
        FOR EACH vars, coeff IN self.terms
            SET new_vars TO EMPTY LIST
            FOR EACH var IN vars
                IF var EXISTS IN var_map THEN
                    APPEND STRING REPRESENTATION OF var_map[var] TO new_vars
                ELSE
                    APPEND var TO new_vars
                END IF
            END FOR
            IF new_vars IS NOT EMPTY THEN
                SET new_coeff TO EVALUATION OF CONCATENATED new_vars AS STRING
            ELSE
                SET new_coeff TO 1
            END IF
            CALL result.add_term WITH NEW Term(coeff MULTIPLIED BY new_coeff, EMPTY LIST)
        END FOR
        RETURN result
    END FUNCTION

    FUNCTION simplify(self)
        SET simplified_terms TO LIST OF Term(coeff, LIST OF vars) FOR EACH vars, coeff IN self.terms WHERE coeff NOT EQUAL 0
        SORT simplified_terms USING Term.__lt__ LOGIC
        RETURN simplified_terms
    END FUNCTION

    FUNCTION __repr__(self)
        RETURN STRING JOINED BY ' + ' OF REPRESENTATION OF EACH TERM IN self.simplify()
    END FUNCTION
END CLASS

CLASS Solution
    FUNCTION basicCalculatorIV(self, expression: STRING, evalvars: LIST OF STRING, evalints: LIST OF INTEGER) RETURNS LIST OF STRING
        SET var_map TO DICTIONARY MAPPING evalvars TO evalints
        SET tokens TO LIST OF SUBSTRINGS MATCHING PARENTHESES, OPERATORS, NUMBERS, OR WORDS IN expression
        SET output TO EMPTY LIST
        SET operators TO EMPTY LIST

        FUNCTION apply_operator()
            SET right TO REMOVE LAST ELEMENT FROM output
            SET left TO REMOVE LAST ELEMENT FROM output
            SET op TO REMOVE LAST ELEMENT FROM operators
            IF op EQUALS '+'
                APPEND left.add(right) TO output
            ELSE IF op EQUALS '-'
                APPEND left.subtract(right) TO output
            ELSE IF op EQUALS '*'
                APPEND left.multiply(right) TO output
            END IF
        END FUNCTION

        SET i TO 0
        WHILE i LESS THAN LENGTH OF tokens
            SET token TO tokens[i]
            IF token IS DIGIT
                CREATE new_exp AS NEW Expression
                CALL new_exp.add_term WITH NEW Term(INTEGER VALUE OF token, EMPTY LIST)
                APPEND new_exp TO output
            ELSE IF token IS ALPHABETIC STRING
                CREATE new_exp AS NEW Expression
                SET coef TO var_map GET token DEFAULT 1
                IF coef EQUALS 1
                    IF token NOT IN var_map THEN
                        CALL new_exp.add_term WITH NEW Term(1, LIST CONTAINING token)
                    ELSE
                        CALL new_exp.add_term WITH NEW Term(1, EMPTY LIST)
                    END IF
                ELSE
                    CALL new_exp.add_term WITH NEW Term(coef, EMPTY LIST)
                END IF
                APPEND new_exp TO output
            ELSE IF token EQUALS '('
                APPEND token TO operators
            ELSE IF token EQUALS ')'
                WHILE operators NOT EMPTY AND LAST ELEMENT OF operators NOT EQUAL TO '('
                    CALL apply_operator()
                END WHILE
                REMOVE LAST ELEMENT FROM operators
            ELSE IF token IN '+-*'
                WHILE operators NOT EMPTY AND LAST ELEMENT OF operators NOT EQUAL '(' AND (token IN '+-' OR LAST ELEMENT OF operators EQUALS '*')
                    CALL apply_operator()
                END WHILE
                APPEND token TO operators
            END IF
            INCREMENT i BY 1
        END WHILE

        WHILE operators NOT EMPTY
            CALL apply_operator()
        END WHILE

        SET simplified_terms TO FIRST ELEMENT OF output CALL simplify()
        RETURN LIST OF STRINGS FORMATTED AS "{coefficient}*{joined variables}" IF VARIABLES EXIST ELSE STRING OF coefficient FOR EACH term IN simplified_terms
    END FUNCTION
END CLASS