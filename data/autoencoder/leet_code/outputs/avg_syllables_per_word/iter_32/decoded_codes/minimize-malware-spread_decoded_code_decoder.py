from typing import List, Set

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def dfs(node: int, component: Set[int]) -> None:
            if node in visited:
                return
            visited.add(node)
            component.add(node)
            for neighbor in range(len(graph)):
                if graph[node][neighbor] == 1 and neighbor not in visited:
                    dfs(neighbor, component)

        visited: Set[int] = set()
        components: List[Set[int]] = []

        # Find connected components using DFS
        for node in range(len(graph)):
            if node not in visited:
                component: Set[int] = set()
                dfs(node, component)
                components.append(component)

        infected_count = [0] * len(graph)
        for node in initial:
            infected_count[node] = 1  # Mark infected nodes

        component_infected_count = [0] * len(components)
        # Count how many infected nodes each component contains
        for node in initial:
            for i, component in enumerate(components):
                if node in component:
                    component_infected_count[i] += 1

        max_saving = 0
        best_node = min(initial)

        # Find the node which, when removed, saves the largest connected component uniquely infected by it
        for node in initial:
            for i, component in enumerate(components):
                if node in component and component_infected_count[i] == 1:
                    saving = len(component)
                    if saving > max_saving or (saving == max_saving and node < best_node):
                        max_saving = saving
                        best_node = node

        return best_node