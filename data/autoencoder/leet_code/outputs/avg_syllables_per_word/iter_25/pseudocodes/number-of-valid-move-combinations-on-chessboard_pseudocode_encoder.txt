CLASS Solution  
    FUNCTION countCombinations(pieces, positions)  
        SET directions TO a mapping with keys and values as follows  
            MAP rook TO a list of vectors representing one step down one step up one step right one step left  
            MAP queen TO a list of vectors representing one step down one step up one step right one step left one step down and right one step up and right one step down and left one step up and left  
            MAP bishop TO a list of vectors representing one step down and right one step up and right one step down and left one step up and left  
        
        SET positions TO a new list constructed by transforming each pair in positions by subtracting one from each element of the pair  
        
        FUNCTION get_destinations(start, piece_type)  
            SET r TO the first element of start  
            SET c TO the second element of start  
            SET dests TO a list initially containing start  
            FOR each vector dr dc in the list directions at key piece_type  
                SET nr TO r plus dr  
                SET nc TO c plus dc  
                WHILE nr is greater than or equal to zero AND nr is less than eight AND nc is greater than or equal to zero AND nc is less than eight  
                    APPEND the pair nr nc TO dests  
                    INCREMENT nr BY dr  
                    INCREMENT nc BY dc  
                END WHILE  
            END FOR  
            RETURN dests  
        END FUNCTION  
        
        SET all_destinations TO a new list constructed by pairing each element pos in positions with each element piece in pieces and applying get_destinations to pos and piece  
        
        FUNCTION is_valid_combination(combination)  
            SET pos TO a shallow copy of positions  
            SET n TO the length of pos  
            WHILE always true  
                IF the size of the set made from elements of pos is less than n  
                    RETURN false  
                END IF  
                SET all_reached TO true  
                FOR i FROM zero TO n MINUS one  
                    IF element at position i of pos equals element at position i of combination  
                        CONTINUE to the next iteration  
                    END IF  
                    SET all_reached TO false  
                    SET r TO element at position zero of element at position i of pos  
                    SET c TO element at position one of element at position i of pos  
                    IF element at position zero of element at position i of combination is greater than r  
                        SET dr TO one  
                    ELSE IF element at position zero of element at position i of combination is less than r  
                        SET dr TO negative one  
                    ELSE  
                        SET dr TO zero  
                    END IF  
                    IF element at position one of element at position i of combination is greater than c  
                        SET dc TO one  
                    ELSE IF element at position one of element at position i of combination is less than c  
                        SET dc TO negative one  
                    ELSE  
                        SET dc TO zero  
                    END IF  
                    SET element at position i of pos TO the pair r plus dr and c plus dc  
                END FOR  
                IF all_reached is true  
                    RETURN true  
                END IF  
            END WHILE  
        END FUNCTION  
        
        SET valid_count TO zero  
        FOR each combination IN the cartesian product of all_destinations with unpacked arguments  
            IF is_valid_combination(combination) is true  
                INCREMENT valid_count BY one  
            END IF  
        END FOR  
        
        RETURN valid_count  
    END FUNCTION  
END CLASS