CLASS Term
    FUNCTION __init__(self, coefficient, variables)
        SET self.coefficient TO coefficient
        SET self.variables TO variables
    END FUNCTION

    FUNCTION __lt__(self, other)
        IF LENGTH OF self.variables IS NOT EQUAL TO LENGTH OF other.variables THEN
            RETURN LENGTH OF self.variables GREATER THAN LENGTH OF other.variables
        END IF
        RETURN JOIN self.variables WITH '*' LESS THAN JOIN other.variables WITH '*'
    END FUNCTION

    FUNCTION __repr__(self)
        IF self.variables IS EMPTY THEN
            RETURN STRING OF self.coefficient
        ELSE
            RETURN CONCATENATE STRING OF self.coefficient, '*', AND JOIN self.variables WITH '*'
        END IF
    END FUNCTION
END CLASS

CLASS Expression
    FUNCTION __init__(self)
        SET self.terms TO A DEFAULT DICTIONARY WITH INT DEFAULT VALUE
    END FUNCTION

    FUNCTION add_term(self, term)
        SET key TO SORTED TUPLE OF term.variables
        INCREMENT self.terms[key] BY term.coefficient
    END FUNCTION

    FUNCTION multiply(self, other)
        SET result TO NEW Expression
        FOR EACH vars1, coeff1 IN self.terms
            FOR EACH vars2, coeff2 IN other.terms
                SET combined_vars TO SORTED LIST OF vars1 CONCATENATED WITH vars2
                CALL result.add_term WITH Term(coeff1 MULTIPLIED BY coeff2, combined_vars)
            END FOR
        END FOR
        RETURN result
    END FUNCTION

    FUNCTION add(self, other)
        FOR EACH vars, coeff IN other.terms
            CALL self.add_term WITH Term(coeff, LIST OF vars)
        END FOR
        RETURN self
    END FUNCTION

    FUNCTION subtract(self, other)
        FOR EACH vars, coeff IN other.terms
            CALL self.add_term WITH Term(NEGATIVE coeff, LIST OF vars)
        END FOR
        RETURN self
    END FUNCTION

    FUNCTION evaluate(self, var_map)
        SET result TO NEW Expression
        FOR EACH vars, coeff IN self.terms
            SET new_vars TO EMPTY LIST
            FOR EACH var IN vars
                IF var IN var_map THEN
                    APPEND STRING OF var_map[var] TO new_vars
                ELSE
                    APPEND var TO new_vars
                END IF
            END FOR
            IF new_vars IS NOT EMPTY THEN
                SET new_coeff TO EVALUATE CONCATENATION OF new_vars
            ELSE
                SET new_coeff TO 1
            END IF
            CALL result.add_term WITH Term(coeff MULTIPLIED BY new_coeff, EMPTY LIST)
        END FOR
        RETURN result
    END FUNCTION

    FUNCTION simplify(self)
        SET simplified_terms TO EMPTY LIST
        FOR EACH vars, coeff IN self.terms
            IF coeff IS NOT ZERO THEN
                APPEND Term(coeff, LIST OF vars) TO simplified_terms
            END IF
        END FOR
        SORT simplified_terms
        RETURN simplified_terms
    END FUNCTION

    FUNCTION __repr__(self)
        RETURN CONCATENATE WITH ' + ' THE RESULT OF MAPPING __repr__ OVER self.simplify()
    END FUNCTION
END CLASS

CLASS Solution
    FUNCTION basicCalculatorIV(self, expression, evalvars, evalints)
        SET var_map TO DICTIONARY MAPPING evalvars TO evalints
        SET tokens TO ALL MATCHES OF PATTERN '\(|\)|\+|\-|\*|\d+|\w+' IN expression
        SET output TO EMPTY LIST
        SET operators TO EMPTY LIST

        FUNCTION apply_operator()
            SET right TO POP LAST FROM output
            SET left TO POP LAST FROM output
            SET op TO POP LAST FROM operators

            IF op IS '+' THEN
                APPEND left.add(right) TO output
            ELSE IF op IS '-' THEN
                APPEND left.subtract(right) TO output
            ELSE IF op IS '*' THEN
                APPEND left.multiply(right) TO output
            END IF
        END FUNCTION

        SET i TO 0
        WHILE i LESS THAN LENGTH OF tokens
            SET token TO tokens[i]

            IF token IS DIGIT THEN
                APPEND NEW Expression TO output
                CALL output LAST ELEMENT add_term WITH Term(INTEGER VALUE OF token, EMPTY LIST)
            ELSE IF token IS ALPHA THEN
                APPEND NEW Expression TO output
                SET coef TO var_map VALUE FOR token WITH DEFAULT 1
                IF coef EQUALS 1 THEN
                    IF token NOT IN var_map THEN
                        CALL output LAST ELEMENT add_term WITH Term(1, LIST WITH token)
                    ELSE
                        CALL output LAST ELEMENT add_term WITH Term(1, EMPTY LIST)
                    END IF
                ELSE
                    CALL output LAST ELEMENT add_term WITH Term(coef, EMPTY LIST)
                END IF
            ELSE IF token IS '(' THEN
                APPEND token TO operators
            ELSE IF token IS ')' THEN
                WHILE operators IS NOT EMPTY AND LAST OF operators IS NOT '('
                    CALL apply_operator()
                END WHILE
                POP LAST FROM operators  // Remove '('
            ELSE IF token IN ['+', '-', '*'] THEN
                WHILE operators IS NOT EMPTY AND LAST OF operators IS NOT '(' AND (token IN ['+', '-'] OR LAST OF operators IS '*')
                    CALL apply_operator()
                END WHILE
                APPEND token TO operators
            END IF

            INCREMENT i BY 1
        END WHILE

        WHILE operators IS NOT EMPTY
            CALL apply_operator()
        END WHILE

        SET simplified_terms TO CALL output FIRST ELEMENT simplify()
        RETURN LIST OF STRINGS FOR EACH term IN simplified_terms WHERE
            IF term.variables IS NOT EMPTY THEN
                FORMAT AS CONCATENATION OF term.coefficient, '*', AND JOIN term.variables WITH '*'
            ELSE
                STRING OF term.coefficient
END FUNCTION
END CLASS