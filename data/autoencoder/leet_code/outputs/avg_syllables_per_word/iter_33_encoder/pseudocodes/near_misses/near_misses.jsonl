{"task_id": "letter-combinations-of-a-phone-number", "passing_rate": 0.9736842105263158, "pseudocode": "CLASS Solution  \n    FUNCTION letterCombinations(digits)  \n        IF digits EQUALS empty string THEN  \n            RETURN empty list  \n        END IF  \n        \n        SET phone_map TO mapping of digit two TO letters a b c AND digit three TO letters d e f AND digit four TO letters g h i AND digit five TO letters j k l AND digit six TO letters m n o AND digit seven TO letters p q r s AND digit eight TO letters t u v AND digit nine TO letters w x y z  \n        \n        FUNCTION backtrack(combination, next_digits)  \n            IF the LENGTH OF next_digits EQUALS zero THEN  \n                APPEND combination TO output  \n            ELSE  \n                FOR each letter IN letters mapped by the element at position zero of next_digits in phone_map  \n                    CALL backtrack WITH the concatenation of combination AND letter AND the substring of next_digits from position one TO the end  \n                END FOR  \n            END IF  \n        END FUNCTION  \n        \n        SET output TO empty list  \n        CALL backtrack WITH empty string AND digits  \n        RETURN output  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "substring-with-concatenation-of-all-words", "passing_rate": 0.9807692307692307, "pseudocode": "CLASS Solution  \n    FUNCTION findSubstring(s parameter TO string, words parameter TO list of strings) RETURNS list of integers  \n        IF the LENGTH OF s EQUALS zero OR the LENGTH OF words EQUALS zero OR the LENGTH OF the element at position zero of words EQUALS zero  \n            RETURN an empty list  \n        END IF  \n        \n        SET word_length TO the LENGTH OF the element at position zero of words  \n        SET num_words TO the LENGTH OF words  \n        SET total_length TO word_length MULTIPLIED BY num_words  \n        SET word_count TO the frequency COUNTER of words  \n        SET result TO an empty list  \n        \n        FOR index i FROM zero TO the LENGTH OF s MINUS total_length PLUS one  \n            SET seen TO an empty frequency COUNTER  \n            FOR index j FROM i TO i PLUS total_length MINUS one IN STEPS OF word_length  \n                SET word TO the substring from position j TO position j PLUS word_length MINUS one of s  \n                INCREMENT the count of word IN seen BY one  \n                IF the count of word IN seen IS GREATER THAN the count of word IN word_count  \n                    BREAK the inner loop  \n                END IF  \n            END FOR  \n            IF the inner loop did not break  \n                APPEND i TO result  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum", "passing_rate": 0.9574468085106383, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum(candidates, target)  \n        FUNCTION backtrack(start, target, path)  \n            IF target EQUALS zero  \n                APPEND path TO result  \n                RETURN  \n            END IF  \n            IF target LESS THAN zero  \n                RETURN  \n            END IF  \n            FOR i FROM start TO the LENGTH OF candidates MINUS one  \n                CALL backtrack WITH i AND target MINUS element at position i of candidates AND path APPENDED WITH element at position i of candidates  \n            END FOR  \n        END FUNCTION  \n        SET result TO empty list  \n        CALL backtrack WITH zero AND target AND empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutation-sequence", "passing_rate": 0.9259259259259259, "pseudocode": "CLASS Solution  \n    FUNCTION getPermutation(n k)  \n        SET numbers TO list of numbers starting from one TO n  \n        DECREMENT k BY one  \n        SET result TO empty list  \n        FOR i FROM n DOWN TO one  \n            SET fact TO factorial of i MINUS one  \n            SET index TO k DIVIDED BY fact  \n            APPEND element at position index of numbers converted to string TO result  \n            REMOVE element at position index FROM numbers  \n            SET k TO k MODULO fact  \n        END FOR  \n        RETURN concatenation of all elements of result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-a-2d-matrix", "passing_rate": 0.9791666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION searchMatrix(matrix, target)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN False  \n        END IF  \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n MINUS one  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the INTEGER DIVISION of left PLUS right BY two  \n            SET mid_value TO element at position mid DIVIDED BY n of matrix AT element at position mid MODULO n  \n            IF mid_value EQUALS target  \n                RETURN True  \n            ELSE IF mid_value LESS THAN target  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "single-number-ii", "passing_rate": 0.9423076923076923, "pseudocode": "CLASS Solution  \n    FUNCTION singleNumber(nums)  \n        SET ones TO zero  \n        SET twos TO zero  \n        FOR each num IN nums  \n            SET ones TO the bitwise XOR of ones and num AND the bitwise NOT of twos  \n            SET twos TO the bitwise XOR of twos and num AND the bitwise NOT of ones  \n        END FOR  \n        RETURN ones  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-points-on-a-line", "passing_rate": 0.9473684210526315, "pseudocode": "CLASS Solution  \n    FUNCTION maxPoints(points)  \n        FUNCTION slope(p1, p2)  \n            IF element at position zero of p1 EQUALS element at position zero of p2  \n                RETURN positive infinity  \n            END IF  \n            RETURN the difference of element at position one of p1 MINUS element at position one of p2 DIVIDED BY the difference of element at position zero of p1 MINUS element at position zero of p2  \n        END FUNCTION  \n\n        SET max_points TO zero  \n\n        FOR i FROM zero TO the length of points MINUS one  \n            SET slopes TO a new mapping that returns zero for missing keys  \n            FOR j FROM zero TO the length of points MINUS one  \n                IF i NOT EQUALS j  \n                    SET s TO slope of element at position i of points AND element at position j of points  \n                    INCREMENT value in slopes at key s BY one  \n                    IF value in slopes at key s GREATER THAN max_points  \n                        SET max_points TO value in slopes at key s  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n\n        IF points is not empty  \n            RETURN max_points PLUS one  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-minimum-in-rotated-sorted-array", "passing_rate": 0.9803921568627451, "pseudocode": "CLASS Solution  \n    FUNCTION findMin(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        IF element at position left of nums LESS THAN element at position right of nums  \n            RETURN element at position left of nums  \n        END IF  \n        WHILE left LESS THAN right  \n            SET mid TO the INTEGER RESULT OF left PLUS right DIVIDED BY two  \n            IF element at position mid of nums GREATER THAN element at position right of nums  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        RETURN element at position left of nums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-gap", "passing_rate": 0.9318181818181818, "pseudocode": "CLASS Solution  \n    FUNCTION maximumGap(nums)  \n        IF the LENGTH OF nums LESS THAN two THEN  \n            RETURN zero  \n        END IF  \n        \n        FUNCTION countingSort(arr, exp)  \n            SET n TO the LENGTH OF arr  \n            SET output TO a list of zeros with the LENGTH OF arr  \n            SET count TO a list of zeros with LENGTH ten  \n            \n            FOR i FROM zero TO n MINUS one  \n                SET index TO the element at position i of arr DIVIDED BY exp  \n                INCREMENT the element at position index MODULO ten of count BY one  \n            END FOR  \n            \n            FOR i FROM one TO nine  \n                INCREMENT the element at position i of count BY the element at position i MINUS one of count  \n            END FOR  \n            \n            SET i TO n MINUS one  \n            WHILE i GREATER THAN OR EQUAL TO zero  \n                SET index TO the element at position i of arr DIVIDED BY exp  \n                SET the element at position the element at position index MODULO ten of count MINUS one of output TO the element at position i of arr  \n                DECREMENT the element at position index MODULO ten of count BY one  \n                DECREMENT i BY one  \n            END WHILE  \n            \n            FOR i FROM zero TO n MINUS one  \n                SET the element at position i of arr TO the element at position i of output  \n            END FOR  \n        END FUNCTION  \n        \n        FUNCTION radixSort(arr)  \n            SET max1 TO the maximum element of arr  \n            SET exp TO one  \n            WHILE the integer division of max1 BY exp GREATER THAN zero  \n                CALL countingSort with arr and exp  \n                SET exp TO exp MULTIPLIED BY ten  \n            END WHILE  \n        END FUNCTION  \n        \n        CALL radixSort with nums  \n        \n        SET max_diff TO zero  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            SET difference TO the element at position i of nums MINUS the element at position i MINUS one of nums  \n            IF difference GREATER THAN max_diff THEN  \n                SET max_diff TO difference  \n            END IF  \n        END FOR  \n        \n        RETURN max_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "two-sum-ii-input-array-is-sorted", "passing_rate": 0.9333333333333333, "pseudocode": "CLASS Solution  \n    FUNCTION twoSum(numbers AS list of integer, target AS integer) RETURNS list of integer  \n        SET left TO zero  \n        SET right TO the LENGTH OF numbers MINUS one  \n        WHILE left LESS THAN right  \n            SET current_sum TO the element at position left of numbers PLUS the element at position right of numbers  \n            IF current_sum EQUALS target  \n                RETURN a list consisting of left PLUS one and right PLUS one  \n            ELSE IF current_sum LESS THAN target  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-skyline-problem", "passing_rate": 0.9607843137254902, "pseudocode": "CLASS Solution  \n    FUNCTION getSkyline(buildings)  \n        SET events TO empty list  \n        FOR each building IN buildings  \n            SET left TO first element of building  \n            SET right TO second element of building  \n            SET height TO third element of building  \n            APPEND a tuple consisting of left position and negative height and right position TO events  \n            APPEND a tuple consisting of right position and zero and zero TO events  \n        END FOR  \n        \n        SORT events in ascending order by first element then by second element then by third element  \n        \n        SET result TO a list containing a list of zero and zero  \n        SET max_heap TO a list containing a tuple of zero and a representation of infinity  \n        \n        FOR each tuple of x position negH and r in events  \n            WHILE the second element of the first tuple in max_heap LESS THAN OR EQUAL TO x position holds  \n                REMOVE the first tuple from max_heap according to heap property  \n            END WHILE  \n            \n            IF negH NOT EQUALS zero  \n                ADD a tuple consisting of negH and r INTO max_heap according to heap property  \n            END IF  \n            \n            IF the second element of the last list in result NOT EQUALS the negative of the first element of the first tuple in max_heap  \n                APPEND a list consisting of x position and the negative of the first element of the first tuple in max_heap TO result  \n            END IF  \n        END FOR  \n        \n        IF the first list in result EQUALS a list of zero and zero  \n            REMOVE the first list from result  \n        END IF  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-a-2d-matrix-ii", "passing_rate": 0.9803921568627451, "pseudocode": "CLASS Solution  \n    FUNCTION searchMatrix(matrix, target)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN false  \n        END IF  \n\n        SET row TO zero  \n        SET col TO the LENGTH OF element at position zero of matrix MINUS one  \n\n        WHILE row LESS THAN the LENGTH OF matrix AND col GREATER THAN OR EQUAL TO zero  \n            IF element at position row of matrix AT position col EQUALS target  \n                RETURN true  \n            ELSE IF element at position row of matrix AT position col GREATER THAN target  \n                DECREMENT col BY one  \n            ELSE  \n                INCREMENT row BY one  \n            END IF  \n        END WHILE  \n\n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "meeting-rooms-ii", "passing_rate": 0.9607843137254902, "pseudocode": "CLASS Solution  \n    FUNCTION minMeetingRooms(intervals)  \n        IF intervals EQUALS empty list  \n            RETURN zero  \n        END IF  \n\n        SORT intervals IN ORDER OF element at position one of each meeting  \n\n        SET min_heap TO empty list  \n\n        FOR each meeting IN intervals  \n            IF min_heap NOT EQUALS empty list AND element at position zero of meeting GREATER THAN OR EQUAL TO element at position zero of element at position zero of min_heap  \n                REMOVE the smallest element FROM min_heap  \n            END IF  \n\n            ADD element at position one of meeting TO min_heap  \n        END FOR  \n\n        RETURN the LENGTH OF min_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "alien-dictionary", "passing_rate": 0.8461538461538461, "pseudocode": "CLASS Solution  \n    FUNCTION alienOrder(words)  \n        SET graph TO an empty mapping of character to set of characters  \n        SET indegree TO an empty mapping of character to integer  \n        SET all_chars TO the set of all characters occurring in the concatenation of all elements in words  \n        FOR index FROM zero TO the length of words MINUS one MINUS one  \n            SET word1 TO the element at position index of words  \n            SET word2 TO the element at position index PLUS one of words  \n            SET min_length TO the lesser value between the length of word1 and the length of word2  \n            SET found TO false  \n            FOR position FROM zero TO min_length MINUS one  \n                IF the character at position of word1 NOT EQUALS the character at position of word2  \n                    IF the character at position of word2 IS NOT in the set associated with the character at position of word1 in graph  \n                        ADD the character at position of word2 TO the set associated with the character at position of word1 in graph  \n                        INCREMENT the integer value associated with the character at position of word2 in indegree BY one  \n                    END IF  \n                    SET found TO true  \n                    BREAK out of the inner loop  \n                END IF  \n            END FOR  \n            IF found EQUALS false AND the length of word1 GREATER THAN the length of word2  \n                RETURN an empty string  \n            END IF  \n        END FOR  \n        SET queue TO a double-ended queue initialized with all characters from all_chars for which the integer value in indegree is equal to zero or the character is not in indegree  \n        SET result TO an empty list  \n        WHILE the queue is not empty  \n            REMOVE the element from the left end of queue and ASSIGN it to char  \n            APPEND char TO result  \n            FOR each neighbor IN the set associated with char in graph  \n                DECREMENT the integer value associated with neighbor in indegree BY one  \n                IF the integer value associated with neighbor in indegree EQUALS zero  \n                    APPEND neighbor TO the right end of queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        IF the length of result NOT EQUALS the length of all_chars  \n            RETURN an empty string  \n        END IF  \n        RETURN the concatenation of all elements of result as a single string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-to-english-words", "passing_rate": 0.9545454545454546, "pseudocode": "CLASS Solution  \n    FUNCTION numberToWords(num)  \n        IF num EQUALS zero  \n            RETURN the word zero  \n        END IF  \n        \n        SET below_twenty TO list of words representing numbers from zero up to nineteen with empty string for zero position  \n        SET tens TO list of words representing multiples of ten from zero up to ninety with empty strings for positions zero and one  \n        SET thousands TO list of words for thousands units including empty string for units, thousand, million, billion  \n        \n        FUNCTION helper(n)  \n            IF n EQUALS zero  \n                RETURN empty string  \n            ELSE IF n LESS THAN twenty  \n                RETURN the element at position n of below_twenty concatenated with a space  \n            ELSE IF n LESS THAN one hundred  \n                RETURN the element at position equal to integer division of n by ten of tens concatenated with a space concatenated with helper called recursively on n modulo ten  \n            ELSE  \n                RETURN the element at position equal to integer division of n by one hundred of below_twenty concatenated with the word hundred and a space concatenated with helper called recursively on n modulo one hundred  \n            END IF  \n        END FUNCTION  \n        \n        SET result TO empty string  \n        SET i TO zero  \n        \n        WHILE num GREATER THAN zero  \n            IF num modulo one thousand NOT EQUALS zero  \n                SET result TO helper called on num modulo one thousand concatenated with the element at position i of thousands concatenated with a space concatenated with result  \n            END IF  \n            SET num TO integer division of num by one thousand  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        RETURN result after removing leading and trailing spaces  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-height-trees", "passing_rate": 0.9333333333333333, "pseudocode": "CLASS Solution  \n    FUNCTION findMinHeightTrees(n, edges)  \n        IF n EQUALS one  \n            RETURN a list containing the element zero  \n        END IF  \n        ASSIGN graph TO an empty map with default value as an empty list  \n        ASSIGN degree TO a list of zeros with length equal to n  \n        FOR each pair of elements u and v IN edges  \n            APPEND element v TO the list at key u in graph  \n            APPEND element u TO the list at key v in graph  \n            INCREMENT element at position u of degree BY one  \n            INCREMENT element at position v of degree BY one  \n        END FOR  \n        ASSIGN leaves TO an empty double ended queue  \n        FOR each index i FROM zero TO n MINUS one  \n            IF element at position i of degree EQUALS one  \n                APPEND element i TO leaves  \n            END IF  \n        END FOR  \n        SET remaining_nodes TO n  \n        WHILE remaining_nodes GREATER THAN two  \n            ASSIGN leaves_count TO the length of leaves  \n            DECREMENT remaining_nodes BY leaves_count  \n            FOR counter FROM one TO leaves_count  \n                REMOVE element from the left of leaves and ASSIGN TO leaf  \n                FOR each neighbor IN the list at key leaf in graph  \n                    DECREMENT element at position neighbor of degree BY one  \n                    IF element at position neighbor of degree EQUALS one  \n                        APPEND neighbor TO leaves  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n        RETURN a list created from the elements in leaves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "range-addition", "passing_rate": 0.9512195121951219, "pseudocode": "CLASS Solution  \n    FUNCTION getModifiedArray(length updates)  \n        SET diff TO list of zeros with size length PLUS one  \n        FOR each element startIdx endIdx inc IN updates  \n            SET element at position startIdx of diff TO element at position startIdx of diff PLUS inc  \n            IF endIdx PLUS one LESS THAN length THEN  \n                SET element at position endIdx PLUS one of diff TO element at position endIdx PLUS one of diff MINUS inc  \n            END IF  \n        END FOR  \n        SET arr TO list of zeros with size length  \n        SET element at position zero of arr TO element at position zero of diff  \n        FOR i FROM one TO length MINUS one  \n            SET element at position i of arr TO element at position i MINUS one of arr PLUS element at position i of diff  \n        END FOR  \n        RETURN arr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-absolute-file-path", "passing_rate": 0.9811320754716981, "pseudocode": "CLASS Solution  \n    FUNCTION lengthLongestPath(input)  \n        SET lines TO list of elements obtained by splitting input at each occurrence of newline character  \n        SET stack TO empty list  \n        SET max_length TO zero  \n        \n        FOR each line IN lines  \n            SET depth TO the number of tab characters contained in line  \n            SET name TO the substring of line starting from position depth to the end  \n            \n            WHILE the LENGTH OF stack IS GREATER THAN depth  \n                REMOVE the last element FROM stack  \n            END WHILE  \n            \n            IF the LENGTH OF stack IS GREATER THAN zero  \n                SET current_length TO the last element of stack PLUS the LENGTH OF name PLUS one  \n            ELSE  \n                SET current_length TO the LENGTH OF name  \n            END IF  \n            \n            IF name CONTAINS the character period  \n                IF current_length IS GREATER THAN max_length  \n                    SET max_length TO current_length  \n                END IF  \n            ELSE  \n                APPEND current_length TO stack  \n            END IF  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ternary-expression-parser", "passing_rate": 0.8148148148148148, "pseudocode": "CLASS Solution  \n    FUNCTION parseTernary(expression)  \n        FUNCTION evaluate(index)  \n            IF index EQUALS the LENGTH OF expression MINUS one OR the element at position index PLUS one of expression EQUALS the character colon  \n                RETURN the element at position index of expression AND index PLUS two  \n            END IF  \n            SET true_part AND next_index TO the result of evaluate called with index PLUS two  \n            SET false_part AND final_index TO the result of evaluate called with next_index  \n            IF the element at position index of expression EQUALS the character T  \n                RETURN true_part AND final_index  \n            ELSE  \n                RETURN false_part AND final_index  \n            END IF  \n        END FUNCTION  \n        SET result AND ignored TO the result of evaluate called with zero  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "circular-array-loop", "passing_rate": 0.8571428571428571, "pseudocode": "CLASS Solution  \n    FUNCTION circularArrayLoop(nums)  \n        FUNCTION sameDirection(val1 val2)  \n            IF val1 GREATER THAN zero AND val2 GREATER THAN zero OR val1 LESS THAN zero AND val2 LESS THAN zero  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n      \n        SET n TO the LENGTH OF nums  \n      \n        FOR i FROM zero TO n MINUS one  \n            SET slow TO i  \n            SET fast TO i  \n          \n            IF element at position i of nums EQUALS zero  \n                CONTINUE TO next iteration  \n            END IF  \n          \n            WHILE true  \n                SET slow TO element at position slow PLUS element at position slow of nums MODULO n  \n                IF slow LESS THAN zero  \n                    INCREMENT slow BY n  \n                END IF  \n              \n                SET fast TO element at position fast PLUS element at position fast of nums MODULO n  \n                IF fast LESS THAN zero  \n                    INCREMENT fast BY n  \n                END IF  \n                SET fast TO element at position fast PLUS element at position fast of nums MODULO n  \n                IF fast LESS THAN zero  \n                    INCREMENT fast BY n  \n                END IF  \n              \n                IF NOT sameDirection(element at position slow of nums element at position i of nums) OR NOT sameDirection(element at position fast of nums element at position i of nums)  \n                    BREAK  \n                END IF  \n              \n                IF slow EQUALS fast  \n                    IF slow EQUALS element at position slow PLUS element at position slow of nums MODULO n  \n                        BREAK  \n                    END IF  \n                    RETURN true  \n                END IF  \n            END WHILE  \n        END FOR  \n      \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "encode-string-with-shortest-length", "passing_rate": 0.8333333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION encode(s)  \n        FUNCTION get_encoded_length(count, substring)  \n            RETURN the LENGTH OF the string representation of count PLUS the LENGTH OF substring PLUS two for opening bracket and closing bracket  \n        END FUNCTION\n\n        FUNCTION dp(i, j)  \n            SET substring TO the part of s from position i to position j inclusive  \n            SET n TO j MINUS i PLUS one  \n            IF n LESS THAN five THEN  \n                RETURN substring  \n            END IF  \n            \n            SET shortest TO substring  \n            FOR k FROM one TO the integer division of n BY two PLUS one  \n                IF n MODULO k EQUALS zero THEN  \n                    SET repeat_count TO n DIVIDED BY k  \n                    IF substring EQUALS the sequence of substring from start to position k MINUS one REPEATED repeat_count times THEN  \n                        SET encoded_candidate TO the string representation of repeat_count CONCATENATED WITH one opening bracket CONCATENATED WITH dp(i, i PLUS k MINUS one) CONCATENATED WITH one closing bracket  \n                        IF the LENGTH OF encoded_candidate LESS THAN the LENGTH OF shortest THEN  \n                            SET shortest TO encoded_candidate  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR\n\n            FOR k FROM i TO j MINUS one  \n                SET left_encoded TO dp(i, k)  \n                SET right_encoded TO dp(k PLUS one, j)  \n                SET combined TO left_encoded CONCATENATED WITH right_encoded  \n                IF the LENGTH OF combined LESS THAN the LENGTH OF shortest THEN  \n                    SET shortest TO combined  \n                END IF  \n            END FOR\n\n            RETURN shortest  \n        END FUNCTION\n\n        RETURN dp(zero, the LENGTH OF s MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "magical-string", "passing_rate": 0.88, "pseudocode": "CLASS Solution  \n    FUNCTION magicalString(n)  \n        IF n EQUALS zero  \n            RETURN zero  \n        END IF  \n        IF n LESS THAN OR EQUAL TO three  \n            RETURN one  \n        END IF  \n        \n        SET s TO list consisting of one followed by two followed by two  \n        SET count TO one  \n        SET index TO two  \n        \n        WHILE the LENGTH OF s LESS THAN n  \n            SET next_num TO three MINUS the element at position negative one of s  \n            APPEND next_num repeated the number of times equal to the element at position index of s TO s  \n            IF next_num EQUALS one  \n                INCREMENT count BY the element at position index of s  \n            END IF  \n            INCREMENT index BY one  \n        END WHILE  \n        \n        IF the LENGTH OF s GREATER THAN n  \n            DECREMENT count BY the element at position negative one of s MULTIPLIED BY the result of the LENGTH OF s MINUS n  \n        END IF  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-good-base", "passing_rate": 0.8297872340425532, "pseudocode": "CLASS Solution  \n    FUNCTION smallestGoodBase(n)  \n        SET n TO the integer value of n  \n        SET max_length TO the integer value of the base two logarithm of n INCREMENTED BY one  \n        FOR m FROM max_length DOWN TO two  \n            SET k TO the integer part of n RAISED TO THE power of one DIVIDED BY the difference of m MINUS one  \n            IF k LESS THAN two  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            SET numerator TO k RAISED TO THE power of m MINUS one  \n            SET denominator TO k MINUS one  \n            SET num TO the quotient of numerator DIVIDED BY denominator  \n            IF num EQUALS n  \n                RETURN the string representation of k  \n            END IF  \n        END FOR  \n        RETURN the string representation of the difference of n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-closest-palindrome", "passing_rate": 0.875, "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic WITH PARAMETER n  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO the numeric conversion of n  \n            SET result_numeric TO numeric_value MINUS one  \n            RETURN the string conversion of result_numeric  \n        END IF  \n        \n        SET candidates TO an empty set  \n        \n        SET candidate_one TO ten RAISED TO THE POWER OF length PLUS one  \n        SET candidate_two TO ten RAISED TO THE POWER OF length MINUS one MINUS one  \n        ADD candidate_one TO candidates  \n        ADD candidate_two TO candidates  \n        \n        SET prefix TO the numeric conversion of the substring of n FROM position one TO the result of length PLUS one DIVIDED BY two  \n        FOR i FROM negative one TO two MINUS one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO the string conversion of new_prefix_numeric  \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the reverse of new_prefix  \n                SET candidate_string TO the concatenation of new_prefix PLUS reversed_part  \n            ELSE  \n                SET substring_for_reverse TO the substring of new_prefix FROM position one TO the position before the last character in reverse order  \n                SET candidate_string TO the concatenation of new_prefix PLUS substring_for_reverse  \n            END IF  \n            SET candidate_numeric TO the numeric conversion of candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO the numeric conversion of n  \n        REMOVE original_number FROM candidates IF it EXISTS  \n        \n        SET closest TO the element IN candidates THAT HAS the MINIMUM value ACCORDING TO the tuple of the absolute value of element MINUS original_number AND the element ITSELF  \n        \n        RETURN the string conversion of closest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tag-validator", "passing_rate": 0.8653846153846154, "pseudocode": "CLASS Solution  \n    FUNCTION isValid(code)  \n        SET cdata_pattern TO the string that matches the literal sequence less than exclamation mark left square bracket CDATA left square bracket followed by any characters non-greedily followed by right square bracket right square bracket greater than  \n        SET code TO the result of replacing all substrings in code matching cdata_pattern with an empty string  \n        SET stack TO an empty list  \n        SET i TO zero  \n        WHILE i LESS THAN the length of code  \n            IF the element at position i of code EQUALS less than  \n                SET j TO the position of the first occurrence of the character greater than in code starting from position i PLUS one  \n                IF j EQUALS negative one  \n                    RETURN False  \n                END IF  \n                SET tag_content TO the substring of code from position i PLUS one TO position j MINUS one  \n                IF the length of tag_content EQUALS zero  \n                    RETURN False  \n                END IF  \n                IF the element at position zero of tag_content EQUALS forward slash  \n                    SET tag_name TO the substring of tag_content from position one TO the end  \n                    IF the length of stack EQUALS zero OR the element at the last position of stack NOT EQUALS tag_name  \n                        RETURN False  \n                    END IF  \n                    REMOVE the element at the last position FROM stack  \n                ELSE IF the element at position zero of tag_content EQUALS exclamation mark  \n                    RETURN False  \n                ELSE  \n                    IF the length of tag_content LESS THAN one OR the length of tag_content GREATER THAN nine OR tag_content IS NOT composed entirely of uppercase letters  \n                        RETURN False  \n                    END IF  \n                    APPEND tag_content TO stack  \n                END IF  \n                SET i TO j PLUS one  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        SET valid_tag_pattern TO the string pattern that matches less than followed by one or more uppercase letters followed by greater than followed by any characters followed by less than forward slash followed by one or more uppercase letters followed by greater than  \n        RETURN the logical negation of the boolean value of stack AND the number of occurrences matching valid_tag_pattern in code GREATER THAN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "4-keys-keyboard", "passing_rate": 0.9375, "pseudocode": "CLASS Solution  \n    FUNCTION maxA(n)  \n        IF n LESS THAN OR EQUAL TO three  \n            RETURN n  \n        END IF  \n        \n        SET dp TO a list of zeros with the length of n PLUS one  \n        \n        FOR i FROM one TO three  \n            SET element at position i of dp TO i  \n        END FOR  \n        \n        FOR i FROM four TO n  \n            FOR j FROM i MINUS three DOWN TO one  \n                SET element at position i of dp TO the maximum of element at position i of dp AND element at position j of dp MULTIPLIED BY i MINUS j MINUS one  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-closest-time", "passing_rate": 0.9666666666666667, "pseudocode": "CLASS Solution  \n    FUNCTION nextClosestTime(time)  \n        SET digits TO the set of characters in time with all colons removed  \n        SET hour AND minute TO the conversion of the parts before and after the colon in time to integers  \n        \n        FUNCTION generate_times(digits)  \n            SET times TO an empty list  \n            FOR each character h1 IN digits  \n                FOR each character h2 IN digits  \n                    FOR each character m1 IN digits  \n                        FOR each character m2 IN digits  \n                            SET hour_candidate TO the integer value of the concatenation of h1 and h2  \n                            SET minute_candidate TO the integer value of the concatenation of m1 and m2  \n                            IF hour_candidate LESS THAN twenty-four AND minute_candidate LESS THAN sixty  \n                                APPEND the pair of hour_candidate and minute_candidate TO times  \n                            END IF  \n                        END FOR  \n                    END FOR  \n                END FOR  \n            END FOR  \n            RETURN times sorted in increasing order  \n        END FUNCTION  \n        \n        SET all_times TO the result of generate_times applied to digits  \n        SET current_time_index TO the position of the pair consisting of hour and minute in all_times  \n        \n        IF current_time_index PLUS one LESS THAN the length of all_times  \n            SET next_hour AND next_minute TO the pair at position current_time_index PLUS one in all_times  \n        ELSE  \n            SET next_hour AND next_minute TO the first pair in all_times  \n        END IF  \n        \n        RETURN the string formed by next_hour formatted as two digits followed by a colon followed by next_minute formatted as two digits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-sum-of-3-non-overlapping-subarrays", "passing_rate": 0.8048780487804879, "pseudocode": "CLASS Solution  \n    FUNCTION maxSumOfThreeSubarrays(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET sums TO a list of zeros with LENGTH n MINUS k PLUS one  \n        SET current_sum TO the SUM OF elements at positions from zero TO position k MINUS one of nums  \n        SET element at position zero of sums TO current_sum  \n        \n        FOR i FROM one TO n MINUS k  \n            INCREMENT current_sum BY element at position i PLUS k MINUS one of nums MINUS element at position i MINUS one of nums  \n            SET element at position i of sums TO current_sum  \n        END FOR  \n        \n        SET left TO a list of zeros with LENGTH n MINUS k PLUS one  \n        SET right TO a list of elements each being n MINUS k with LENGTH n MINUS k PLUS one  \n        \n        SET max_sum TO zero  \n        FOR i FROM zero TO n MINUS k  \n            IF element at position i of sums GREATER THAN element at position max_sum of sums  \n                SET max_sum TO i  \n            END IF  \n            SET element at position i of left TO max_sum  \n        END FOR  \n        \n        SET max_sum TO n MINUS k  \n        FOR i FROM n MINUS k DOWN TO zero  \n            IF element at position i of sums GREATER THAN OR EQUAL TO element at position max_sum of sums  \n                SET max_sum TO i  \n            END IF  \n            SET element at position i of right TO max_sum  \n        END FOR  \n        \n        SET max_total TO zero  \n        SET result TO a list of three zeros  \n        FOR j FROM k TO n MINUS two MULTIPLIED BY k  \n            SET i TO element at position j MINUS k of left  \n            SET l TO element at position j PLUS k of right  \n            SET total TO element at position i of sums PLUS element at position j of sums PLUS element at position l of sums  \n            IF total GREATER THAN max_total  \n                SET max_total TO total  \n                SET result TO a list consisting of i, j, and l in order  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands-ii", "passing_rate": 0.9795918367346939, "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero of grid OR element at position x of grid at position y EQUALS zero  \n                RETURN  \n            END IF  \n            SET element at position x of grid at position y TO zero  \n            APPEND pair of x AND y TO island  \n            CALL dfs WITH x PLUS one AND y AND island  \n            CALL dfs WITH x MINUS one AND y AND island  \n            CALL dfs WITH x AND y PLUS one AND island  \n            CALL dfs WITH x AND y MINUS one AND island  \n        END FUNCTION  \n\n        FUNCTION normalize(island)  \n            SET shapes TO empty list  \n            FOR each pair dx AND dy IN list of pairs ONE AND ONE AND ONE AND MINUS ONE AND MINUS ONE AND ONE AND MINUS ONE AND MINUS ONE  \n                SET new_island TO empty list  \n                FOR each pair x AND y IN island  \n                    APPEND pair of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island  \n                END FOR  \n                SORT new_island IN ascending order  \n                SET min_x TO the minimum x value among pairs in new_island  \n                SET min_y TO the minimum y value among pairs in new_island  \n                APPEND tuple of pairs where each pair is x MINUS min_x AND y MINUS min_y IN new_island TO shapes  \n            END FOR  \n            FOR i FROM zero TO the LENGTH OF shapes MINUS one  \n                APPEND tuple of pairs where each pair is y AND MINUS x FROM pairs in element at position i of shapes TO shapes  \n            END FOR  \n            RETURN the minimum element in shapes according to ordering  \n        END FUNCTION  \n\n        SET islands TO empty set  \n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET island TO empty list  \n                    CALL dfs WITH i AND j AND island  \n                    ADD the result of normalize called with island TO islands  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the LENGTH OF islands  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "candy-crush", "passing_rate": 0.9285714285714286, "pseudocode": "CLASS Solution  \n    FUNCTION candyCrush(board)  \n        SET R TO the LENGTH OF board  \n        SET C TO the LENGTH OF element at position zero of board  \n        SET stable TO false  \n  \n        WHILE stable EQUALS false  \n            SET stable TO true  \n            SET to_crush TO an empty set  \n  \n            FOR r FROM zero TO R MINUS one  \n                FOR c FROM zero TO C MINUS three  \n                    IF the ABSOLUTE VALUE of element at position r of board at position c EQUALS the ABSOLUTE VALUE of element at position r of board at position c PLUS one AND the ABSOLUTE VALUE of element at position r of board at position c EQUALS the ABSOLUTE VALUE of element at position r of board at position c PLUS two AND the ABSOLUTE VALUE of element at position r of board at position c NOT EQUALS zero  \n                        SET stable TO false  \n                        ADD the pair consisting of r and c TO to_crush  \n                        ADD the pair consisting of r and c PLUS one TO to_crush  \n                        ADD the pair consisting of r and c PLUS two TO to_crush  \n                    END IF  \n                END FOR  \n            END FOR  \n  \n            FOR r FROM zero TO R MINUS three  \n                FOR c FROM zero TO C MINUS one  \n                    IF the ABSOLUTE VALUE of element at position r of board at position c EQUALS the ABSOLUTE VALUE of element at position r PLUS one of board at position c AND the ABSOLUTE VALUE of element at position r of board at position c EQUALS the ABSOLUTE VALUE of element at position r PLUS two of board at position c AND the ABSOLUTE VALUE of element at position r of board at position c NOT EQUALS zero  \n                        SET stable TO false  \n                        ADD the pair consisting of r and c TO to_crush  \n                        ADD the pair consisting of r PLUS one and c TO to_crush  \n                        ADD the pair consisting of r PLUS two and c TO to_crush  \n                    END IF  \n                END FOR  \n            END FOR  \n  \n            FOR each pair consisting of r and c IN to_crush  \n                SET element at position r of board at position c TO zero  \n            END FOR  \n  \n            FOR c FROM zero TO C MINUS one  \n                SET wr TO R MINUS one  \n                FOR r FROM R MINUS one DOWN TO zero  \n                    IF element at position r of board at position c NOT EQUALS zero  \n                        SET element at position wr of board at position c TO element at position r of board at position c  \n                        DECREMENT wr BY one  \n                    END IF  \n                END FOR  \n                FOR wr FROM wr DOWN TO zero  \n                    SET element at position wr of board at position c TO zero  \n                END FOR  \n            END FOR  \n        END WHILE  \n  \n        RETURN board  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parse-lisp-expression", "passing_rate": 0.975609756097561, "pseudocode": "CLASS Solution  \n    FUNCTION evaluate(expression)  \n        FUNCTION get_tokens(expression)  \n            SET tokens TO empty list  \n            SET buf TO empty string  \n            SET depth TO zero  \n            FOR each char IN expression  \n                IF char EQUALS space AND depth EQUALS zero  \n                    APPEND buf TO tokens  \n                    SET buf TO empty string  \n                ELSE  \n                    IF char EQUALS left parenthesis  \n                        INCREMENT depth BY one  \n                    ELSE IF char EQUALS right parenthesis  \n                        DECREMENT depth BY one  \n                    END IF  \n                    APPEND char TO buf  \n                END IF  \n            END FOR  \n            IF buf IS NOT empty string  \n                APPEND buf TO tokens  \n            END IF  \n            RETURN tokens  \n        END FUNCTION  \n\n        FUNCTION evaluate_expression(tokens context)  \n            IF element at position zero of tokens EQUALS the word add  \n                RETURN evaluate_expression(element at position one of tokens context) PLUS evaluate_expression(element at position two of tokens context)  \n            ELSE IF element at position zero of tokens EQUALS the word mult  \n                RETURN evaluate_expression(element at position one of tokens context) MULTIPLIED BY evaluate_expression(element at position two of tokens context)  \n            ELSE IF element at position zero of tokens EQUALS the word let  \n                SET new_context TO a copy of context  \n                SET i TO one  \n                WHILE i LESS THAN the LENGTH OF tokens MINUS one  \n                    SET var TO element at position i of tokens  \n                    SET expr TO element at position i PLUS one of tokens  \n                    SET the value associated with var in new_context TO evaluate_expression(expr new_context)  \n                    INCREMENT i BY two  \n                END WHILE  \n                RETURN evaluate_expression(element at the last position of tokens new_context)  \n            ELSE  \n                TRY  \n                    RETURN the integer conversion of element at position zero of tokens  \n                CATCH failure of conversion  \n                    RETURN the value associated with element at position zero of tokens in context  \n                END TRY  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION parse_expression(expression)  \n            IF element at position zero of expression NOT EQUALS left parenthesis  \n                RETURN expression  \n            END IF  \n            SET tokens TO get_tokens(substring from position one TO position before the last of expression)  \n            RETURN list formed by parse_expression applied to each token in tokens  \n        END FUNCTION  \n\n        SET parsed_expression TO parse_expression(expression)  \n        RETURN evaluate_expression(parsed_expression empty dictionary)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "open-the-lock", "passing_rate": 0.9130434782608695, "pseudocode": "CLASS Solution  \n    FUNCTION openLock(deadends LIST OF STRING, target STRING) RETURNS INTEGER  \n        SET deadends_set TO the SET of elements IN deadends  \n        \n        IF the STRING zero zero zero zero IS IN deadends_set THEN  \n            RETURN the INTEGER negative one  \n        END IF  \n        \n        IF target EQUALS the STRING zero zero zero zero THEN  \n            RETURN the INTEGER zero  \n        END IF  \n        \n        SET queue TO a new deque CONTAINING the PAIR of the STRING zero zero zero zero AND the INTEGER zero  \n        SET visited TO the SET CONTAINING the STRING zero zero zero zero  \n        \n        FUNCTION neighbors(state STRING)  \n            SET result TO an empty LIST  \n            FOR index FROM the INTEGER zero TO the INTEGER three  \n                SET digit TO the INTEGER value OF the CHARACTER at position index OF state  \n                FOR move IN the LIST containing the INTEGER negative one AND the INTEGER one  \n                    SET new_digit TO the remainder after dividing the SUM of digit AND move BY the INTEGER ten  \n                    SET new_state TO the CONCATENATION of the substring from position zero TO position index MINUS one OF state WITH the STRING representation OF new_digit WITH the substring from position index PLUS one TO the end OF state  \n                    APPEND new_state TO result  \n                END FOR  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        WHILE the LENGTH OF queue IS GREATER THAN zero  \n            REMOVE AND RETURN the LEFTMOST element FROM queue AS the PAIR current_state AND steps  \n            \n            FOR each neighbor IN neighbors(current_state)  \n                IF neighbor NOT IN visited AND neighbor NOT IN deadends_set THEN  \n                    IF neighbor EQUALS target THEN  \n                        RETURN the SUM of steps AND the INTEGER one  \n                    END IF  \n                    ADD neighbor TO visited  \n                    APPEND the PAIR neighbor AND the SUM of steps AND the INTEGER one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the INTEGER negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cracking-the-safe", "passing_rate": 0.8947368421052632, "pseudocode": "CLASS Solution  \n    FUNCTION crackSafe(n k)  \n        SET visited TO empty set  \n        SET sequence TO empty list  \n        \n        FUNCTION dfs(node)  \n            FOR i FROM zero TO k MINUS one  \n                SET edge TO concatenation of node AND string conversion of i  \n                IF edge NOT IN visited THEN  \n                    ADD edge TO visited  \n                    CALL dfs WITH substring of edge FROM position two TO position length of edge  \n                    APPEND string conversion of i TO sequence  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET start_node TO string consisting of n MINUS one repetitions of character zero  \n        CALL dfs WITH start_node  \n        RETURN concatenation of all elements in sequence FOLLOWED BY start_node  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-chunks-to-make-sorted-ii", "passing_rate": 0.9285714285714286, "pseudocode": "CLASS Solution  \n    FUNCTION maxChunksToSorted(arr)  \n        SET max_so_far TO an empty list  \n        SET current_max TO element at position one of arr  \n        FOR each num IN arr  \n            IF current_max GREATER THAN OR EQUAL TO num  \n                SET current_max TO current_max  \n            ELSE  \n                SET current_max TO num  \n            END IF  \n            APPEND current_max TO max_so_far  \n        END FOR  \n        SET sorted_arr TO arr sorted in ascending order  \n        SET chunks TO zero  \n        SET max_chunk TO zero  \n        FOR i FROM one TO the LENGTH OF arr  \n            IF max_chunk GREATER THAN OR EQUAL TO element at position i of arr  \n                SET max_chunk TO max_chunk  \n            ELSE  \n                SET max_chunk TO element at position i of arr  \n            END IF  \n            IF max_chunk EQUALS element at position i of sorted_arr  \n                INCREMENT chunks BY one  \n            END IF  \n        END FOR  \n        RETURN chunks  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cheapest-flights-within-k-stops", "passing_rate": 0.9622641509433962, "pseudocode": "CLASS Solution  \n    FUNCTION findCheapestPrice(n, flights, src, dst, k)  \n        SET graph TO empty mapping FROM each integer FROM zero TO n MINUS one TO empty list  \n        FOR each u, v, w IN flights  \n            APPEND pair OF v AND w TO list AT element at position u of graph  \n        END FOR  \n\n        SET min_heap TO list CONTAINING one tuple of zero cost, minus one stops, and src city  \n        SET min_cost TO mapping FROM src TO minus one  \n\n        WHILE min_heap IS NOT empty  \n            REMOVE and RETURN the smallest element FROM min_heap INTO cost, stops, city  \n\n            IF city EQUALS dst  \n                RETURN cost  \n            END IF  \n\n            IF stops GREATER THAN OR EQUAL TO k  \n                CONTINUE to next iteration  \n            END IF  \n\n            FOR each neighbor, price IN list AT element at position city of graph  \n                SET next_cost TO cost PLUS price  \n                SET next_stops TO stops PLUS one  \n\n                IF neighbor NOT IN keys of min_cost OR next_stops LESS THAN element at neighbor key of min_cost OR next_cost LESS THAN element at position zero of the first tuple in min_heap  \n                    SET element at neighbor key of min_cost TO next_stops  \n                    ADD tuple OF next_cost, next_stops, neighbor TO min_heap  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-rotation-with-highest-score", "passing_rate": 0.9591836734693877, "pseudocode": "CLASS Solution  \n    FUNCTION bestRotation(nums)  \n        SET n TO the LENGTH OF nums  \n        SET delta TO list of zeros with the LENGTH OF n  \n        \n        FOR each index i AND element num IN nums  \n            IF num LESS THAN OR EQUAL TO i  \n                INCREMENT element at position zero of delta BY one  \n                IF the result of i MINUS num PLUS one LESS THAN n  \n                    DECREMENT element at position of the result of i MINUS num PLUS one of delta BY one  \n                END IF  \n            END IF  \n            IF i PLUS one LESS THAN n  \n                INCREMENT element at position of i PLUS one of delta BY one  \n                IF the result of i PLUS n MINUS num PLUS one LESS THAN n  \n                    DECREMENT element at position of the result of i PLUS n MINUS num PLUS one of delta BY one  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET score TO zero  \n        SET max_score TO zero  \n        SET best_k TO zero  \n        \n        FOR each integer k FROM zero TO n MINUS one  \n            INCREMENT score BY element at position k of delta  \n            IF score GREATER THAN max_score  \n                SET max_score TO score  \n                SET best_k TO k  \n            END IF  \n        END FOR  \n        \n        RETURN best_k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-eventual-safe-states", "passing_rate": 0.8181818181818182, "pseudocode": "CLASS Solution  \n    FUNCTION eventualSafeNodes(graph)  \n        FUNCTION is_safe(node)  \n            IF element at position node of visited EQUALS one  \n                RETURN False  \n            END IF  \n            IF element at position node of visited EQUALS two  \n                RETURN True  \n            END IF  \n            SET element at position node of visited TO one  \n            FOR each neighbor IN element at position node of graph  \n                IF NOT is_safe(neighbor)  \n                    RETURN False  \n                END IF  \n            END FOR  \n            SET element at position node of visited TO two  \n            RETURN True  \n        END FUNCTION  \n        SET n TO the LENGTH OF graph  \n        SET visited TO list of zero repeated n times  \n        SET safe_nodes TO empty list  \n        FOR node FROM zero TO n MINUS one  \n            IF is_safe(node)  \n                APPEND node TO safe_nodes  \n            END IF  \n        END FOR  \n        RETURN safe_nodes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-increase-to-keep-city-skyline", "passing_rate": 0.9803921568627451, "pseudocode": "CLASS Solution  \n    FUNCTION maxIncreaseKeepingSkyline(grid)  \n        SET n TO the LENGTH OF grid  \n        SET row_maxes TO an empty list  \n        FOR each row IN grid  \n            SET max_value TO the maximum value IN the row  \n            APPEND max_value TO row_maxes  \n        END FOR  \n        SET col_maxes TO an empty list  \n        FOR each column AS each element at position index FROM zero TO n MINUS one IN grid  \n            SET column_elements TO a list of element at position index FROM each row IN grid  \n            SET max_value TO the maximum value IN column_elements  \n            APPEND max_value TO col_maxes  \n        END FOR  \n        SET total_increase TO zero  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET max_height TO the smaller value BETWEEN element at position i OF row_maxes AND element at position j OF col_maxes  \n                IF max_height GREATER THAN element at position j OF element at position i OF grid  \n                    INCREMENT total_increase BY max_height MINUS element at position j OF element at position i OF grid  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN total_increase  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "friends-of-appropriate-ages", "passing_rate": 0.8372093023255814, "pseudocode": "CLASS Solution  \n    FUNCTION numFriendRequests(ages)  \n        FUNCTION request_will_be_sent(age_x, age_y)  \n            RETURN NOT (age_y LESS THAN OR EQUAL TO age_x MULTIPLIED BY one HALF PLUS seven OR age_y GREATER THAN age_x OR age_y GREATER THAN one hundred AND age_x LESS THAN one hundred)  \n        END FUNCTION  \n\n        SET count TO list of zeroes with length one hundred twenty one  \n        FOR each age IN ages  \n            INCREMENT element at position age of count BY one  \n        END FOR  \n\n        SET total_requests TO zero  \n        FOR age_x FROM one TO one hundred twenty  \n            FOR age_y FROM one TO one hundred twenty  \n                IF request_will_be_sent(age_x, age_y)  \n                    INCREMENT total_requests BY element at position age_x of count MULTIPLIED BY (element at position age_y of count MINUS one IF age_x EQUALS age_y ELSE zero)  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN total_requests  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-and-replace-in-string", "passing_rate": 0.9038461538461539, "pseudocode": "CLASS Solution  \n    FUNCTION findReplaceString(s parameter, indices parameter, sources parameter, targets parameter)  \n        SET replacements TO list of tuples each containing element at position index of indices parameter element at position index of sources parameter element at position index of targets parameter sorted by the first element in each tuple  \n        SET result TO empty list  \n        SET prev_end TO zero  \n        FOR each tuple containing index source target IN replacements  \n            APPEND substring from position prev_end TO position index of s parameter TO result  \n            IF substring from position index TO position index PLUS the LENGTH OF source EQUALS source THEN  \n                APPEND target TO result  \n            ELSE  \n                APPEND substring from position index TO position index PLUS the LENGTH OF source of s parameter TO result  \n            END IF  \n            SET prev_end TO index PLUS the LENGTH OF source  \n        END FOR  \n        APPEND substring from position prev_end TO the end of s parameter TO result  \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shifting-letters", "passing_rate": 0.9545454545454546, "pseudocode": "CLASS Solution  \n    FUNCTION shiftingLetters(s, shifts)  \n        SET total_shifts TO zero  \n        FOR i FROM the LENGTH OF shifts MINUS one TO zero STEPPING BY minus one  \n            INCREMENT total_shifts BY element at position i of shifts  \n            SET element at position i of shifts TO total_shifts  \n        END FOR  \n        SET result TO empty list  \n        FOR i FROM zero TO the LENGTH OF s MINUS one  \n            SET alphabetical_position TO alphabetical numerical value of element at position i of s MINUS alphabetical numerical value of the letter a  \n            SET shifted_position TO alphabetical_position PLUS element at position i of shifts  \n            SET wrapped_position TO remainder of shifted_position DIVIDED BY twenty-six  \n            SET new_character TO the character corresponding to wrapped_position PLUS alphabetical numerical value of the letter a  \n            APPEND new_character TO result  \n        END FOR  \n        RETURN concatenation of all elements in result as a string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "advantage-shuffle", "passing_rate": 0.8478260869565217, "pseudocode": "CLASS Solution  \n    FUNCTION advantageCount(nums1, nums2)  \n        SORT nums1 IN ASCENDING ORDER  \n        SET nums2_with_indices TO A LIST OF ELEMENTS WHERE EACH ELEMENT IS A PAIR OF value AND index SUCH THAT value IS THE ELEMENT IN nums2 AND index IS THE POSITION OF THAT ELEMENT IN nums2  \n        SORT nums2_with_indices IN DESCENDING ORDER BY THEIR value  \n        SET result TO A LIST OF ZEROES WITH LENGTH EQUAL TO THE LENGTH OF nums1  \n        SET left TO zero  \n        SET right TO THE LENGTH OF nums1 MINUS one  \n        FOR EACH pair OF value AND index IN nums2_with_indices  \n            IF element at position right of nums1 IS GREATER THAN value THEN  \n                SET element at position index of result TO element at position right of nums1  \n                DECREMENT right BY one  \n            ELSE  \n                SET element at position index of result TO element at position left of nums1  \n                INCREMENT left BY one  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse", "passing_rate": 0.8857142857142857, "pseudocode": "CLASS Solution  \n    FUNCTION catMouseGame(graph)  \n        SET DRAW TO zero  \n        SET MOUSE_WIN TO one  \n        SET CAT_WIN TO two  \n        SET n TO the LENGTH OF graph  \n        \n        FUNCTION dfs(turn, mouse_pos, cat_pos)  \n            IF turn EQUALS two MULTIPLIED BY n THEN  \n                RETURN DRAW  \n            END IF  \n            IF mouse_pos EQUALS zero THEN  \n                RETURN MOUSE_WIN  \n            END IF  \n            IF mouse_pos EQUALS cat_pos THEN  \n                RETURN CAT_WIN  \n            END IF  \n            \n            SET turn_remainder TO turn MODULO two  \n            IF turn_remainder EQUALS zero THEN  \n                SET current_player TO mouse  \n            ELSE  \n                SET current_player TO cat  \n            END IF  \n            \n            IF current_player EQUALS mouse THEN  \n                SET result TO CAT_WIN  \n                FOR each next_pos IN the element at position mouse_pos of graph  \n                    SET next_result TO dfs with parameters turn PLUS one, next_pos, cat_pos  \n                    IF next_result EQUALS MOUSE_WIN THEN  \n                        RETURN MOUSE_WIN  \n                    ELSE IF next_result EQUALS DRAW THEN  \n                        SET result TO DRAW  \n                    END IF  \n                END FOR  \n                RETURN result  \n            ELSE  \n                SET result TO MOUSE_WIN  \n                FOR each next_pos IN the element at position cat_pos of graph  \n                    IF next_pos EQUALS zero THEN  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    SET next_result TO dfs with parameters turn PLUS one, mouse_pos, next_pos  \n                    IF next_result EQUALS CAT_WIN THEN  \n                        RETURN CAT_WIN  \n                    ELSE IF next_result EQUALS DRAW THEN  \n                        SET result TO DRAW  \n                    END IF  \n                END FOR  \n                RETURN result  \n            END IF  \n        END FUNCTION  \n        \n        RETURN dfs with parameters zero, one, two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "three-equal-parts", "passing_rate": 0.9534883720930233, "pseudocode": "CLASS Solution  \n    FUNCTION threeEqualParts(arr)  \n        SET total_ones TO the SUM OF all elements IN arr  \n        IF total_ones EQUALS zero  \n            RETURN a list containing zero AND two  \n        END IF  \n        IF total_ones MODULO three NOT EQUALS zero  \n            RETURN a list containing minus one AND minus one  \n        END IF  \n        SET part_ones TO total_ones DIVIDED BY three  \n        SET first_part_index TO zero  \n        SET count_ones TO zero  \n        FOR index FROM zero TO the LENGTH OF arr MINUS one  \n            IF element at position index of arr EQUALS one  \n                INCREMENT count_ones BY one  \n                IF count_ones EQUALS one  \n                    SET first_part_index TO index  \n                END IF  \n                IF count_ones EQUALS part_ones  \n                    BREAK the loop  \n                END IF  \n            END IF  \n        END FOR  \n        SET second_part_index TO zero  \n        SET count_ones TO zero  \n        FOR index FROM zero TO the LENGTH OF arr MINUS one  \n            IF element at position index of arr EQUALS one  \n                INCREMENT count_ones BY one  \n                IF count_ones EQUALS part_ones PLUS one  \n                    SET second_part_index TO index  \n                    BREAK the loop  \n                END IF  \n            END IF  \n        END FOR  \n        SET third_part_index TO zero  \n        SET count_ones TO zero  \n        FOR index FROM zero TO the LENGTH OF arr MINUS one  \n            IF element at position index of arr EQUALS one  \n                INCREMENT count_ones BY one  \n                IF count_ones EQUALS two MULTIPLIED BY part_ones PLUS one  \n                    SET third_part_index TO index  \n                    BREAK the loop  \n                END IF  \n            END IF  \n        END FOR  \n        SET n TO the LENGTH OF arr MINUS third_part_index  \n        IF first_part_index PLUS n LESS THAN OR EQUAL TO the LENGTH OF arr AND second_part_index PLUS n LESS THAN OR EQUAL TO the LENGTH OF arr AND  \n           the sublist of arr from position first_part_index TO the position first_part_index PLUS n MINUS one EQUALS  \n           the sublist of arr from position second_part_index TO the position second_part_index PLUS n MINUS one AND  \n           the sublist of arr from position third_part_index TO the end  \n            RETURN a list containing first_part_index PLUS n MINUS one AND second_part_index PLUS n  \n        END IF  \n        RETURN a list containing minus one AND minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences-ii", "passing_rate": 0.9534883720930233, "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET n TO the LENGTH OF s  \n        SET dp TO a list of zeros with the LENGTH OF n PLUS one  \n        SET element at position zero of dp TO one  \n        SET last TO an empty mapping  \n        FOR i FROM one TO n  \n            SET char TO the element at position i MINUS one of s  \n            SET element at position i of dp TO two MULTIPLIED BY the element at position i MINUS one of dp MODULO MOD  \n            IF char EXISTS AS a key IN last  \n                SET element at position i of dp TO the element at position i of dp MINUS the element at position last mapped by char MINUS one of dp PLUS MOD MODULO MOD  \n            END IF  \n            ASSIGN last mapped by char TO i  \n        END FOR  \n        RETURN the element at position n of dp MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-shortest-superstring", "passing_rate": 0.8888888888888888, "pseudocode": "CLASS Solution  \n    FUNCTION shortestSuperstring(words)  \n        SET n TO the LENGTH OF words  \n        \n        FUNCTION overlap(i, j)  \n            FOR k FROM the MINIMUM of the LENGTH OF element at position i of words AND the LENGTH OF element at position j of words DOWN TO one  \n                IF the SUBSTRING of element at position i of words from position LENGTH OF element at position i of words MINUS k PLUS one TO the LENGTH OF element at position i of words EQUALS the SUBSTRING of element at position j of words from position one TO k  \n                    RETURN k  \n                END IF  \n            END FOR  \n            RETURN zero  \n        END FUNCTION  \n        \n        FUNCTION dp(mask, i)  \n            IF mask EQUALS the VALUE of one SHIFTED LEFT BY n MINUS one  \n                RETURN tuple of zero AND empty string  \n            END IF  \n            \n            SET min_len TO positive infinity  \n            SET best_path TO empty string  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of mask AND one SHIFTED LEFT BY j EQUALS zero  \n                    CALL dp with the ARGUMENTS the BITWISE OR of mask AND one SHIFTED LEFT BY j AND j AND ASSIGN the RESULTS TO length AND path  \n                    SET length TO length PLUS the LENGTH OF element at position j of words MINUS the CALL of overlap with i AND j  \n                    IF length LESS THAN min_len  \n                        SET min_len TO length  \n                        SET best_path TO the SUBSTRING of element at position j of words from position the CALL of overlap with i AND j PLUS one TO the LENGTH OF element at position j of words CONCATENATED WITH path  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN tuple of min_len AND best_path  \n        END FUNCTION  \n        \n        SET min_len TO positive infinity  \n        SET shortest_path TO empty string  \n        FOR i FROM zero TO n MINUS one  \n            CALL dp with the ARGUMENTS one SHIFTED LEFT BY i AND i AND ASSIGN the RESULTS TO length AND path  \n            SET length TO length PLUS the LENGTH OF element at position i of words  \n            IF length LESS THAN min_len  \n                SET min_len TO length  \n                SET shortest_path TO the ELEMENT at position i of words CONCATENATED WITH path  \n            END IF  \n        END FOR  \n        \n        RETURN shortest_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-component-size-by-common-factor", "passing_rate": 0.9811320754716981, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n        SET self.rank TO list where each element is one REPEATED size times  \n        SET self.size TO list where each element is one REPEATED size times  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET rootU TO self.find(u)  \n        SET rootV TO self.find(v)  \n        IF rootU NOT EQUALS rootV THEN  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank THEN  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.size BY element at position rootV of self.size  \n            ELSE IF element at position rootU of self.rank LESS THAN element at position rootV of self.rank THEN  \n                SET element at position rootU of self.parent TO rootV  \n                INCREMENT element at position rootV of self.size BY element at position rootU of self.size  \n            ELSE  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.rank BY one  \n                INCREMENT element at position rootU of self.size BY element at position rootV of self.size  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION largestComponentSize(self, nums)  \n        SET max_num TO the maximum value in nums  \n        SET uf TO new UnionFind object with parameter max_num PLUS one  \n        SET prime_to_index TO empty dictionary  \n        FOR each num IN nums  \n            FOR each prime IN self.prime_factors(num)  \n                IF prime IS IN prime_to_index THEN  \n                    CALL uf.union(element in prime_to_index at key prime, num)  \n                ELSE  \n                    SET value at key prime in prime_to_index TO num  \n                END IF  \n            END FOR  \n        END FOR  \n        SET max_component_size TO zero  \n        FOR each num IN nums  \n            SET root TO uf.find(num)  \n            IF element at position root of uf.size GREATER THAN max_component_size THEN  \n                SET max_component_size TO element at position root of uf.size  \n            END IF  \n        END FOR  \n        RETURN max_component_size  \n    END FUNCTION  \n\n    FUNCTION prime_factors(self, n)  \n        SET factors TO empty set  \n        WHILE n MODULO two EQUALS zero  \n            ADD two TO factors  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        FOR i FROM three TO the integer value of the square root of n PLUS one STEP two  \n            WHILE n MODULO i EQUALS zero  \n                ADD i TO factors  \n                SET n TO n DIVIDED BY i  \n            END WHILE  \n        END FOR  \n        IF n GREATER THAN two THEN  \n            ADD n TO factors  \n        END IF  \n        RETURN factors  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "brace-expansion-ii", "passing_rate": 0.9791666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION braceExpansionII(expression)  \n        FUNCTION parse_expression(index)  \n            SET current_set TO empty set  \n            SET current_product TO list containing empty string  \n            WHILE index LESS THAN the LENGTH OF expression  \n                SET char TO element at position index of expression  \n                IF char EQUALS the opening brace character  \n                    SET inner_set AND index TO the result of calling parse_expression WITH index PLUS one  \n                    SET new_product TO empty list  \n                    FOR each element a IN current_product  \n                        FOR each element b IN inner_set  \n                            APPEND concatenation of a AND b TO new_product  \n                        END FOR  \n                    END FOR  \n                    SET current_product TO new_product  \n                ELSE IF char EQUALS the closing brace character  \n                    FOR each element p IN current_product  \n                        JOIN elements of p INTO a single string  \n                        ADD the resulting string TO current_set  \n                    END FOR  \n                    RETURN current_set AND index  \n                ELSE IF char EQUALS the comma character  \n                    FOR each element p IN current_product  \n                        JOIN elements of p INTO a single string  \n                        ADD the resulting string TO current_set  \n                    END FOR  \n                    SET current_product TO list containing empty string  \n                ELSE  \n                    SET new_product TO empty list  \n                    FOR each element a IN current_product  \n                        CONCATENATE a WITH char TO form new string  \n                        APPEND the new string TO new_product  \n                    END FOR  \n                    SET current_product TO new_product  \n                END IF  \n                INCREMENT index BY one  \n            END WHILE  \n            FOR each element p IN current_product  \n                JOIN elements of p INTO a single string  \n                ADD the resulting string TO current_set  \n            END FOR  \n            RETURN current_set AND index  \n        END FUNCTION  \n        SET result_set AND unused_variable TO the result of calling parse_expression WITH zero  \n        RETURN the sorted list of elements in result_set  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-words-formed-by-letters", "passing_rate": 0.9215686274509803, "pseudocode": "CLASS Solution  \n    FUNCTION maxScoreWords(words letters score)  \n        FUNCTION word_score(word score_map)  \n            SET total_score TO zero  \n            FOR each character IN word  \n                INCREMENT total_score BY the value of character in score_map  \n            END FOR  \n            RETURN total_score  \n        END FUNCTION  \n        \n        FUNCTION can_form(word letter_count)  \n            SET word_count TO the count of each character in word  \n            FOR each character and count_value IN word_count  \n                IF the value of character in letter_count LESS THAN count_value  \n                    RETURN False  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        \n        FUNCTION update_letter_count(letter_count word add)  \n            FOR each character IN word  \n                IF add EQUALS True  \n                    INCREMENT the value of character in letter_count BY one  \n                ELSE  \n                    DECREMENT the value of character in letter_count BY one  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        FUNCTION backtrack(index current_score letter_count)  \n            IF index EQUALS the LENGTH OF words  \n                RETURN current_score  \n            END IF  \n            \n            SET max_score TO current_score  \n            FOR i FROM index TO the LENGTH OF words MINUS one  \n                IF can_form(the element at position i of words letter_count) EQUALS True  \n                    CALL update_letter_count(letter_count the element at position i of words add EQUALS False)  \n                    SET candidate_score TO backtrack(i PLUS one current_score PLUS word_score(the element at position i of words score_map) letter_count)  \n                    IF candidate_score GREATER THAN max_score  \n                        SET max_score TO candidate_score  \n                    END IF  \n                    CALL update_letter_count(letter_count the element at position i of words add EQUALS True)  \n                END IF  \n            END FOR  \n            RETURN max_score  \n        END FUNCTION  \n        \n        SET score_map TO an empty mapping  \n        FOR i FROM zero TO twenty five  \n            SET character TO the character corresponding to the position i starting from lowercase a  \n            SET the value of character in score_map TO the element at position i of score  \n        END FOR  \n        \n        SET letter_count TO the count of each character in letters  \n        \n        RETURN backtrack(zero zero letter_count)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-falling-path-sum-ii", "passing_rate": 0.9183673469387755, "pseudocode": "CLASS Solution  \n    FUNCTION minFallingPathSum(grid)  \n        IF grid EQUALS nothing OR element at position zero of grid EQUALS nothing THEN  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF grid  \n        \n        IF n EQUALS one THEN  \n            RETURN the MINIMUM value IN element at position zero of grid  \n        END IF  \n        \n        SET dp TO a COPY OF element at position zero of grid  \n        \n        FOR i FROM one TO n MINUS one  \n            SET new_dp TO a list OF n ZEROES  \n            SET min1 TO positive infinity  \n            SET min2 TO positive infinity  \n            SET min1_index TO negative one  \n            \n            FOR j FROM zero TO n MINUS one  \n                IF element at position j of dp LESS THAN min1 THEN  \n                    SET min2 TO min1  \n                    SET min1 TO element at position j of dp  \n                    SET min1_index TO j  \n                ELSE IF element at position j of dp LESS THAN min2 THEN  \n                    SET min2 TO element at position j of dp  \n                END IF  \n            END FOR  \n            \n            FOR j FROM zero TO n MINUS one  \n                IF j EQUALS min1_index THEN  \n                    SET element at position j of new_dp TO element at position i of grid at position j PLUS min2  \n                ELSE  \n                    SET element at position j of new_dp TO element at position i of grid at position j PLUS min1  \n                END IF  \n            END FOR  \n            \n            SET dp TO a COPY OF new_dp  \n        END FOR  \n        \n        RETURN the MINIMUM value IN dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-candies-you-can-get-from-boxes", "passing_rate": 0.8571428571428571, "pseudocode": "CLASS Solution  \n    FUNCTION maxCandies(status LIST OF INTEGER, candies LIST OF INTEGER, keys LIST OF LIST OF INTEGER, containedBoxes LIST OF LIST OF INTEGER, initialBoxes LIST OF INTEGER) RETURNS INTEGER  \n        SET boxes_we_have TO a new set containing elements of initialBoxes  \n        SET keys_we_have TO an empty set  \n        SET total_candies TO zero  \n        SET progress_made TO true  \n        WHILE progress_made holds  \n            SET progress_made TO false  \n            FOR each box IN the set converted from boxes_we_have to a list  \n                IF the element at position box of status EQUALS one OR the element box is contained in keys_we_have  \n                    INCREMENT total_candies BY the element at position box of candies  \n                    ADD each element of the element at position box of keys TO keys_we_have  \n                    ADD each element of the element at position box of containedBoxes TO boxes_we_have  \n                    REMOVE the element box FROM boxes_we_have  \n                    SET progress_made TO true  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN total_candies  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "verbal-arithmetic-puzzle", "passing_rate": 0.9811320754716981, "pseudocode": "CLASS Solution  \n    FUNCTION isSolvable(words, result)  \n        SET unique_chars TO the SET OF all characters IN concatenation OF all elements IN words PLUS all characters IN result  \n        IF the SIZE OF unique_chars GREATER THAN ten  \n            RETURN False  \n        END IF  \n        \n        SET non_zero_chars TO the SET OF element at position zero OF each word IN words WHERE the LENGTH OF word GREATER THAN one  \n        IF the LENGTH OF result GREATER THAN one  \n            ADD element at position zero OF result TO non_zero_chars  \n        END IF  \n        \n        SET char_to_digit TO an empty MAPPING  \n        SET digit_to_char TO an empty MAPPING  \n        \n        FUNCTION can_assign(char, digit)  \n            RETURN char NOT IN char_to_digit AND (digit NOT IN digit_to_char OR element at key digit OF digit_to_char EQUALS char)  \n        END FUNCTION  \n        \n        FUNCTION assign(char, digit)  \n            SET element at key char OF char_to_digit TO digit  \n            SET element at key digit OF digit_to_char TO char  \n        END FUNCTION  \n        \n        FUNCTION unassign(char, digit)  \n            REMOVE element at key char FROM char_to_digit  \n            REMOVE element at key digit FROM digit_to_char  \n        END FUNCTION  \n        \n        FUNCTION word_value(word)  \n            SET total_value TO zero  \n            FOR each index i AND character char IN the REVERSE ORDER of characters IN word  \n                INCREMENT total_value BY element at key char OF char_to_digit MULTIPLIED BY ten RAISED TO the power of i  \n            END FOR  \n            RETURN total_value  \n        END FUNCTION  \n        \n        FUNCTION backtrack(index, col, sum_col)  \n            SET max_word_length TO the MAXIMUM LENGTH OF each word IN words  \n            IF col GREATER THAN OR EQUAL TO max_word_length AND col GREATER THAN OR EQUAL TO the LENGTH OF result  \n                RETURN sum_col EQUALS zero  \n            END IF  \n            \n            IF index EQUALS the LENGTH OF words  \n                IF col LESS THAN the LENGTH OF result  \n                    SET digit_char TO element at position LENGTH OF result MINUS one MINUS col OF result  \n                    IF digit_char IN char_to_digit  \n                        IF element at key digit_char OF char_to_digit EQUALS sum_col MODULO ten  \n                            RETURN backtrack zero col PLUS one sum_col DIVIDED BY ten  \n                        ELSE  \n                            RETURN False  \n                        END IF  \n                    ELSE IF can_assign digit_char sum_col MODULO ten AND (sum_col MODULO ten NOT EQUALS zero OR digit_char NOT IN non_zero_chars)  \n                        assign digit_char sum_col MODULO ten  \n                        IF backtrack zero col PLUS one sum_col DIVIDED BY ten  \n                            RETURN True  \n                        END IF  \n                        unassign digit_char sum_col MODULO ten  \n                    END IF  \n                ELSE  \n                    RETURN sum_col EQUALS zero  \n                END IF  \n                RETURN False  \n            END IF  \n            \n            SET current_word TO element at position index OF words  \n            IF col GREATER THAN OR EQUAL TO the LENGTH OF current_word  \n                RETURN backtrack index PLUS one col sum_col  \n            END IF  \n            \n            SET current_char TO element at position LENGTH OF current_word MINUS one MINUS col OF current_word  \n            IF current_char IN char_to_digit  \n                RETURN backtrack index PLUS one col sum_col PLUS element at key current_char OF char_to_digit  \n            END IF  \n            \n            FOR digit FROM zero TO nine  \n                IF can_assign current_char digit AND (digit NOT EQUALS zero OR current_char NOT IN non_zero_chars)  \n                    assign current_char digit  \n                    IF backtrack index PLUS one col sum_col PLUS digit  \n                        RETURN True  \n                    END IF  \n                    unassign current_char digit  \n                END IF  \n            END FOR  \n            \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN backtrack zero zero zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-taps-to-open-to-water-a-garden", "passing_rate": 0.9591836734693877, "pseudocode": "CLASS Solution  \n    FUNCTION minTaps(n, ranges)  \n        SET max_range TO a list of zeros with the length equal to the value of n PLUS one  \n        \n        FOR index i FROM zero TO the value of n  \n            IF the element at position i of ranges GREATER THAN zero  \n                SET left TO the greater value between zero AND the result of index i MINUS the element at position i of ranges  \n                SET right TO the lesser value between the value of n AND the result of index i PLUS the element at position i of ranges  \n                IF the element at position left of max_range LESS THAN the value of right  \n                    SET the element at position left of max_range TO the value of right  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET taps TO zero  \n        SET current_end TO zero  \n        SET farthest TO zero  \n        \n        FOR index i FROM zero TO the value of n  \n            IF index i GREATER THAN farthest  \n                RETURN negative one  \n            END IF  \n            IF index i GREATER THAN current_end  \n                INCREMENT taps BY one  \n                SET current_end TO farthest  \n            END IF  \n            IF farthest LESS THAN the element at position i of max_range  \n                SET farthest TO the element at position i of max_range  \n            END IF  \n        END FOR  \n        \n        RETURN taps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-of-cutting-a-pizza", "passing_rate": 0.967741935483871, "pseudocode": "CLASS Solution  \n    FUNCTION ways(pizza, k)  \n        FUNCTION dfs(i, j, k)  \n            IF k EQUALS zero  \n                IF the number of apples in the rectangular area from row i to the last row and from column j to the last column of the pizza is GREATER THAN zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM i PLUS one TO the number of rows in pizza MINUS one  \n                IF the number of apples in the rectangular area from row x to the last row and from column j to the last column of the pizza is GREATER THAN zero  \n                    INCREMENT ans BY dfs(x, j, k MINUS one)  \n                END IF  \n            END FOR  \n            FOR y FROM j PLUS one TO the number of columns in pizza MINUS one  \n                IF the number of apples in the rectangular area from row i to the last row and from column y to the last column of the pizza is GREATER THAN zero  \n                    INCREMENT ans BY dfs(i, y, k MINUS one)  \n                END IF  \n            END FOR  \n            RETURN ans MODULO the value of mod  \n        END FUNCTION  \n\n        SET mod TO one billion PLUS seven  \n        SET m TO the number of rows in pizza  \n        SET n TO the number of columns in pizza  \n        SET s TO a two dimensional list with the number of rows equal to m PLUS one and the number of columns equal to n PLUS one filled with zeros  \n        FOR each i and row in pizza starting the count at one  \n            FOR each j and character in row starting the count at one  \n                SET s at position i and j TO the value at position i MINUS one and j PLUS the value at position i and j MINUS one MINUS the value at position i MINUS one and j MINUS one PLUS one IF character EQUALS the apple character OTHERWISE zero  \n            END FOR  \n        END FOR  \n        RETURN dfs(zero, zero, k MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "form-largest-integer-with-digits-that-add-up-to-target", "passing_rate": 0.9722222222222222, "pseudocode": "CLASS Solution  \n    FUNCTION largestNumber(cost, target)  \n        CREATE a dictionary cost to digit mapping each element in cost to the string representation of its one based index  \n        SET dp TO a list starting with an empty string followed by target number of elements each set to a string representing negative one  \n        FOR t FROM one TO target  \n            FOR each cost value c and corresponding digit string d in the dictionary cost to digit  \n                IF t is greater than or equal to c AND element at position t MINUS c of dp does NOT EQUAL the string representing negative one  \n                    SET candidate TO concatenation of d followed by element at position t MINUS c of dp  \n                    IF element at position t of dp EQUALS the string representing negative one OR LENGTH OF candidate greater than LENGTH OF element at position t of dp OR (LENGTH OF candidate EQUALS LENGTH OF element at position t of dp AND candidate lexicographically greater than element at position t of dp)  \n                        SET element at position t of dp TO candidate  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        IF element at position target of dp NOT EQUALS the string representing negative one  \n            RETURN element at position target of dp  \n        ELSE  \n            RETURN the string representing zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree", "passing_rate": 0.9795918367346939, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self n)  \n        SET self.parent TO list of integers from zero TO n MINUS one  \n        SET self.rank TO list of integer one repeated n times  \n    END FUNCTION  \n\n    FUNCTION find(self u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self u v)  \n        SET rootU TO self.find(u)  \n        SET rootV TO self.find(v)  \n\n        IF rootU NOT EQUALS rootV THEN  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank THEN  \n                SET element at position rootV of self.parent TO rootU  \n            ELSE IF element at position rootU of self.rank LESS THAN element at position rootV of self.rank THEN  \n                SET element at position rootU of self.parent TO rootV  \n            ELSE  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.rank BY one  \n            END IF  \n            RETURN True  \n        END IF  \n        RETURN False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findCriticalAndPseudoCriticalEdges(self n edges)  \n        FOR index i AND element edge IN elements of edges WITH index  \n            APPEND i TO edge  \n        END FOR  \n\n        SORT edges BY weight which is element at position three of each edge  \n\n        FUNCTION mst(exclude=None include=None)  \n            SET uf TO new UnionFind with parameter n  \n            SET weight TO zero  \n\n            IF include IS NOT None THEN  \n                CALL uf.union with parameters element at position zero of include AND element at position one of include  \n                INCREMENT weight BY element at position two of include  \n            END IF  \n\n            FOR each element edge IN edges  \n                IF element at position three of edge EQUALS exclude THEN  \n                    CONTINUE TO next iteration  \n                END IF  \n\n                IF uf.union(element at position zero of edge element at position one of edge) THEN  \n                    INCREMENT weight BY element at position two of edge  \n                END IF  \n            END FOR  \n\n            SET root TO uf.find(zero)  \n            FOR index i FROM zero TO n MINUS one  \n                IF uf.find(i) NOT EQUALS root THEN  \n                    RETURN infinity  \n                END IF  \n            END FOR  \n\n            RETURN weight  \n        END FUNCTION  \n\n        SET mst_weight TO result of calling mst with no parameters  \n        SET critical TO empty list  \n        SET pseudo_critical TO empty list  \n\n        FOR each element edge IN edges  \n            IF result of calling mst with exclude parameter as element at position three of edge GREATER THAN mst_weight THEN  \n                APPEND element at position three of edge TO critical  \n            ELSE IF result of calling mst with include parameter as tuple of element zero edge element one edge element two edge EQUALS mst_weight THEN  \n                APPEND element at position three of edge TO pseudo_critical  \n            END IF  \n        END FOR  \n\n        RETURN list containing critical AND pseudo_critical  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "passing_rate": 0.96, "pseudocode": "CLASS Solution  \n    FUNCTION minInteger(num, k)  \n        SET num TO list of elements in num  \n        SET n TO the LENGTH OF num  \n        \n        WHILE k GREATER THAN zero  \n            SET swapped TO False  \n            FOR i FROM zero TO n MINUS one MINUS one  \n                IF element at position i of num GREATER THAN element at position i PLUS one of num  \n                    SET min_digit TO the character nine  \n                    SET min_index TO negative one  \n                    FOR j FROM i TO MINIMUM OF i PLUS k PLUS one AND n MINUS one  \n                        IF element at position j of num LESS THAN min_digit  \n                            SET min_digit TO element at position j of num  \n                            SET min_index TO j  \n                        END IF  \n                    END FOR  \n                    \n                    SET num elements from position i TO min_index INCLUSIVE TO a new list consisting of element at position min_index of num FOLLOWED BY the elements from position i TO min_index MINUS one of num  \n                    DECREMENT k BY min_index MINUS i  \n                    SET swapped TO True  \n                    BREAK the FOR loop  \n                END IF  \n            END FOR  \n            \n            IF swapped EQUALS False  \n                BREAK the WHILE loop  \n            END IF  \n        END WHILE  \n        \n        RETURN the concatenation of all elements in num into a single string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-connect-two-groups-of-points", "passing_rate": 0.8076923076923077, "pseudocode": "CLASS Solution  \n    FUNCTION connectTwoGroups(cost)  \n        SET size1 TO the LENGTH OF cost  \n        SET size2 TO the LENGTH OF the element at position zero of cost  \n        INITIALIZE dp AS a two dimensional list with size1 PLUS one rows AND two RAISED TO THE power OF size2 columns  \n        FOR each row_index FROM zero TO size1  \n            FOR each column_index FROM zero TO two RAISED TO THE power OF size2 MINUS one  \n                SET the element at row_index and column_index of dp TO infinity  \n            END FOR  \n        END FOR  \n        SET the element at zero and zero of dp TO zero  \n      \n        FOR i FROM zero TO size1 MINUS one  \n            FOR mask FROM zero TO two RAISED TO THE power OF size2 MINUS one  \n                FOR j FROM zero TO size2 MINUS one  \n                    SET new_mask TO mask OR two RAISED TO THE power OF j  \n                    IF the element at i PLUS one and new_mask of dp IS GREATER THAN the element at i and mask of dp PLUS the element at i and j of cost  \n                        SET the element at i PLUS one and new_mask of dp TO the element at i and mask of dp PLUS the element at i and j of cost  \n                    END IF  \n                END FOR  \n                FOR j FROM zero TO size2 MINUS one  \n                    IF mask AND two RAISED TO THE power OF j HOLDS  \n                        SET toggled_mask TO mask XOR two RAISED TO THE power OF j  \n                        IF the element at i PLUS one and mask of dp IS GREATER THAN the element at i PLUS one and toggled_mask of dp PLUS the element at i and j of cost  \n                            SET the element at i PLUS one and mask of dp TO the element at i PLUS one and toggled_mask of dp PLUS the element at i and j of cost  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n      \n        RETURN the element at size1 and two RAISED TO THE power OF size2 MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "graph-connectivity-with-threshold", "passing_rate": 0.8928571428571429, "pseudocode": "CLASS Solution  \n    FUNCTION areConnected(n, threshold, queries)  \n        IF threshold EQUALS zero  \n            RETURN a list of TRUE values with the length equal to the number of elements in queries  \n        END IF  \n\n        SET parent TO a list of integers from zero TO n inclusive  \n\n        FUNCTION find(x)  \n            IF the element at position x of parent NOT EQUALS x  \n                SET the element at position x of parent TO find(the element at position x of parent)  \n            END IF  \n            RETURN the element at position x of parent  \n        END FUNCTION  \n\n        FUNCTION union(x, y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET the element at position rootY of parent TO rootX  \n            END IF  \n        END FUNCTION  \n\n        FOR i FROM threshold PLUS one TO n  \n            FOR j FROM i MULTIPLIED BY two TO n IN STEPS OF i  \n                CALL union(i, j)  \n            END FOR  \n        END FOR  \n\n        SET result TO an empty list  \n        FOR each pair of variables a and b IN queries  \n            APPEND the expression whether find(a) EQUALS find(b) TO result  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "checking-existence-of-edge-length-limited-paths", "passing_rate": 0.9487179487179487, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__ WITH PARAMETER size  \n        SET parent TO an empty list  \n        FOR each number FROM zero TO size MINUS one  \n            APPEND number TO parent  \n        END FOR  \n        SET rank TO an empty list  \n        FOR each number FROM zero TO size MINUS one  \n            APPEND one TO rank  \n        END FOR  \n    END FUNCTION  \n  \n    FUNCTION find WITH PARAMETER p  \n        IF element at position p of parent NOT EQUALS p  \n            SET element at position p of parent TO the result of find WITH PARAMETER element at position p of parent  \n        END IF  \n        RETURN element at position p of parent  \n    END FUNCTION  \n  \n    FUNCTION union WITH PARAMETERS p AND q  \n        SET rootP TO the result of find WITH PARAMETER p  \n        SET rootQ TO the result of find WITH PARAMETER q  \n        IF rootP EQUALS rootQ  \n            RETURN False  \n        END IF  \n        IF element at position rootP of rank GREATER THAN element at position rootQ of rank  \n            SET element at position rootQ of parent TO rootP  \n        ELSE IF element at position rootP of rank LESS THAN element at position rootQ of rank  \n            SET element at position rootP of parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of parent TO rootP  \n            INCREMENT element at position rootP of rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION distanceLimitedPathsExist WITH PARAMETERS n edgeList queries  \n        SORT edgeList IN ASCENDING ORDER BY the element at position three of each sublist  \n        SET indexedQueries TO an empty list  \n        SET index TO zero  \n        FOR each element IN queries  \n            SET p TO element at position zero of element  \n            SET q TO element at position one of element  \n            SET limit TO element at position two of element  \n            APPEND a tuple of limit p q index TO indexedQueries  \n            INCREMENT index BY one  \n        END FOR  \n        SORT indexedQueries IN ASCENDING ORDER  \n        CREATE a new UnionFind instance WITH PARAMETER n AND ASSIGN IT TO uf  \n        SET edgeIndex TO zero  \n        SET numEdges TO the LENGTH OF edgeList  \n        SET results TO a list of False values HAVING THE SAME LENGTH AS queries  \n        FOR each limit p q originalIndex IN indexedQueries  \n            WHILE edgeIndex LESS THAN numEdges AND element at position two of element at position edgeIndex of edgeList LESS THAN limit  \n                SET u TO element at position zero of element at position edgeIndex of edgeList  \n                SET v TO element at position one of element at position edgeIndex of edgeList  \n                CALL union ON uf WITH PARAMETERS u v  \n                INCREMENT edgeIndex BY one  \n            END WHILE  \n            IF the result of find ON uf WITH PARAMETER p EQUALS the result of find ON uf WITH PARAMETER q  \n                SET element at position originalIndex of results TO True  \n            END IF  \n        END FOR  \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-special-evenly-spaced-elements-in-array", "passing_rate": 0.9333333333333333, "pseudocode": "CLASS Solution  \n    FUNCTION solve(nums, queries)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET n TO the LENGTH OF nums  \n\n        SET max_y TO the maximum y value from each pair of first and y in queries  \n\n        INITIALIZE prefix_sums AS a list of lists  \n        FOR each y FROM one TO max_y INCLUSIVE  \n            CREATE a list of zeros of length n AND APPEND to prefix_sums  \n        END FOR  \n\n        FOR each y FROM one TO max_y INCLUSIVE  \n            FOR each i FROM n MINUS one DOWN TO zero  \n                IF i PLUS y LESS THAN n THEN  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums PLUS element at position i PLUS y of prefix_sums at position y  \n                ELSE  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums  \n                END IF  \n            END FOR  \n        END FOR  \n\n        INITIALIZE answer AS an empty list  \n        FOR each pair of x and y IN queries  \n            APPEND element at position x of prefix_sums at position y MODULO MOD TO answer  \n        END FOR  \n\n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-minimum-time-to-finish-all-jobs", "passing_rate": 0.9166666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTimeRequired(jobs, k)  \n        SET n TO the LENGTH OF jobs  \n        SET subset_sums TO a list OF zero VALUES OF SIZE two RAISED TO THE POWER OF n  \n        FOR i FROM zero TO n MINUS one  \n            FOR mask FROM zero TO two RAISED TO THE POWER OF i MINUS one  \n                SET element at position mask OR with two RAISED TO THE POWER OF i OF subset_sums TO element at position mask OF subset_sums PLUS element at position i OF jobs  \n            END FOR  \n        END FOR  \n        \n        FUNCTION dp(k, mask)  \n            IF k EQUALS one THEN  \n                RETURN element at position mask OF subset_sums  \n            END IF  \n            SET res TO positive infinity  \n            SET submask TO mask  \n            WHILE submask GREATER THAN zero  \n                SET temp_result_one TO dp(k MINUS one, mask XOR submask)  \n                SET temp_result_two TO element at position submask OF subset_sums  \n                SET candidate TO the GREATER OF temp_result_one AND temp_result_two  \n                IF candidate LESS THAN res THEN  \n                    SET res TO candidate  \n                END IF  \n                SET submask TO submask MINUS one AND mask  \n            END WHILE  \n            RETURN res  \n        END FUNCTION  \n        \n        RETURN dp(k, two RAISED TO THE POWER OF n MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-degree-of-a-connected-trio-in-a-graph", "passing_rate": 0.975609756097561, "pseudocode": "CLASS Solution  \n    FUNCTION minTrioDegree(n parameter, edges parameter)  \n        SET graph TO empty mapping from integer to empty set for each integer FROM one TO n parameter  \n        FOR each pair u parameter, v parameter IN edges parameter  \n            ADD v parameter TO the set corresponding to u parameter in graph  \n            ADD u parameter TO the set corresponding to v parameter in graph  \n        END FOR  \n        SET min_degree TO infinite value  \n        SET trio_found TO false  \n        FOR i parameter FROM one TO n parameter  \n            FOR j parameter FROM i parameter PLUS one TO n parameter  \n                FOR k parameter FROM j parameter PLUS one TO n parameter  \n                    IF element j parameter IS IN the set corresponding to i parameter in graph AND element k parameter IS IN the set corresponding to i parameter in graph AND element k parameter IS IN the set corresponding to j parameter in graph  \n                        SET trio_found TO true  \n                        SET trio_degree TO the LENGTH OF the set corresponding to i parameter in graph PLUS the LENGTH OF the set corresponding to j parameter in graph PLUS the LENGTH OF the set corresponding to k parameter in graph MINUS six  \n                        IF trio_degree LESS THAN min_degree  \n                            SET min_degree TO trio_degree  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        IF trio_found EQUALS true  \n            RETURN min_degree  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-pairs-with-xor-in-a-range", "passing_rate": 0.9807692307692307, "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__()  \n        SET children TO an empty mapping from bits to TrieNode  \n        SET count TO zero  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Trie  \n    FUNCTION __init__(bit_length)  \n        ASSIGN reference TO a new TrieNode and SET root TO this reference  \n        SET bit_length TO the value of bit_length parameter  \n    END FUNCTION  \n\n    FUNCTION insert(num)  \n        SET node TO root  \n        FOR integer i FROM bit_length DOWN TO zero  \n            SET bit TO the result of obtaining the bit at position i from num by shifting num right by i positions AND extracting value one  \n            IF bit NOT IN the keys of node's children mapping THEN  \n                ASSIGN reference TO a new TrieNode and ASSIGN it to node's children at key bit  \n            END IF  \n            SET node TO the element at key bit in node's children mapping  \n            INCREMENT node's count BY one  \n        END FOR  \n    END FUNCTION  \n\n    FUNCTION count_less_than(num, threshold)  \n        SET count TO zero  \n        SET node TO root  \n        FOR integer i FROM bit_length DOWN TO zero  \n            IF node IS NOT a valid reference THEN  \n                BREAK the loop  \n            END IF  \n            SET bit TO the result of obtaining the bit at position i from num by shifting num right by i positions AND extracting value one  \n            SET threshold_bit TO the result of obtaining the bit at position i from threshold by shifting threshold right by i positions AND extracting value one  \n            IF threshold_bit EQUALS one THEN  \n                INCREMENT count BY count of the element at key bit in node's children mapping IF such exists OTHERWISE zero  \n                SET node TO the element at key opposite bit of bit in node's children mapping  \n            ELSE  \n                SET node TO the element at key bit in node's children mapping  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION countPairs(nums, low, high)  \n        ASSIGN reference TO a new Trie and SET trie TO this reference  \n        SET nice_pairs TO zero  \n        FOR each num IN nums  \n            INCREMENT nice_pairs BY the result of trie.count_less_than with num and high PLUS one MINUS the result of trie.count_less_than with num and low  \n            CALL trie.insert with num  \n        END FOR  \n        RETURN nice_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-reach-destination-in-time", "passing_rate": 0.9245283018867925, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(maxTime, edges, passingFees)  \n        SET n TO the LENGTH OF passingFees  \n        SET graph TO an empty list containing n empty lists  \n        FOR each x y time IN edges  \n            APPEND the pair of y AND time TO element at position x of graph  \n            APPEND the pair of x AND time TO element at position y of graph  \n        END FOR  \n        \n        SET pq TO a list containing a tuple of element at position zero of passingFees AND zero AND zero  \n        SET visited_time TO a list of length n with each element set to infinity  \n        SET element at position zero of visited_time TO zero  \n        \n        WHILE pq is not empty  \n            REMOVE from pq the element with the smallest first element and ASSIGN current_cost current_city current_time FROM that element  \n            \n            IF current_city EQUALS n MINUS one  \n                RETURN current_cost  \n            END IF  \n            \n            FOR each neighbor travel_time IN element at position current_city of graph  \n                SET new_time TO current_time PLUS travel_time  \n                SET new_cost TO current_cost PLUS element at position neighbor of passingFees  \n                \n                IF new_time LESS THAN OR EQUAL TO maxTime AND (new_time LESS THAN element at position neighbor of visited_time OR new_cost LESS THAN current_cost)  \n                    SET element at position neighbor of visited_time TO new_time  \n                    ADD the tuple of new_cost neighbor new_time TO pq maintaining its priority order by first element  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-visible-people-in-a-queue", "passing_rate": 0.9047619047619048, "pseudocode": "CLASS Solution  \n    FUNCTION canSeePersonsCount WITH parameter heights  \n        SET n TO the LENGTH OF heights  \n        SET answer TO list of zeroes of LENGTH n  \n        SET stack TO empty list  \n        FOR index i FROM zero TO n MINUS one  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND the element at position element at the LAST POSITION OF stack of heights IS LESS THAN the element at position i of heights  \n                SET popped_index TO the element REMOVED FROM the LAST POSITION OF stack  \n                INCREMENT the element at position popped_index of answer BY one  \n            END WHILE  \n            IF the LENGTH OF stack IS GREATER THAN zero  \n                INCREMENT the element at position the LAST POSITION OF stack of answer BY one  \n            END IF  \n            APPEND i TO stack  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-missing-genetic-value-in-each-subtree", "passing_rate": 0.9473684210526315, "pseudocode": "CLASS Solution  \n    FUNCTION smallestMissingValueSubtree(parents AS List OF integer, nums AS List OF integer) RETURNS List OF integer  \n        SET n TO the LENGTH OF parents  \n        SET tree TO a mapping with default of empty list  \n        \n        FOR i FROM one TO n MINUS one  \n            APPEND i TO the list mapped by element at position i of parents in tree  \n        END FOR  \n        \n        SET node_with_one TO negative one  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of nums EQUALS one THEN  \n                SET node_with_one TO i  \n                BREAK  \n            END IF  \n        END FOR  \n        \n        IF node_with_one EQUALS negative one THEN  \n            RETURN a list of one repeated n times  \n        END IF  \n        \n        SET result TO a list of one repeated n times  \n        \n        FUNCTION dfs(node AS integer) RETURNS set of integer  \n            ADD node TO visited  \n            SET genetic_values TO a new set containing element at position node of nums  \n            FOR each child IN the list mapped by node in tree  \n                IF child NOT IN visited THEN  \n                    SET genetic_values TO the union of genetic_values and dfs(child)  \n                END IF  \n            END FOR  \n            SET smallest_missing TO one  \n            WHILE smallest_missing IS IN genetic_values  \n                INCREMENT smallest_missing BY one  \n            END WHILE  \n            SET element at position node of result TO smallest_missing  \n            RETURN genetic_values  \n        END FUNCTION  \n        \n        SET visited TO an empty set  \n        SET path TO an empty list  \n        SET current TO node_with_one  \n        WHILE current NOT EQUALS negative one  \n            APPEND current TO path  \n            SET current TO element at position current of parents  \n        END WHILE  \n        \n        SET path_set TO a set containing elements of path  \n        FOR each node IN path in reverse order  \n            IF node IN visited THEN  \n                CONTINUE  \n            END IF  \n            CALL dfs(node)  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "process-restricted-friend-requests", "passing_rate": 0.8461538461538461, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO a list containing numbers from zero TO n MINUS one  \n        SET self.size TO a list containing one repeated n times  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET root_u TO self.find(u)  \n        SET root_v TO self.find(v)  \n        IF root_u NOT EQUALS root_v THEN  \n            IF element at position root_u of self.size GREATER THAN element at position root_v of self.size THEN  \n                SET element at position root_v of self.parent TO root_u  \n                INCREMENT element at position root_u of self.size BY element at position root_v of self.size  \n            ELSE  \n                SET element at position root_u of self.parent TO root_v  \n                INCREMENT element at position root_v of self.size BY element at position root_u of self.size  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION friendRequests(self, n, restrictions, requests)  \n        ASSIGN reference TO object UnionFind CREATED WITH parameter n TO variable uf  \n        SET result TO an empty list  \n        SET restriction_map TO an empty dictionary  \n\n        FOR each pair of values x and y IN restrictions  \n            IF x NOT IN keys of restriction_map THEN  \n                SET element at key x of restriction_map TO an empty set  \n            END IF  \n            IF y NOT IN keys of restriction_map THEN  \n                SET element at key y of restriction_map TO an empty set  \n            END IF  \n            ADD y TO the set at key x of restriction_map  \n            ADD x TO the set at key y of restriction_map  \n        END FOR  \n\n        FUNCTION can_union(u, v)  \n            SET root_u TO uf.find(u)  \n            SET root_v TO uf.find(v)  \n            FOR each person IN the set at key root_u of restriction_map OR empty set if absent  \n                IF uf.find(person) EQUALS root_v THEN  \n                    RETURN False  \n                END IF  \n            END FOR  \n            FOR each person IN the set at key root_v of restriction_map OR empty set if absent  \n                IF uf.find(person) EQUALS root_u THEN  \n                    RETURN False  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n\n        FOR each pair of values u and v IN requests  \n            IF uf.find(u) EQUALS uf.find(v) THEN  \n                APPEND True TO result  \n            ELSE IF can_union(u, v) THEN  \n                CALL uf.union(u, v)  \n                APPEND True TO result  \n            ELSE  \n                APPEND False TO result  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "recover-the-original-array", "passing_rate": 0.96, "pseudocode": "CLASS Solution  \n    FUNCTION recoverArray(nums)  \n        CALL sort ON nums  \n        SET n TO the LENGTH OF nums  \n\n        SET first TO the element at position one of nums  \n\n        FOR i FROM two TO n  \n            SET k TO the element at position i of nums MINUS first DIVIDED BY two  \n            IF k LESS THAN OR EQUAL TO zero OR first PLUS two MULTIPLIED BY k NOT EQUALS the element at position i of nums  \n                CONTINUE TO the next iteration  \n            END IF  \n\n            SET count TO a COUNTER object initialized with nums  \n            SET arr TO an empty list  \n\n            FOR each element x IN nums  \n                IF the count of x EQUALS zero  \n                    CONTINUE TO the next iteration  \n                END IF  \n                IF the count of x PLUS two MULTIPLIED BY k EQUALS zero  \n                    BREAK out of the loop  \n                END IF  \n\n                APPEND x PLUS k TO arr  \n                DECREMENT the count of x BY one  \n                DECREMENT the count of x PLUS two MULTIPLIED BY k BY one  \n            END FOR  \n\n            IF the LENGTH OF arr EQUALS n DIVIDED BY two  \n                RETURN arr  \n            END IF  \n        END FOR  \n\n        RETURN an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "groups-of-strings", "passing_rate": 0.9019607843137255, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO a list containing the sequence of numbers from zero to size MINUS one  \n        SET self.rank TO a list containing size number of zeros  \n        SET self.size TO a list containing size number of ones  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF the element at position u of self.parent NOT EQUALS u THEN  \n            SET the element at position u of self.parent TO the result of calling self.find with argument the element at position u of self.parent  \n        END IF  \n        RETURN the element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET rootU TO the result of calling self.find with argument u  \n        SET rootV TO the result of calling self.find with argument v  \n        IF rootU NOT EQUALS rootV THEN  \n            IF the element at position rootU of self.rank GREATER THAN the element at position rootV of self.rank THEN  \n                SET the element at position rootV of self.parent TO rootU  \n                INCREMENT the element at position rootU of self.size BY the element at position rootV of self.size  \n            ELSE IF the element at position rootU of self.rank LESS THAN the element at position rootV of self.rank THEN  \n                SET the element at position rootU of self.parent TO rootV  \n                INCREMENT the element at position rootV of self.size BY the element at position rootU of self.size  \n            ELSE  \n                SET the element at position rootV of self.parent TO rootU  \n                INCREMENT the element at position rootU of self.size BY the element at position rootV of self.size  \n                INCREMENT the element at position rootU of self.rank BY one  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION groupStrings(self, words)  \n        FUNCTION bitmask(word)  \n            SET mask TO zero  \n            FOR each char IN word  \n                SET mask TO mask OR the value one MULTIPLIED BY two RAISED TO the power of the numerical code of char MINUS the numerical code of the lowercase letter a  \n            END FOR  \n            RETURN mask  \n        END FUNCTION  \n\n        SET word_map TO a new mapping with default value empty list  \n        SET n TO the length of words  \n        SET uf TO a new instance of UnionFind with argument n  \n\n        FOR each index i and word IN words  \n            SET mask TO the result of calling bitmask with argument word  \n            APPEND i TO the list at key mask of word_map  \n        END FOR  \n\n        FOR each index i and word IN words  \n            SET mask TO the result of calling bitmask with argument word  \n            FOR each number j FROM zero TO twenty five  \n                SET new_mask TO the value of mask XOR one MULTIPLIED BY two RAISED TO the power of j  \n                IF new_mask is a key in word_map THEN  \n                    FOR each element k IN the list at key new_mask of word_map  \n                        CALL uf.union with arguments i and k  \n                    END FOR  \n                END IF  \n\n                IF the value of mask AND one MULTIPLIED BY two RAISED TO the power of j EQUALS zero THEN  \n                    SET new_mask TO the value of mask OR one MULTIPLIED BY two RAISED TO the power of j  \n                    IF new_mask is a key in word_map THEN  \n                        FOR each element k IN the list at key new_mask of word_map  \n                            CALL uf.union with arguments i and k  \n                        END FOR  \n                    END IF  \n                END IF  \n\n                IF the value of mask AND one MULTIPLIED BY two RAISED TO the power of j NOT EQUALS zero THEN  \n                    FOR each number k FROM zero TO twenty five  \n                        IF the value of mask AND one MULTIPLIED BY two RAISED TO the power of k EQUALS zero THEN  \n                            SET new_mask TO the value of mask XOR one MULTIPLIED BY two RAISED TO the power of j OR one MULTIPLIED BY two RAISED TO the power of k  \n                            IF new_mask is a key in word_map THEN  \n                                FOR each element l IN the list at key new_mask of word_map  \n                                    CALL uf.union with arguments i and l  \n                                END FOR  \n                            END IF  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n\n        SET root_sizes TO a new mapping with default value zero  \n        FOR each number i FROM zero TO n MINUS one  \n            SET root TO the result of calling uf.find with argument i  \n            INCREMENT the value at key root of root_sizes BY one  \n        END FOR  \n\n        SET max_group_size TO the maximum value among the values of root_sizes  \n        SET num_groups TO the number of keys in root_sizes  \n\n        RETURN a list containing num_groups followed by max_group_size  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "amount-of-new-area-painted-each-day", "passing_rate": 0.9761904761904762, "pseudocode": "CLASS Solution  \n    FUNCTION amountPainted(paint)  \n        SET max_end TO the maximum value of the second element in each pair of paint  \n        SET painted TO a list of length max_end PLUS one filled with minus one  \n        SET worklog TO an empty list  \n        \n        FOR each pair start and end IN paint  \n            SET current_start TO start  \n            SET new_paint TO zero  \n            \n            WHILE current_start LESS THAN end  \n                IF element at position current_start of painted EQUALS minus one  \n                    SET element at position current_start of painted TO end  \n                    INCREMENT new_paint BY one  \n                    INCREMENT current_start BY one  \n                ELSE  \n                    SET current_start TO element at position current_start of painted  \n                END IF  \n            END WHILE  \n            \n            APPEND new_paint TO worklog  \n        END FOR  \n        \n        RETURN worklog  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distance-to-a-cycle-in-undirected-graph", "passing_rate": 0.8055555555555556, "pseudocode": "CLASS Solution  \n    FUNCTION distanceToCycle(n, edges)  \n        SET graph TO an empty default collection with list as default type  \n        FOR each pair u AND v IN edges  \n            APPEND v TO the list at key u IN graph  \n            APPEND u TO the list at key v IN graph  \n        END FOR  \n        \n        FUNCTION dfs(node, parent, path, visited)  \n            IF node IS IN visited THEN  \n                SET cycle_start TO the position of node IN path  \n                RETURN the sublist of path FROM position cycle_start TO the end  \n            END IF  \n            ADD node TO visited  \n            APPEND node TO path  \n            FOR each neighbor IN the list at key node OF graph  \n                IF neighbor IS NOT EQUAL TO parent THEN  \n                    SET cycle TO dfs(neighbor, node, path, visited)  \n                    IF cycle IS NOT null THEN  \n                        RETURN cycle  \n                    END IF  \n                END IF  \n            END FOR  \n            REMOVE the last element FROM path  \n            RETURN null  \n        END FUNCTION  \n        \n        SET visited TO an empty set  \n        SET cycle TO null  \n        FOR node FROM zero TO n MINUS one  \n            IF node IS NOT IN visited THEN  \n                SET cycle TO dfs(node, negative one, an empty list, visited)  \n                IF cycle IS NOT null THEN  \n                    BREAK the loop  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET distance TO a list of zeros with length n  \n        SET queue TO a dequeue initialized with all nodes in cycle  \n        SET visited TO a set initialized with all nodes in cycle  \n        \n        SET level TO zero  \n        WHILE queue IS NOT empty  \n            FOR index FROM zero TO the length of queue MINUS one  \n                SET node TO the element removed from the front of queue  \n                SET the element at position node OF distance TO level  \n                FOR each neighbor IN the list at key node OF graph  \n                    IF neighbor IS NOT IN visited THEN  \n                        ADD neighbor TO visited  \n                        ADD neighbor TO the end of queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT level BY one  \n        END WHILE  \n        \n        RETURN distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "make-array-non-decreasing-or-non-increasing", "passing_rate": 0.9583333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION convertArray(nums)  \n        FUNCTION min_operations_to_non_decreasing(nums)  \n            SET max_heap TO empty list  \n            SET operations TO zero  \n            FOR each num IN nums  \n                IF max_heap IS NOT empty AND the NEGATION of the element at position zero of max_heap IS GREATER THAN num  \n                    INCREMENT operations BY the NEGATION of the value obtained by REMOVING the element at position zero of max_heap MINUS num  \n                    ADD the NEGATION of num TO max_heap  \n                END IF  \n                ADD the NEGATION of num TO max_heap  \n            END FOR  \n            RETURN operations  \n        END FUNCTION  \n        \n        FUNCTION min_operations_to_non_increasing(nums)  \n            SET min_heap TO empty list  \n            SET operations TO zero  \n            FOR each num IN nums  \n                IF min_heap IS NOT empty AND the element at position zero of min_heap IS LESS THAN num  \n                    INCREMENT operations BY num MINUS the value obtained by REMOVING the element at position zero of min_heap  \n                    ADD num TO min_heap  \n                END IF  \n                ADD num TO min_heap  \n            END FOR  \n            RETURN operations  \n        END FUNCTION  \n        \n        RETURN the MINIMUM OF the value returned by min_operations_to_non_decreasing with argument nums AND the value returned by min_operations_to_non_increasing with argument nums  \n    END FUNCTION  \nEND CLASS"}
