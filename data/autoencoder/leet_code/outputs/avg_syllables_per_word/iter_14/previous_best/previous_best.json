{
  "prompt": "Given source code containing classes, functions, and other code elements, generate a strictly hierarchical, maximally abstract pseudocode that:\n\n- Preserves all original class names, function names, and parameter names exactly; maintains precise nesting and structural hierarchy of classes, methods, and inner elements.\n- Uses intuitive, concise indentation to represent all code blocks and scopes exactly as in the original source.\n- Produces only uppercase pseudocode keywords as control markers: CLASS, FUNCTION, IF, ELSE IF, ELSE, FOR, WHILE, RETURN, END FUNCTION, END CLASS, END IF, END FOR, END WHILE.\n- Expresses all operations, conditions, and control flows fully and clearly in natural language without any programming syntax, symbols, or literal notation.\n- Converts all arithmetic and logical expressions into unambiguous, capitalized full-word operators, such as PLUS, MINUS, MULTIPLIED BY, DIVIDED BY, MODULO, EQUALS, NOT EQUALS, LESS THAN, LESS THAN OR EQUAL TO, GREATER THAN, GREATER THAN OR EQUAL TO, AND, OR, NOT.\n- Uses standard, uniform verbs for data manipulation actions: SET variable TO value, INCREMENT variable BY amount, DECREMENT variable BY amount, APPEND item TO list, REMOVE element FROM list, ASSIGN pointer/reference TO object.\n- Translates all indexing and element access into natural language phrases \u2014 e.g., element at position index of collection, substring from position start TO end of string.\n- Clearly spells out all conditional expressions and logical tests without abbreviations or programming shortcuts.\n- Describes loop iterations explicitly and naturally: FOR each element IN collection, FOR index FROM start TO end, WHILE condition holds.\n- Includes all original constructor and special method names verbatim with their exact parameters.\n- Represents complex data structure initializations, conversions, or helper routines as auxiliary FUNCTIONS with original names, describing only their essential abstract behaviors without language-specific implementation details.\n- Omits any form of literal notation such as brackets, braces, quotes, commas, colons, periods, or special symbols in data or code.\n- Omits all comments, explanations, notes, separators, or any textual or meta text before, after, or inside the pseudocode output.\n- Uses consistent descriptive terminology that balances clarity with conciseness, favoring natural language expressions with moderate syllabic complexity to improve readability and abstraction.\n- Outputs code only as pseudocode matching the above style and conventions, preserving exact class and function names and parameter lists from the input code.\n\nHere is an example of the desired pseudocode style:\n\nFUNCTION calc_average(list_of_numbers)  \n    SET total_sum TO zero  \n    FOR each number IN list_of_numbers  \n        INCREMENT total_sum BY number  \n    END FOR  \n    SET average_value TO total_sum DIVIDED BY the LENGTH OF list_of_numbers  \n    RETURN average_value  \nEND FUNCTION",
  "response": "Given source code containing classes, functions, and other code elements, generate a strictly hierarchical, maximally abstract pseudocode that:\n\n- Preserves all original class names, function names, and parameter names exactly; maintains precise nesting and structural hierarchy of classes, methods, and inner elements.\n- Uses intuitive, concise indentation to represent all code blocks and scopes exactly as in the original source.\n- Produces only uppercase pseudocode keywords as control markers: CLASS, FUNCTION, IF, ELSE IF, ELSE, FOR, WHILE, RETURN, END FUNCTION, END CLASS, END IF, END FOR, END WHILE.\n- Expresses all operations, conditions, and control flows fully and clearly in natural language without any programming syntax, symbols, or literal notation.\n- Converts all arithmetic and logical expressions into unambiguous, capitalized full-word operators, such as PLUS, MINUS, MULTIPLIED BY, DIVIDED BY, MODULO, EQUALS, NOT EQUALS, LESS THAN, LESS THAN OR EQUAL TO, GREATER THAN, GREATER THAN OR EQUAL TO, AND, OR, NOT.\n- Uses standard, uniform verbs for data manipulation actions: SET variable TO value, INCREMENT variable BY amount, DECREMENT variable BY amount, APPEND item TO list, REMOVE element FROM list, ASSIGN pointer/reference TO object.\n- Translates all indexing and element access into natural language phrases \u2014 e.g., element at position index of collection, substring from position start TO end of string.\n- Clearly spells out all conditional expressions and logical tests without abbreviations or programming shortcuts.\n- Describes loop iterations explicitly and naturally: FOR each element IN collection, FOR index FROM start TO end, WHILE condition holds.\n- Includes all original constructor and special method names verbatim with their exact parameters.\n- Represents complex data structure initializations, conversions, or helper routines as auxiliary FUNCTIONS with original names, describing only their essential abstract behaviors without language-specific implementation details.\n- Omits any form of literal notation such as brackets, braces, quotes, commas, colons, periods, or special symbols in data or code.\n- Omits all comments, explanations, notes, separators, or any textual or meta text before, after, or inside the pseudocode output.\n- Uses consistent descriptive terminology that balances clarity with conciseness, favoring natural language expressions with moderate syllabic complexity to improve readability and abstraction.\n- Outputs code only as pseudocode matching the above style and conventions, preserving exact class and function names and parameter lists from the input code.\n\nHere is an example of the desired pseudocode style:\n\nFUNCTION calc_average(list_of_numbers)  \n    SET total_sum TO zero  \n    FOR each number IN list_of_numbers  \n        INCREMENT total_sum BY number  \n    END FOR  \n    SET average_value TO total_sum DIVIDED BY the LENGTH OF list_of_numbers  \n    RETURN average_value  \nEND FUNCTION",
  "score": 2.1681118081186868,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\nfrom typing import List\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n    \n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # Path compression\n        return self.parent[u]\n    \n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            # Union by size\n            if self.size[root_u] > self.size[root_v]:\n                self.parent[root_v] = root_u\n                self.size[root_u] += self.size[root_v]\n\nPseudocode for Problem 1:\nCLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO A LIST OF INTEGERS FROM zero TO n MINUS one  \n        SET self.size TO A LIST OF ONES WITH LENGTH n  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent IS NOT EQUAL TO u  \n            SET element at position u of self.parent TO THE RESULT OF self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET root_u TO self.find(u)  \n        SET root_v TO self.find(v)  \n        IF root_u IS NOT EQUAL TO root_v  \n            IF element at position root_u of self.size IS GREATER THAN element at position root_v of self.size  \n                SET element at position root_v of self.parent TO root_u  \n                INCREMENT element at position root_u of self.size BY element at position root_v of self.size  \n\nError(s) from the decoded code for Problem 1:\n['Outputs do not match']\n\nOriginal Code for Problem 2:\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        \n        # Dictionary to store the last two positions of each character\n        last = [-1] * 26\n        last2 = [-1] * 26\n        \n        result = 0\n        \n        for i, char in enumerate(s):\n            idx = ord(char) - ord('A')\n            \n            # Contribution of the current character\n            result = (result + (i - last[idx]) * (last[idx] - last2[idx])) % MOD\n            \n            # Update the last two positions\n            last2[idx] = last[idx]\n            last[idx] = i\n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION uniqueLetterString(s)  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        SET last TO a list containing negative one repeated twenty six times  \n        SET last2 TO a list containing negative one repeated twenty six times  \n        SET result TO zero  \n        FOR each pair of index i AND character char IN enumeration of s  \n            SET idx TO the ASCII code of char MINUS the ASCII code of capital A  \n            SET result TO the REMAINDER after division by MOD of result PLUS the difference between i AND element at position idx of last MULTIPLIED BY the difference between element at position idx of last AND element at position idx of last2  \n            SET element at position idx of last2 TO element at position idx of last  \n            SET element at position idx of last TO i  \n        END FOR  \n        FOR each index i FROM zero TO twenty five  \n            SET result TO the REMAINDER after division by MOD of result PLUS the difference between n AND element at position i of last MULTIPLIED BY the difference between element at position i of last AND element at position i of last2  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpkwx1umh3/solution_2.py\", line 36, in <module>\\n    print(Solution().uniqueLetterString(s = \"AaBbCc\"))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpkwx1umh3/solution_2.py\", line 28, in uniqueLetterString\\n    result += (i - last[idx]) * (last[idx] - last2[idx])\\n                   ~~~~^^^^^\\nIndexError: list index out of range\\n']\n\nOriginal Code for Problem 3:\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        \n        below_twenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                      \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def helper(n):\n            if n == 0:\n                return \"\"\n            elif n < 20:\n                return below_twenty[n] + \" \"\n            elif n < 100:\n                return tens[n // 10] + \" \" + helper(n % 10)\n            else:\n                return below_twenty[n // 100] + \" Hundred \" + helper(n % 100)\n        \n\nPseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION numberToWords(num)  \n        IF num EQUALS zero  \n            RETURN the word Zero  \n        END IF  \n        \n        SET below_twenty TO the list of words for numbers zero to nineteen starting with empty string for zero  \n        SET tens TO the list of words for ten multiples starting with empty strings for positions zero and one  \n        SET thousands TO the list containing empty string followed by Thousand Million and Billion  \n        \n        FUNCTION helper(n)  \n            IF n EQUALS zero  \n                RETURN empty string  \n            ELSE IF n LESS THAN twenty  \n                RETURN the element at position n of below_twenty concatenated with a single space  \n            ELSE IF n LESS THAN one hundred  \n                RETURN the element at position of the result of n DIVIDED BY ten of tens concatenated with a single space concatenated with the result of helper called with the remainder of n DIVIDED BY ten  \n            ELSE  \n                RETURN the element at position of the result of n DIVIDED BY one hundred of below_twenty concatenated with the word Hundred concatenated with a single space concatenated with the result of helper called with the remainder of n DIVIDED BY one hundred  \n            END IF  \n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpmuwqyg6o/solution_16.py\", line 53, in <module>\\n    print(Solution().numberToWords(num = 1000000000000))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpmuwqyg6o/solution_16.py\", line 48, in numberToWords\\n    result = helper(num % 1000) + thousands[i] + \" \" + result\\n                                  ~~~~~~~~~^^^\\nIndexError: list index out of range\\n']\n\nOriginal Code for Problem 4:\nfrom typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def shortestSuperstring(self, words: List[str]) -> str:\n        n = len(words)\n        \n        # Calculate the overlap between each pair of words\n        @lru_cache(None)\n        def overlap(i, j):\n            for k in range(min(len(words[i]), len(words[j])), 0, -1):\n                if words[i][-k:] == words[j][:k]:\n                    return k\n            return 0\n        \n        # Use dynamic programming to find the shortest superstring\n        @lru_cache(None)\n        def dp(mask, i):\n            if mask == (1 << n) - 1:\n                return (0, \"\")\n\nPseudocode for Problem 4:\nCLASS Solution  \n    FUNCTION shortestSuperstring(words)  \n        SET n TO the LENGTH OF words  \n        \n        FUNCTION overlap(i, j)  \n            FOR k FROM the MINIMUM OF the LENGTH OF element at position i of words AND the LENGTH OF element at position j of words DOWN TO one  \n                IF the SUBSTRING from position LENGTH OF element at position i of words MINUS k PLUS one TO the LENGTH OF element at position i of words of element at position i of words EQUALS the SUBSTRING from position one TO k of element at position j of words  \n                    RETURN k  \n                END IF  \n            END FOR  \n            RETURN zero  \n        END FUNCTION  \n        \n        FUNCTION dp(mask, i)  \n            IF mask EQUALS one SHIFTED LEFT BY n MINUS one  \n                RETURN zero AND empty string  \n            END IF  \n            \n            SET min_len TO positive infinity  \n            SET best_path TO empty string  \n\nError(s) from the decoded code for Problem 4:\n['Outputs do not match']\n\nOriginal Code for Problem 5:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:\n        def helper(node):\n            if not node:\n                return True, 0\n            \n            is_left_unival, left_count = helper(node.left)\n            is_right_unival, right_count = helper(node.right)\n            \n            if is_left_unival and is_right_unival:\n                if (not node.left or node.left.val == node.val) and (not node.right or node.right.val == node.val):\n                    return True, left_count + right_count + 1\n            \n            return False, left_count + right_count\n\nPseudocode for Problem 5:\nCLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS val EQUALS zero, left EQUALS none, right EQUALS none  \n        SET val ATTRIBUTE OF self TO val  \n        SET left ATTRIBUTE OF self TO left  \n        SET right ATTRIBUTE OF self TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values AS list  \n    IF values IS EMPTY  \n        RETURN none  \n    END IF  \n    SET root TO NEW TreeNode WITH PARAMETER element at position zero OF values  \n    SET i TO one  \n    SET queue TO NEW deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO FIRST ELEMENT REMOVED FROM queue  \n        IF i IS LESS THAN LENGTH OF values AND element at position i OF values IS NOT none  \n            SET left ATTRIBUTE OF node TO NEW TreeNode WITH PARAMETER element at position i OF values  \n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpcdg51r8c/solution_0.py\", line 105, in <module>\\n    print(Solution().countUnivalSubtrees(root = [1,1,2,1,1,null,1,null,null,null,null,1]))\\n                                                           ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 6:\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def wordsAbbreviation(self, words: List[str]) -> List[str]:\n        def abbreviate(word, prefix_length):\n            if len(word) - prefix_length <= 2:\n                return word\n            return word[:prefix_length] + str(len(word) - prefix_length - 1) + word[-1]\n\n        def get_unique_abbreviations(words_with_indices, prefix_length):\n            abbs = defaultdict(list)\n            for index, word in words_with_indices:\n                abbs[abbreviate(word, prefix_length)].append((index, word))\n            return abbs\n\n        n = len(words)\n        ans = [\"\"] * n\n        words_with_indices = [(i, word) for i, word in enumerate(words)]\n        \n\nPseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION wordsAbbreviation(words)  \n        FUNCTION abbreviate(word, prefix_length)  \n            IF the LENGTH OF word MINUS prefix_length IS LESS THAN OR EQUAL TO two  \n                RETURN word  \n            END IF  \n            RETURN the SUBSTRING OF word from position zero TO prefix_length MINUS one CONCATENATED WITH the FULL-WORD REPRESENTATION OF the LENGTH OF word MINUS prefix_length MINUS one CONCATENATED WITH the LAST CHARACTER OF word  \n        END FUNCTION  \n\n        FUNCTION get_unique_abbreviations(words_with_indices, prefix_length)  \n            SET abbs TO an empty mapping with default value as empty list  \n            FOR each index, word IN words_with_indices  \n                APPEND the pair index and word TO the list at the key given by abbreviate(word, prefix_length) IN abbs  \n            END FOR  \n            RETURN abbs  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF words  \n        SET ans TO a list of empty strings with size n  \n        SET words_with_indices TO the collection of pairs index and word for each index and word in words with their respective positions  \n\nError(s) from the decoded code for Problem 6:\n['Outputs do not match']\n\nOriginal Code for Problem 7:\nfrom collections import defaultdict, deque\nfrom typing import List\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Step 1: Build the graph\n        graph = defaultdict(dict)\n        for (a, b), value in zip(equations, values):\n            graph[a][b] = value\n            graph[b][a] = 1.0 / value\n        \n        # Step 2: Define a DFS function to find the result of the query\n        def dfs(start, end, visited):\n            if start not in graph or end not in graph:\n                return -1.0\n            if start == end:\n                return 1.0\n            visited.add(start)\n            for neighbor, weight in graph[start].items():\n                if neighbor not in visited:\n\nPseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION calcEquation(equations AS list of list of strings, values AS list of floating point numbers, queries AS list of list of strings) RETURNS list of floating point numbers  \n        SET graph TO an empty mapping where each key maps to a mapping of strings to floating point numbers  \n        \n        FOR each pair of variables named a and b in equations AND corresponding value in values simultaneously  \n            SET the element at position b of the element at position a of graph TO value  \n            SET the element at position a of the element at position b of graph TO one DIVIDED BY value  \n        END FOR  \n        \n        FUNCTION dfs(start AS string, end AS string, visited AS set of strings) RETURNS floating point number  \n            IF start IS NOT an element of graph OR end IS NOT an element of graph  \n                RETURN negative one floating point number  \n            END IF  \n            IF start EQUALS end  \n                RETURN one floating point number  \n            END IF  \n            ADD start TO visited  \n            FOR each neighbor and corresponding weight in the elements of graph at position start  \n                IF neighbor IS NOT an element of visited  \n                    SET result TO dfs(neighbor, end, visited)  \n\nError(s) from the decoded code for Problem 7:\n['Outputs do not match']\n\nOriginal Code for Problem 8:\nfrom typing import List\n\nclass Solution:\n    def numFriendRequests(self, ages: List[int]) -> int:\n        def request_will_be_sent(age_x, age_y):\n            return not (age_y <= 0.5 * age_x + 7 or age_y > age_x or (age_y > 100 and age_x < 100))\n        \n        count = [0] * 121  # Since ages range from 1 to 120\n        for age in ages:\n            count[age] += 1\n        \n        total_requests = 0\n        for age_x in range(1, 121):\n            for age_y in range(1, 121):\n                if request_will_be_sent(age_x, age_y):\n                    total_requests += count[age_x] * (count[age_y] - (age_x == age_y))\n        \n        return total_requests\n\n\nPseudocode for Problem 8:\nCLASS Solution  \n    FUNCTION numFriendRequests(ages)  \n        FUNCTION request_will_be_sent(age_x, age_y)  \n            RETURN NOT (age_y LESS THAN OR EQUAL TO age_x MULTIPLIED BY one HALF PLUS seven OR age_y GREATER THAN age_x OR age_y GREATER THAN one hundred AND age_x LESS THAN one hundred)  \n        END FUNCTION  \n\n        SET count TO list OF zeros WITH LENGTH one hundred twenty ONE  \n        FOR each age IN ages  \n            INCREMENT element at position age OF count BY one  \n        END FOR  \n\n        SET total_requests TO zero  \n        FOR age_x FROM one TO one hundred twenty  \n            FOR age_y FROM one TO one hundred twenty  \n                IF request_will_be_sent(age_x, age_y)  \n                    INCREMENT total_requests BY element at position age_x OF count MULTIPLIED BY (element at position age_y OF count MINUS one IF age_x EQUALS age_y OTHERWISE zero)  \n                END IF  \n            END FOR  \n        END FOR  \n\n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp3yo823f/solution_3.py\", line 42, in <module>\\n    print(Solution().numFriendRequests(ages = [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp3yo823f/solution_3.py\", line 30, in numFriendRequests\\n    count[age] += 1\\n    ~~~~~^^^^^\\nIndexError: list index out of range\\n']\nScore of (4*(Average syllables per word) + passing rate) for ALL the problems: 2.1681118081186868"
}