CLASS Solution  
    FUNCTION countCombinations WITH PARAMETERS pieces AND positions  
        SET directions TO a mapping from piece type TO a list of direction pairs AS follows  
            MAP rook TO a list containing pair one zero AND pair minus one zero AND pair zero one AND pair zero minus one  
            MAP queen TO a list containing pair one zero AND pair minus one zero AND pair zero one AND pair zero minus one AND pair one one AND pair minus one one AND pair one minus one AND pair minus one minus one  
            MAP bishop TO a list containing pair one one AND pair minus one one AND pair one minus one AND pair minus one minus one  
        
        SET positions TO a list composed by FOR EACH pair INCLUDING r comma c IN original positions DO  
            CREATE a new pair by subtracting one FROM r AND subtracting one FROM c  
        
        FUNCTION get_destinations WITH PARAMETERS start AND piece_type  
            DESTRUCTURE start INTO r AND c  
            SET dests TO a list containing start  
            FOR EACH pair INCLUDING dr comma dc IN directions accessed BY piece_type  
                SET nr TO r PLUS dr  
                SET nc TO c PLUS dc  
                WHILE nr IS GREATER THAN OR EQUAL TO zero AND nr IS LESS THAN eight AND nc IS GREATER THAN OR EQUAL TO zero AND nc IS LESS THAN eight  
                    APPEND a pair consisting of nr AND nc TO dests  
                    INCREMENT nr BY dr  
                    INCREMENT nc BY dc  
                END WHILE  
            END FOR  
            RETURN dests  
        END FUNCTION  
        
        SET all_destinations TO a list composed by FOR EACH pair INCLUDING pos comma piece IN a zipped sequence of positions AND pieces DO  
            CALL get_destinations WITH pos AND piece  
        
        FUNCTION is_valid_combination WITH PARAMETER combination  
            SET pos TO a shallow copy of positions  
            SET n TO the LENGTH OF pos  
            WHILE true  
                IF the LENGTH OF a set converted from pos IS LESS THAN n  
                    RETURN false  
                END IF  
                SET all_reached TO true  
                FOR i FROM zero TO n MINUS one  
                    IF the element at position i OF pos IS EQUAL TO the element at position i OF combination  
                        CONTINUE to next iteration  
                    END IF  
                    SET all_reached TO false  
                    DESTRUCTURE the element at position i OF pos INTO r AND c  
                    IF the element at position i AND zero OF combination IS GREATER THAN r  
                        SET dr TO one  
                    ELSE IF the element at position i AND zero OF combination IS LESS THAN r  
                        SET dr TO minus one  
                    ELSE  
                        SET dr TO zero  
                    END IF  
                    IF the element at position i AND one OF combination IS GREATER THAN c  
                        SET dc TO one  
                    ELSE IF the element at position i AND one OF combination IS LESS THAN c  
                        SET dc TO minus one  
                    ELSE  
                        SET dc TO zero  
                    END IF  
                    SET the element at position i OF pos TO a pair consisting of r PLUS dr AND c PLUS dc  
                END FOR  
                IF all_reached IS true  
                    RETURN true  
                END IF  
            END WHILE  
        END FUNCTION  
        
        SET valid_count TO zero  
        FOR EACH combination IN the cartesian product of all_destinations  
            IF is_valid_combination WITH combination RETURNS true  
                INCREMENT valid_count BY one  
            END IF  
        END FOR  
        
        RETURN valid_count  
    END FUNCTION  
END CLASS