CLASS Solution  
    FUNCTION minimumIncompatibility(nums, k)  
        IMPORT collections.Counter
        
        SET n TO the LENGTH OF nums  
        SET subset_size TO n DIVIDED BY k  
        
        SET count_map TO A NEW Counter OF nums  
        FOR each element_count IN the VALUES OF count_map  
            IF element_count IS GREATER THAN k  
                RETURN minus one  
            END IF  
        END FOR  
        
        SET subset_incompatibility TO AN EMPTY DICTIONARY  
        
        SET limit TO two RAISED TO THE POWER OF n  
        FOR each mask FROM zero TO limit MINUS one  
            SET bit_count TO zero  
            FOR each bit_position FROM zero TO n MINUS one  
                IF the BIT AT bit_position OF mask IS SET  
                    INCREMENT bit_count BY one  
                END IF  
            END FOR  
            
            IF bit_count EQUAL TO subset_size  
                SET elements TO an EMPTY LIST  
                FOR each index FROM zero TO n MINUS one  
                    IF the BIT AT index OF mask IS SET  
                        APPEND the element at position index OF nums TO elements  
                    END IF  
                END FOR  
                
                SET unique_check TO an EMPTY SET  
                FOR each element IN elements  
                    ADD element TO unique_check  
                END FOR  
                
                IF the SIZE OF unique_check EQUAL TO subset_size  
                    SET maximum_element TO the GREATER element AMONG elements  
                    SET minimum_element TO the SMALLER element AMONG elements  
                    SET incompatibility TO maximum_element MINUS minimum_element  
                    SET subset_incompatibility AT mask TO incompatibility  
                END IF  
            END IF  
        END FOR  
        
        SET dp TO a LIST OF size limit FILLED WITH positive infinity value  
        SET dp AT zero TO zero  
        
        FOR each mask FROM zero TO limit MINUS one  
            SET current_bit_count TO zero  
            FOR each bit_position FROM zero TO n MINUS one  
                IF the BIT AT bit_position OF mask IS SET  
                    INCREMENT current_bit_count BY one  
                END IF  
            END FOR  
            
            IF current_bit_count MODULO subset_size NOT EQUAL TO zero  
                CONTINUE TO next iteration of outer FOR  
            END IF  
            
            FOR each subset_mask IN the KEYS OF subset_incompatibility  
                SET intersection TO bitwise AND OF mask AND subset_mask  
                IF intersection EQUAL TO subset_mask  
                    SET possible_value TO dp AT the BITWISE XOR OF mask AND subset_mask PLUS subset_incompatibility AT subset_mask  
                    IF possible_value IS LESS THAN dp AT mask  
                        SET dp AT mask TO possible_value  
                    END IF  
                END IF  
            END FOR  
        END FOR  
        
        SET full_mask TO limit MINUS one  
        IF dp AT full_mask EQUAL TO positive infinity value  
            RETURN minus one  
        ELSE  
            RETURN dp AT full_mask  
        END IF  
    END FUNCTION  
END CLASS