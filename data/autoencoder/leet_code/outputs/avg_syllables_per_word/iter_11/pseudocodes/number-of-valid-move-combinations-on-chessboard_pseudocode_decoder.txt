CLASS Solution  
    FUNCTION countCombinations(pieces, positions)  
        SET directions TO dictionary with keys and values  
            SET rook TO list of tuples with elements one zero, negative one zero, zero one, zero negative one  
            SET queen TO list of tuples with elements one zero, negative one zero, zero one, zero negative one, one one, negative one one, one negative one, negative one negative one  
            SET bishop TO list of tuples with elements one one, negative one one, one negative one, negative one negative one  
  
        SET positions TO empty list  
        FOR each r, c IN original positions  
            APPEND tuple of r MINUS one, c MINUS one TO positions  
        END FOR  
  
        FUNCTION get_destinations(start, piece_type)  
            SET r, c TO elements of start  
            SET dests TO list containing start  
            FOR each dr, dc IN directions at key piece_type  
                SET nr TO r PLUS dr  
                SET nc TO c PLUS dc  
                WHILE nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN eight AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN eight  
                    APPEND tuple of nr, nc TO dests  
                    INCREMENT nr BY dr  
                    INCREMENT nc BY dc  
                END WHILE  
            END FOR  
            RETURN dests  
        END FUNCTION  
  
        SET all_destinations TO empty list  
        FOR each pos, piece IN parallel iteration of positions and pieces  
            APPEND get_destinations with pos and piece TO all_destinations  
        END FOR  
  
        FUNCTION is_valid_combination(combination)  
            SET pos TO copy of positions  
            SET n TO LENGTH OF pos  
            WHILE TRUE  
                IF LENGTH OF set of pos LESS THAN n  
                    RETURN false  
                END IF  
  
                SET all_reached TO true  
                FOR index FROM zero TO n MINUS one  
                    IF element at position index of pos EQUALS element at position index of combination  
                        CONTINUE TO next iteration  
                    END IF  
  
                    SET all_reached TO false  
                    SET r, c TO elements of element at position index of pos  
  
                    IF element at position index of combination at position zero GREATER THAN r  
                        SET dr TO one  
                    ELSE IF element at position index of combination at position zero LESS THAN r  
                        SET dr TO negative one  
                    ELSE  
                        SET dr TO zero  
                    END IF  
  
                    IF element at position index of combination at position one GREATER THAN c  
                        SET dc TO one  
                    ELSE IF element at position index of combination at position one LESS THAN c  
                        SET dc TO negative one  
                    ELSE  
                        SET dc TO zero  
                    END IF  
  
                    SET element at position index of pos TO tuple of r PLUS dr, c PLUS dc  
                END FOR  
  
                IF all_reached  
                    RETURN true  
                END IF  
            END WHILE  
        END FUNCTION  
  
        SET valid_count TO zero  
        FOR each combination IN Cartesian product of all_destinations  
            IF is_valid_combination with combination  
                INCREMENT valid_count BY one  
            END IF  
        END FOR  
  
        RETURN valid_count  
    END FUNCTION  
END CLASS