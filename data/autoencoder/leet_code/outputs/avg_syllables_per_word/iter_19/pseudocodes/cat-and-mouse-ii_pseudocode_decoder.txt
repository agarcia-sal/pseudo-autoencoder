CLASS Solution  
    FUNCTION canMouseWin(grid AS List OF string, catJump AS integer, mouseJump AS integer) RETURNS boolean  
        SET m TO the LENGTH OF grid  
        SET n TO the LENGTH OF element at position zero of grid  
        SET cat_start TO zero  
        SET mouse_start TO zero  
        SET food TO zero  
        SET dirs TO a sequence of integer values MINUS ONE zero ONE zero MINUS ONE  
        SET g_mouse TO a list of empty lists repeated m MULTIPLIED BY n times  
        SET g_cat TO a list of empty lists repeated m MULTIPLIED BY n times  
        FOR each pair of i and row IN the enumeration of grid  
            FOR each pair of j and c IN the enumeration of row  
                IF c EQUALS the hash symbol  
                    CONTINUE to next iteration  
                END IF  
                SET v TO i MULTIPLIED BY n PLUS j  
                IF c EQUALS the character C  
                    SET cat_start TO v  
                ELSE IF c EQUALS the character M  
                    SET mouse_start TO v  
                ELSE IF c EQUALS the character F  
                    SET food TO v  
                END IF  
                FOR each pair of a and b FROM pairwise of dirs  
                    FOR k FROM zero TO mouseJump INCLUSIVE  
                        SET x TO i PLUS k MULTIPLIED BY a  
                        SET y TO j PLUS k MULTIPLIED BY b  
                        IF x IS LESS THAN zero OR x IS GREATER THAN OR EQUAL TO m OR y IS LESS THAN zero OR y IS GREATER THAN OR EQUAL TO n OR element at position x of grid IS EQUAL TO the string containing the hash symbol  
                            BREAK the current inner loop  
                        END IF  
                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_mouse  
                    END FOR  
                    FOR k FROM zero TO catJump INCLUSIVE  
                        SET x TO i PLUS k MULTIPLIED BY a  
                        SET y TO j PLUS k MULTIPLIED BY b  
                        IF x IS LESS THAN zero OR x IS GREATER THAN OR EQUAL TO m OR y IS LESS THAN zero OR y IS GREATER THAN OR EQUAL TO n OR element at position x of grid IS EQUAL TO the string containing the hash symbol  
                            BREAK the current inner loop  
                        END IF  
                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_cat  
                    END FOR  
                END FOR  
            END FOR  
        END FOR  
        RETURN the result of calling self dot calc with parameters g_mouse g_cat mouse_start cat_start and food EQUALS the integer one  
    END FUNCTION  

    FUNCTION calc(g_mouse AS List OF List OF integer, g_cat AS List OF List OF integer, mouse_start AS integer, cat_start AS integer, hole AS integer) RETURNS integer  
        FUNCTION get_prev_states(state AS tuple) RETURNS list  
            SET m TO element at position zero of state  
            SET c TO element at position one of state  
            SET t TO element at position two of state  
            SET pt TO the bitwise exclusive OR of t and one  
            SET pre TO an empty list  
            IF pt EQUALS one  
                FOR each pc IN element at position c of g_cat  
                    IF element at position m of element at position pc of ans for index one EQUALS zero  
                        APPEND tuple of m pc pt TO pre  
                    END IF  
                END FOR  
            ELSE  
                FOR each pm IN element at position m of g_mouse  
                    IF element at position pm of element at position c of ans for index zero EQUALS zero  
                        APPEND tuple of pm c zero TO pre  
                    END IF  
                END FOR  
            END IF  
            RETURN pre  
        END FUNCTION  

        SET n TO the LENGTH OF g_mouse  
        SET degree TO a three dimensional list of zeros with dimensions n BY n BY two  
        FOR i FROM zero TO n MINUS one  
            FOR j FROM zero TO n MINUS one  
                SET element at position zero of element at position j of element at position i of degree TO the LENGTH OF element at position i of g_mouse  
                SET element at position one of element at position j of element at position i of degree TO the LENGTH OF element at position j of g_cat  
            END FOR  
        END FOR  

        SET ans TO a three dimensional list of zeros with dimensions n BY n BY two  
        SET q TO a deque data structure  
        FOR i FROM zero TO n MINUS one  
            SET element at position one of element at position i of element at position hole of ans TO one  
            SET element at position zero of element at position hole of element at position i of ans TO two  
            SET element at position one of element at position i of element at position i of ans TO two  
            SET element at position zero of element at position i of element at position i of ans TO two  
            APPEND tuple of hole i one TO q  
            APPEND tuple of i hole zero TO q  
            APPEND tuple of i i zero TO q  
            APPEND tuple of i i one TO q  
        END FOR  
        WHILE q IS NOT empty  
            SET state TO the element popped from the left of q  
            SET t TO element at position in ans corresponding to element at position zero of state element at position one of state and element at position two of state  
            FOR each prev_state IN the result of get_prev_states called with parameter state  
                SET pm TO element at position zero of prev_state  
                SET pc TO element at position one of prev_state  
                SET pt TO element at position two of prev_state  
                IF pt EQUALS t MINUS one  
                    SET element at position pt of element at position pc of element at position pm of ans TO t  
                    APPEND prev_state TO q  
                ELSE  
                    DECREMENT element at position pt of element at position pc of element at position pm of degree BY one  
                    IF element at position pt of element at position pc of element at position pm of degree EQUALS zero  
                        SET element at position pt of element at position pc of element at position pm of ans TO t  
                        APPEND prev_state TO q  
                    END IF  
                END IF  
            END FOR  
        END WHILE  
        RETURN element at position zero of element at position cat_start of element at position mouse_start of ans  
    END FUNCTION  
END CLASS