CLASS Solution  
    FUNCTION countCombinations(pieces, positions)  
        SET directions TO dictionary mapping rook TO list of pairs one zero zero minus one zero zero one zero minus one, queen TO list of pairs rook directions PLUS list of pairs one one minus one one one minus one minus one minus one minus one, bishop TO list of pairs one one minus one one one minus one minus one minus one  
        
        SET adjusted_positions TO empty list  
        FOR each pair r, c IN positions  
            APPEND pair r MINUS one, c MINUS one TO adjusted_positions  
        END FOR  
        SET positions TO adjusted_positions  
        
        FUNCTION get_destinations(start, piece_type)  
            SET r TO element at position zero of start  
            SET c TO element at position one of start  
            SET dests TO list containing start  
            FOR each pair dr, dc IN directions at key piece_type  
                SET nr TO r PLUS dr  
                SET nc TO c PLUS dc  
                WHILE nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN eight AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN eight  
                    APPEND pair nr, nc TO dests  
                    INCREMENT nr BY dr  
                    INCREMENT nc BY dc  
                END WHILE  
            END FOR  
            RETURN dests  
        END FUNCTION  
        
        SET all_destinations TO empty list  
        FOR each pair pos, piece IN zipped positions and pieces  
            APPEND get_destinations(pos, piece) TO all_destinations  
        END FOR  
        
        FUNCTION is_valid_combination(combination)  
            SET pos TO copy of positions  
            SET n TO LENGTH OF pos  
            LOOP indefinitely  
                IF LENGTH OF set constructed from pos LESS THAN n  
                    RETURN false  
                END IF  
                SET all_reached TO true  
                FOR index i FROM zero TO n MINUS one  
                    IF element at position i of pos EQUALS element at position i of combination  
                        CONTINUE to next iteration  
                    END IF  
                    SET all_reached TO false  
                    SET r TO element at position zero of element at position i of pos  
                    SET c TO element at position one of element at position i of pos  
                    SET dr TO value one IF element at position zero of element at position i of combination GREATER THAN r ELSE value minus one IF element at position zero of element at position i of combination LESS THAN r ELSE zero  
                    SET dc TO value one IF element at position one of element at position i of combination GREATER THAN c ELSE value minus one IF element at position one of element at position i of combination LESS THAN c ELSE zero  
                    SET element at position i of pos TO pair r PLUS dr, c PLUS dc  
                END FOR  
                IF all_reached EQUALS true  
                    RETURN true  
                END IF  
            END LOOP  
        END FUNCTION  
        
        SET valid_count TO zero  
        FOR each combination IN product applied to all_destinations unpacked  
            IF is_valid_combination(combination) EQUALS true  
                INCREMENT valid_count BY one  
            END IF  
        END FOR  
        
        RETURN valid_count  
    END FUNCTION  
END CLASS