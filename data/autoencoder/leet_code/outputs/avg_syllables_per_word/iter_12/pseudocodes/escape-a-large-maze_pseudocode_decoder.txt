CLASS Solution  
    FUNCTION isEscapePossible(blocked, source, target)  
        IF blocked IS empty  
            RETURN True  
        END IF  
        
        SET blocked_set TO an empty set  
        FOR each block IN blocked  
            ADD tuple of block TO blocked_set  
        END FOR  
        
        SET n TO the LENGTH OF blocked  
        SET max_steps TO n MULTIPLIED BY (n MINUS one) DIVIDED BY two  
        
        FUNCTION bfs(start, end)  
            INITIALIZE queue WITH tuple of start  
            INITIALIZE visited WITH the same elements as queue  
            
            WHILE queue IS NOT empty  
                REMOVE first element FROM queue INTO variables x, y  
                
                IF LENGTH OF visited IS GREATER THAN max_steps OR (x EQUALS element at position zero of end AND y EQUALS element at position one of end)  
                    RETURN True  
                END IF  
                
                FOR each pair dx, dy IN the list containing pairs (zero, one), (zero, negative one), (one, zero), (negative one, zero)  
                    SET nx TO x PLUS dx  
                    SET ny TO y PLUS dy  
                    
                    IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN ten TO THE POWER OF six AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN ten TO THE POWER OF six AND tuple of nx, ny IS NOT IN blocked_set AND tuple of nx, ny IS NOT IN visited  
                        ADD tuple of nx, ny TO visited  
                        APPEND tuple of nx, ny TO queue  
                    END IF  
                END FOR  
            END WHILE  
            
            RETURN False  
        END FUNCTION  
        
        RETURN bfs(source, target) AND bfs(target, source)  
    END FUNCTION  
END CLASS