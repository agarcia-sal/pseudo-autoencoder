```
n ← length(words)

define overlap(i,j):
  for k from min(len(words[i]), len(words[j])) down to 1:
    if words[i][-k:] = words[j][:k]: return k
  return 0

define dp(mask, i):
  if mask = (1 << n) - 1: return (0, "")
  min_len, best_path ← ∞, ""
  for j in [0..n-1]:
    if not mask&(1<<j):
      length, path ← dp(mask|(1<<j), j)
      length += len(words[j]) - overlap(i,j)
      if length < min_len:
        min_len, best_path ← length, words[j][overlap(i,j):] + path
  return (min_len, best_path)

min_len, shortest_path ← ∞, ""
for i in [0..n-1]:
  length, path ← dp(1<<i, i)
  length += len(words[i])
  if length < min_len:
    min_len, shortest_path ← length, words[i] + path

return shortest_path
```