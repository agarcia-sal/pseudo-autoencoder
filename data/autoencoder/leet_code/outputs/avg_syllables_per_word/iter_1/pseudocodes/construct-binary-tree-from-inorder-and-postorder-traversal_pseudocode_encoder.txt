```
class TreeNode(val=0, left=None, right=None)

func tree_node(values):
    if empty(values) return None
    root ← TreeNode(values[0])
    queue ← [root]
    i ← 1
    while queue not empty:
        node ← dequeue(queue)
        if i < len(values) and values[i] != None:
            node.left ← TreeNode(values[i])
            enqueue(queue, node.left)
        i += 1
        if i < len(values) and values[i] != None:
            node.right ← TreeNode(values[i])
            enqueue(queue, node.right)
        i += 1
    return root

func is_same_tree(p, q):
    if p == None and q == None return True
    if p == None or q == None or p.val != q.val return False
    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)

class Solution:
    func buildTree(inorder, postorder):
        if empty(inorder) or empty(postorder) return None
        root_val ← pop(postorder)
        root ← TreeNode(root_val)
        idx ← find_index(inorder, root_val)
        root.right ← buildTree(inorder[idx+1:], postorder)
        root.left ← buildTree(inorder[:idx], postorder)
        return root
```