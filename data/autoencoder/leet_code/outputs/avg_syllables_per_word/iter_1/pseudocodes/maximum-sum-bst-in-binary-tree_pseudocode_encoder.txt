```
class TreeNode(val=0, left=None, right=None)

tree_node(values):
  if values empty: return None
  root = TreeNode(values[0])
  i = 1; q = deque([root])
  while q:
    n = q.popleft()
    if i < len(values) and values[i] != None:
      n.left = TreeNode(values[i]); q.append(n.left)
    i += 1
    if i < len(values) and values[i] != None:
      n.right = TreeNode(values[i]); q.append(n.right)
    i += 1
  return root

is_same_tree(p, q):
  if not p and not q: return True
  if not p or not q: return False
  if p.val != q.val: return False
  return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)

class Solution:
  maxSumBST(root):
    max_sum = 0

    helper(node):
      if not node: return True, 0, +∞, -∞
      l_bst, l_sum, l_min, l_max = helper(node.left)
      r_bst, r_sum, r_min, r_max = helper(node.right)
      if l_bst and r_bst and l_max < node.val < r_min:
        cur_sum = l_sum + r_sum + node.val
        cur_min = min(node.val, l_min)
        cur_max = max(node.val, r_max)
        max_sum = max(max_sum, cur_sum)
        return True, cur_sum, cur_min, cur_max
      return False, 0, +∞, -∞

    helper(root)
    return max_sum
```