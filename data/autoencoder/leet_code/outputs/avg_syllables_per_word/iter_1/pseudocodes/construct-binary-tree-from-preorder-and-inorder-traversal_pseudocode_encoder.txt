```
class TreeNode(val=0, left=None, right=None)

func tree_node(vals):
  if empty(vals): return None
  root = TreeNode(vals[0])
  q = queue([root])
  i = 1
  while q not empty:
    node = q.pop_front()
    if i < len(vals) and vals[i] != None:
      node.left = TreeNode(vals[i])
      q.push_back(node.left)
    i +=1
    if i < len(vals) and vals[i] != None:
      node.right = TreeNode(vals[i])
      q.push_back(node.right)
    i +=1
  return root

func is_same_tree(p, q):
  if not p and not q: return True
  if not p or not q: return False
  if p.val != q.val: return False
  return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)

class Solution:
  func buildTree(pre, ino):
    if empty(pre) or empty(ino): return None
    root_val = pre[0]
    root = TreeNode(root_val)
    idx = ino.index(root_val)
    root.left = buildTree(pre[1:idx+1], ino[:idx])
    root.right = buildTree(pre[idx+1:], ino[idx+1:])
    return root
```