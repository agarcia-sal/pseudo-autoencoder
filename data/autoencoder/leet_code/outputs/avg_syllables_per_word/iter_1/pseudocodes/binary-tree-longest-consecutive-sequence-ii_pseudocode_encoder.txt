```
func tree_node(vals):
  if empty(vals): return None
  root = new TreeNode(vals[0])
  q = deque([root])
  i = 1
  while q not empty:
    n = q.popleft()
    if i < len(vals) and vals[i] != None:
      n.left = new TreeNode(vals[i]); q.append(n.left)
    i += 1
    if i < len(vals) and vals[i] != None:
      n.right = new TreeNode(vals[i]); q.append(n.right)
    i += 1
  return root

func is_same_tree(p, q):
  if not p and not q: return True
  if not p or not q or p.val != q.val: return False
  return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)

class Solution:
  func longestConsecutive(root):
    max_len = 0
    func dfs(node):
      if not node: return (0, 0)
      inc = dec = 1
      l_inc, l_dec = dfs(node.left)
      r_inc, r_dec = dfs(node.right)
      if node.left:
        if node.val == node.left.val + 1: dec = l_dec + 1
        elif node.val == node.left.val - 1: inc = l_inc + 1
      if node.right:
        if node.val == node.right.val + 1: dec = max(dec, r_dec + 1)
        elif node.val == node.right.val - 1: inc = max(inc, r_inc + 1)
      max_len = max(max_len, inc + dec - 1)
      return (inc, dec)
    dfs(root)
    return max_len
```