```
if n = 1: return 1.0
graph ← map node to neighbors from edges
queue ← [(1,1.0,0)], visited ← {1}
while queue not empty:
  node, prob, time ← dequeue
  if time = t or (node ≠ 1 and degree(node) = 1):
    if node = target: return prob
    else: continue
  moves ← degree(node) - (if node ≠ 1 then 1 else 0)
  for nbr in neighbors(node):
    if nbr not in visited:
      visited += nbr
      enqueue (nbr, prob/moves, time+1)
return 0.0
```