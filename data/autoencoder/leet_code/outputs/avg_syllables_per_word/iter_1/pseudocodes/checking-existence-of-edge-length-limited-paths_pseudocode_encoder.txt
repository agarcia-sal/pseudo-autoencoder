```
class UF:
  init(n): parent=[0..n-1]; rank=[1]*n
  find(p): 
    if parent[p]!=p: parent[p]=find(parent[p])
    return parent[p]
  union(p,q):
    rp=find(p); rq=find(q)
    if rp==rq: return False
    if rank[rp]>rank[rq]: parent[rq]=rp
    elif rank[rp]<rank[rq]: parent[rp]=rq
    else: parent[rq]=rp; rank[rp]+=1
    return True

distanceLimitedPathsExist(n, edges, queries):
  edges.sort by dist
  qidx = [(lim,p,q,i) for i,(p,q,lim) in enumerate(queries)]
  qidx.sort by lim
  uf=UF(n)
  ei=0; res=[False]*len(queries)
  for lim,p,q,i in qidx:
    while ei<len(edges) and edges[ei][2]<lim:
      uf.union(edges[ei][0], edges[ei][1])
      ei+=1
    if uf.find(p)==uf.find(q): res[i]=True
  return res
```