```
set blocked_set ← blocked as tuples
n ← length(blocked)
max_steps ← n*(n-1)//2

func bfs(start, end):
    queue ← [start as tuple]
    visited ← {start as tuple}
    while queue not empty:
        (x,y) ← queue.pop_front()
        if size(visited) > max_steps or (x,y) = end: return True
        for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0)]:
            nx, ny ← x+dx, y+dy
            if 0 ≤ nx,ny < 10^6 and (nx,ny) not in blocked_set and (nx,ny) not in visited:
                visited add (nx, ny)
                queue append (nx, ny)
    return False

if blocked empty: return True
return bfs(source, target) and bfs(target, source)
```