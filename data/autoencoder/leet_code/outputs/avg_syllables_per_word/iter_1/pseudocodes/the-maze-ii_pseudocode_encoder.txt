```
m, n ← dimensions of maze
dirs ← [(1,0), (-1,0), (0,1), (0,-1)]
start, dest ← tuple(start), tuple(destination)
visited ← {}
pq ← min-heap with (0, start)

while pq not empty:
    dist, (x,y) ← pop pq
    if (x,y) = dest: return dist
    if (x,y) in visited: continue
    add (x,y) to visited
    for dx, dy in dirs:
        nx, ny, step ← x, y, 0
        while inside maze and maze[nx+dx][ny+dy] = 0:
            nx, ny ← nx+dx, ny+dy
            step += 1
        if (nx, ny) not in visited:
            push (dist + step, (nx, ny)) to pq

return -1
```