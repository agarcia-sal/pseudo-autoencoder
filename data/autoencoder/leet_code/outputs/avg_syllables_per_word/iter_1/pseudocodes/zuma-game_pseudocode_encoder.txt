```
define clean(b):
  s = []
  for c in b:
    if s and s[-1][0] != c and s[-1][1] >= 3: s.pop()
    if not s or s[-1][0] != c: s.append([c,1])
    else: s[-1][1] += 1
  if s and s[-1][1] >= 3: s.pop()
  return join([c*cnt for c,cnt in s])

define dfs(b, h):
  if b is empty: return 0
  res = ∞
  i = 0
  while i < length(b):
    j = i+1
    while j < length(b) and b[i] == b[j]: j+=1
    need = 3 - (j - i)
    if h[b[i]] ≥ need:
      newh = copy h
      newh[b[i]] -= need
      nb = clean(b[:i] + b[j:])
      steps = dfs(nb, newh)
      if steps ≥ 0: res = min(res, steps + need)
    i = j
  return res if res ≠ ∞ else -1

count = frequency(hand)
return dfs(board, count)
```