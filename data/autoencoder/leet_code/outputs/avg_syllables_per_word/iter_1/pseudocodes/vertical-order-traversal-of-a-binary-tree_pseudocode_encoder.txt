```
class TreeNode(val=0, left=None, right=None)

func tree_node(vals):
  if empty(vals): return None
  root = TreeNode(vals[0])
  q = queue(root)
  i = 1
  while q and i < len(vals):
    n = q.pop()
    if i < len(vals) and vals[i] != None:
      n.left = TreeNode(vals[i])
      q.push(n.left)
    i += 1
    if i < len(vals) and vals[i] != None:
      n.right = TreeNode(vals[i])
      q.push(n.right)
    i += 1
  return root

func is_same_tree(p, q):
  if not p and not q: return True
  if not p or not q: return False
  if p.val != q.val: return False
  return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)

class Solution:
  func verticalTraversal(root):
    if not root: return []
    dict = defaultdict(list)
    min_c = max_c = 0

    func dfs(n, r, c):
      if not n: return
      dict[c].append((r, n.val))
      min_c = min(min_c, c)
      max_c = max(max_c, c)
      dfs(n.left, r+1, c-1)
      dfs(n.right, r+1, c+1)

    dfs(root, 0, 0)

    res = []
    for c in range(min_c, max_c+1):
      res.append([v for r, v in sorted(dict[c])])
    return res
```