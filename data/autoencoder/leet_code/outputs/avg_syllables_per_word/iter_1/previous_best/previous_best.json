{
  "prompt": "Given a problem description, generate concise, high-level pseudocode that is easy to read and understand, using natural language, one-liners, symbolic forms, and abbreviations. Do not include purpose, summary, overview statements, notes, comments, or explanations\u2014only the pseudocode itself. Aim for compactness and clarity without sacrificing readability.",
  "response": "Given a problem description, generate concise, high-level pseudocode that is easy to read and understand, using natural language, one-liners, symbolic forms, and abbreviations. Do not include purpose, summary, overview statements, notes, comments, or explanations\u2014only the pseudocode itself. Aim for compactness and clarity without sacrificing readability.",
  "score": 0.8082711566148959,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        # Dictionary to store the count of each 10-letter sequence\n        sequence_count = defaultdict(int)\n        \n        # Iterate through the string to extract all 10-letter sequences\n        for i in range(len(s) - 9):\n            sequence = s[i:i+10]\n            sequence_count[sequence] += 1\n        \n        # Collect sequences that occur more than once\n        repeated_sequences = [seq for seq, count in sequence_count.items() if count > 1]\n        \n        return repeated_sequences\n\n\nPseudocode for Problem 1:\n```\ninit map seq_count to default int\nfor i in 0 to len(s)-10:\n    seq = s[i:i+10]\n    seq_count[seq] += 1\nres = [seq for seq, c in seq_count.items() if c > 1]\nreturn res\n```\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpg4ibvb96/solution_0.py\", line 28, in <module>\\n    print(Solution().findRepeatedDnaSequences(s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\n\nOriginal Code for Problem 2:\nfrom typing import List\n\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        n = len(nums)\n        f = [1] * n\n        k = 0\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    f[i] = max(f[i], f[j] + 1)\n            if f[k] < f[i]:\n                k = i\n        m = f[k]\n        i = k\n        ans = []\n        while m:\n            if nums[k] % nums[i] == 0 and f[i] == m:\n                ans.append(nums[i])\n\nPseudocode for Problem 2:\n```\nsort nums\nn \u2190 len(nums)\nf \u2190 [1]*n\nk \u2190 0\nfor i in [0..n-1]:\n    for j in [0..i-1]:\n        if nums[i] mod nums[j] = 0: f[i] \u2190 max(f[i], f[j]+1)\n    if f[k] < f[i]: k \u2190 i\nm \u2190 f[k]\ni \u2190 k\nans \u2190 []\nwhile m > 0:\n    if nums[k] mod nums[i] = 0 and f[i] = m:\n        append nums[i] to ans\n        k \u2190 i\n        m \u2190 m - 1\n    i \u2190 i - 1\nreturn ans\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp4t03sq31/solution_0.py\", line 40, in <module>\\n    print(Solution().largestDivisibleSubset(nums = [1,3,6,9,18]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\n\nOriginal Code for Problem 3:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        if root.val > key:\n            root.left = self.deleteNode(root.left, key)\n            return root\n        if root.val < key:\n            root.right = self.deleteNode(root.right, key)\n            return root\n        if root.left is None:\n            return root.right\n        if root.right is None:\n            return root.left\n\nPseudocode for Problem 3:\n```\nclass TreeNode(val=0, left=None, right=None)\n\ntree_node(values):\n    if empty values: return None\n    root = TreeNode(values[0])\n    q = deque([root])\n    i = 1\n    while q and i < len(values):\n        node = q.popleft()\n        if i < len(values) and values[i] != None:\n            node.left = TreeNode(values[i])\n            q.append(node.left)\n        i += 1\n        if i < len(values) and values[i] != None:\n            node.right = TreeNode(values[i])\n            q.append(node.right)\n        i += 1\n    return root\n\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpgsnlmttk/solution_0.py\", line 110, in <module>\\n    print(Solution().deleteNode(root = [5,3,6,2,4,null,7], key = 3))\\n                                                  ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 4:\nclass Solution:\n    def countVowelPermutation(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Initialize the number of strings of length 1 ending with each vowel\n        a, e, i, o, u = 1, 1, 1, 1, 1\n        \n        # Iterate from length 2 to n\n        for _ in range(1, n):\n            # Update the counts for the next length\n            a_next = e + i + u\n            e_next = a + i\n            i_next = e + o\n            o_next = i\n            u_next = i + o\n            \n            # Apply modulo to prevent overflow\n            a, e, i, o, u = a_next % MOD, e_next % MOD, i_next % MOD, o_next % MOD, u_next % MOD\n        \n        # Sum up all the possibilities for strings of length n\n\nPseudocode for Problem 4:\n```\nset MOD = 10^9+7\ninit a,e,i,o,u = 1,1,1,1,1\nfor _ in 1 to n-1:\n    a,e,i,o,u = (e+i+u)%MOD, (a+i)%MOD, (e+o)%MOD, i%MOD, (i+o)%MOD\nreturn (a+e+i+o+u) % MOD\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpq00lbfhj/solution_0.py\", line 25, in <module>\\n    print(Solution().countVowelPermutation(n = 1))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\n\nOriginal Code for Problem 5:\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        # Initialize the set to store unique sequences and the Eulerian path\n        visited = set()\n        sequence = []\n\n        # Helper function to perform the Depth-First Search (DFS)\n        def dfs(node):\n            for i in range(k):\n                edge = node + str(i)\n                if edge not in visited:\n                    visited.add(edge)\n                    dfs(edge[1:])\n                    sequence.append(str(i))\n\n        # Start the DFS with the initial node of n-1 zeros\n        start_node = '0' * (n - 1)\n        dfs(start_node)\n\n        # The sequence contains all the edges in reverse order, so we need to reverse it\n\nPseudocode for Problem 5:\n```\ndef crackSafe(n, k):\n    visited = set()\n    seq = []\n    def dfs(node):\n        for i in range(k):\n            e = node + str(i)\n            if e not in visited:\n                visited.add(e)\n                dfs(e[1:])\n                seq.append(str(i))\n    start = '0' * (n-1)\n    dfs(start)\n    return ''.join(seq) + start\n```\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpqcpah3z3/solution_0.py\", line 32, in <module>\\n    print(Solution().crackSafe(n = 1, k = 2))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\n\nOriginal Code for Problem 6:\nclass Solution:\n    def strobogrammaticInRange(self, low: str, high: str) -> int:\n        # Helper function to generate strobogrammatic numbers of a given length\n        def generate_strobogrammatic(n, final_length):\n            if n == 0:\n                return [\"\"]\n            if n == 1:\n                return [\"0\", \"1\", \"8\"]\n            \n            middles = generate_strobogrammatic(n - 2, final_length)\n            result = []\n            for middle in middles:\n                if n != final_length:  # Avoid leading zeros\n                    result.append(\"0\" + middle + \"0\")\n                result.append(\"1\" + middle + \"1\")\n                result.append(\"6\" + middle + \"9\")\n                result.append(\"8\" + middle + \"8\")\n                result.append(\"9\" + middle + \"6\")\n            return result\n        \n\nPseudocode for Problem 6:\n```\ndefine generate_strobogrammatic(n, length):\n    if n = 0: return [\"\"]\n    if n = 1: return [\"0\",\"1\",\"8\"]\n    middles = generate_strobogrammatic(n-2, length)\n    res = []\n    for m in middles:\n        if n != length: res += [\"0\"+m+\"0\"]\n        res += [\"1\"+m+\"1\",\"6\"+m+\"9\",\"8\"+m+\"8\",\"9\"+m+\"6\"]\n    return res\n\ndefine count_strobogrammatic(low, high):\n    c = 0\n    for l in range(len(low), len(high)+1):\n        for num in generate_strobogrammatic(l, l):\n            if (l = len(low) and num < low) or (l = len(high) and num > high): continue\n            c += 1\n    return c\n\nreturn count_strobogrammatic(low, high)\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpejejm6tt/solution_0.py\", line 45, in <module>\\n    print(Solution().strobogrammaticInRange(low = \"50\", high = \"100\"))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\n\nOriginal Code for Problem 7:\nfrom typing import List\n\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(path, used, res):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                # Skip used numbers or duplicates\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\n                    continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path, used, res)\n                path.pop()\n                used[i] = False\n        \n        nums.sort()  # Sort the numbers to handle duplicates\n        res = []\n\nPseudocode for Problem 7:\n```\nsort nums\ninit used = [False]*len(nums), res = []\ndefine backtrack(path):\n    if len(path) == len(nums): append copy(path) to res; return\n    for i in 0..len(nums)-1:\n        if used[i] or (i>0 and nums[i]==nums[i-1] and not used[i-1]): continue\n        used[i] = True; append nums[i] to path\n        backtrack(path)\n        pop path; used[i] = False\n\nbacktrack([])\nreturn res\n```\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpryau9s_h/solution_0.py\", line 39, in <module>\\n    print(Solution().permuteUnique(nums = [0,1,0,0,9]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\n\nOriginal Code for Problem 8:\nclass Solution:\n    def minimumDistance(self, word: str) -> int:\n        def distance(c1, c2):\n            if c1 is None:\n                return 0\n            x1, y1 = divmod(ord(c1) - ord('A'), 6)\n            x2, y2 = divmod(ord(c2) - ord('A'), 6)\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dp(i, f1, f2):\n            if i == len(word):\n                return 0\n            c = word[i]\n            # Move finger 1 to c\n            d1 = distance(f1, c) + dp(i + 1, c, f2)\n            # Move finger 2 to c\n            d2 = distance(f2, c) + dp(i + 1, f1, c)\n\nPseudocode for Problem 8:\n```\ndist(c1,c2) = 0 if c1=None else abs((ord(c1)-65)//6-(ord(c2)-65)//6) + abs((ord(c1)-65)%6-(ord(c2)-65)%6)\n\ndp(i,f1,f2) = 0 if i=len(word) else \n              min(dist(f1,word[i]) + dp(i+1, word[i], f2), dist(f2,word[i]) + dp(i+1, f1, word[i]))\n\nreturn dp(0,None,None)\n```\n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpepxku0v0/solution_0.py\", line 35, in <module>\\n    print(Solution().minimumDistance(word = \"CAKE\"))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\nScore of (4*(Average syllables per word) + passing rate) for ALL the problems: 0.8082711566148959"
}