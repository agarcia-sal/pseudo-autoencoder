from collections import defaultdict
from typing import List

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        number_of_nodes = len(graph)
        adjacency_list = defaultdict(list)

        # Build adjacency list for the undirected graph
        for i in range(number_of_nodes):
            for j in range(i + 1, number_of_nodes):
                if graph[i][j] == 1:
                    adjacency_list[i].append(j)
                    adjacency_list[j].append(i)

        def dfs(node: int, visited: set) -> int:
            if node in visited:
                return 0
            visited.add(node)
            component_size = 1
            for neighbor in adjacency_list[node]:
                component_size += dfs(neighbor, visited)
            return component_size

        infected_nodes = set(initial)
        component_sizes = []
        visited = set()
        component_index = {}

        # For each node not visited and not infected, find component sizes and mark component indices
        for node in range(number_of_nodes):
            if node not in visited and node not in infected_nodes:
                size_of_component = dfs(node, visited)
                component_sizes.append(size_of_component)
                last_component_position = len(component_sizes) - 1
                # Assign component index to each node in this component
                # We need to mark all nodes in this component, so do a traversal:
                stack = [node]
                while stack:
                    curr = stack.pop()
                    if curr not in component_index:
                        component_index[curr] = last_component_position
                        for neighbor in adjacency_list[curr]:
                            if neighbor not in component_index and neighbor not in infected_nodes:
                                stack.append(neighbor)

        infected_count_in_component = defaultdict(int)

        # Count how many infected nodes are associated with each component index
        for node in infected_nodes:
            if node in component_index:
                cidx = component_index[node]
                infected_count_in_component[cidx] += 1

        maximum_size = 0
        node_to_remove = min(initial)

        # Determine the node to remove based on conditions given
        for node in infected_nodes:
            if node in component_index:
                comp_idx = component_index[node]
                if infected_count_in_component[comp_idx] == 1:
                    comp_size = component_sizes[comp_idx]
                    if comp_size > maximum_size:
                        maximum_size = comp_size
                        node_to_remove = node
                    elif comp_size == maximum_size and node < node_to_remove:
                        node_to_remove = node

        return node_to_remove