{
  "prompt": "Translate the given pseudocode into clean, efficient, and fully functional Python code, strictly preserving all original class names, function names, signatures, and their class/object structures exactly as specified. Your implementation must handle all typical input conventions in Python (e.g., use `None` instead of `null`, convert input lists into linked structures or trees as needed) and avoid any runtime errors. \n\nEnclose your entire code output in a single Python code block like this:\n\n```python\n# your translated code here\n```\n\nRequirements:\n- Do not add extraneous explanations or unrelated comments; only include comments that clarify complex or non-obvious parts of the code.\n- The code must be optimized for correctness and efficiency within a 5-second runtime limit.\n- You may freely use any standard Python libraries or modules to improve clarity, correctness, and performance.\n- Carefully handle boundary cases, proper imports, and data structure conversions implied by the pseudocode.\n- Avoid leaving incomplete code fragments or unhandled conditions that cause runtime errors.\n- Inputs described in pseudocode as lists that represent trees or linked lists should be converted appropriately using helper functions if needed, respecting Python conventions.\n- Maintain idiomatic and readable Python style consistent with best practices.\n\nThis approach ensures faithful and robust translations ready for direct use and testing.",
  "response": "Translate the given pseudocode into clean, efficient, and fully functional Python code, strictly preserving all original class names, function names, signatures, and their class/object structures exactly as specified. Your implementation must handle all typical input conventions in Python (e.g., use `None` instead of `null`, convert input lists into linked structures or trees as needed) and avoid any runtime errors. \n\nEnclose your entire code output in a single Python code block like this:\n\n```python\n# your translated code here\n```\n\nRequirements:\n- Do not add extraneous explanations or unrelated comments; only include comments that clarify complex or non-obvious parts of the code.\n- The code must be optimized for correctness and efficiency within a 5-second runtime limit.\n- You may freely use any standard Python libraries or modules to improve clarity, correctness, and performance.\n- Carefully handle boundary cases, proper imports, and data structure conversions implied by the pseudocode.\n- Avoid leaving incomplete code fragments or unhandled conditions that cause runtime errors.\n- Inputs described in pseudocode as lists that represent trees or linked lists should be converted appropriately using helper functions if needed, respecting Python conventions.\n- Maintain idiomatic and readable Python style consistent with best practices.\n\nThis approach ensures faithful and robust translations ready for direct use and testing.",
  "score": 0.8957765643710465,
  "feedback": "The following are 20 lines of pseudocode of a random subset of the problems along with their decoded codes.\n\nPseudocode for Problem 1:\nCLASS Solution  \n    FUNCTION smallestMissingValueSubtree(parents, nums)  \n        SET n TO the LENGTH OF parents  \n        SET tree TO an EMPTY map FROM keys TO lists  \n        \n        FOR index FROM one TO n MINUS one  \n            APPEND index TO list at key parents element at position index IN tree  \n        END FOR  \n        \n        SET node_with_one TO negative one  \n        FOR index FROM zero TO n MINUS one  \n            IF element at position index of nums EQUALS one  \n                SET node_with_one TO index  \n                BREAK  \n            END IF  \n        END FOR  \n        \n        IF node_with_one EQUALS negative one  \n            SET result TO an EMPTY list  \n            FOR index FROM zero TO n MINUS one  \n\nDecoded code for Problem 1:\nfrom collections import defaultdict\n\nclass Solution:\n    def smallestMissingValueSubtree(self, parents, nums):\n        n = len(parents)\n        tree = defaultdict(list)\n\n        for index in range(1, n):\n            tree[parents[index]].append(index)\n\n        node_with_one = -1\n        for index in range(n):\n            if nums[index] == 1:\n                node_with_one = index\n                break\n\n        if node_with_one == -1:\n            return [1] * n\n\n        result = [1] * n\n\nError(s) from the decoded code for Problem 1:\n['Outputs do not match']\n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION minMeetingRooms(intervals)  \n        IF intervals EQUALS empty  \n            RETURN zero  \n        END IF  \n\n        SORT intervals BY the element at position zero of each meeting  \n\n        SET min_heap TO empty list  \n\n        FOR each meeting IN intervals  \n            IF min_heap NOT EQUALS empty AND element at position zero of meeting GREATER THAN OR EQUAL TO element at position zero of min_heap  \n                REMOVE first element FROM min_heap  \n            END IF  \n            APPEND element at position one of meeting TO min_heap  \n        END FOR  \n\n        RETURN the LENGTH OF min_heap  \n    END FUNCTION  \nEND CLASS\n\nDecoded code for Problem 2:\nimport heapq\n\nclass Solution:\n    def minMeetingRooms(self, intervals):\n        if not intervals:\n            return 0\n\n        intervals.sort(key=lambda x: x[0])\n        min_heap = []\n\n        for meeting in intervals:\n            if min_heap and meeting[0] >= min_heap[0]:\n                heapq.heappop(min_heap)\n            heapq.heappush(min_heap, meeting[1])\n\n        return len(min_heap)\n\nError(s) from the decoded code for Problem 2:\n['Outputs do not match']\n\nPseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION searchMatrix(matrix, target)  \n        IF matrix EQUALS nothing OR element at position zero of matrix EQUALS nothing  \n            RETURN False  \n        END IF  \n        SET row TO zero  \n        SET col TO the LENGTH OF element at position zero of matrix MINUS one  \n        WHILE row LESS THAN the LENGTH OF matrix AND col GREATER THAN OR EQUAL TO zero  \n            IF element at position row of matrix AT position col EQUALS target  \n                RETURN True  \n            ELSE IF element at position row of matrix AT position col GREATER THAN target  \n                DECREMENT col BY one  \n            ELSE  \n                INCREMENT row BY one  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS\n\nDecoded code for Problem 3:\nfrom typing import List\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n        row, col = 0, len(matrix[0]) - 1\n        while row < len(matrix) and col >= 0:\n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] > target:\n                col -= 1\n            else:\n                row += 1\n        return False\n\nError(s) from the decoded code for Problem 3:\n['Outputs do not match']\n\nPseudocode for Problem 4:\nCLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS val EQUAL TO zero, left EQUAL TO none, right EQUAL TO none  \n        SET the attribute val TO val  \n        SET the attribute left TO left  \n        SET the attribute right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values  \n    IF values IS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode WITH val AS element at position zero of values  \n    SET i TO one  \n    INITIALIZE queue AS a new empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO first element REMOVED FROM queue  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.left TO new TreeNode WITH val AS element at position i of values  \n\nDecoded code for Problem 4:\nfrom collections import deque\nfrom typing import Optional, List\n\nclass TreeNode:\n    def __init__(self, val=0, left: Optional['TreeNode']=None, right: Optional['TreeNode']=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: List[Optional[int]]) -> Optional[TreeNode]:\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque([root])\n    while queue and i < len(values):\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp54tg51xi/solution_0.py\", line 106, in <module>\\n    print(Solution().addOneRow(root = [4,2,6,3,1,5], val = 1, depth = 2))\\n          ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp54tg51xi/solution_0.py\", line 98, in addOneRow\\n    node.left = TreeNode(val, left=node.left)\\n                                   ^^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'left\\'\\n']\n\nPseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION findReplaceString(s, indices, sources, targets)  \n        SET replacements TO list of tuples CREATED BY combining indices, sources, and targets SORTED BY the first element (index)  \n        SET result TO empty list  \n        SET prev_end TO zero  \n        FOR each tuple WITH elements index, source, target IN replacements  \n            APPEND substring of s FROM position prev_end TO position index TO result  \n            IF substring of s FROM position index TO position index PLUS LENGTH OF source EQUALS source  \n                APPEND target TO result  \n            ELSE  \n                APPEND substring of s FROM position index TO position index PLUS LENGTH OF source TO result  \n            END IF  \n            SET prev_end TO index PLUS LENGTH OF source  \n        END FOR  \n        APPEND substring of s FROM position prev_end TO END TO result  \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS\n\nDecoded code for Problem 5:\nclass Solution:\n    def findReplaceString(self, s, indices, sources, targets):\n        replacements = sorted(zip(indices, sources, targets), key=lambda x: x[0])\n        result = []\n        prev_end = 0\n        for index, source, target in replacements:\n            result.append(s[prev_end:index])\n            if s[index:index + len(source)] == source:\n                result.append(target)\n                prev_end = index + len(source)\n            else:\n                result.append(s[index:index + len(source)])\n                prev_end = index + len(source)\n        result.append(s[prev_end:])\n        return \"\".join(result)\n\nError(s) from the decoded code for Problem 5:\n['Outputs do not match']\n\nPseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION wordsAbbreviation(words)  \n        FUNCTION abbreviate(word, prefix_length)  \n            IF the LENGTH OF word MINUS prefix_length LESS THAN OR EQUAL TO two  \n                RETURN word  \n            END IF  \n            RETURN the SUBSTRING of word FROM start TO position prefix_length CONCATENATED WITH the STRING of the LENGTH OF word MINUS prefix_length MINUS one CONCATENATED WITH the LAST CHARACTER of word  \n        END FUNCTION  \n\n        FUNCTION get_unique_abbreviations(words_with_indices, prefix_length)  \n            SET abbs TO a new DEFAULTDICT of list  \n            FOR each index, word IN words_with_indices  \n                APPEND the PAIR of index AND word TO the LIST in abbs at the KEY abbreviate(word, prefix_length)  \n            END FOR  \n            RETURN abbs  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF words  \n        SET ans TO a LIST of empty strings of size n  \n        SET words_with_indices TO a LIST of PAIRS index, word FOR each index, word FROM ENUMERATE words  \n\nDecoded code for Problem 6:\nfrom collections import defaultdict\nfrom typing import List, Tuple\n\nclass Solution:\n    def wordsAbbreviation(self, words: List[str]) -> List[str]:\n        def abbreviate(word: str, prefix_length: int) -> str:\n            # If the abbreviation would not shorten the word, return original\n            if len(word) - prefix_length <= 2:\n                return word\n            return word[:prefix_length] + str(len(word) - prefix_length - 1) + word[-1]\n\n        def get_unique_abbreviations(words_with_indices: List[Tuple[int, str]], prefix_length: int):\n            abbs = defaultdict(list)\n            for index, word in words_with_indices:\n                abbs[abbreviate(word, prefix_length)].append((index, word))\n            return abbs\n\n        n = len(words)\n        ans = [\"\"] * n\n        words_with_indices = list(enumerate(words))\n\nError(s) from the decoded code for Problem 6:\n['timed out']\n\nPseudocode for Problem 7:\nCLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with val EQUALS element at position zero of values  \n    SET i TO one  \n    SET queue TO empty deque  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO first element removed from queue  \n        IF i LESS THAN length of values AND element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with val EQUALS element at position i of values  \n\nDecoded code for Problem 7:\nfrom collections import deque, defaultdict\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: List[Optional[int]]) -> Optional[TreeNode]:\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp56r5c79_/solution_0.py\", line 108, in <module>\\n    print(Solution().verticalOrder(root = [3,9,8,4,0,1,7]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp56r5c79_/solution_0.py\", line 100, in verticalOrder\\n    column_table[column_index].append(node.val)\\n                                      ^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'val\\'\\n']\n\nPseudocode for Problem 8:\nCLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS none OR LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value at position zero of values  \n    SET i TO one  \n    SET queue TO new deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO first element removed FROM queue  \n        IF i LESS THAN LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.left TO new TreeNode with value at position i of values  \n\nDecoded code for Problem 8:\nfrom collections import deque\nfrom typing import Optional, List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: Optional[List[Optional[int]]]) -> Optional[TreeNode]:\n    if values is None or len(values) == 0:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n\nError(s) from the decoded code for Problem 8:\n['Outputs do not match']\nAvg Passing Rate for ALL the problems: 0.8957765643710465"
}