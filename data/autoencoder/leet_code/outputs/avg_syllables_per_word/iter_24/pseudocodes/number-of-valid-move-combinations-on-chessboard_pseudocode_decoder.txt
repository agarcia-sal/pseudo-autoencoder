CLASS Solution  
    FUNCTION countCombinations(pieces, positions)  
        SET directions TO dictionary with keys and values as follows  
            KEY rook VALUES list of pairs each representing one unit step in direction up down left right  
            KEY queen VALUES list of pairs each representing one unit step in directions up down left right and all four diagonals  
            KEY bishop VALUES list of pairs each representing one unit step in all four diagonals  
        
        SET positions TO empty list  
        FOR each pair named r c IN original positions  
            SET new_r TO r MINUS one  
            SET new_c TO c MINUS one  
            APPEND pair new_r new_c TO positions  
        END FOR  
        
        FUNCTION get_destinations(start, piece_type)  
            DESTRUCTURE start INTO r c  
            SET dests TO list containing start  
            FOR each pair dr dc IN directions at piece_type  
                SET nr TO r PLUS dr  
                SET nc TO c PLUS dc  
                WHILE nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN eight AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN eight  
                    APPEND pair nr nc TO dests  
                    SET nr TO nr PLUS dr  
                    SET nc TO nc PLUS dc  
                END WHILE  
            END FOR  
            RETURN dests  
        END FUNCTION  
        
        SET all_destinations TO empty list  
        FOR each position pos AND piece piece IN pairs from positions AND pieces zipped together  
            APPEND get_destinations at pos piece TO all_destinations  
        END FOR  
        
        FUNCTION is_valid_combination(combination)  
            SET pos TO a shallow copy of positions  
            SET n TO the LENGTH OF pos  
            WHILE True  
                IF LENGTH OF unique elements in pos LESS THAN n  
                    RETURN False  
                END IF  
                SET all_reached TO True  
                FOR i FROM zero TO n MINUS one  
                    IF element at position i of pos EQUALS element at position i of combination  
                        CONTINUE TO next iteration  
                    END IF  
                    SET all_reached TO False  
                    DESTRUCTURE element at position i of pos INTO r c  
                    SET dr TO one IF element at position i in combination at first coordinate GREATER THAN r ELSE MINUS one IF element at position i in combination at first coordinate LESS THAN r ELSE zero  
                    SET dc TO one IF element at position i in combination at second coordinate GREATER THAN c ELSE MINUS one IF element at position i in combination at second coordinate LESS THAN c ELSE zero  
                    SET element at position i of pos TO pair r PLUS dr c PLUS dc  
                END FOR  
                IF all_reached  
                    RETURN True  
                END IF  
            END WHILE  
        END FUNCTION  
        
        SET valid_count TO zero  
        FOR each combination IN Cartesian product of all_destinations unpacked  
            IF is_valid_combination at combination  
                INCREMENT valid_count BY one  
            END IF  
        END FOR  
        
        RETURN valid_count  
    END FUNCTION  
END CLASS