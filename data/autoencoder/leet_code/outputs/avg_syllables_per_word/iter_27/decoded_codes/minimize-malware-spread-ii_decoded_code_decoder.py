from collections import defaultdict
from typing import List

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        adj_list = defaultdict(list)
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    adj_list[i].append(j)
                    adj_list[j].append(i)

        def dfs(node: int, visited: set) -> int:
            if node in visited:
                return 0
            visited.add(node)
            size = 1
            for neighbor in adj_list[node]:
                size += dfs(neighbor, visited)
            return size

        infected = set(initial)

        component_sizes = []
        visited = set()
        component_index = {}

        # Find connected components excluding infected nodes
        for node in range(n):
            if node not in visited and node not in infected:
                size = dfs(node, visited)
                component_sizes.append(size)
                # Index of the newly added component
                i = len(component_sizes) - 1
                # Mark all neighbors of this node with component index
                # Actually, to match the pseudocode exactly, we do this for all neighbors of node.
                # But that only marks neighbors directly connected to node, so we must mark all nodes in component
                # The pseudocode marks only neighbors of node, but that loses other nodes in that component.
                # Probably the pseudocode intended to mark all nodes in the component with the same index.
                # To fix this logically, we can do a DFS to collect all nodes in component
                # Since visited already has these nodes, we can check which nodes are in this component by the 'visited' set difference before and after dfs
                # But since we do not have that info, we can do a dfs that collects nodes instead.

        # To implement component_index correctly:
        # We must associate each node not infected to the component index it belongs to
        # So redo this by slightly changing dfs to collect nodes
        # Let's redefine dfs to return the nodes in the component

        adj_list = defaultdict(list)
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    adj_list[i].append(j)
                    adj_list[j].append(i)

        infected = set(initial)
        component_sizes = []
        component_index = {}
        visited = set()

        def dfs_collect(node: int, visited: set) -> List[int]:
            stack = [node]
            comp_nodes = []
            while stack:
                curr = stack.pop()
                if curr not in visited:
                    visited.add(curr)
                    comp_nodes.append(curr)
                    for neighbor in adj_list[curr]:
                        if neighbor not in visited and neighbor not in infected:
                            stack.append(neighbor)
            return comp_nodes

        for node in range(n):
            if node not in visited and node not in infected:
                comp_nodes = dfs_collect(node, visited)
                size = len(comp_nodes)
                component_sizes.append(size)
                comp_idx = len(component_sizes) - 1
                for comp_node in comp_nodes:
                    component_index[comp_node] = comp_idx

        infected_in_component = defaultdict(int)
        for node in infected:
            if node in component_index:
                infected_in_component[component_index[node]] += 1

        max_size = 0
        node_to_remove = min(initial)

        for node in infected:
            if node in component_index:
                comp_idx = component_index[node]
                if infected_in_component[comp_idx] == 1:
                    comp_size = component_sizes[comp_idx]
                    if comp_size > max_size:
                        max_size = comp_size
                        node_to_remove = node
                    elif comp_size == max_size:
                        node_to_remove = min(node_to_remove, node)

        return node_to_remove