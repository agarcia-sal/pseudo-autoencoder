{
  "prompt": "Given source code containing classes, functions, and other code elements, generate a strictly hierarchical and highly abstract pseudocode that:\n\n- Preserves all original class names, function names, parameter names, and the exact nesting of classes and objects.\n- Uses indentation exactly reflecting code blocks as in the original source.\n- Captures all logic and control flow precisely, including conditions, loops, returns, and nested constructs.\n- Uses only these uppercase pseudocode keywords as control markers: CLASS, FUNCTION, IF, ELSE, ELSE IF, FOR, WHILE, RETURN, END FUNCTION, END CLASS, END IF, END FOR, END WHILE.\n- Expresses all operations using clear, consistent natural language phrasing without any programming language syntax or symbols.\n- Translates all arithmetic and logical operations into full-word expressions (e.g., PLUS, MINUS, MULTIPLIED BY, DIVIDED BY, MODULO, EQUALS, NOT EQUALS, LESS THAN, LESS THAN OR EQUAL TO, GREATER THAN, GREATER THAN OR EQUAL TO, AND, OR, NOT).\n- Uses precise, uniform verbs for data manipulation such as: SET variable TO value, INCREMENT variable BY amount, DECREMENT variable BY amount, APPEND item TO list, REMOVE first element FROM list, REMOVE last element FROM list.\n- Explicitly include original constructors and special methods by name with the same parameters and structure.\n- Represent complex data structure initializations or helper routines as auxiliary FUNCTIONS with their original names, describing only essential abstract actions without concrete syntax or low-level details.\n- Represent iteration over collections or numeric ranges explicitly in natural language: FOR each element IN collection, FOR index FROM start TO end.\n- Spell out all conditional expressions and logical tests fully without shortcuts or operators.\n- Omit all comments, textual explanations, notes, separators, or any additional text before or after the pseudocode output.\n- Do not include variable type annotations, language-specific idioms, or or literal syntax such as brackets, braces, or language symbols.\n- Use concise, consistently descriptive terminology maximizing clarity and abstraction.\n- Include all function parameters exactly as named in the original code, without adding types or language-specific decorations.\n- When referring to indexing or elements in collections, use natural language: element at position index of collection.\n\nHere is an example of the style the pseudocode must follow:\n\nFUNCTION calc_average(list_of_numbers)  \n    SET total_sum TO zero  \n    FOR each number IN list_of_numbers  \n        INCREMENT total_sum BY number  \n    END FOR  \n    SET average_value TO total_sum DIVIDED BY the LENGTH OF list_of_numbers  \n    RETURN average_value  \nEND FUNCTION",
  "response": "Given source code containing classes, functions, and other code elements, generate a strictly hierarchical and highly abstract pseudocode that:\n\n- Preserves all original class names, function names, parameter names, and the exact nesting of classes and objects.\n- Uses indentation exactly reflecting code blocks as in the original source.\n- Captures all logic and control flow precisely, including conditions, loops, returns, and nested constructs.\n- Uses only these uppercase pseudocode keywords as control markers: CLASS, FUNCTION, IF, ELSE, ELSE IF, FOR, WHILE, RETURN, END FUNCTION, END CLASS, END IF, END FOR, END WHILE.\n- Expresses all operations using clear, consistent natural language phrasing without any programming language syntax or symbols.\n- Translates all arithmetic and logical operations into full-word expressions (e.g., PLUS, MINUS, MULTIPLIED BY, DIVIDED BY, MODULO, EQUALS, NOT EQUALS, LESS THAN, LESS THAN OR EQUAL TO, GREATER THAN, GREATER THAN OR EQUAL TO, AND, OR, NOT).\n- Uses precise, uniform verbs for data manipulation such as: SET variable TO value, INCREMENT variable BY amount, DECREMENT variable BY amount, APPEND item TO list, REMOVE first element FROM list, REMOVE last element FROM list.\n- Explicitly include original constructors and special methods by name with the same parameters and structure.\n- Represent complex data structure initializations or helper routines as auxiliary FUNCTIONS with their original names, describing only essential abstract actions without concrete syntax or low-level details.\n- Represent iteration over collections or numeric ranges explicitly in natural language: FOR each element IN collection, FOR index FROM start TO end.\n- Spell out all conditional expressions and logical tests fully without shortcuts or operators.\n- Omit all comments, textual explanations, notes, separators, or any additional text before or after the pseudocode output.\n- Do not include variable type annotations, language-specific idioms, or or literal syntax such as brackets, braces, or language symbols.\n- Use concise, consistently descriptive terminology maximizing clarity and abstraction.\n- Include all function parameters exactly as named in the original code, without adding types or language-specific decorations.\n- When referring to indexing or elements in collections, use natural language: element at position index of collection.\n\nHere is an example of the style the pseudocode must follow:\n\nFUNCTION calc_average(list_of_numbers)  \n    SET total_sum TO zero  \n    FOR each number IN list_of_numbers  \n        INCREMENT total_sum BY number  \n    END FOR  \n    SET average_value TO total_sum DIVIDED BY the LENGTH OF list_of_numbers  \n    RETURN average_value  \nEND FUNCTION",
  "score": 1.964091463254273,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def addOneRow(self, root: Optional[TreeNode], val: int, depth: int) -> Optional[TreeNode]:\n        if depth == 1:\n            return TreeNode(val, left=root)\n        \n        queue = deque([(root, 1)])\n        \n        while queue:\n            node, level = queue.popleft()\n            \n            if level == depth - 1:\n                node.left = TreeNode(val, left=node.left)\n                node.right = TreeNode(val, right=node.right)\n            elif level < depth - 1:\n\nPseudocode for Problem 1:\nCLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with val equal to element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO first element removed FROM queue  \n        IF i LESS THAN length of values AND element at position i of values IS NOT none  \n            SET node.left TO new TreeNode with val equal to element at position i of values  \n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpu7q0oln2/solution_0.py\", line 103, in <module>\\n    print(Solution().addOneRow(root = [4,2,6,3,1,5], val = 1, depth = 2))\\n          ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpu7q0oln2/solution_0.py\", line 95, in addOneRow\\n    node.left = TreeNode(val, left=node.left)\\n                                   ^^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'left\\'\\n']\n\nOriginal Code for Problem 2:\nfrom typing import List\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words or not words[0]:\n            return []\n        \n        word_length = len(words[0])\n        num_words = len(words)\n        total_length = word_length * num_words\n        word_count = Counter(words)\n        result = []\n        \n        for i in range(len(s) - total_length + 1):\n            seen = Counter()\n            for j in range(i, i + total_length, word_length):\n                word = s[j:j + word_length]\n                seen[word] += 1\n                if seen[word] > word_count[word]:\n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION findSubstring(s, words)  \n        IF s EQUALS empty OR words EQUALS empty OR the element at position zero of words EQUALS empty  \n            RETURN empty list  \n        END IF  \n        \n        SET word_length TO the LENGTH OF the element at position zero of words  \n        SET num_words TO the LENGTH OF words  \n        SET total_length TO word_length MULTIPLIED BY num_words  \n        SET word_count TO the result of Counter applied to words  \n        SET result TO empty list  \n        \n        FOR index i FROM zero TO the LENGTH OF s MINUS total_length PLUS one  \n            SET seen TO an empty Counter  \n            FOR index j FROM i TO i PLUS total_length, with step size word_length  \n                SET word TO the substring of s from position j TO position j PLUS word_length  \n                INCREMENT the count of word in seen BY one  \n                IF the count of word in seen GREATER THAN the count of word in word_count  \n                    BREAK  \n                END IF  \n\nError(s) from the decoded code for Problem 2:\n['Outputs do not match']\n\nOriginal Code for Problem 3:\nfrom typing import List\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n        self.size = [1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # Path compression\n        return self.parent[u]\n\n    def union(self, u, v):\n        rootU = self.find(u)\n        rootV = self.find(v)\n        if rootU != rootV:\n            if self.rank[rootU] > self.rank[rootV]:\n                self.parent[rootV] = rootU\n\nPseudocode for Problem 3:\nCLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of numbers from zero TO size MINUS one  \n        SET self.rank TO list of size elements each SET TO one  \n        SET self.size TO list of size elements each SET TO one  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET rootU TO self.find(u)  \n        SET rootV TO self.find(v)  \n        IF rootU NOT EQUALS rootV  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank  \n                SET element at position rootV of self.parent TO rootU  \n\nError(s) from the decoded code for Problem 3:\n['Outputs do not match']\n\nOriginal Code for Problem 4:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        def helper(node):\n            if not node:\n                return \"\"\n            \n            # Start with the root's value\n            result = str(node.val)\n            \n            # If there is a left child, or there is no left child but there is a right child\n            if node.left or node.right:\n                result += \"(\" + helper(node.left) + \")\"\n            \n            # If there is a right child\n\nPseudocode for Problem 4:\nCLASS TreeNode  \n    FUNCTION __init__ with parameters val, left, right  \n        SET val TO val  \n        SET left TO left  \n        SET right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node with parameter values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value at position zero of values  \n    SET i TO one  \n    SET queue TO empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        REMOVE first element FROM queue and SET to node  \n        IF i LESS THAN length of values AND element at position i of values NOT EQUALS None  \n            SET node.left TO new TreeNode with value at position i of values  \n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpuevckgci/solution_0.py\", line 101, in <module>\\n    print(Solution().tree2str(root = [1,2,3,4]))\\n          ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpuevckgci/solution_0.py\", line 100, in tree2str\\n    return helper(root)\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpuevckgci/solution_0.py\", line 94, in helper\\n    result = str(node.val)\\n                 ^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'val\\'\\n']\n\nOriginal Code for Problem 5:\nfrom typing import List\n\nclass Solution:\n    def constructArray(self, n: int, k: int) -> List[int]:\n        # Initialize the result array with the first part being a sequence of length n-k-1\n        result = list(range(1, n - k))\n        \n        # Initialize the two pointers for the second part of the array\n        left, right = n - k, n\n        \n        # Use the two pointers to create the second part of the array\n        while left <= right:\n            if left == right:\n                result.append(left)\n            else:\n                result.append(left)\n                result.append(right)\n            left += 1\n            right -= 1\n        \n\nPseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION constructArray(n, k)  \n        SET result TO list of integers from one TO n MINUS k MINUS one  \n        SET left TO n MINUS k  \n        SET right TO n  \n        WHILE left LESS THAN OR EQUAL TO right  \n            IF left EQUALS right  \n                APPEND left TO result  \n            ELSE  \n                APPEND left TO result  \n                APPEND right TO result  \n            END IF  \n            INCREMENT left BY one  \n            DECREMENT right BY one  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\n\nError(s) from the decoded code for Problem 5:\n['Outputs do not match']\n\nOriginal Code for Problem 6:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return (0, 0, float('inf'))  # (no camera, monitored, camera)\n            \n            left_no_camera, left_monitored, left_camera = dfs(node.left)\n            right_no_camera, right_monitored, right_camera = dfs(node.right)\n            \n            no_camera = left_monitored + right_monitored\n            monitored = min(left_camera + min(right_monitored, right_camera),\n                            right_camera + min(left_monitored, left_camera),\n                            left_camera + right_camera)\n            camera = 1 + min(left_no_camera, left_monitored, left_camera) + min(right_no_camera, right_monitored, right_camera)\n\nPseudocode for Problem 6:\nCLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS val EQUALS zero, left EQUALS none, right EQUALS none  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO NEW TreeNode WITH value at position zero of values  \n    SET i TO one  \n    SET queue TO new deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO REMOVE first element FROM queue  \n        IF i LESS THAN the LENGTH OF values AND value at position i of values IS NOT none  \n            SET node.left TO NEW TreeNode WITH value at position i of values  \n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpfy2xcmoa/solution_0.py\", line 110, in <module>\\n    print(Solution().minCameraCover(root = [0,0,0,null,null,0,0]))\\n                                                  ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 7:\nfrom typing import List\n\nclass Solution:\n    def amountPainted(self, paint: List[List[int]]) -> List[int]:\n        # Initialize a list to keep track of the painted areas\n        max_end = max(end for _, end in paint)\n        painted = [-1] * (max_end + 1)\n        worklog = []\n        \n        for start, end in paint:\n            current_start = start\n            new_paint = 0\n            \n            # While there are unpainted areas in the current range\n            while current_start < end:\n                if painted[current_start] == -1:\n                    # Paint the current area\n                    painted[current_start] = end\n                    new_paint += 1\n                    current_start += 1\n\nPseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION amountPainted(paint)  \n        SET max_end TO the maximum value of the second element of each pair in paint  \n        SET painted TO a list of length max_end PLUS one filled with minus one  \n        SET worklog TO an empty list  \n        \n        FOR each pair of start and end IN paint  \n            SET current_start TO start  \n            SET new_paint TO zero  \n            \n            WHILE current_start LESS THAN end  \n                IF the element at position current_start of painted EQUALS minus one  \n                    SET the element at position current_start of painted TO end  \n                    INCREMENT new_paint BY one  \n                    INCREMENT current_start BY one  \n                ELSE  \n                    SET current_start TO the element at position current_start of painted  \n                END IF  \n            END WHILE  \n            \n\nError(s) from the decoded code for Problem 7:\n['Outputs do not match']\n\nOriginal Code for Problem 8:\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def plusOne(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Helper function to reverse the linked list\n        def reverseList(node: ListNode) -> ListNode:\n            prev = None\n            while node:\n                next_node = node.next\n                node.next = prev\n                prev = node\n                node = next_node\n            return prev\n        \n        # Reverse the linked list to make addition easier\n        reversed_head = reverseList(head)\n        \n\nPseudocode for Problem 8:\nCLASS ListNode  \n    FUNCTION __init__ with parameters val EQUALS zero, next EQUALS none  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node with parameter values  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET head TO a new ListNode with parameter the element at position zero of values  \n    SET p TO head  \n    FOR each val IN values starting from position one TO the last position  \n        SET node TO a new ListNode with parameter val  \n        SET p.next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp6ohzdigf/solution_0.py\", line 90, in <module>\\n    print(Solution().plusOne(head = [1,2,3]))\\n          ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp6ohzdigf/solution_0.py\", line 76, in plusOne\\n    reversed_head = reverseList(head)\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp6ohzdigf/solution_0.py\", line 70, in reverseList\\n    next_node = node.next\\n                ^^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'next\\'\\n']\nScore of (4*(Average syllables per word) + passing rate) for ALL the problems: 1.964091463254273"
}