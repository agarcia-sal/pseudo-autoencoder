{
  "prompt": "Given a code snippet including classes and functions, generate clear, concise, and highly abstract pseudocode that strictly preserves the original class and function names, parameters, and their hierarchical structure. Use consistent indentation to reflect code blocks precisely as in the source. Express all operations at a high semantic level using conventional pseudocode keywords (e.g., CLASS, FUNCTION, IF, ELSE, FOR, WHILE, RETURN) and natural language phrasing.  \n\nRepresent data manipulations abstractly with phrases like SET variable TO value, INCREMENT variable BY amount, APPEND item TO list, WITHOUT any language-specific syntax, operators, or symbols. Replace symbolic operators with natural language equivalents (e.g., DIVIDED BY instead of /, MODULO instead of %, GREATER THAN instead of >). Omit all comments, explanatory notes, and summaries. Output only the pseudocode without extra text.\n\nPreserve control flow and logic exactly, including conditions, loops, and return statements. Method signatures must include all parameters with their names cleanly stated, omitting explicit types unless they clarify meaning without language bias. The class structure and nesting must be identical to the original code, with constructors and special methods explicitly shown if present.\n\nFor complex data structures or initialization helper code inside or outside classes (e.g., linked list or tree node creation), write auxiliary FUNCTIONs that retain the original naming conventions and reflect the logical steps abstractly with no implementation detail.\n\nMaintain natural language expressions that maximize readability and abstraction by avoiding low-level programming constructs, language-specific idioms, or literal syntax. Use descriptive, concise terms, and consistently standardized pseudocode style throughout.\n\nExample style:  \nCLASS Solution  \n    FUNCTION calc_average(list_of_numbers)  \n        SET total_sum TO 0  \n        FOR each number IN list_of_numbers  \n            INCREMENT total_sum BY number  \n        SET average_value TO total_sum DIVIDED BY LENGTH OF list_of_numbers  \n        RETURN average_value  \n    END FUNCTION  \nEND CLASS",
  "response": "Given a code snippet including classes and functions, generate clear, concise, and highly abstract pseudocode that strictly preserves the original class and function names, parameters, and their hierarchical structure. Use consistent indentation to reflect code blocks precisely as in the source. Express all operations at a high semantic level using conventional pseudocode keywords (e.g., CLASS, FUNCTION, IF, ELSE, FOR, WHILE, RETURN) and natural language phrasing.  \n\nRepresent data manipulations abstractly with phrases like SET variable TO value, INCREMENT variable BY amount, APPEND item TO list, WITHOUT any language-specific syntax, operators, or symbols. Replace symbolic operators with natural language equivalents (e.g., DIVIDED BY instead of /, MODULO instead of %, GREATER THAN instead of >). Omit all comments, explanatory notes, and summaries. Output only the pseudocode without extra text.\n\nPreserve control flow and logic exactly, including conditions, loops, and return statements. Method signatures must include all parameters with their names cleanly stated, omitting explicit types unless they clarify meaning without language bias. The class structure and nesting must be identical to the original code, with constructors and special methods explicitly shown if present.\n\nFor complex data structures or initialization helper code inside or outside classes (e.g., linked list or tree node creation), write auxiliary FUNCTIONs that retain the original naming conventions and reflect the logical steps abstractly with no implementation detail.\n\nMaintain natural language expressions that maximize readability and abstraction by avoiding low-level programming constructs, language-specific idioms, or literal syntax. Use descriptive, concise terms, and consistently standardized pseudocode style throughout.\n\nExample style:  \nCLASS Solution  \n    FUNCTION calc_average(list_of_numbers)  \n        SET total_sum TO 0  \n        FOR each number IN list_of_numbers  \n            INCREMENT total_sum BY number  \n        SET average_value TO total_sum DIVIDED BY LENGTH OF list_of_numbers  \n        RETURN average_value  \n    END FUNCTION  \nEND CLASS",
  "score": 1.862042777362458,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        def dfs(node):\n            if not node:\n                return node, 0\n            \n            left_node, left_depth = dfs(node.left)\n            right_node, right_depth = dfs(node.right)\n            \n            if left_depth > right_depth:\n                return left_node, left_depth + 1\n            elif right_depth > left_depth:\n                return right_node, right_depth + 1\n            else:\n\nPseudocode for Problem 1:\nCLASS TreeNode  \n    FUNCTION __init__(self, val = 0, left = None, right = None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS EMPTY  \n        RETURN None  \n    SET root TO NEW TreeNode WITH val AS values AT index 0  \n    SET i TO 1  \n    SET queue TO NEW empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO REMOVE first element FROM queue  \n        IF i IS LESS THAN LENGTH OF values AND values AT index i IS NOT None  \n            SET node.left TO NEW TreeNode WITH val AS values AT index i  \n            APPEND node.left TO queue  \n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp31l2j6gb/solution_0.py\", line 103, in <module>\\n    print(Solution().subtreeWithAllDeepest(root = [3,5,1,6,2,0,8,null,null,7,4]))\\n                                                                 ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 2:\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        def justify_line(line, num_of_letters, is_last_line):\n            if len(line) == 1 or is_last_line:\n                # Left justify for single word line or last line\n                return ' '.join(line) + ' ' * (maxWidth - num_of_letters - len(line) + 1)\n            else:\n                # Full justify for the middle lines\n                total_spaces = maxWidth - num_of_letters\n                num_of_gaps = len(line) - 1\n                spaces_between_words = total_spaces // num_of_gaps\n                extra_spaces = total_spaces % num_of_gaps\n                \n                for i in range(num_of_gaps):\n                    if i < extra_spaces:\n                        line[i] += ' ' * (spaces_between_words + 1)\n                    else:\n                        line[i] += ' ' * spaces_between_words\n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION fullJustify(words, maxWidth)  \n        FUNCTION justify_line(line, num_of_letters, is_last_line)  \n            IF LENGTH OF line EQUALS 1 OR is_last_line IS TRUE THEN  \n                RETURN join words in line separated by a space PLUS append spaces TO fill maxWidth minus num_of_letters minus LENGTH OF line plus one  \n            ELSE  \n                SET total_spaces TO maxWidth MINUS num_of_letters  \n                SET num_of_gaps TO LENGTH OF line MINUS 1  \n                SET spaces_between_words TO total_spaces DIVIDED BY num_of_gaps  \n                SET extra_spaces TO total_spaces MODULO num_of_gaps  \n              \n                FOR i FROM 0 TO num_of_gaps MINUS 1 DO  \n                    IF i LESS THAN extra_spaces THEN  \n                        APPEND spaces of length spaces_between_words PLUS one TO line at index i  \n                    ELSE  \n                        APPEND spaces of length spaces_between_words TO line at index i  \n                END FOR  \n              \n                RETURN concatenate all elements in line into a single string  \n            END IF  \n\nError(s) from the decoded code for Problem 2:\n['Outputs do not match']\n\nOriginal Code for Problem 3:\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Count the frequency of each character\n        count = Counter(s)\n        # Sort characters by frequency\n        max_heap = [(-freq, char) for char, freq in count.items()]\n        import heapq\n        heapq.heapify(max_heap)\n        \n        prev_char = None\n        prev_freq = 0\n        result = []\n        \n        while max_heap or prev_freq < 0:\n            if not max_heap and prev_freq < 0:\n                return \"\"\n            \n            freq, char = heapq.heappop(max_heap)\n\nPseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION reorganizeString(s)  \n        SET count TO frequency count of characters in s  \n        SET max_heap TO list of pairs with negative frequency and character from count  \n        CALL heapify on max_heap  \n\n        SET prev_char TO None  \n        SET prev_freq TO 0  \n        SET result TO empty list  \n\n        WHILE max_heap is not empty OR prev_freq is less than 0  \n            IF max_heap is empty AND prev_freq is less than 0  \n                RETURN empty string  \n            END IF  \n\n            SET freq, char TO pop from max_heap  \n            APPEND char TO result  \n\n            INCREMENT freq BY 1  \n\n\nError(s) from the decoded code for Problem 3:\n['Outputs do not match']\n\nOriginal Code for Problem 4:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        current = root\n        count = 0\n        \n        while stack or current:\n            while current:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            count += 1\n            if count == k:\n                return current.val\n\nPseudocode for Problem 4:\nCLASS TreeNode  \n    FUNCTION __init__(self, val SET TO 0, left SET TO None, right SET TO None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS EMPTY  \n        RETURN None  \n    SET root TO NEW TreeNode WITH values AT POSITION 0  \n    SET i TO 1  \n    SET queue TO NEW deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO REMOVE FIRST ELEMENT FROM queue  \n        IF i IS LESS THAN LENGTH OF values AND values AT POSITION i IS NOT None  \n            SET node.left TO NEW TreeNode WITH values AT POSITION i  \n            APPEND node.left TO queue  \n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpk3j_yc3b/solution_0.py\", line 103, in <module>\\n    print(Solution().kthSmallest(root = [3,1,4,null,2], k = 1))\\n                                               ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 5:\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        import re\n        \n        # Regular expression for CDATA\n        cdata_pattern = r'<!\\[CDATA\\[.*?\\]\\]>'\n        \n        # Remove all CDATA sections\n        code = re.sub(cdata_pattern, '', code)\n        \n        # Stack to keep track of open tags\n        stack = []\n        \n        i = 0\n        while i < len(code):\n            if code[i] == '<':\n                # Find the next '>'\n                j = code.find('>', i + 1)\n                if j == -1:\n                    return False  # No matching '>'\n\nPseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION isValid(code)  \n        IMPORT regular expression module AS re  \n        \n        SET cdata_pattern TO pattern matching '<![CDATA[...]]>' sections  \n        \n        SET code TO result of removing all cdata_pattern matches from code  \n        \n        SET stack TO empty list  \n        \n        SET i TO 0  \n        WHILE i LESS THAN length of code  \n            IF character at code position i IS '<' THEN  \n                SET j TO position of next '>' character after i in code  \n                IF j EQUALS -1 THEN  \n                    RETURN False  \n                END IF  \n                \n                SET tag_content TO substring of code from i plus 1 TO j minus 1  \n                \n\nError(s) from the decoded code for Problem 5:\n['Outputs do not match']\n\nOriginal Code for Problem 6:\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # Define the range for 32-bit signed integer\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        # Initialize variables\n        result = 0\n        index = 0\n        n = len(s)\n        sign = 1\n        \n        # Step 1: Ignore leading whitespace\n        while index < n and s[index] == ' ':\n            index += 1\n        \n        # Step 2: Check for a sign\n        if index < n and (s[index] == '+' or s[index] == '-'):\n            sign = -1 if s[index] == '-' else 1\n            index += 1\n\nPseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO 2 raised to the power 31 MINUS 1  \n        SET INT_MIN TO NEGATIVE 2 raised to the power 31  \n        \n        SET result TO 0  \n        SET index TO 0  \n        SET n TO LENGTH OF s  \n        SET sign TO 1  \n        \n        WHILE index LESS THAN n AND CHARACTER AT s AT index EQUALS whitespace  \n            INCREMENT index BY 1  \n        \n        IF index LESS THAN n AND (CHARACTER AT s AT index EQUALS plus SIGN OR CHARACTER AT s AT index EQUALS minus SIGN)  \n            SET sign TO NEGATIVE 1 IF CHARACTER AT s AT index EQUALS minus SIGN OTHERWISE 1  \n            INCREMENT index BY 1  \n        \n        WHILE index LESS THAN n AND CHARACTER AT s AT index IS digit  \n            SET digit TO numeric VALUE OF CHARACTER AT s AT index  \n            IF result GREATER THAN ((INT_MAX MINUS digit) DIVIDED BY 10)  \n\nError(s) from the decoded code for Problem 6:\n['Outputs do not match']\n\nOriginal Code for Problem 7:\nfrom typing import List\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\n# Precompute the prime factorization for numbers 1 to 30\nprime_factors = {\n    2: [2],\n    3: [3],\n    5: [5],\n    6: [2, 3],\n    7: [7],\n    10: [2, 5],\n    11: [11],\n    13: [13],\n    14: [2, 7],\n    15: [3, 5],\n    17: [17],\n    19: [19],\n    21: [3, 7],\n\nPseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION numberOfGoodSubsets(nums)  \n        SET count TO frequency count of elements in nums  \n        INITIALIZE dp AS list of zeros with length equal to two raised to the power of ten  \n        SET dp at index zero TO 1  \n\n        FOR each num IN keys of count  \n            IF num EQUALS 1 THEN  \n                SET dp at index zero TO dp at index zero MULTIPLIED BY two raised to the power of count at 1  \n                SET dp at index zero TO dp at index zero MODULO MOD  \n                CONTINUE to next iteration  \n            END IF  \n\n            IF num NOT IN prime_factors THEN  \n                CONTINUE to next iteration  \n            END IF  \n\n            SET factors TO prime_factors at num  \n            SET mask TO zero  \n            FOR each prime IN factors  \n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps177e878/solution_0.py\", line 65, in <module>\\n    print(Solution().numberOfGoodSubsets(nums = [1,2,3,4]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps177e878/solution_0.py\", line 51, in numberOfGoodSubsets\\n    dp[0] = dp[0] * pow(2, count[1], self.MOD) % self.MOD\\n                    ~~~^^^^^^^^^^^^^^^^^^^^^^^\\nTypeError: pow expected 2 arguments, got 3\\n']\n\nOriginal Code for Problem 8:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\nfrom typing import List, Optional\n\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n\n        # Dictionary to store the nodes' values by their (col, row) positions\n        node_dict = defaultdict(list)\n        min_col = max_col = 0\n\n        # Perform a depth-first search to populate node_dict\n        def dfs(node, row, col):\n\nPseudocode for Problem 8:\nCLASS TreeNode  \n    FUNCTION __init__(self, val = 0, left = None, right = None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with values at index 0  \n    SET i TO 1  \n    SET queue TO new empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO REMOVE first element FROM queue  \n        IF i IS LESS THAN LENGTH OF values AND values at index i IS NOT None  \n            SET node.left TO new TreeNode with values at index i  \n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpdf_lih2_/solution_0.py\", line 114, in <module>\\n    print(Solution().verticalTraversal(root = [3,9,20,null,null,15,7]))\\n                                                      ^^^^\\nNameError: name \\'null\\' is not defined\\n']\nScore of (4*(Average syllables per word) + passing rate) for ALL the problems: 1.862042777362458"
}