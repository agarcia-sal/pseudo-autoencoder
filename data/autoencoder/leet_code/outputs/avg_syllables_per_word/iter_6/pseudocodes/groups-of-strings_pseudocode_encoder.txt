CLASS UnionFind  
    FUNCTION __init__(self, size)  
        SET self.parent TO list of integers from zero TO size MINUS one  
        SET self.rank TO list of zeros of length size  
        SET self.size TO list of ones of length size  
    END FUNCTION  

    FUNCTION find(self, u)  
        IF self.parent[u] NOT EQUALS u THEN  
            SET self.parent[u] TO CALL self.find WITH self.parent[u]  
        RETURN self.parent[u]  
    END FUNCTION  

    FUNCTION union(self, u, v)  
        SET rootU TO CALL self.find WITH u  
        SET rootV TO CALL self.find WITH v  
        IF rootU NOT EQUALS rootV THEN  
            IF self.rank[rootU] GREATER THAN self.rank[rootV] THEN  
                SET self.parent[rootV] TO rootU  
                INCREMENT self.size[rootU] BY self.size[rootV]  
            ELSE IF self.rank[rootU] LESS THAN self.rank[rootV] THEN  
                SET self.parent[rootU] TO rootV  
                INCREMENT self.size[rootV] BY self.size[rootU]  
            ELSE  
                SET self.parent[rootV] TO rootU  
                INCREMENT self.size[rootU] BY self.size[rootV]  
                INCREMENT self.rank[rootU] BY one  
    END FUNCTION  
END CLASS  

CLASS Solution  
    FUNCTION groupStrings(self, words)  
        FUNCTION bitmask(word)  
            SET mask TO zero  
            FOR each char IN word  
                SET mask TO mask OR bit shifted one LEFT BY (character code of char MINUS character code of 'a')  
            RETURN mask  
        END FUNCTION  

        SET word_map TO empty map with default value as empty list  
        SET n TO length of words  
        SET uf TO new UnionFind initialized with n  

        FOR index i, word IN words  
            SET mask TO CALL bitmask WITH word  
            APPEND i TO word_map AT key mask  

        FOR index i, word IN words  
            SET mask TO CALL bitmask WITH word  
            FOR j FROM zero TO twenty five  
                SET new_mask TO mask XOR bit shifted one LEFT BY j  
                IF new_mask EXISTS IN word_map THEN  
                    FOR each k IN word_map AT new_mask  
                        CALL uf.union WITH i AND k  

                IF mask AND bit shifted one LEFT BY j EQUALS zero THEN  
                    SET new_mask TO mask OR bit shifted one LEFT BY j  
                    IF new_mask EXISTS IN word_map THEN  
                        FOR each k IN word_map AT new_mask  
                            CALL uf.union WITH i AND k  

                IF mask AND bit shifted one LEFT BY j NOT EQUALS zero THEN  
                    FOR k FROM zero TO twenty five  
                        IF mask AND bit shifted one LEFT BY k EQUALS zero THEN  
                            SET new_mask TO (mask XOR bit shifted one LEFT BY j) OR bit shifted one LEFT BY k  
                            IF new_mask EXISTS IN word_map THEN  
                                FOR each l IN word_map AT new_mask  
                                    CALL uf.union WITH i AND l  

        SET root_sizes TO empty map with default value zero  
        FOR i FROM zero TO n MINUS one  
            SET root TO CALL uf.find WITH i  
            INCREMENT root_sizes[root] BY one  

        SET max_group_size TO maximum value in root_sizes  
        SET num_groups TO number of keys in root_sizes  

        RETURN list containing num_groups and max_group_size  
    END FUNCTION  
END CLASS