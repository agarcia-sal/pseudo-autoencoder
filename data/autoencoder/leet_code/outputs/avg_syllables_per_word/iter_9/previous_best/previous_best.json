{
  "prompt": "Given a code snippet containing classes, functions, and other code elements, produce a strictly structured, highly abstract pseudocode that:\n\n- Preserves exactly all original class names, function names, parameter names, and the hierarchical class/object nesting.\n- Uses consistent indentation reflecting code blocks identically to the source.\n- Expresses logic and control flow precisely as in the original, including all conditions, loops, and returns.\n- Uses only conventional pseudocode keywords such as CLASS, FUNCTION, IF, ELSE, FOR, WHILE, RETURN, and END FUNCTION / END CLASS.\n- Represents operations at a semantic level using natural language phrasing and avoids any programming language specific syntax, symbols, or operators.\n- Maps all arithmetic and logical operators into clear natural language equivalents: e.g., PLUS, MINUS, MULTIPLIED BY, DIVIDED BY, MODULO, EQUALS, NOT EQUALS, LESS THAN, GREATER THAN, AND, OR, NOT.\n- Represents data manipulation with uniform abstract verbs and phrases, e.g.: SET variable TO value, INCREMENT variable BY amount, APPEND item TO list, REMOVE first/last element FROM list.\n- Explicitly defines constructors and special methods using their exact original names.\n- Converts complex data structure initializations or helper routines outside or inside classes into auxiliary FUNCTIONs with original names, describing only essential abstract steps without concrete implementation or data structure syntax.\n- Omits all comments, explanatory notes, example explanations, and additional text\u2014output ONLY the pseudocode.\n- Avoids low-level programming details, language-specific idioms, literal syntax, or any variable type annotations.\n- Uses descriptive, concise terms consistently to maximize clarity and naturalness without sacrificing abstraction.\n- Includes all parameters in function signatures exactly as named, excluding any type hints or language-specific constructs.\n- For loops and conditionals, clearly reflect iteration over collections or ranges using natural language constructs like \"FOR each element IN collection\" or \"FOR index FROM start TO end\".\n- Presents all conditionals and expressions in fully spelled-out, readable form without symbolic shortcuts.\n\nExample style for functions:\n\nFUNCTION example_function(parameter_list)  \n    SET variable TO initial_value  \n    FOR each element IN parameter_list  \n        IF element GREATER THAN threshold THEN  \n            INCREMENT variable BY element  \n        ELSE  \n            SET variable TO variable MINUS element  \n        END IF  \n    END FOR  \n    RETURN variable  \nEND FUNCTION\n\nExample style for classes:\n\nCLASS ClassName  \n    FUNCTION __init__(self, param1, param2)  \n        SET self.param1 TO param1  \n        SET self.param2 TO param2  \n    END FUNCTION  \n\n    FUNCTION method_name(self, param)  \n        [method body at this level of abstraction]  \n    END FUNCTION  \nEND CLASS",
  "response": "Given a code snippet containing classes, functions, and other code elements, produce a strictly structured, highly abstract pseudocode that:\n\n- Preserves exactly all original class names, function names, parameter names, and the hierarchical class/object nesting.\n- Uses consistent indentation reflecting code blocks identically to the source.\n- Expresses logic and control flow precisely as in the original, including all conditions, loops, and returns.\n- Uses only conventional pseudocode keywords such as CLASS, FUNCTION, IF, ELSE, FOR, WHILE, RETURN, and END FUNCTION / END CLASS.\n- Represents operations at a semantic level using natural language phrasing and avoids any programming language specific syntax, symbols, or operators.\n- Maps all arithmetic and logical operators into clear natural language equivalents: e.g., PLUS, MINUS, MULTIPLIED BY, DIVIDED BY, MODULO, EQUALS, NOT EQUALS, LESS THAN, GREATER THAN, AND, OR, NOT.\n- Represents data manipulation with uniform abstract verbs and phrases, e.g.: SET variable TO value, INCREMENT variable BY amount, APPEND item TO list, REMOVE first/last element FROM list.\n- Explicitly defines constructors and special methods using their exact original names.\n- Converts complex data structure initializations or helper routines outside or inside classes into auxiliary FUNCTIONs with original names, describing only essential abstract steps without concrete implementation or data structure syntax.\n- Omits all comments, explanatory notes, example explanations, and additional text\u2014output ONLY the pseudocode.\n- Avoids low-level programming details, language-specific idioms, literal syntax, or any variable type annotations.\n- Uses descriptive, concise terms consistently to maximize clarity and naturalness without sacrificing abstraction.\n- Includes all parameters in function signatures exactly as named, excluding any type hints or language-specific constructs.\n- For loops and conditionals, clearly reflect iteration over collections or ranges using natural language constructs like \"FOR each element IN collection\" or \"FOR index FROM start TO end\".\n- Presents all conditionals and expressions in fully spelled-out, readable form without symbolic shortcuts.\n\nExample style for functions:\n\nFUNCTION example_function(parameter_list)  \n    SET variable TO initial_value  \n    FOR each element IN parameter_list  \n        IF element GREATER THAN threshold THEN  \n            INCREMENT variable BY element  \n        ELSE  \n            SET variable TO variable MINUS element  \n        END IF  \n    END FOR  \n    RETURN variable  \nEND FUNCTION\n\nExample style for classes:\n\nCLASS ClassName  \n    FUNCTION __init__(self, param1, param2)  \n        SET self.param1 TO param1  \n        SET self.param2 TO param2  \n    END FUNCTION  \n\n    FUNCTION method_name(self, param)  \n        [method body at this level of abstraction]  \n    END FUNCTION  \nEND CLASS",
  "score": 1.8941756123004736,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import Optional\n\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        def helper(node, current_sum, prefix_sums):\n            if not node:\n                return 0\n            \n            # Update the current sum\n            current_sum += node.val\n            \n            # Number of times the (current_sum - targetSum) has occurred already\n            # This indicates the number of valid paths ending at the current node\n            paths_to_here = prefix_sums.get(current_sum - targetSum, 0)\n\nPseudocode for Problem 1:\nCLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS empty THEN  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with val SET TO first element of values  \n    SET i TO 1  \n    SET queue TO empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty DO  \n        SET node TO element removed from front of queue  \n        IF i LESS THAN length of values AND values at i IS NOT None THEN  \n            SET node.left TO new TreeNode with val SET TO values at i  \n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmppd1zycre/solution_0.py\", line 104, in <module>\\n    print(Solution().pathSum(root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8))\\n                                                 ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 2:\nfrom typing import List\n\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        n = len(nums)\n        f = [1] * n\n        k = 0\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    f[i] = max(f[i], f[j] + 1)\n            if f[k] < f[i]:\n                k = i\n        m = f[k]\n        i = k\n        ans = []\n        while m:\n            if nums[k] % nums[i] == 0 and f[i] == m:\n                ans.append(nums[i])\n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION largestDivisibleSubset(self, nums)  \n        CALL sort ON nums  \n        SET n TO length of nums  \n        SET f TO a list of length n with all elements SET TO 1  \n        SET k TO 0  \n        FOR i FROM 0 TO n MINUS 1  \n            FOR j FROM 0 TO i MINUS 1  \n                IF nums at i MODULO nums at j EQUALS 0 THEN  \n                    SET f at i TO the greater value BETWEEN f at i AND f at j PLUS 1  \n                END IF  \n            END FOR  \n            IF f at k LESS THAN f at i THEN  \n                SET k TO i  \n            END IF  \n        END FOR  \n        SET m TO f at k  \n        SET i TO k  \n        SET ans TO an empty list  \n        WHILE m GREATER THAN 0  \n\nError(s) from the decoded code for Problem 2:\n['Outputs do not match']\n\nOriginal Code for Problem 3:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        \n        # Recursively prune the left and right subtrees\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        \n        # If the current node is 0 and both subtrees are pruned (None), prune this node as well\n        if root.val == 0 and not root.left and not root.right:\n            return None\n        \n        return root\n\nPseudocode for Problem 3:\nCLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS empty THEN  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with val as first element of values  \n    SET i TO 1  \n    SET queue TO a new empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty DO  \n        SET node TO first element removed from queue  \n        IF i LESS THAN length of values AND element at index i of values IS NOT None THEN  \n            SET node.left TO new TreeNode with val as element at index i of values  \n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpwgbaowjq/solution_0.py\", line 96, in <module>\\n    print(Solution().pruneTree(root = [1,null,0,0,1]))\\n                                         ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nOriginal Code for Problem 4:\nfrom typing import List\n\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        # If total gas is less than total cost, it's impossible to complete the circuit\n        if sum(gas) < sum(cost):\n            return -1\n        \n        # Initialize variables\n        start = 0\n        total_tank = 0\n        \n        # Iterate over the gas stations\n        for i in range(len(gas)):\n            # Update the total tank with gas gained and cost spent at station i\n            total_tank += gas[i] - cost[i]\n            \n            # If total_tank is negative, we cannot reach the next station\n            if total_tank < 0:\n                # Start over from the next station\n\nPseudocode for Problem 4:\nCLASS Solution  \n    FUNCTION canCompleteCircuit(gas, cost)  \n        IF sum of gas LESS THAN sum of cost THEN  \n            RETURN negative one  \n        END IF  \n        \n        SET start TO zero  \n        SET total tank TO zero  \n        \n        FOR index FROM zero TO length of gas MINUS one  \n            SET total tank TO total tank PLUS gas at index MINUS cost at index  \n            \n            IF total tank LESS THAN zero THEN  \n                SET start TO index PLUS one  \n                SET total tank TO zero  \n            END IF  \n        END FOR  \n        \n        RETURN start  \n    END FUNCTION  \n\nError(s) from the decoded code for Problem 4:\n['Outputs do not match']\n\nOriginal Code for Problem 5:\nfrom typing import List\n\nclass Solution:\n    def bestRotation(self, nums: List[int]) -> int:\n        n = len(nums)\n        delta = [0] * n\n        \n        for i, num in enumerate(nums):\n            if num <= i:\n                # The element nums[i] will contribute to the score from rotation 0 to (i - num)\n                delta[0] += 1\n                if i - num + 1 < n:\n                    delta[i - num + 1] -= 1\n            # The element nums[i] will contribute to the score from rotation (i + 1) to (i + n - num)\n            if i + 1 < n:\n                delta[i + 1] += 1\n                if (i + n - num) + 1 < n:\n                    delta[(i + n - num) + 1] -= 1\n        \n        # Now, compute the cumulative scores for each rotation\n\nPseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION bestRotation(self, nums)  \n        SET n TO length of nums  \n        SET delta TO list of n zeros  \n        \n        FOR each index i and element num IN nums  \n            IF num LESS THAN OR EQUAL TO i THEN  \n                INCREMENT delta at position zero BY one  \n                IF i MINUS num PLUS one LESS THAN n THEN  \n                    DECREMENT delta at position (i MINUS num PLUS one) BY one  \n                END IF  \n            END IF  \n            \n            IF i PLUS one LESS THAN n THEN  \n                INCREMENT delta at position (i PLUS one) BY one  \n                IF i PLUS n MINUS num PLUS one LESS THAN n THEN  \n                    DECREMENT delta at position (i PLUS n MINUS num PLUS one) BY one  \n                END IF  \n            END IF  \n        END FOR  \n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmprbiwydzj/solution_3.py\", line 41, in <module>\\n    print(Solution().bestRotation(nums = [10, 20, 30, 40, 50, 0, 10, 20, 30, 40]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmprbiwydzj/solution_3.py\", line 32, in bestRotation\\n    delta[i + n - num + 1] -= 1\\n    ~~~~~^^^^^^^^^^^^^^^^^\\nIndexError: list index out of range\\n']\n\nOriginal Code for Problem 6:\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        n = len(nums) // 3\n        \n        # Min-heap to find the smallest n elements in the first 2n elements\n        min_heap = []\n        min_sums = [0] * (2 * n + 1)\n        \n        for i in range(2 * n):\n            heapq.heappush(min_heap, -nums[i])\n            if len(min_heap) > n:\n                heapq.heappop(min_heap)\n            if len(min_heap) == n:\n                min_sums[i] = -sum(min_heap)\n        \n        # Max-heap to find the largest n elements in the last 2n elements\n        max_heap = []\n\nPseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION minimumDifference(self, nums)  \n        SET n TO the length of nums DIVIDED BY three  \n        \n        SET min_heap TO an empty list  \n        SET min_sums TO a list of zeros with length equal to two MULTIPLIED BY n PLUS one  \n        \n        FOR i FROM zero TO two MULTIPLIED BY n MINUS one  \n            ADD the negation of nums at index i TO min_heap using heap addition  \n            IF the length of min_heap GREATER THAN n THEN  \n                REMOVE the smallest element FROM min_heap using heap removal  \n            END IF  \n            IF the length of min_heap EQUALS n THEN  \n                SET min_sums at index i TO the negation of the sum of elements in min_heap  \n            END IF  \n        END FOR  \n        \n        SET max_heap TO an empty list  \n        SET max_sums TO a list of zeros with length equal to two MULTIPLIED BY n PLUS one  \n        \n\nError(s) from the decoded code for Problem 6:\n['Outputs do not match']\n\nOriginal Code for Problem 7:\nclass Solution:\n    def parseTernary(self, expression: str) -> str:\n        def evaluate(index):\n            # Base case: if the current character is a digit or 'T'/'F', return it\n            if index == len(expression) - 1 or expression[index + 1] == ':':\n                return expression[index], index + 2\n            \n            # Determine the true and false parts of the ternary expression\n            true_part, next_index = evaluate(index + 2)\n            false_part, final_index = evaluate(next_index)\n            \n            # Evaluate the current ternary expression\n            if expression[index] == 'T':\n                return true_part, final_index\n            else:\n                return false_part, final_index\n        \n        result, _ = evaluate(0)\n        return result\n\n\nPseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION parseTernary(self, expression)  \n        FUNCTION evaluate(index)  \n            IF index EQUALS length of expression MINUS one OR character at expression position index PLUS one EQUALS colon THEN  \n                RETURN character at expression position index, index PLUS two  \n            END IF  \n          \n            SET true_part, next_index TO result of calling evaluate with index PLUS two  \n            SET false_part, final_index TO result of calling evaluate with next_index  \n          \n            IF character at expression position index EQUALS 'T' THEN  \n                RETURN true_part, final_index  \n            ELSE  \n                RETURN false_part, final_index  \n            END IF  \n        END FUNCTION  \n      \n        SET result, unused_variable TO result of calling evaluate with zero  \n        RETURN result  \n    END FUNCTION  \n\nError(s) from the decoded code for Problem 7:\n['Outputs do not match']\n\nOriginal Code for Problem 8:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nfrom typing import List, Optional\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        \n        right_side_view = []\n        queue = deque([root])\n        \n        while queue:\n            level_length = len(queue)\n            for i in range(level_length):\n\nPseudocode for Problem 8:\nCLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS empty THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode initialized with the first element of values  \n    SET i TO 1  \n    SET queue TO an empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty DO  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN length of values AND values at i IS NOT None THEN  \n            SET node.left TO a new TreeNode initialized with values at i  \n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp4wpcymaz/solution_0.py\", line 106, in <module>\\n    print(Solution().rightSideView(root = [1,2,3,null,5,null,4]))\\n                                                 ^^^^\\nNameError: name \\'null\\' is not defined\\n']\nScore of (4*(Average syllables per word) + passing rate) for ALL the problems: 1.8941756123004736"
}