CLASS Solution  
    FUNCTION minimumIncompatibility(self, nums, k)  
        FROM collections IMPORT Counter  
        
        SET n TO length of nums  
        SET subset_size TO n DIVIDED BY k  
        
        IF any element count IN Counter(nums).values() GREATER THAN k THEN  
            RETURN negative one  
        END IF  
        
        SET subset_incompatibility TO empty mapping  
        FOR mask FROM zero TO two RAISED TO n MINUS one  
            IF count of bits SET to one IN binary representation of mask EQUALS subset_size THEN  
                SET elements TO list of nums at indices i WHERE bit i OF mask IS set  
                IF number of unique elements IN elements EQUALS subset_size THEN  
                    SET incompatibility TO maximum element IN elements MINUS minimum element IN elements  
                    SET subset_incompatibility at key mask TO incompatibility  
                END IF  
            END IF  
        END FOR  
        
        SET dp TO list of size two RAISED TO n FILLED WITH infinity  
        SET dp at zero TO zero  
        
        FOR mask FROM zero TO two RAISED TO n MINUS one  
            IF count of bits set to one IN binary representation of mask MODULO subset_size NOT EQUALS zero THEN  
                CONTINUE to next iteration  
            END IF  
            FOR each subset_mask IN keys of subset_incompatibility  
                IF bitwise AND of mask AND subset_mask EQUALS subset_mask THEN  
                    SET dp at mask TO minimum of dp at mask AND dp at bitwise XOR of mask AND subset_mask PLUS subset_incompatibility at subset_mask  
                END IF  
            END FOR  
        END FOR  
        
        IF dp at two RAISED TO n MINUS one EQUALS infinity THEN  
            RETURN negative one  
        ELSE  
            RETURN dp at two RAISED TO n MINUS one  
        END IF  
    END FUNCTION  
END CLASS