CLASS Solution  
    FUNCTION canMouseWin(self, grid, catJump, mouseJump)  
        SET m TO length of grid  
        SET n TO length of first element of grid  
        SET cat_start TO zero  
        SET mouse_start TO zero  
        SET food TO zero  
        SET dirs TO list of elements negative one, zero, one, zero, negative one  
        SET g_mouse TO list containing empty lists repeated m multiplied by n times  
        SET g_cat TO list containing empty lists repeated m multiplied by n times  

        FOR each i and row IN enumeration of grid  
            FOR each j and c IN enumeration of row  
                IF c EQUALS "#" THEN  
                    CONTINUE to next iteration  
                END IF  
                SET v TO i multiplied by n PLUS j  
                IF c EQUALS "C" THEN  
                    SET cat_start TO v  
                ELSE IF c EQUALS "M" THEN  
                    SET mouse_start TO v  
                ELSE IF c EQUALS "F" THEN  
                    SET food TO v  
                END IF  
                FOR each pair a and b IN successive pairs of dirs  
                    FOR k FROM zero TO mouseJump INCLUSIVE  
                        SET x TO i PLUS k multiplied by a  
                        SET y TO j PLUS k multiplied by b  
                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR grid at position x and y EQUALS "#" THEN  
                            BREAK inner loop over k  
                        END IF  
                        APPEND x multiplied by n PLUS y TO g_mouse at index v  
                    END FOR  
                    FOR k FROM zero TO catJump INCLUSIVE  
                        SET x TO i PLUS k multiplied by a  
                        SET y TO j PLUS k multiplied by b  
                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR grid at position x and y EQUALS "#" THEN  
                            BREAK inner loop over k  
                        END IF  
                        APPEND x multiplied by n PLUS y TO g_cat at index v  
                    END FOR  
                END FOR  
            END FOR  
        END FOR  
        RETURN result of self dot calc called with g_mouse, g_cat, mouse_start, cat_start, and food EQUALS to one  
    END FUNCTION  

    FUNCTION calc(self, g_mouse, g_cat, mouse_start, cat_start, hole)  
        FUNCTION get_prev_states(state)  
            SET m TO first element of state  
            SET c TO second element of state  
            SET t TO third element of state  
            SET pt TO t XOR one  
            SET pre TO empty list  
            IF pt EQUALS one THEN  
                FOR each pc IN g_cat at index c  
                    IF ans at index m, pc, and one EQUALS zero THEN  
                        APPEND tuple of m, pc, and pt TO pre  
                    END IF  
                END FOR  
            ELSE  
                FOR each pm IN g_mouse at index m  
                    IF ans at index pm, c, and zero EQUALS zero THEN  
                        APPEND tuple of pm, c, and zero TO pre  
                    END IF  
                END FOR  
            END IF  
            RETURN pre  
        END FUNCTION  

        SET n TO length of g_mouse  
        SET degree TO list containing lists containing lists with zero and zero repeated n times, repeated n times, repeated n times  
        FOR i FROM zero TO n MINUS one  
            FOR j FROM zero TO n MINUS one  
                SET degree at index i, j, and zero TO length of g_mouse at index i  
                SET degree at index i, j, and one TO length of g_cat at index j  
            END FOR  
        END FOR  

        SET ans TO list containing lists containing lists with zero and zero repeated n times, repeated n times  
        SET q TO empty double ended queue  
        FOR i FROM zero TO n MINUS one  
            SET ans at index hole, i, and one TO one  
            SET ans at index i, hole, and zero TO two  
            SET ans at index i, i, and one TO two  
            SET ans at index i, i, and zero TO two  
            APPEND tuple of hole, i, and one TO q  
            APPEND tuple of i, hole, and zero TO q  
            APPEND tuple of i, i, and zero TO q  
            APPEND tuple of i, i, and one TO q  
        END FOR  
        WHILE q is not empty  
            REMOVE first element FROM q AND SET TO state  
            SET t TO ans at index first element of state, second element of state, and third element of state  
            FOR each prev_state IN result of get_prev_states called with state  
                SET pm TO first element of prev_state  
                SET pc TO second element of prev_state  
                SET pt TO third element of prev_state  
                IF pt EQUALS t MINUS one THEN  
                    SET ans at index pm, pc, and pt TO t  
                    APPEND prev_state TO q  
                ELSE  
                    DECREMENT degree at index pm, pc, and pt BY one  
                    IF degree at index pm, pc, and pt EQUALS zero THEN  
                        SET ans at index pm, pc, and pt TO t  
                        APPEND prev_state TO q  
                    END IF  
                END IF  
            END FOR  
        END WHILE  
        RETURN ans at index mouse_start, cat_start, and zero  
    END FUNCTION  
END CLASS