from collections import defaultdict
from typing import List, Dict, Set

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        adj_list: Dict[int, List[int]] = defaultdict(list)

        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    adj_list[i].append(j)
                    adj_list[j].append(i)

        def dfs(node: int, visited: Set[int]) -> int:
            if node in visited:
                return 0
            visited.add(node)
            size = 1
            for neighbor in adj_list[node]:
                size += dfs(neighbor, visited)
            return size

        infected = set(initial)
        component_sizes: List[int] = []
        visited: Set[int] = set()
        component_index: Dict[int, int] = {}

        for node in range(n):
            if node not in visited and node not in infected:
                size = dfs(node, visited)
                component_sizes.append(size)
                i = len(component_sizes) - 1
                # mark all nodes in this component with the component index
                # we do this by a DFS again or by iterating neighbors of node?
                # The pseudocode wants a loop that breaks when component_sizes[i] == size,
                # we already have i at the last appended index
                # assign component_index for all neighbors in adj_list[node]
                # but this only assigns immediate neighbors, we need to assign all nodes in the component
                # The pseudocode is ambiguous here, but likely intends assigning component_index for all nodes in the component.
                # So we need to do a DFS or BFS to assign component_index for all nodes in this component.
                # Since dfs above already visited nodes in visited, we can figure out component nodes by difference.
                # But we can do a separate DFS to assign component_index for nodes in component.

                # Let's assign component_index to all nodes in this component:
                stack = [node]
                while stack:
                    curr = stack.pop()
                    if curr in component_index:
                        continue
                    component_index[curr] = i
                    for nei in adj_list[curr]:
                        if nei not in component_index and nei not in infected:
                            stack.append(nei)

        infected_in_component: Dict[int, int] = defaultdict(int)
        for node in infected:
            if node in component_index:
                infected_in_component[component_index[node]] += 1

        max_size = 0
        node_to_remove = min(initial)

        for node in infected:
            if node in component_index:
                comp_idx = component_index[node]
                if infected_in_component[comp_idx] == 1:
                    if component_sizes[comp_idx] > max_size:
                        max_size = component_sizes[comp_idx]
                        node_to_remove = node
                    elif component_sizes[comp_idx] == max_size:
                        node_to_remove = min(node_to_remove, node)

        return node_to_remove