CLASS Solution  
    FUNCTION minimumIncompatibility(nums k)  
        SET n TO the LENGTH OF nums  
        SET subset_size TO n DIVIDED BY k  
        
        FUNCTION has_any_number_appearing_more_than_k TIMES(numbers times)  
            CREATE a mapping from numbers to their counts named counts  
            FOR each number IN numbers  
                IF number EXISTS in counts  
                    INCREMENT the count of number BY one  
                ELSE  
                    SET the count of number TO one  
                END IF  
            END FOR  
            FOR each count IN the values of counts  
                IF count IS GREATER THAN times  
                    RETURN true  
                END IF  
            END FOR  
            RETURN false  
        END FUNCTION  
        
        IF has_any_number_appearing_more_than_k TIMES with nums and k IS true  
            RETURN negative one  
        END IF  
        
        CREATE an empty mapping named subset_incompatibility  
        
        FUNCTION count_set_bits_of_integer(number)  
            SET count TO zero  
            WHILE number IS GREATER THAN zero  
                INCREMENT count BY number MODULO two  
                SET number TO number DIVIDED BY two (integer division)  
            END WHILE  
            RETURN count  
        END FUNCTION  
        
        FUNCTION elements_in_mask(mask_array full_list)  
            CREATE an empty list named extracted_elements  
            FOR index FROM zero TO n MINUS one  
                IF the element at position index of mask_array IS one  
                    APPEND the element at position index of full_list TO extracted_elements  
                END IF  
            END FOR  
            RETURN extracted_elements  
        END FUNCTION  
        
        FUNCTION mask_to_array(mask length)  
            CREATE an empty list named bits_array  
            FOR position FROM zero TO length MINUS one  
                SET bit_value TO (mask DIVIDED BY two RAISED TO THE POWER OF position) MODULO two  
                APPEND bit_value TO bits_array  
            END FOR  
            RETURN bits_array  
        END FUNCTION  
        
        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  
            SET bit_count TO count_set_bits_of_integer with mask  
            IF bit_count EQUALS subset_size  
                SET mask_array TO mask_to_array with mask AND n  
                SET elements TO elements_in_mask with mask_array AND nums  
                CREATE a mapping named element_uniqueness_checker  
                FOR each element IN elements  
                    IF element EXISTS in element_uniqueness_checker  
                        SET element_uniqueness_checker element TO element_uniqueness_checker element PLUS one  
                    ELSE  
                        SET element_uniqueness_checker element TO one  
                    END IF  
                END FOR  
                SET all_unique TO true  
                FOR each count IN the values of element_uniqueness_checker  
                    IF count IS GREATER THAN one  
                        SET all_unique TO false  
                        BREAK  
                    END IF  
                END FOR  
                IF all_unique IS true  
                    SET maximum_element TO the element at position zero of elements  
                    SET minimum_element TO the element at position zero of elements  
                    FOR each element IN elements  
                        IF element IS GREATER THAN maximum_element  
                            SET maximum_element TO element  
                        END IF  
                        IF element IS LESS THAN minimum_element  
                            SET minimum_element TO element  
                        END IF  
                    END FOR  
                    SET incompatibility_value TO maximum_element MINUS minimum_element  
                    ASSIGN incompatibility_value TO subset_incompatibility at key mask  
                END IF  
            END IF  
        END FOR  
        
        CREATE a list named dp of length two RAISED TO THE POWER OF n FILLED WITH positive infinity  
        SET the element at position zero of dp TO zero  
        
        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  
            SET bit_count TO count_set_bits_of_integer with mask  
            IF bit_count MODULO subset_size DOES NOT EQUAL zero  
                CONTINUE to next iteration  
            END IF  
            FOR each subset_mask IN the keys of subset_incompatibility  
                IF (bitwise AND of mask and subset_mask) EQUALS subset_mask  
                    SET current_value TO the element at position mask of dp  
                    SET candidate_value TO the element at position (bitwise XOR of mask and subset_mask) of dp PLUS the value at key subset_mask of subset_incompatibility  
                    IF candidate_value IS LESS THAN current_value  
                        SET the element at position mask of dp TO candidate_value  
                    END IF  
                END IF  
            END FOR  
        END FOR  
        
        SET final_mask TO two RAISED TO THE POWER OF n MINUS one  
        IF the element at position final_mask of dp IS EQUAL TO positive infinity  
            RETURN negative one  
        ELSE  
            RETURN the element at position final_mask of dp  
        END IF  
    END FUNCTION  
END CLASS