{
  "prompt": "Translate the following pseudocode into efficient and clean Python code. Ensure the entire code output is enclosed within a Python code block using triple backticks, like this:\n\n```python\n# your translated code here\n```\n\nFocus on clarity, correctness, and optimizing for execution within a 5-second runtime limit. Do not include any explanation or comments unrelated to the implementation unless they help clarify complex parts of the code.",
  "response": "Translate the following pseudocode into efficient and clean Python code. Ensure the entire code output is enclosed within a Python code block using triple backticks, like this:\n\n```python\n# your translated code here\n```\n\nFocus on clarity, correctness, and optimizing for execution within a 5-second runtime limit. Do not include any explanation or comments unrelated to the implementation unless they help clarify complex parts of the code.",
  "score": 0.8945532698658814,
  "feedback": "The following are 20 lines of pseudocode of a random subset of the problems along with their decoded codes.\n\nPseudocode for Problem 1:\nCLASS TreeNode\n    FUNCTION __init__(val = 0, left = None, right = None)\n        SET self.val TO val\n        SET self.left TO left\n        SET self.right TO right\n    END FUNCTION\nEND CLASS\n\nFUNCTION tree_node(values: list)\n    IF values IS EMPTY\n        RETURN None\n    SET root TO new TreeNode WITH val values[0]\n    SET i TO 1\n    INITIALIZE queue AS empty deque\n    APPEND root TO queue\n    WHILE queue IS NOT EMPTY\n        SET node TO queue.popleft()\n        IF i LESS THAN LENGTH OF values AND values[i] IS NOT None\n            SET node.left TO new TreeNode WITH val values[i]\n            APPEND node.left TO queue\n\nDecoded code for Problem 1:\nfrom collections import deque\nfrom math import inf\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list) -> Optional[TreeNode]:\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque([root])\n    while queue and i < len(values):\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmplt4fgyrz/solution_0.py\", line 111, in <module>\\n    print(Solution().maxSumBST(root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]))\\n                                                     ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nPseudocode for Problem 2:\nCLASS TreeNode\n    FUNCTION __init__(val = 0, left = None, right = None)\n        SET self.val TO val\n        SET self.left TO left\n        SET self.right TO right\n    END FUNCTION\nEND CLASS\n\nFUNCTION tree_node(values: list)\n    IF values IS EMPTY\n        RETURN None\n    SET root TO TreeNode(values[0])\n    SET i TO 1\n    CREATE queue AS empty deque\n    APPEND root TO queue\n    WHILE queue IS NOT EMPTY\n        SET node TO REMOVE FIRST ELEMENT FROM queue\n        IF i < LENGTH OF values AND values[i] IS NOT None\n            SET node.left TO TreeNode(values[i])\n            APPEND node.left TO queue\n\nDecoded code for Problem 2:\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    queue = deque([root])\n    i = 1\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp55p6l1q7/solution_0.py\", line 100, in <module>\\n    print(Solution().rob(root = [3,2,3,null,3,null,1]))\\n                                       ^^^^\\nNameError: name \\'null\\' is not defined\\n']\n\nPseudocode for Problem 3:\nCLASS ListNode\n    FUNCTION __init__(val = 0, next = None)\n        SET self.val TO val\n        SET self.next TO next\n    END FUNCTION\nEND CLASS\n\nFUNCTION list_node(values: list)\n    IF values IS EMPTY\n        RETURN None\n    END IF\n    SET head TO ListNode(values[0])\n    SET p TO head\n    FOR each val IN values FROM SECOND ELEMENT TO END\n        SET node TO ListNode(val)\n        SET p.next TO node\n        SET p TO node\n    END FOR\n    RETURN head\nEND FUNCTION\n\nDecoded code for Problem 3:\nfrom typing import Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list) -> Optional[ListNode]:\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1: Optional[ListNode], p2: Optional[ListNode]) -> bool:\n    if p1 is None and p2 is None:\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpqjt5zsvi/solution_0.py\", line 88, in <module>\\n    print(Solution().addTwoNumbers(l1 = [2,4,3], l2 = [5,6,4]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpqjt5zsvi/solution_0.py\", line 74, in addTwoNumbers\\n    val1 = l1.val if l1 else 0\\n           ^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'val\\'\\n']\n\nPseudocode for Problem 4:\nCLASS TreeNode\n    FUNCTION __init__(self, val = 0, left = None, right = None)\n        SET self.val TO val\n        SET self.left TO left\n        SET self.right TO right\n    END FUNCTION\nEND CLASS\n\nFUNCTION tree_node(values: list)\n    IF values IS EMPTY\n        RETURN None\n    SET root TO TreeNode(values[0])\n    SET i TO 1\n    SET queue TO empty double-ended queue\n    APPEND root TO queue\n    WHILE queue IS NOT EMPTY\n        SET node TO REMOVE FIRST ELEMENT FROM queue\n        IF i < LENGTH OF values AND values[i] IS NOT None\n            SET node.left TO TreeNode(values[i])\n            APPEND node.left TO queue\n\nDecoded code for Problem 4:\nfrom collections import deque\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list) -> Optional[TreeNode]:\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpwojhpiuz/solution_0.py\", line 104, in <module>\\n    print(Solution().addOneRow(root = [4,2,6,3,1,5], val = 1, depth = 2))\\n          ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpwojhpiuz/solution_0.py\", line 96, in addOneRow\\n    node.left = TreeNode(val, left=node.left)\\n                                   ^^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'left\\'\\n']\n\nPseudocode for Problem 5:\nCLASS Solution\n    FUNCTION uniqueLetterString(s)\n        SET MOD TO 1000000007\n        SET n TO LENGTH OF s\n\n        SET last TO LIST OF 26 ELEMENTS ALL -1\n        SET last2 TO LIST OF 26 ELEMENTS ALL -1\n\n        SET result TO 0\n\n        FOR i FROM 0 TO n - 1\n            SET char TO s[i]\n            SET idx TO ASCII VALUE OF char MINUS ASCII VALUE OF 'A'\n\n            SET contribution TO (i MINUS last[idx]) MULTIPLIED BY (last[idx] MINUS last2[idx])\n            SET result TO (result PLUS contribution) MODULO MOD\n\n            SET last2[idx] TO last[idx]\n            SET last[idx] TO i\n\n\nDecoded code for Problem 5:\nclass Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n\n        last = [-1] * 26\n        last2 = [-1] * 26\n\n        result = 0\n\n        for i, char in enumerate(s):\n            idx = ord(char) - ord('A')\n\n            contribution = (i - last[idx]) * (last[idx] - last2[idx])\n            result = (result + contribution) % MOD\n\n            last2[idx] = last[idx]\n            last[idx] = i\n\n        for i in range(26):\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpf_rdcvfk/solution_2.py\", line 43, in <module>\\n    print(Solution().uniqueLetterString(s = \"AaBbCc\"))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpf_rdcvfk/solution_2.py\", line 32, in uniqueLetterString\\n    contribution = (i - last[idx]) * (last[idx] - last2[idx])\\n                        ~~~~^^^^^\\nIndexError: list index out of range\\n']\n\nPseudocode for Problem 6:\nCLASS ListNode\n    FUNCTION __init__(self, val = 0, next = None)\n        SET self.val TO val\n        SET self.next TO next\n    END FUNCTION\nEND CLASS\n\nFUNCTION list_node(values: list)\n    IF values IS EMPTY\n        RETURN None\n    SET head TO ListNode(values[0])\n    SET p TO head\n    FOR each val IN values FROM SECOND ELEMENT TO END\n        SET node TO ListNode(val)\n        SET p.next TO node\n        SET p TO node\n    RETURN head\nEND FUNCTION\n\nFUNCTION is_same_list(p1, p2)\n\nDecoded code for Problem 6:\nfrom typing import Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list) -> Optional[ListNode]:\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1: Optional[ListNode], p2: Optional[ListNode]) -> bool:\n    if p1 is None and p2 is None:\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpqox2485c/solution_0.py\", line 92, in <module>\\n    print(Solution().addTwoNumbers(l1 = [7,2,4,3], l2 = [5,6,4]))\\n          ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpqox2485c/solution_0.py\", line 77, in addTwoNumbers\\n    stack1 = pushIntoStack(l1)\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpqox2485c/solution_0.py\", line 73, in pushIntoStack\\n    stack.append(node.val)\\n                 ^^^^^^^^\\nAttributeError: \\'list\\' object has no attribute \\'val\\'\\n']\n\nPseudocode for Problem 7:\nCLASS Solution\n    FUNCTION openLock(deadends: List of String, target: String) RETURNS Integer\n        SET deadends_set TO CONVERT deadends INTO SET\n        IF \"0000\" IN deadends_set THEN\n            RETURN -1\n        END IF\n        IF target EQUALS \"0000\" THEN\n            RETURN 0\n        END IF\n        SET queue TO NEW deque WITH ELEMENT (\"0000\", 0)\n        SET visited TO SET CONTAINING \"0000\"\n        FUNCTION neighbors(state: String) RETURNS List of String\n            SET result TO EMPTY LIST\n            FOR i FROM 0 TO 3\n                SET digit TO INTEGER VALUE OF state AT POSITION i\n                FOR move IN [-1, 1]\n                    SET new_digit TO (digit + move) MODULO 10\n                    SET new_state TO CONCATENATE state UP TO i, STRING OF new_digit, AND state AFTER i+1\n                    APPEND new_state TO result\n                END FOR\n\nDecoded code for Problem 7:\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        deadends_set = set(deadends)\n        if \"0000\" in deadends_set:\n            return -1\n        if target == \"0000\":\n            return 0\n\n        def neighbors(state):\n            res = []\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    res.append(new_state)\n            return res\n\n\nError(s) from the decoded code for Problem 7:\n['Outputs do not match']\n\nPseudocode for Problem 8:\n```\nCLASS Solution\n    FUNCTION ways(pizza, k)\n        SET mod TO 1000000007\n        SET m TO LENGTH OF pizza\n        SET n TO LENGTH OF pizza[0]\n        INITIALIZE s AS 2D LIST WITH DIMENSIONS (m + 1) BY (n + 1) FILLED WITH 0\n\n        FOR i FROM 1 TO m\n            FOR j FROM 1 TO n\n                SET s[i][j] TO s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + (1 IF pizza[i - 1][j - 1] EQUALS 'A' ELSE 0)\n\n        FUNCTION dfs(i, j, k) WITH CACHE\n            IF k EQUALS 0 THEN\n                RETURN 1 IF s[m][n] - s[i][n] - s[m][j] + s[i][j] GREATER THAN 0 ELSE 0\n\n            SET ans TO 0\n            FOR x FROM i + 1 TO m - 1\n                IF s[x][n] - s[i][n] - s[x][j] + s[i][j] GREATER THAN 0 THEN\n                    SET ans TO ans + dfs(x, j, k - 1)\n\nDecoded code for Problem 8:\nfrom functools import cache\n\nclass Solution:\n    def ways(self, pizza: list[str], k: int) -> int:\n        mod = 10**9 + 7\n        m, n = len(pizza), len(pizza[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + (1 if pizza[i - 1][j - 1] == 'A' else 0)\n\n        @cache\n        def dfs(i: int, j: int, cuts_left: int) -> int:\n            if cuts_left == 0:\n                return 1 if s[m][n] - s[i][n] - s[m][j] + s[i][j] > 0 else 0\n\n            ans = 0\n            for x in range(i + 1, m):\n                if s[x][n] - s[i][n] - s[x][j] + s[i][j] > 0:\n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp_uyqo_v/solution_27.py\", line 46, in <module>\\n    print(Solution().ways(pizza = [\"...\",\"...\",\"...\",\"...\",\".\"], k = 1))\\n          ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp_uyqo_v/solution_27.py\", line 29, in ways\\n    s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + (1 if pizza[i - 1][j - 1] == \\'A\\' else 0)\\n                                                                  ~~~~~~~~~~~~^^^^^^^\\nIndexError: string index out of range\\n']\nAvg Passing Rate for ALL the problems: 0.8945532698658814"
}