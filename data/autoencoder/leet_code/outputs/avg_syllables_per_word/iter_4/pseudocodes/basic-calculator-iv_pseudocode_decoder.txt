```
CLASS Term
    FUNCTION __init__(self, coefficient, variables)
        SET self.coefficient TO coefficient
        SET self.variables TO variables
    END FUNCTION

    FUNCTION __lt__(self, other)
        IF LENGTH OF self.variables NOT EQUAL TO LENGTH OF other.variables THEN
            RETURN LENGTH OF self.variables GREATER THAN LENGTH OF other.variables
        RETURN JOIN self.variables WITH '*' LESS THAN JOIN other.variables WITH '*'
    END FUNCTION

    FUNCTION __repr__(self)
        IF self.variables IS EMPTY THEN
            RETURN STRING OF self.coefficient
        RETURN STRING OF self.coefficient CONCATENATED WITH '*' CONCATENATED WITH JOIN self.variables WITH '*'
    END FUNCTION
END CLASS

CLASS Expression
    FUNCTION __init__(self)
        SET self.terms TO DEFAULTDICT OF INT
    END FUNCTION

    FUNCTION add_term(self, term)
        SET key TO SORTED TUPLE OF term.variables
        INCREMENT self.terms[key] BY term.coefficient
    END FUNCTION

    FUNCTION multiply(self, other)
        SET result TO NEW Expression
        FOR EACH vars1, coeff1 IN self.terms
            FOR EACH vars2, coeff2 IN other.terms
                SET combined_vars TO SORTED LIST OF vars1 CONCATENATED WITH vars2
                CALL result.add_term WITH NEW Term(coeff1 TIMES coeff2, combined_vars)
        RETURN result
    END FUNCTION

    FUNCTION add(self, other)
        FOR EACH vars, coeff IN other.terms
            CALL self.add_term WITH NEW Term(coeff, LIST OF vars)
        RETURN self
    END FUNCTION

    FUNCTION subtract(self, other)
        FOR EACH vars, coeff IN other.terms
            CALL self.add_term WITH NEW Term(NEGATIVE coeff, LIST OF vars)
        RETURN self
    END FUNCTION

    FUNCTION evaluate(self, var_map)
        SET result TO NEW Expression
        FOR EACH vars, coeff IN self.terms
            SET new_vars TO EMPTY LIST
            FOR EACH var IN vars
                IF var IN var_map THEN
                    APPEND STRING OF var_map[var] TO new_vars
                ELSE
                    APPEND var TO new_vars
            IF new_vars IS NOT EMPTY THEN
                SET new_coeff TO EVALUATE CONCATENATION OF new_vars
            ELSE
                SET new_coeff TO 1
            CALL result.add_term WITH NEW Term(coeff TIMES new_coeff, EMPTY LIST)
        RETURN result
    END FUNCTION

    FUNCTION simplify(self)
        SET simplified_terms TO EMPTY LIST
        FOR EACH vars, coeff IN self.terms
            IF coeff NOT EQUAL TO 0 THEN
                APPEND NEW Term(coeff, LIST OF vars) TO simplified_terms
        SORT simplified_terms USING Term.__lt__
        RETURN simplified_terms
    END FUNCTION

    FUNCTION __repr__(self)
        RETURN JOIN MAP OF __repr__ OVER self.simplify() WITH ' + '
    END FUNCTION
END CLASS

CLASS Solution
    FUNCTION basicCalculatorIV(self, expression, evalvars, evalints)
        SET var_map TO DICTIONARY ZIPPING evalvars WITH evalints
        SET tokens TO REGEX FIND ALL TOKENS OF '(', ')', '+', '-', '*', DIGITS, OR WORDS IN expression
        SET output TO EMPTY LIST
        SET operators TO EMPTY LIST

        FUNCTION apply_operator()
            SET right TO POP FROM output
            SET left TO POP FROM output
            SET op TO POP FROM operators
            IF op EQUALS '+' THEN
                APPEND left.add(right) TO output
            ELSE IF op EQUALS '-' THEN
                APPEND left.subtract(right) TO output
            ELSE IF op EQUALS '*' THEN
                APPEND left.multiply(right) TO output
        END FUNCTION

        SET i TO 0
        WHILE i LESS THAN LENGTH OF tokens
            SET token TO tokens[i]
            IF token IS DIGIT THEN
                APPEND NEW Expression TO output
                CALL output[-1].add_term WITH NEW Term(INTEGER OF token, EMPTY LIST)
            ELSE IF token IS ALPHABETIC THEN
                APPEND NEW Expression TO output
                SET coef TO var_map GET token DEFAULT 1
                IF coef EQUALS 1 THEN
                    IF token NOT IN var_map THEN
                        CALL output[-1].add_term WITH NEW Term(1, LIST CONTAINING token)
                    ELSE
                        CALL output[-1].add_term WITH NEW Term(1, EMPTY LIST)
                ELSE
                    CALL output[-1].add_term WITH NEW Term(coef, EMPTY LIST)
            ELSE IF token EQUALS '(' THEN
                APPEND token TO operators
            ELSE IF token EQUALS ')' THEN
                WHILE operators IS NOT EMPTY AND OPERATORS[-1] NOT EQUAL '('
                    CALL apply_operator()
                POP FROM operators  # Remove '('
            ELSE IF token IN '+-*' THEN
                WHILE operators IS NOT EMPTY AND operators[-1] NOT EQUAL '(' AND (token IN '+-' OR operators[-1] EQUALS '*')
                    CALL apply_operator()
                APPEND token TO operators
            INCREMENT i BY 1

        WHILE operators IS NOT EMPTY
            CALL apply_operator()

        SET simplified_terms TO output[0].simplify()
        RETURN LIST COMPRISING FOR EACH term IN simplified_terms:  
            IF term.variables IS NOT EMPTY THEN  
                STRING OF term.coefficient CONCATENATED WITH '*' CONCATENATED WITH JOIN term.variables WITH '*'  
            ELSE  
                STRING OF term.coefficient
    END FUNCTION
END CLASS
```