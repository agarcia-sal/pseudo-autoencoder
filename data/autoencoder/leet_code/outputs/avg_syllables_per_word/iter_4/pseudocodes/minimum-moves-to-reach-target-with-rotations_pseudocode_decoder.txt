```
CLASS Solution
    FUNCTION minimumMoves(grid)
        SET n TO LENGTH OF grid
        INITIALIZE queue WITH (0, 0, 0, 1, 0)  // tail row, tail column, head row, head column, steps
        INITIALIZE visited WITH (0, 0, 0, 1)

        WHILE queue IS NOT EMPTY
            REMOVE FIRST ELEMENT FROM queue INTO (r1, c1, r2, c2, steps)

            IF (r1, c1, r2, c2) EQUALS (n - 1, n - 2, n - 1, n - 1)
                RETURN steps

            // Move right
            IF c2 + 1 IS LESS THAN n AND grid[r1][c1 + 1] IS 0 AND grid[r2][c2 + 1] IS 0 AND (r1, c1 + 1, r2, c2 + 1) NOT IN visited
                ADD (r1, c1 + 1, r2, c2 + 1) TO visited
                APPEND (r1, c1 + 1, r2, c2 + 1, steps + 1) TO queue

            // Move down
            IF r2 + 1 IS LESS THAN n AND grid[r1 + 1][c1] IS 0 AND grid[r2 + 1][c2] IS 0 AND (r1 + 1, c1, r2 + 1, c2) NOT IN visited
                ADD (r1 + 1, c1, r2 + 1, c2) TO visited
                APPEND (r1 + 1, c1, r2 + 1, c2, steps + 1) TO queue

            // Rotate clockwise
            IF r1 EQUALS r2 AND r1 + 1 IS LESS THAN n AND grid[r1 + 1][c1] IS 0 AND grid[r1 + 1][c2] IS 0 AND (r1, c1, r1 + 1, c1) NOT IN visited
                ADD (r1, c1, r1 + 1, c1) TO visited
                APPEND (r1, c1, r1 + 1, c1, steps + 1) TO queue

            // Rotate counterclockwise
            IF c1 EQUALS c2 AND c1 + 1 IS LESS THAN n AND grid[r1][c1 + 1] IS 0 AND grid[r2][c2 + 1] IS 0 AND (r1, c1, r1, c1 + 1) NOT IN visited
                ADD (r1, c1, r1, c1 + 1) TO visited
                APPEND (r1, c1, r1, c1 + 1, steps + 1) TO queue

        RETURN -1
    END FUNCTION
END CLASS
```