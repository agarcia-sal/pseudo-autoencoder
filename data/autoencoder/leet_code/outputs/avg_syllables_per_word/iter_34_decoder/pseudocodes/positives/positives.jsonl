{"task_id": "longest-substring-without-repeating-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLongestSubstring WITH PARAMETER s  \n        SET char_index_map TO an empty mapping from character to index  \n        SET max_length TO zero  \n        SET start TO zero  \n        \n        FOR each position end AND character char IN the enumeration of s  \n            IF char_index_map CONTAINS char AND the value at char in char_index_map IS GREATER THAN OR EQUAL TO start THEN  \n                SET start TO the value at char in char_index_map PLUS one  \n            END IF  \n            SET the value at char in char_index_map TO end  \n            SET max_length TO the greater value BETWEEN max_length AND end MINUS start PLUS one  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "median-of-two-sorted-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMedianSortedArrays(nums1 nums2)  \n        IF the LENGTH OF nums1 GREATER THAN the LENGTH OF nums2 THEN  \n            SET temporary variable first TO nums1  \n            SET nums1 TO nums2  \n            SET nums2 TO first  \n        END IF  \n        \n        SET x TO the LENGTH OF nums1  \n        SET y TO the LENGTH OF nums2  \n        SET low TO zero  \n        SET high TO x  \n        \n        WHILE low LESS THAN OR EQUAL TO high  \n            SET partitionX TO the INTEGER DIVISION OF the SUM of low PLUS high BY two  \n            SET partitionY TO the INTEGER DIVISION OF the SUM of x PLUS y PLUS one BY two MINUS partitionX  \n            \n            IF partitionX EQUALS zero THEN  \n                SET maxLeftX TO NEGATIVE_INFINITY  \n            ELSE  \n                SET maxLeftX TO the element at position partitionX MINUS one OF nums1  \n            END IF  \n            \n            IF partitionX EQUALS x THEN  \n                SET minRightX TO POSITIVE_INFINITY  \n            ELSE  \n                SET minRightX TO the element at position partitionX OF nums1  \n            END IF  \n            \n            IF partitionY EQUALS zero THEN  \n                SET maxLeftY TO NEGATIVE_INFINITY  \n            ELSE  \n                SET maxLeftY TO the element at position partitionY MINUS one OF nums2  \n            END IF  \n            \n            IF partitionY EQUALS y THEN  \n                SET minRightY TO POSITIVE_INFINITY  \n            ELSE  \n                SET minRightY TO the element at position partitionY OF nums2  \n            END IF  \n            \n            IF maxLeftX LESS THAN OR EQUAL TO minRightY AND maxLeftY LESS THAN OR EQUAL TO minRightX THEN  \n                IF the MODULO of the SUM of x PLUS y EQUALS zero THEN  \n                    SET maximum_left TO maxLeftX  \n                    IF maxLeftY GREATER THAN maximum_left THEN  \n                        SET maximum_left TO maxLeftY  \n                    END IF  \n                    SET minimum_right TO minRightX  \n                    IF minRightY LESS THAN minimum_right THEN  \n                        SET minimum_right TO minRightY  \n                    END IF  \n                    RETURN the SUM of maximum_left PLUS minimum_right DIVIDED BY two  \n                ELSE  \n                    IF maxLeftX GREATER THAN maxLeftY THEN  \n                        RETURN maxLeftX  \n                    ELSE  \n                        RETURN maxLeftY  \n                    END IF  \n                END IF  \n            ELSE IF maxLeftX GREATER THAN minRightY THEN  \n                SET high TO partitionX MINUS one  \n            ELSE  \n                SET low TO partitionX PLUS one  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-palindromic-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "zigzag-conversion", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION convert WITH PARAMETERS s numRows  \n        IF numRows EQUALS one  \n            RETURN s  \n        END IF  \n        SET rows TO a list containing numRows empty strings  \n        SET current_row TO zero  \n        SET going_down TO false  \n        FOR each character IN s  \n            SET element at position current_row of rows TO the element at position current_row of rows PLUS character  \n            IF current_row EQUALS zero OR current_row EQUALS numRows MINUS one  \n                SET going_down TO NOT going_down  \n            END IF  \n            IF going_down IS true  \n                INCREMENT current_row BY one  \n            ELSE  \n                DECREMENT current_row BY one  \n            END IF  \n        END FOR  \n        RETURN the concatenation of all elements in rows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-integer", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reverse(x)  \n        IF x LESS THAN zero  \n            SET sign TO negative one  \n        ELSE  \n            SET sign TO one  \n        END IF  \n        SET absolute_value_of_x TO the absolute value of x  \n        SET string_representation TO the string form of absolute_value_of_x  \n        SET reversed_string TO the characters of string_representation in reverse order  \n        SET reversed_x TO the integer form of reversed_string  \n        SET result TO sign MULTIPLIED BY reversed_x  \n        IF result LESS THAN negative two RAISED TO THE THIRTY-FIRST POWER OR result GREATER THAN positive two RAISED TO THE THIRTY-FIRST POWER MINUS one  \n            RETURN zero  \n        END IF  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-to-integer-atoi", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "regular-expression-matching", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s string p string) RETURNS boolean  \n        SET dp TO a two dimensional list of boolean values all set to false with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero at position zero of dp TO true  \n        FOR j FROM one TO the LENGTH OF p  \n            IF element at position j MINUS one of p EQUALS the character Asterisk  \n                SET element at position zero at position j of dp TO element at position zero at position j MINUS two of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the LENGTH OF s  \n            FOR j FROM one TO the LENGTH OF p  \n                IF element at position j MINUS one of p EQUALS element at position i MINUS one of s OR element at position j MINUS one of p EQUALS the character Dot  \n                    SET element at position i at position j of dp TO element at position i MINUS one at position j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character Asterisk  \n                    SET element at position i at position j of dp TO element at position i at position j MINUS two of dp  \n                    IF element at position j MINUS two of p EQUALS element at position i MINUS one of s OR element at position j MINUS two of p EQUALS the character Dot  \n                        SET element at position i at position j of dp TO element at position i at position j of dp OR element at position i MINUS one at position j of dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the LENGTH OF s at position the LENGTH OF p of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "container-with-most-water", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxArea(height)  \n        SET left TO zero  \n        SET right TO the LENGTH OF height MINUS one  \n        SET max_area TO zero  \n        WHILE left LESS THAN right  \n            SET current_area TO the MINIMUM OF element at position left of height AND element at position right of height MULTIPLIED BY right MINUS left  \n            SET max_area TO the GREATER OF max_area AND current_area  \n            IF element at position left of height LESS THAN element at position right of height  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-to-roman", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION intToRoman(num)  \n        SET val TO list of integer one thousand PLUS nine hundred PLUS five hundred PLUS four hundred PLUS one hundred PLUS ninety PLUS fifty PLUS forty PLUS ten PLUS nine PLUS five PLUS four PLUS one  \n        SET syms TO list of string M PLUS CM PLUS D PLUS CD PLUS C PLUS XC PLUS L PLUS XL PLUS X PLUS IX PLUS V PLUS IV PLUS I  \n        SET roman_numeral TO an empty string  \n        SET i TO zero  \n        WHILE num GREATER THAN zero  \n            SET times TO num DIVIDED BY element at position i of val  \n            FOR each iteration FROM one TO times  \n                APPEND element at position i of syms TO roman_numeral  \n                DECREMENT num BY element at position i of val  \n            END FOR  \n            INCREMENT i BY one  \n        END WHILE  \n        RETURN roman_numeral  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "3sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION threeSum(nums)  \n        CALL sort on nums to arrange elements in ascending order  \n        SET result TO an empty list  \n        SET n TO the LENGTH OF nums  \n        \n        FOR i FROM zero TO n MINUS two MINUS one  \n            IF i GREATER THAN zero AND element at position i of nums EQUALS element at position i MINUS one of nums  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            \n            SET left TO i PLUS one  \n            SET right TO n MINUS one  \n            WHILE left LESS THAN right  \n                SET total TO element at position i of nums PLUS element at position left of nums PLUS element at position right of nums  \n                \n                IF total EQUALS zero  \n                    APPEND a list containing element at position i of nums PLUS element at position left of nums PLUS element at position right of nums TO result  \n                    \n                    WHILE left LESS THAN right AND element at position left of nums EQUALS element at position left PLUS one of nums  \n                        INCREMENT left BY one  \n                    END WHILE  \n                    \n                    WHILE left LESS THAN right AND element at position right of nums EQUALS element at position right MINUS one of nums  \n                        DECREMENT right BY one  \n                    END WHILE  \n                    \n                    INCREMENT left BY one  \n                    DECREMENT right BY one  \n                \n                ELSE IF total LESS THAN zero  \n                    INCREMENT left BY one  \n                \n                ELSE  \n                    DECREMENT right BY one  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "3sum-closest", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION threeSumClosest(nums target)  \n        CALL sort ON nums  \n        SET closest_sum TO positive infinity  \n        FOR i FROM zero TO the LENGTH OF nums MINUS two MINUS one  \n            SET left TO i PLUS one  \n            SET right TO the LENGTH OF nums MINUS one  \n            WHILE left LESS THAN right  \n                SET current_sum TO element at position i of nums PLUS element at position left of nums PLUS element at position right of nums  \n                IF the absolute value of current_sum MINUS target LESS THAN the absolute value of closest_sum MINUS target  \n                    SET closest_sum TO current_sum  \n                END IF  \n                IF current_sum LESS THAN target  \n                    INCREMENT left BY one  \n                ELSE IF current_sum GREATER THAN target  \n                    DECREMENT right BY one  \n                ELSE  \n                    RETURN current_sum  \n                END IF  \n            END WHILE  \n        END FOR  \n        RETURN closest_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "4sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fourSum(nums LIST OF INTEGERS target INTEGER) RETURNS LIST OF LIST OF INTEGERS  \n        SORT the list nums IN ASCENDING ORDER  \n        SET n TO the LENGTH OF nums  \n        SET quadruplets TO an EMPTY LIST  \n        FOR i FROM zero TO n MINUS three MINUS one  \n            IF i GREATER THAN zero AND element at position i of nums EQUALS element at position i MINUS one of nums  \n                CONTINUE to the next iteration of the FOR loop  \n            END IF  \n            FOR j FROM i PLUS one TO n MINUS two MINUS one  \n                IF j GREATER THAN i PLUS one AND element at position j of nums EQUALS element at position j MINUS one of nums  \n                    CONTINUE to the next iteration of the FOR loop  \n                END IF  \n                SET left TO j PLUS one  \n                SET right TO n MINUS one  \n                WHILE left LESS THAN right  \n                    SET total TO element at position i of nums PLUS element at position j of nums PLUS element at position left of nums PLUS element at position right of nums  \n                    IF total EQUALS target  \n                        APPEND a list containing element at position i of nums element at position j of nums element at position left of nums AND element at position right of nums TO quadruplets  \n                        WHILE left LESS THAN right AND element at position left of nums EQUALS element at position left PLUS one of nums  \n                            INCREMENT left BY one  \n                        END WHILE  \n                        WHILE left LESS THAN right AND element at position right of nums EQUALS element at position right MINUS one of nums  \n                            DECREMENT right BY one  \n                        END WHILE  \n                        INCREMENT left BY one  \n                        DECREMENT right BY one  \n                    ELSE IF total LESS THAN target  \n                        INCREMENT left BY one  \n                    ELSE  \n                        DECREMENT right BY one  \n                    END IF  \n                END WHILE  \n            END FOR  \n        END FOR  \n        RETURN quadruplets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "generate-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generateParenthesis WITH parameter n  \n        FUNCTION backtrack WITH parameters s AS an empty string left AS zero right AS zero  \n            IF the LENGTH OF s EQUALS two MULTIPLIED BY n  \n                APPEND s TO result  \n                RETURN  \n            END IF  \n            IF left LESS THAN n  \n                CALL backtrack WITH s CONCATENATED WITH an opening parenthesis left INCREMENTED BY one right  \n            END IF  \n            IF right LESS THAN left  \n                CALL backtrack WITH s CONCATENATED WITH a closing parenthesis left right INCREMENTED BY one  \n            END IF  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL backtrack WITH no arguments  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-permutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextPermutation(nums)  \n        SET i TO the LENGTH OF nums MINUS two  \n        WHILE i GREATER THAN OR EQUAL TO zero AND the element at position i of nums GREATER THAN OR EQUAL TO the element at position i PLUS one of nums  \n            DECREMENT i BY one  \n        END WHILE  \n        IF i GREATER THAN OR EQUAL TO zero  \n            SET j TO the LENGTH OF nums MINUS one  \n            WHILE the element at position j of nums LESS THAN OR EQUAL TO the element at position i of nums  \n                DECREMENT j BY one  \n            END WHILE  \n            SET temporary TO the element at position i of nums  \n            SET the element at position i of nums TO the element at position j of nums  \n            SET the element at position j of nums TO temporary  \n        END IF  \n        SET start TO i PLUS one  \n        SET end TO the LENGTH OF nums MINUS one  \n        WHILE start LESS THAN end  \n            SET temporary TO the element at position start of nums  \n            SET the element at position start of nums TO the element at position end of nums  \n            SET the element at position end of nums TO temporary  \n            INCREMENT start BY one  \n            DECREMENT end BY one  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-valid-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestValidParentheses(s)  \n        SET stack TO a new list containing the element negative one  \n        SET max_length TO zero  \n        FOR each index i AND each character char IN the enumeration of s  \n            IF character char EQUALS the opening parenthesis character  \n                APPEND index i TO stack  \n            ELSE  \n                REMOVE the last element FROM stack  \n                IF the stack is empty  \n                    APPEND index i TO stack  \n                ELSE  \n                    SET current_length TO index i MINUS the last element of stack  \n                    IF current_length GREATER THAN max_length  \n                        SET max_length TO current_length  \n                    END IF  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-in-rotated-sorted-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION search(nums target)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS the DIFFERENCE BETWEEN right AND left DIVIDED BY two  \n            IF the element at position mid of nums EQUALS target  \n                RETURN mid  \n            END IF  \n            IF the element at position left of nums LESS THAN OR EQUAL TO the element at position mid of nums  \n                IF the element at position left of nums LESS THAN OR EQUAL TO target AND target LESS THAN the element at position mid of nums  \n                    SET right TO mid MINUS one  \n                ELSE  \n                    SET left TO mid PLUS one  \n                END IF  \n            ELSE  \n                IF the element at position mid of nums LESS THAN target AND target LESS THAN OR EQUAL TO the element at position right of nums  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION searchRange(nums target)  \n        FUNCTION find_left(nums target)  \n            SET left TO zero  \n            SET right TO the length of nums MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO the integer division of left PLUS right BY two  \n                IF the element at position mid of nums LESS THAN target  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN left  \n        END FUNCTION  \n\n        FUNCTION find_right(nums target)  \n            SET left TO zero  \n            SET right TO the length of nums MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO the integer division of left PLUS right BY two  \n                IF the element at position mid of nums LESS THAN OR EQUAL TO target  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN right  \n        END FUNCTION  \n\n        SET left_index TO find_left(nums target)  \n        SET right_index TO find_right(nums target)  \n\n        IF left_index LESS THAN OR EQUAL TO right_index AND zero LESS THAN OR EQUAL TO right_index AND right_index LESS THAN the length of nums AND the element at position left_index of nums EQUALS target  \n            RETURN the list consisting of left_index and right_index  \n        ELSE  \n            RETURN the list consisting of negative one and negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sudoku-solver", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solveSudoku(board)  \n        FUNCTION is_valid(board, row, col, num)  \n            FOR i FROM zero TO eight  \n                IF element at position i of row at position row of board EQUALS num  \n                    RETURN False  \n                END IF  \n            END FOR  \n            FOR i FROM zero TO eight  \n                IF element at position col of row at position i of board EQUALS num  \n                    RETURN False  \n                END IF  \n            END FOR  \n            SET start_row TO three MULTIPLIED BY the result of integer division of row BY three  \n            SET start_col TO three MULTIPLIED BY the result of integer division of col BY three  \n            FOR i FROM zero TO two  \n                FOR j FROM zero TO two  \n                    IF element at position start_col PLUS j of row at position start_row PLUS i of board EQUALS num  \n                        RETURN False  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        FUNCTION solve(board)  \n            FOR row FROM zero TO eight  \n                FOR col FROM zero TO eight  \n                    IF element at position col of row at position row of board EQUALS the character representing empty cell  \n                        FOR num AS string representation of number FROM one TO nine  \n                            IF is_valid(board, row, col, num) EQUALS True  \n                                SET element at position col of row at position row of board TO num  \n                                IF solve(board) EQUALS True  \n                                    RETURN True  \n                                END IF  \n                                SET element at position col of row at position row of board TO the character representing empty cell  \n                            END IF  \n                        END FOR  \n                        RETURN False  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        CALL solve WITH argument board  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-and-say", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countAndSay(n)  \n        IF n EQUALS one  \n            RETURN the string representing one  \n        END IF  \n        \n        SET current_sequence TO the string representing one  \n        \n        FOR each index FROM two TO n  \n            SET next_sequence TO the empty string  \n            SET count TO one  \n            SET previous_char TO the first character of current_sequence  \n            \n            FOR each position FROM two TO the length of current_sequence  \n                IF the character at position of current_sequence EQUALS previous_char  \n                    INCREMENT count BY one  \n                ELSE  \n                    APPEND the string form of count concatenated with previous_char TO next_sequence  \n                    SET previous_char TO the character at position of current_sequence  \n                    SET count TO one  \n                END IF  \n            END FOR  \n            \n            APPEND the string form of count concatenated with previous_char TO next_sequence  \n            \n            SET current_sequence TO next_sequence  \n        END FOR  \n        \n        RETURN current_sequence  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum2(candidates, target)  \n        FUNCTION backtrack(start, target, path)  \n            IF target EQUALS zero  \n                APPEND path TO result  \n                RETURN  \n            END IF  \n            IF target LESS THAN zero  \n                RETURN  \n            END IF  \n            FOR i FROM start TO LENGTH OF candidates MINUS one  \n                IF i GREATER THAN start AND element at position i of candidates EQUALS element at position i MINUS one of candidates  \n                    CONTINUE  \n                END IF  \n                CALL backtrack WITH arguments i PLUS one, target MINUS element at position i of candidates, concatenation of path AND list containing element at position i of candidates  \n            END FOR  \n        END FUNCTION  \n        SORT candidates IN NON-DECREASING ORDER  \n        SET result TO empty list  \n        CALL backtrack WITH arguments zero, target, empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "first-missing-positive", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION firstMissingPositive(nums)  \n        SET n TO the LENGTH OF nums  \n        \n        FOR i FROM zero TO n MINUS one  \n            WHILE the element at position i of nums IS GREATER THAN OR EQUAL TO one AND the element at position i of nums IS LESS THAN OR EQUAL TO n AND the element at position the element at position i of nums MINUS one of nums IS NOT EQUALS TO the element at position i of nums  \n                SET correct_index TO the element at position i of nums MINUS one  \n                SET temporary_value TO the element at position i of nums  \n                SET the element at position i of nums TO the element at position correct_index of nums  \n                SET the element at position correct_index of nums TO temporary_value  \n            END WHILE  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of nums IS NOT EQUALS TO i PLUS one  \n                RETURN i PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN n PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "trapping-rain-water", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION trap(height)  \n        IF height EQUALS no elements  \n            RETURN zero  \n        END IF  \n\n        SET n TO the LENGTH OF height  \n        INITIALIZE left_max AS a list of zeros WITH LENGTH n  \n        INITIALIZE right_max AS a list of zeros WITH LENGTH n  \n\n        SET element at position one of left_max TO element at position one of height  \n        FOR i FROM two TO n  \n            SET element at position i of left_max TO THE MAXIMUM OF element at position i MINUS one of left_max AND element at position i of height  \n        END FOR  \n\n        SET element at position n of right_max TO element at position n of height  \n        FOR i FROM n MINUS one DOWN TO one  \n            SET element at position i of right_max TO THE MAXIMUM OF element at position i PLUS one of right_max AND element at position i of height  \n        END FOR  \n\n        SET trapped_water TO zero  \n        FOR i FROM one TO n  \n            INCREMENT trapped_water BY THE MINIMUM OF element at position i of left_max AND element at position i of right_max MINUS element at position i of height  \n        END FOR  \n\n        RETURN trapped_water  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "multiply-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wildcard-matching", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION jump(nums)  \n        IF the LENGTH OF nums LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        SET jumps TO zero  \n        SET current_end TO zero  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one MINUS one  \n            SET farthest TO the GREATER THAN value BETWEEN farthest AND the SUM of i PLUS the element at position i of nums  \n            IF i EQUALS current_end  \n                INCREMENT jumps BY one  \n                SET current_end TO farthest  \n                IF current_end GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n                    BREAK the FOR loop  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN jumps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION permute(nums)  \n        FUNCTION backtrack(path, remaining)  \n            IF the LENGTH OF remaining EQUALS zero  \n                APPEND path TO permutations  \n                RETURN  \n            END IF  \n            FOR i FROM zero TO THE LENGTH OF remaining MINUS one  \n                SET new_path TO path PLUS element at position i of remaining  \n                SET new_remaining TO concatenation of elements from position zero TO position i MINUS one of remaining PLUS elements from position i PLUS one TO THE END of remaining  \n                CALL backtrack(new_path, new_remaining)  \n            END FOR  \n        END FUNCTION  \n\n        SET permutations TO an empty list  \n        CALL backtrack(empty list, nums)  \n        RETURN permutations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutations-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION permuteUnique(nums)  \n        FUNCTION backtrack(path, used, res)  \n            IF the LENGTH OF path EQUALS the LENGTH OF nums  \n                APPEND a COPY OF path TO res  \n                RETURN  \n            END IF  \n            FOR index i FROM zero TO the LENGTH OF nums MINUS one  \n                IF the element at position i of used IS true OR (i GREATER THAN zero AND the element at position i of nums EQUALS the element at position i MINUS one of nums AND the element at position i MINUS one of used IS false)  \n                    CONTINUE to the next iteration  \n                END IF  \n                SET the element at position i of used TO true  \n                APPEND the element at position i of nums TO path  \n                CALL backtrack WITH arguments path used res  \n                REMOVE the last element FROM path  \n                SET the element at position i of used TO false  \n            END FOR  \n        END FUNCTION  \n        SORT nums IN ascending order  \n        SET res TO empty list  \n        SET used TO a list of false values with the LENGTH OF nums  \n        CALL backtrack WITH arguments empty list used res  \n        RETURN res  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-image", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rotate(matrix)  \n        SET n TO the LENGTH OF matrix  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET temporary_value TO the element at position j OF the element at position i OF matrix  \n                SET the element at position j OF the element at position i OF matrix TO the element at position i OF the element at position j OF matrix  \n                SET the element at position i OF the element at position j OF matrix TO temporary_value  \n            END FOR  \n        END FOR  \n        FOR i FROM zero TO n MINUS one  \n            CALL reverse_row ON the element at position i OF matrix  \n        END FOR  \n    END FUNCTION  \n  \n    FUNCTION reverse_row(row)  \n        SET start_index TO zero  \n        SET end_index TO the LENGTH OF row MINUS one  \n        WHILE start_index LESS THAN end_index  \n            SET temporary_value TO the element at position start_index OF row  \n            SET the element at position start_index OF row TO the element at position end_index OF row  \n            SET the element at position end_index OF row TO temporary_value  \n            INCREMENT start_index BY one  \n            DECREMENT end_index BY one  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "group-anagrams", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION groupAnagrams(strs)  \n        SET anagrams TO a default dictionary that returns an empty list for each new key  \n        FOR each string s IN strs  \n            SET sorted_str TO the concatenation of elements obtained by arranging each character of string s in ascending alphabetical order  \n            APPEND string s TO the list that corresponds to key sorted_str in anagrams  \n        END FOR  \n        RETURN the collection of all lists that are values in anagrams converted to a list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "powx-n", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION myPow(x, n)  \n        FUNCTION qpow(a, n)  \n            SET ans TO one  \n            WHILE n GREATER THAN zero  \n                IF the bitwise AND of n AND one EQUALS one  \n                    SET ans TO ans MULTIPLIED BY a  \n                END IF  \n                SET a TO a MULTIPLIED BY a  \n                SET n TO the integer division of n BY two discarding remainder  \n            END WHILE  \n            RETURN ans  \n        END FUNCTION  \n        IF n GREATER THAN OR EQUAL TO zero  \n            RETURN qpow with parameters x and n  \n        ELSE  \n            RETURN one DIVIDED BY qpow with parameters x and the negation of n  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "n-queens", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solveNQueens(n)  \n        FUNCTION is_not_under_attack(row, col)  \n            RETURN NOT (element at position col of cols EQUALS one OR element at position row MINUS col of hills EQUALS one OR element at position row PLUS col of dales EQUALS one)  \n        END FUNCTION  \n  \n        FUNCTION place_queen(row, col)  \n            ADD the pair consisting of row and col TO queens  \n            SET element at position col of cols TO one  \n            SET element at position row MINUS col of hills TO one  \n            SET element at position row PLUS col of dales TO one  \n        END FUNCTION  \n  \n        FUNCTION remove_queen(row, col)  \n            REMOVE the pair consisting of row and col FROM queens  \n            SET element at position col of cols TO zero  \n            SET element at position row MINUS col of hills TO zero  \n            SET element at position row PLUS col of dales TO zero  \n        END FUNCTION  \n  \n        FUNCTION add_solution()  \n            SET solution TO an empty list  \n            FOR each pair of underscore and col IN the sorted sequence of queens  \n                SET line TO an empty string  \n                APPEND the character representing a period repeated col times TO line  \n                APPEND the character representing a capital letter Q TO line  \n                APPEND the character representing a period repeated n MINUS col MINUS one times TO line  \n                APPEND line TO solution  \n            END FOR  \n            APPEND solution TO output  \n        END FUNCTION  \n  \n        FUNCTION backtrack(row)  \n            FOR col FROM zero TO n MINUS one  \n                IF is_not_under_attack(row, col)  \n                    CALL place_queen WITH row AND col  \n                    IF row PLUS one EQUALS n  \n                        CALL add_solution  \n                    ELSE  \n                        CALL backtrack WITH row PLUS one  \n                    END IF  \n                    CALL remove_queen WITH row AND col  \n                END IF  \n            END FOR  \n        END FUNCTION  \n  \n        SET cols TO a list of zero repeated n times  \n        SET hills TO a list of zero repeated two MULTIPLIED BY n MINUS one times  \n        SET dales TO a list of zero repeated two MULTIPLIED BY n MINUS one times  \n        SET queens TO an empty set  \n        SET output TO an empty list  \n        CALL backtrack WITH zero  \n        RETURN output  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "n-queens-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION totalNQueens WITH PARAMETER n  \n        FUNCTION is_not_under_attack WITH PARAMETERS row col  \n            RETURN NOT the sum of element at position col of cols PLUS element at position computed by row MINUS col of hills PLUS element at position computed by row PLUS col of dales EQUALS zero  \n        END FUNCTION  \n        FUNCTION place_queen WITH PARAMETERS row col  \n            SET element at position col of cols TO one  \n            SET element at position computed by row MINUS col of hills TO one  \n            SET element at position computed by row PLUS col of dales TO one  \n        END FUNCTION  \n        FUNCTION remove_queen WITH PARAMETERS row col  \n            SET element at position col of cols TO zero  \n            SET element at position computed by row MINUS col of hills TO zero  \n            SET element at position computed by row PLUS col of dales TO zero  \n        END FUNCTION  \n        FUNCTION backtrack WITH PARAMETERS row initialized to zero count initialized to zero  \n            FOR col FROM zero TO n MINUS one  \n                IF is_not_under_attack WITH ARGUMENTS row col EQUALS true  \n                    CALL place_queen WITH ARGUMENTS row col  \n                    IF the sum of row PLUS one EQUALS n  \n                        INCREMENT count BY one  \n                    ELSE  \n                        SET count TO the result of calling backtrack WITH ARGUMENTS the sum of row PLUS one count  \n                    END IF  \n                    CALL remove_queen WITH ARGUMENTS row col  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        SET cols TO a list containing zero repeated n times  \n        SET hills TO a list containing zero repeated the result of two MULTIPLIED BY n MINUS one times  \n        SET dales TO a list containing zero repeated the result of two MULTIPLIED BY n MINUS one times  \n        RETURN the result of calling backtrack with no arguments  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSubArray(nums)  \n        SET max_sum TO element at position one of nums  \n        SET current_sum TO element at position one of nums  \n        FOR each num IN the elements of nums from position two to the end  \n            IF num GREATER THAN current_sum PLUS num  \n                SET current_sum TO num  \n            ELSE  \n                SET current_sum TO current_sum PLUS num  \n            END IF  \n            IF current_sum GREATER THAN max_sum  \n                SET max_sum TO current_sum  \n            END IF  \n        END FOR  \n        RETURN max_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "spiral-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION spiralOrder(matrix)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN empty list  \n        END IF  \n        \n        SET result TO empty list  \n        SET top TO zero  \n        SET bottom TO the length of matrix MINUS one  \n        SET left TO zero  \n        SET right TO the length of element at position zero of matrix MINUS one  \n        \n        WHILE top LESS THAN OR EQUAL TO bottom AND left LESS THAN OR EQUAL TO right  \n            FOR i FROM left TO right  \n                APPEND element at position top of matrix AT position i TO result  \n            END FOR  \n            INCREMENT top BY one  \n            \n            FOR i FROM top TO bottom  \n                APPEND element at position i of matrix AT position right TO result  \n            END FOR  \n            DECREMENT right BY one  \n            \n            IF top LESS THAN OR EQUAL TO bottom  \n                FOR i FROM right DOWN TO left  \n                    APPEND element at position bottom of matrix AT position i TO result  \n                END FOR  \n                DECREMENT bottom BY one  \n            END IF  \n            \n            IF left LESS THAN OR EQUAL TO right  \n                FOR i FROM bottom DOWN TO top  \n                    APPEND element at position i of matrix AT position left TO result  \n                END FOR  \n                INCREMENT left BY one  \n            END IF  \n        END WHILE  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "merge-intervals", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION merge(intervals)  \n        SORT intervals BY the element at position zero of each interval  \n        SET merged TO empty list  \n        FOR each interval IN intervals  \n            IF merged EQUALS empty list OR the element at position one of the last element in merged IS LESS THAN the element at position zero of interval  \n                APPEND interval TO merged  \n            ELSE  \n                SET the element at position one of the last element in merged TO the GREATER THAN OR EQUAL TO of the element at position one of the last element in merged AND the element at position one of interval  \n            END IF  \n        END FOR  \n        RETURN merged  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "insert-interval", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION insert(intervals AS list of list of integer newInterval AS list of integer) RETURNS list of list of integer  \n        IF intervals EQUALS an empty list THEN  \n            RETURN a list containing newInterval  \n        END IF  \n\n        SET merged TO an empty list  \n        SET i TO zero  \n        SET n TO the LENGTH OF intervals  \n\n        WHILE i LESS THAN n AND element at position one of element at position i of intervals LESS THAN element at position zero of newInterval HOLDS  \n            APPEND element at position i of intervals TO merged  \n            INCREMENT i BY one  \n        END WHILE  \n\n        WHILE i LESS THAN n AND element at position zero of element at position i of intervals LESS THAN OR EQUAL TO element at position one of newInterval HOLDS  \n            SET element at position zero of newInterval TO the MINIMUM OF element at position zero of newInterval AND element at position zero of element at position i of intervals  \n            SET element at position one of newInterval TO the MAXIMUM OF element at position one of newInterval AND element at position one of element at position i of intervals  \n            INCREMENT i BY one  \n        END WHILE  \n\n        APPEND newInterval TO merged  \n\n        WHILE i LESS THAN n HOLDS  \n            APPEND element at position i of intervals TO merged  \n            INCREMENT i BY one  \n        END WHILE  \n\n        RETURN merged  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "spiral-matrix-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generateMatrix(n)  \n        SET matrix TO a list containing n elements each being a list containing n elements each set TO zero  \n        SET top TO zero  \n        SET bottom TO n MINUS one  \n        SET left TO zero  \n        SET right TO n MINUS one  \n        SET num TO one  \n        WHILE top LESS THAN OR EQUAL TO bottom AND left LESS THAN OR EQUAL TO right  \n            FOR i FROM left TO right  \n                SET the element at position top of matrix at position i TO num  \n                INCREMENT num BY one  \n            END FOR  \n            INCREMENT top BY one  \n            FOR i FROM top TO bottom  \n                SET the element at position i of matrix at position right TO num  \n                INCREMENT num BY one  \n            END FOR  \n            DECREMENT right BY one  \n            IF top LESS THAN OR EQUAL TO bottom  \n                FOR i FROM right DOWN TO left  \n                    SET the element at position bottom of matrix at position i TO num  \n                    INCREMENT num BY one  \n                END FOR  \n                DECREMENT bottom BY one  \n            END IF  \n            IF left LESS THAN OR EQUAL TO right  \n                FOR i FROM bottom DOWN TO top  \n                    SET the element at position i of matrix at position left TO num  \n                    INCREMENT num BY one  \n                END FOR  \n                INCREMENT left BY one  \n            END IF  \n        END WHILE  \n        RETURN matrix  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION uniquePathsWithObstacles(obstacleGrid)  \n        IF obstacleGrid EQUALS nothing OR element at position zero of element at position zero of obstacleGrid EQUALS one  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF obstacleGrid  \n        SET n TO the LENGTH OF element at position zero of obstacleGrid  \n        SET dp TO a list of m elements each being a list of n elements each set to zero  \n        SET element at position zero of element at position zero of dp TO one  \n        FOR j FROM one TO n MINUS one  \n            IF element at position j of element at position zero of obstacleGrid EQUALS zero  \n                SET element at position j of element at position zero of dp TO element at position j MINUS one of element at position zero of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO m MINUS one  \n            IF element at position zero of element at position i of obstacleGrid EQUALS zero  \n                SET element at position zero of element at position i of dp TO element at position zero of element at position i MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                IF element at position j of element at position i of obstacleGrid EQUALS zero  \n                    SET element at position j of element at position i of dp TO element at position j of element at position i MINUS one of dp PLUS element at position j MINUS one of element at position i of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n MINUS one of element at position m MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-path-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minPathSum(grid)  \n        IF grid EQUALS empty OR the element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF the element at position zero of grid  \n        \n        CREATE two dimensional list dp WITH zero VALUES WITH m ROWS AND n COLUMNS  \n        \n        SET the element at position zero zero of dp TO the element at position zero zero of grid  \n        \n        FOR j FROM one TO n MINUS one  \n            SET the element at position zero j of dp TO the element at position zero j MINUS one of dp PLUS the element at position zero j of grid  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            SET the element at position i zero of dp TO the element at position i MINUS one zero of dp PLUS the element at position i zero of grid  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                SET the element at position i j of dp TO the minimum BETWEEN the element at position i MINUS one j of dp AND the element at position i j MINUS one of dp PLUS the element at position i j of grid  \n            END FOR  \n        END FOR  \n        \n        RETURN the element at position m MINUS one n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "text-justification", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fullJustify(words maxWidth)  \n        FUNCTION justify_line(line num_of_letters is_last_line)  \n            IF the LENGTH OF line EQUALS one OR is_last_line EQUALS true  \n                RETURN the CONCATENATION OF the ELEMENTS OF line SEPARATED BY one SPACE FOLLOWED BY a NUMBER OF SPACES EQUAL TO maxWidth MINUS num_of_letters MINUS the LENGTH OF line PLUS one  \n            ELSE  \n                SET total_spaces TO maxWidth MINUS num_of_letters  \n                SET num_of_gaps TO the LENGTH OF line MINUS one  \n                SET spaces_between_words TO total_spaces DIVIDED BY num_of_gaps  \n                SET extra_spaces TO total_spaces MODULO num_of_gaps  \n                \n                FOR i FROM zero TO num_of_gaps MINUS one  \n                    IF i LESS THAN extra_spaces  \n                        APPEND a NUMBER OF SPACES EQUAL TO spaces_between_words PLUS one TO the ELEMENT AT POSITION i OF line  \n                    ELSE  \n                        APPEND a NUMBER OF SPACES EQUAL TO spaces_between_words TO the ELEMENT AT POSITION i OF line  \n                    END IF  \n                END FOR  \n                \n                RETURN the CONCATENATION OF the ELEMENTS OF line WITHOUT ANY SEPARATORS  \n            END IF  \n        END FUNCTION  \n        \n        SET result TO an empty list  \n        SET line TO an empty list  \n        SET num_of_letters TO zero  \n        \n        FOR each word IN words  \n            IF num_of_letters PLUS the LENGTH OF word PLUS the LENGTH OF line GREATER THAN maxWidth  \n                APPEND the RESULT OF justify_line WITH ARGUMENTS line num_of_letters false TO result  \n                SET line TO an empty list  \n                SET num_of_letters TO zero  \n            END IF  \n            \n            APPEND word TO line  \n            INCREMENT num_of_letters BY the LENGTH OF word  \n        END FOR  \n        \n        APPEND the RESULT OF justify_line WITH ARGUMENTS line num_of_letters true TO result  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "simplify-path", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION simplifyPath(path)  \n        SET components TO the list of substrings obtained by dividing path by the character slash  \n        SET stack TO an empty list  \n        FOR each component IN components  \n            IF component EQUALS an empty string OR component EQUALS a single period representing the current directory  \n                CONTINUE to the next component  \n            ELSE IF component EQUALS two consecutive periods representing the parent directory  \n                IF the LENGTH OF stack IS greater than zero  \n                    REMOVE the last element FROM stack  \n                END IF  \n            ELSE  \n                APPEND component TO stack  \n            END IF  \n        END FOR  \n        SET simplified_path TO the character slash concatenated with the strings in stack joined by the character slash  \n        RETURN simplified_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "edit-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        SET m TO the LENGTH OF word1  \n        SET n TO the LENGTH OF word2  \n  \n        CREATE a two dimensional list dp with m PLUS one rows each containing n PLUS one zeros  \n  \n        FOR i FROM zero TO m  \n            SET element at position zero of dp at position i TO i  \n        END FOR  \n  \n        FOR j FROM zero TO n  \n            SET element at position j of dp at position zero TO j  \n        END FOR  \n  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF element at position i MINUS one of word1 EQUALS element at position j MINUS one of word2  \n                    SET element at position j of dp at position i TO element at position j MINUS one of dp at position i MINUS one  \n                ELSE  \n                    SET element at position j of dp at position i TO one PLUS the MINIMUM OF element at position j of dp at position i MINUS one  \n                                                                 AND element at position j MINUS one of dp at position i  \n                                                                 AND element at position j MINUS one of dp at position i MINUS one  \n                END IF  \n            END FOR  \n        END FOR  \n  \n        RETURN element at position n of dp at position m  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "set-matrix-zeroes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION setZeroes(matrix)  \n        IF matrix EQUALS nothing OR the LENGTH OF matrix EQUALS zero OR the LENGTH OF element at position zero of matrix EQUALS zero  \n            RETURN  \n        END IF  \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET first_row_has_zero TO false  \n        FOR each index j FROM zero TO n MINUS one  \n            IF element at position zero of matrix AT position j EQUALS zero  \n                SET first_row_has_zero TO true  \n                BREAK  \n            END IF  \n        END FOR  \n        SET first_col_has_zero TO false  \n        FOR each index i FROM zero TO m MINUS one  \n            IF element at position i of matrix AT position zero EQUALS zero  \n                SET first_col_has_zero TO true  \n                BREAK  \n            END IF  \n        END FOR  \n        FOR each index i FROM one TO m MINUS one  \n            FOR each index j FROM one TO n MINUS one  \n                IF element at position i of matrix AT position j EQUALS zero  \n                    SET element at position i of matrix AT position zero TO zero  \n                    SET element at position zero of matrix AT position j TO zero  \n                END IF  \n            END FOR  \n        END FOR  \n        FOR each index i FROM one TO m MINUS one  \n            FOR each index j FROM one TO n MINUS one  \n                IF element at position i of matrix AT position zero EQUALS zero OR element at position zero of matrix AT position j EQUALS zero  \n                    SET element at position i of matrix AT position j TO zero  \n                END IF  \n            END FOR  \n        END FOR  \n        IF first_row_has_zero  \n            FOR each index j FROM zero TO n MINUS one  \n                SET element at position zero of matrix AT position j TO zero  \n            END FOR  \n        END IF  \n        IF first_col_has_zero  \n            FOR each index i FROM zero TO m MINUS one  \n                SET element at position i of matrix AT position zero TO zero  \n            END FOR  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-colors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sortColors(nums)  \n        SET low TO zero  \n        SET mid TO zero  \n        SET high TO the LENGTH OF nums MINUS one  \n        WHILE mid LESS THAN OR EQUAL TO high  \n            IF element at position mid of nums EQUALS zero  \n                SET temporary TO element at position mid of nums  \n                SET element at position mid of nums TO element at position low of nums  \n                SET element at position low of nums TO temporary  \n                INCREMENT low BY one  \n                INCREMENT mid BY one  \n            ELSE IF element at position mid of nums EQUALS one  \n                INCREMENT mid BY one  \n            ELSE IF element at position mid of nums EQUALS two  \n                SET temporary TO element at position mid of nums  \n                SET element at position mid of nums TO element at position high of nums  \n                SET element at position high of nums TO temporary  \n                DECREMENT high BY one  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-window-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minWindow(s parameter OF TYPE string, t parameter OF TYPE string) RETURNS string  \n        SET t_count TO a mapping of characters to their frequency counts in t  \n        SET required TO the length of the set of unique characters in t_count  \n        SET left TO zero  \n        SET right TO zero  \n        SET formed TO zero  \n        SET window_counts TO an empty mapping of characters to their frequency counts  \n        SET min_length TO a representation of infinity  \n        SET min_start TO zero  \n        \n        WHILE right is LESS THAN the length of s  \n            INCREMENT the frequency count of the character at position right of s in window_counts BY one  \n            \n            IF the character at position right of s is a key in t_count AND the frequency count of the character at position right of s in window_counts EQUALS the frequency count of that character in t_count THEN  \n                INCREMENT formed BY one  \n            END IF  \n            \n            WHILE left is LESS THAN OR EQUAL TO right AND formed EQUALS required  \n                SET char TO the character at position left of s  \n                \n                IF right MINUS left PLUS one is LESS THAN min_length THEN  \n                    SET min_length TO right MINUS left PLUS one  \n                    SET min_start TO left  \n                END IF  \n                \n                DECREMENT the frequency count of char in window_counts BY one  \n                \n                IF char is a key in t_count AND the frequency count of char in window_counts is LESS THAN the frequency count of char in t_count THEN  \n                    DECREMENT formed BY one  \n                END IF  \n                \n                INCREMENT left BY one  \n            END WHILE  \n            \n            INCREMENT right BY one  \n        END WHILE  \n        \n        IF min_length EQUALS infinity THEN  \n            RETURN an empty string  \n        ELSE  \n            RETURN the substring of s from position min_start TO position min_start PLUS min_length MINUS one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combinations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subsets", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subsets(nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN a LIST containing an EMPTY LIST  \n        END IF  \n        SET subsets_without_first TO the result of CALLING subsets with the LIST of elements of nums FROM position two TO the end  \n        SET subsets_with_first TO an EMPTY LIST  \n        FOR each subset IN subsets_without_first  \n            SET new_subset TO a LIST with the element at position one of nums FOLLOWED BY the elements of subset  \n            APPEND new_subset TO subsets_with_first  \n        END FOR  \n        SET combined_subsets TO the concatenation of subsets_without_first FOLLOWED BY subsets_with_first  \n        RETURN combined_subsets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-search", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION exist(board, word)  \n        IF board EQUALS an empty list  \n            RETURN false  \n        END IF  \n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF element at position zero of board  \n        CREATE visited AS a list containing m elements EACH of which is a list containing n elements EACH of which is false  \n\n        FUNCTION dfs(x, y, index)  \n            IF index EQUALS the LENGTH OF word  \n                RETURN true  \n            END IF  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x of visited WITHIN which element at position y IS true OR element at position x of board WITHIN which element at position y NOT EQUALS element at position index of word  \n                RETURN false  \n            END IF  \n            SET element at position x of visited WITHIN which element at position y TO true  \n            FOR each pair dx dy IN the list containing pairs of minus one zero and one zero and zero minus one and zero one  \n                IF dfs(x PLUS dx, y PLUS dy, index PLUS one)  \n                    RETURN true  \n                END IF  \n            END FOR  \n            SET element at position x of visited WITHIN which element at position y TO false  \n            RETURN false  \n        END FUNCTION  \n\n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF dfs(i, j, zero)  \n                    RETURN true  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicates-from-sorted-array-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-in-rotated-sorted-array-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION search(nums target)  \n        IF the collection nums EQUALS empty  \n            RETURN false  \n        END IF  \n        SET left TO zero  \n        SET right TO the LENGTH OF the collection nums MINUS one  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS the DIFFERENCE OF right MINUS left DIVIDED BY two  \n            IF element at position mid of the collection nums EQUALS target  \n                RETURN true  \n            END IF  \n            IF element at position left of the collection nums EQUALS element at position mid of the collection nums AND element at position mid of the collection nums EQUALS element at position right of the collection nums  \n                INCREMENT left BY one  \n                DECREMENT right BY one  \n            ELSE IF element at position left of the collection nums LESS THAN OR EQUAL TO element at position mid of the collection nums  \n                IF element at position left of the collection nums LESS THAN OR EQUAL TO target AND target LESS THAN element at position mid of the collection nums  \n                    SET right TO mid MINUS one  \n                ELSE  \n                    SET left TO mid PLUS one  \n                END IF  \n            ELSE  \n                IF element at position mid of the collection nums LESS THAN target AND target LESS THAN OR EQUAL TO element at position right of the collection nums  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-rectangle-in-histogram", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestRectangleArea(heights)  \n        SET stack TO a list containing only minus one  \n        SET max_area TO zero  \n        APPEND zero TO heights  \n        \n        FOR each index i AND each height h IN heights  \n            WHILE the last element of stack NOT EQUALS minus one AND h LESS THAN the element of heights AT the last element of stack  \n                SET height TO the element of heights AT the result of removing the last element of stack  \n                SET width TO i MINUS the last element of stack MINUS one  \n                SET max_area TO the greater value BETWEEN max_area AND height MULTIPLIED BY width  \n            END WHILE  \n            APPEND i TO stack  \n        END FOR  \n        \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximal-rectangle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximalRectangle(matrix)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET rows TO the LENGTH OF matrix  \n        SET cols TO the LENGTH OF element at position zero of matrix  \n        SET heights TO a new list of zeros WITH the LENGTH OF cols  \n        SET max_area TO zero  \n        FOR i FROM zero TO rows MINUS one  \n            FOR j FROM zero TO cols MINUS one  \n                IF element at position i of matrix AND element at position j EQUALS character one  \n                    INCREMENT element at position j of heights BY one  \n                ELSE  \n                    SET element at position j of heights TO zero  \n                END IF  \n            END FOR  \n            SET max_area TO the GREATER OF max_area AND the RESULT OF self CALLING largestRectangleArea WITH heights AS ARGUMENT  \n        END FOR  \n        RETURN max_area  \n    END FUNCTION  \n\n    FUNCTION largestRectangleArea(heights)  \n        SET stack TO an empty list  \n        SET max_area TO zero  \n        SET index TO zero  \n        WHILE index LESS THAN the LENGTH OF heights  \n            IF stack IS empty OR element at position index of heights GREATER THAN OR EQUAL TO element at position element at POSITION of the last element of stack of heights  \n                APPEND index TO stack  \n                INCREMENT index BY one  \n            ELSE  \n                SET top_of_stack TO the last element removed FROM stack  \n                IF stack IS NOT empty  \n                    SET area TO element at position top_of_stack of heights MULTIPLIED BY (index MINUS element at position element at POSITION of the last element of stack MINUS one)  \n                ELSE  \n                    SET area TO element at position top_of_stack of heights MULTIPLIED BY index  \n                END IF  \n                SET max_area TO the GREATER OF max_area AND area  \n            END IF  \n        END WHILE  \n        WHILE stack IS NOT empty  \n            SET top_of_stack TO the last element removed FROM stack  \n            IF stack IS NOT empty  \n                SET area TO element at position top_of_stack of heights MULTIPLIED BY (index MINUS element at position element at POSITION of the last element of stack MINUS one)  \n            ELSE  \n                SET area TO element at position top_of_stack of heights MULTIPLIED BY index  \n            END IF  \n            SET max_area TO the GREATER OF max_area AND area  \n        END WHILE  \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "scramble-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isScramble with parameters s1 AND s2  \n        IF s1 EQUALS s2 THEN  \n            RETURN True  \n        END IF  \n        IF the characters of s1 sorted DOES NOT EQUAL the characters of s2 sorted THEN  \n            RETURN False  \n        END IF  \n        SET n TO the LENGTH OF s1  \n        FOR i FROM one TO n MINUS one  \n            IF the result of calling isScramble with the substring of s1 from position one TO position i AND the substring of s2 from position one TO position i IS True  \n            AND the result of calling isScramble with the substring of s1 from position i PLUS one TO the end AND the substring of s2 from position i PLUS one TO the end IS True THEN  \n                RETURN True  \n            END IF  \n            IF the result of calling isScramble with the substring of s1 from position one TO position i AND the substring of s2 from the position corresponding to the last i characters TO the end IS True  \n            AND the result of calling isScramble with the substring of s1 from position i PLUS one TO the end AND the substring of s2 from position one TO the position corresponding to the length of s2 MINUS i THEN  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gray-code", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subsets-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subsetsWithDup(nums)  \n        SORT nums INTO ascending order  \n        SET result TO empty list  \n        SET subset TO empty list  \n        \n        FUNCTION dfs(i)  \n            IF i GREATER THAN OR EQUAL TO the LENGTH OF nums THEN  \n                APPEND a copy of subset TO result  \n                RETURN  \n            END IF  \n            \n            APPEND element at position i of nums TO subset  \n            CALL dfs WITH argument i PLUS one  \n            \n            REMOVE the last element FROM subset  \n            WHILE i PLUS one LESS THAN the LENGTH OF nums AND element at position i of nums EQUALS element at position i PLUS one of nums DO  \n                INCREMENT i BY one  \n            END WHILE  \n            CALL dfs WITH argument i PLUS one  \n        END FUNCTION  \n        \n        CALL dfs WITH argument zero  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decode-ways", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDecodings(s)  \n        IF s EQUALS empty string OR element at position zero of s EQUALS character zero  \n            RETURN zero  \n        END IF  \n        \n        SET dp TO list of zero repeated the LENGTH OF s PLUS one times  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        \n        FOR i FROM two TO the LENGTH OF s PLUS one  \n            IF element at position i MINUS one of s NOT EQUALS character zero  \n                INCREMENT element at position i of dp BY element at position i MINUS one of dp  \n            END IF  \n            \n            SET two_digit TO integer value of substring from position i MINUS two TO position i of s  \n            IF two_digit GREATER THAN OR EQUAL TO ten AND two_digit LESS THAN OR EQUAL TO twenty six  \n                INCREMENT element at position i of dp BY element at position i MINUS two of dp  \n            END IF  \n        END FOR  \n        \n        RETURN element at the last position of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-ip-addresses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION restoreIpAddresses(s)  \n        FUNCTION is_valid(segment)  \n            RETURN the LENGTH OF segment EQUALS one OR (the element at position one of segment NOT EQUALS zero AND the number represented by segment LESS THAN OR EQUAL TO two hundred and fifty five)  \n        END FUNCTION  \n        \n        FUNCTION backtrack(start, path)  \n            IF the LENGTH OF path EQUALS four THEN  \n                IF start EQUALS the LENGTH OF s THEN  \n                    APPEND the concatenation of elements in path separated by the word dot TO result  \n                END IF  \n                RETURN  \n            END IF  \n            FOR length FROM one TO three  \n                IF start PLUS length LESS THAN OR EQUAL TO the LENGTH OF s THEN  \n                    SET segment TO the substring of s from position start TO the position start PLUS length MINUS one  \n                    IF is_valid(segment) THEN  \n                        CALL backtrack WITH start PLUS length AND path PLUS list containing segment  \n                    END IF  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        CALL backtrack WITH zero AND empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-binary-search-trees", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numTrees(n)  \n        SET dp TO a list of zeros of length n PLUS one  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            FOR j FROM one TO i  \n                SET element at position i of dp TO element at position i of dp PLUS element at position j MINUS one of dp MULTIPLIED BY element at position i MINUS j of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "interleaving-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isInterleave(s1 s2 s3)  \n        IF the LENGTH OF s1 PLUS the LENGTH OF s2 NOT EQUALS the LENGTH OF s3  \n            RETURN false  \n        END IF  \n\n        SET dp TO a list of boolean false values with the length of the LENGTH OF s2 PLUS one  \n        SET element at position zero of dp TO true  \n\n        FOR i FROM zero TO the LENGTH OF s1  \n            FOR j FROM zero TO the LENGTH OF s2  \n                IF i GREATER THAN zero  \n                    SET element at position j of dp TO the logical AND of element at position j of dp AND the condition that element at position i MINUS one of s1 EQUALS element at position i PLUS j MINUS one of s3  \n                END IF  \n                IF j GREATER THAN zero  \n                    SET element at position j of dp TO the logical OR of element at position j of dp AND the logical AND of element at position j MINUS one of dp AND the condition that element at position j MINUS one of s2 EQUALS element at position i PLUS j MINUS one of s3  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN element at position the LENGTH OF s2 of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDistinct(s, t)  \n        SET m TO the LENGTH OF s  \n        SET n TO the LENGTH OF t  \n        \n        CREATE dp AS a two dimensional list OF size m PLUS one BY n PLUS one FILLED WITH zeros  \n        \n        FOR i FROM zero TO m  \n            SET the element at position i AND zero OF dp TO one  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF the element at position i MINUS one OF s EQUALS the element at position j MINUS one OF t THEN  \n                    SET the element at position i AND j OF dp TO the element at position i MINUS one AND j MINUS one OF dp PLUS the element at position i MINUS one AND j OF dp  \n                ELSE  \n                    SET the element at position i AND j OF dp TO the element at position i MINUS one AND j OF dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN the element at position m AND n OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "triangle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTotal(triangle)  \n        FOR row FROM the LENGTH OF triangle MINUS two TO zero DECREASING BY one  \n            FOR col FROM zero TO the LENGTH OF element at position row of triangle MINUS one  \n                SET element at position row at position col of triangle TO element at position row at position col of triangle PLUS the MINIMUM of element at position row PLUS one at position col of triangle AND element at position row PLUS one at position col PLUS one of triangle  \n            END FOR  \n        END FOR  \n        RETURN element at position zero at position zero of triangle  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices)  \n        SET max_profit TO zero  \n        FOR i FROM one TO the LENGTH OF prices MINUS one  \n            IF element at position i of prices GREATER THAN element at position i MINUS one of prices  \n                INCREMENT max_profit BY element at position i of prices MINUS element at position i MINUS one of prices  \n            END IF  \n        END FOR  \n        RETURN max_profit  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices)  \n        IF the collection prices is empty  \n            RETURN zero  \n        END IF  \n        SET min_price1 TO positive infinity  \n        SET min_price2 TO positive infinity  \n        SET max_profit1 TO zero  \n        SET max_profit2 TO zero  \n        FOR each element price IN the collection prices  \n            IF price LESS THAN min_price1  \n                SET min_price1 TO price  \n            END IF  \n            IF price MINUS min_price1 GREATER THAN max_profit1  \n                SET max_profit1 TO price MINUS min_price1  \n            END IF  \n            IF price MINUS max_profit1 LESS THAN min_price2  \n                SET min_price2 TO price MINUS max_profit1  \n            END IF  \n            IF price MINUS min_price2 GREATER THAN max_profit2  \n                SET max_profit2 TO price MINUS min_price2  \n            END IF  \n        END FOR  \n        RETURN max_profit2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-ladder", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION ladderLength(beginWord endWord wordList)  \n        IF endWord NOT IN wordList THEN  \n            RETURN zero  \n        END IF  \n        \n        SET word_dict TO empty dictionary where each key maps to an empty list  \n        SET word_length TO the LENGTH OF beginWord  \n        \n        FOR each word IN wordList  \n            FOR i FROM zero TO word_length MINUS one  \n                SET intermediate_key TO concatenation of substring from position zero TO position i MINUS one of word PLUS the character symbol called star PLUS substring from position i PLUS one TO position word_length MINUS one of word  \n                APPEND word TO the list in word_dict associated with intermediate_key  \n            END FOR  \n        END FOR  \n        \n        SET queue TO an empty double ended queue initialized with tuple containing beginWord and one  \n        SET visited TO a set initialized with beginWord  \n        \n        WHILE queue is not empty  \n            REMOVE and ASSIGN the first tuple from queue TO current_word and current_length  \n            \n            FOR i FROM zero TO word_length MINUS one  \n                SET intermediate_word TO concatenation of substring from position zero TO position i MINUS one of current_word PLUS the character symbol called star PLUS substring from position i PLUS one TO position word_length MINUS one of current_word  \n                \n                FOR each word IN the list from word_dict associated with intermediate_word  \n                    IF word EQUALS endWord THEN  \n                        RETURN current_length PLUS one  \n                    END IF  \n                    IF word NOT IN visited THEN  \n                        ADD word TO visited  \n                        APPEND tuple containing word and current_length PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n        \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-consecutive-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestConsecutive(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET num_set TO the SET OF elements IN nums  \n        SET longest_streak TO zero  \n        \n        FOR each num IN num_set  \n            IF the element AT position the VALUE OF num MINUS one IS NOT IN num_set THEN  \n                SET current_num TO num  \n                SET current_streak TO one  \n                \n                WHILE the element AT position the VALUE OF current_num PLUS one IS IN num_set  \n                    INCREMENT current_num BY one  \n                    INCREMENT current_streak BY one  \n                END WHILE  \n                \n                IF current_streak GREATER THAN longest_streak THEN  \n                    SET longest_streak TO current_streak  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN longest_streak  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "surrounded-regions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solve(board)  \n        IF board EQUALS empty OR the element at position zero of board EQUALS empty THEN  \n            RETURN  \n        END IF  \n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF the element at position zero of board  \n        FUNCTION dfs(x, y)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of board at position y NOT EQUALS string O THEN  \n                RETURN  \n            END IF  \n            SET the element at position x of board at position y TO string S  \n            CALL dfs with x PLUS one and y  \n            CALL dfs with x MINUS one and y  \n            CALL dfs with x and y PLUS one  \n            CALL dfs with x and y MINUS one  \n        END FUNCTION  \n        FOR i FROM zero TO m MINUS one  \n            CALL dfs with i and zero  \n            CALL dfs with i and n MINUS one  \n        END FOR  \n        FOR j FROM zero TO n MINUS one  \n            CALL dfs with zero and j  \n            CALL dfs with m MINUS one and j  \n        END FOR  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the element at position i of board at position j EQUALS string O THEN  \n                    SET the element at position i of board at position j TO string X  \n                END IF  \n            END FOR  \n        END FOR  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the element at position i of board at position j EQUALS string S THEN  \n                    SET the element at position i of board at position j TO string O  \n                END IF  \n            END FOR  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION partition(s)  \n        FUNCTION is_palindrome(sub)  \n            RETURN sub EQUALS reverse of sub  \n        END FUNCTION  \n        \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF s  \n                APPEND path TO result  \n                RETURN  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF s PLUS one  \n                IF is_palindrome(substring from position start TO position end MINUS one of s)  \n                    CALL backtrack WITH end AND path PLUS list containing substring from position start TO position end MINUS one of s  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        CALL backtrack WITH zero AND empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "candy", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION candy WITH PARAMETER ratings  \n        SET n TO the LENGTH OF ratings  \n        SET candies TO a list of size n where each element IS one  \n        FOR i FROM two TO n  \n            IF element at position i of ratings GREATER THAN element at position i MINUS one of ratings  \n                SET element at position i of candies TO element at position i MINUS one of candies PLUS one  \n            END IF  \n        END FOR  \n        FOR i FROM n MINUS one MINUS one DOWN TO one  \n            IF element at position i of ratings GREATER THAN element at position i PLUS one of ratings  \n                IF element at position i of candies LESS THAN element at position i PLUS one of candies PLUS one  \n                    SET element at position i of candies TO element at position i PLUS one of candies PLUS one  \n                END IF  \n            END IF  \n        END FOR  \n        SET total_candies TO zero  \n        FOR each candy_count IN candies  \n            INCREMENT total_candies BY candy_count  \n        END FOR  \n        RETURN total_candies  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-break", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordBreak(s string, wordDict list of string) RETURNS boolean  \n        SET wordSet TO set of elements in wordDict  \n        SET dp TO list of boolean values of length the LENGTH OF s PLUS one  \n        SET element at position zero of dp TO true  \n        \n        FOR index i FROM one TO the LENGTH OF s PLUS one  \n            FOR index j FROM zero TO i MINUS one  \n                IF element at position j of dp EQUALS true AND the substring from position j TO position i MINUS one of s IS IN wordSet  \n                    SET element at position i of dp TO true  \n                    BREAK inner loop  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position the LENGTH OF s of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-break-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordBreak(s, wordDict)  \n        SET wordSet TO the SET of all elements IN wordDict  \n        SET memo TO an empty MAPPING FROM integers TO lists of strings  \n        \n        FUNCTION backtrack(start)  \n            IF start IS PRESENT IN memo THEN  \n                RETURN the VALUE ASSOCIATED WITH start IN memo  \n            END IF  \n            IF start EQUALS the LENGTH OF s THEN  \n                RETURN a LIST CONTAINING an EMPTY STRING  \n            END IF  \n            \n            SET res TO an EMPTY LIST  \n            FOR end FROM start PLUS one TO the LENGTH OF s INCLUSIVE  \n                SET word TO the SUBSTRING OF s FROM position start TO position end MINUS one  \n                IF word IS PRESENT IN wordSet THEN  \n                    FOR each sentence IN backtrack(end)  \n                        IF sentence EQUALS an EMPTY STRING THEN  \n                            APPEND word TO res  \n                        ELSE  \n                            APPEND word PLUS a SINGLE SPACE PLUS sentence TO res  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            \n            SET memo AT start TO res  \n            RETURN res  \n        END FUNCTION  \n        \n        RETURN backtrack WITH argument zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "evaluate-reverse-polish-notation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION evalRPN(tokens)  \n        SET stack TO an empty list  \n        FOR each token IN tokens  \n            IF token EQUALS one of the symbols plus MINUS MULTIPLY DIVIDE  \n                SET b TO the last element removed from stack  \n                SET a TO the last element removed from stack  \n                IF token EQUALS plus  \n                    APPEND a PLUS b TO stack  \n                ELSE IF token EQUALS minus  \n                    APPEND a MINUS b TO stack  \n                ELSE IF token EQUALS multiply  \n                    APPEND a MULTIPLIED BY b TO stack  \n                ELSE IF token EQUALS divide  \n                    APPEND the integer value of a DIVIDED BY b TO stack  \n                END IF  \n            ELSE  \n                APPEND the integer value of token TO stack  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-words-in-a-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        SET words TO list of words obtained by splitting s by spaces where multiple spaces are handled automatically  \n        REVERSE the order of elements in words  \n        RETURN single string obtained by joining elements of words with single spaces between them  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        SET max_product TO element at position one of nums  \n        SET min_product TO element at position one of nums  \n        SET result TO element at position one of nums  \n        FOR each num IN elements of nums starting from position two to the end  \n            IF num LESS THAN zero THEN  \n                SET temporary TO max_product  \n                SET max_product TO min_product  \n                SET min_product TO temporary  \n            END IF  \n            IF num GREATER THAN max_product MULTIPLIED BY num THEN  \n                SET max_product TO num  \n            ELSE  \n                SET max_product TO max_product MULTIPLIED BY num  \n            END IF  \n            IF num LESS THAN min_product MULTIPLIED BY num THEN  \n                SET min_product TO num  \n            ELSE  \n                SET min_product TO min_product MULTIPLIED BY num  \n            END IF  \n            IF result GREATER THAN max_product THEN  \n                SET result TO result  \n            ELSE  \n                SET result TO max_product  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-minimum-in-rotated-sorted-array-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMin(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        WHILE left IS LESS THAN right  \n            SET mid TO the whole number result of left PLUS right DIVIDED BY two  \n            IF the element at position mid of nums IS GREATER THAN the element at position right of nums  \n                SET left TO mid PLUS one  \n            ELSE IF the element at position mid of nums IS LESS THAN the element at position right of nums  \n                SET right TO mid  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN the element at position left of nums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-with-at-most-two-distinct-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLongestSubstringTwoDistinct(s)  \n        SET char_count TO a dictionary with default integer values  \n        SET left TO zero  \n        SET max_length TO zero  \n        \n        FOR right FROM zero TO the LENGTH OF s MINUS one  \n            INCREMENT the count of the character at position right of s IN char_count BY one  \n            \n            WHILE the NUMBER OF KEYS IN char_count IS GREATER THAN two  \n                DECREMENT the count of the character at position left of s IN char_count BY one  \n                IF the count of the character at position left of s IN char_count EQUALS zero  \n                    REMOVE the character at position left of s FROM char_count  \n                END IF  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            SET max_length TO the GREATER VALUE BETWEEN max_length AND right MINUS left PLUS one  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "one-edit-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isOneEditDistance(s, t)  \n        IF the LENGTH OF s GREATER THAN the LENGTH OF t  \n            RETURN the RESULT OF isOneEditDistance WITH PARAMETERS t AND s  \n        END IF  \n        SET diff TO the LENGTH OF t MINUS the LENGTH OF s  \n        IF diff GREATER THAN one  \n            RETURN false  \n        END IF  \n        IF diff EQUALS zero  \n            SET difference_count TO zero  \n            FOR index FROM zero TO the LENGTH OF s MINUS one  \n                IF the element at position index of s NOT EQUALS the element at position index of t  \n                    INCREMENT difference_count BY one  \n                END IF  \n            END FOR  \n            RETURN whether difference_count EQUALS one  \n        ELSE  \n            FOR index FROM zero TO the LENGTH OF s MINUS one  \n                IF the element at position index of s NOT EQUALS the element at position index of t  \n                    RETURN whether the substring from position index TO the END of s EQUALS the substring from position index PLUS one TO the END of t  \n                END IF  \n            END FOR  \n            RETURN true  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-peak-element", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPeakElement(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right DIVIDED BY two using integer division  \n            IF element at position mid of nums GREATER THAN element at position mid PLUS one of nums  \n                SET right TO mid  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "compare-version-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION compareVersion(version1, version2)  \n        SET v1_revisions TO the list obtained by splitting version1 by the character that represents a dot  \n        SET v2_revisions TO the list obtained by splitting version2 by the character that represents a dot  \n        SET max_length TO the larger value between the length of v1_revisions AND the length of v2_revisions  \n        FOR index FROM zero TO max_length MINUS one  \n            IF index LESS THAN the length of v1_revisions  \n                SET v1 TO the integer value of the element at position index of v1_revisions  \n            ELSE  \n                SET v1 TO zero  \n            END IF  \n            IF index LESS THAN the length of v2_revisions  \n                SET v2 TO the integer value of the element at position index of v2_revisions  \n            ELSE  \n                SET v2 TO zero  \n            END IF  \n            IF v1 LESS THAN v2  \n                RETURN negative one  \n            ELSE IF v1 GREATER THAN v2  \n                RETURN one  \n            END IF  \n        END FOR  \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "fraction-to-recurring-decimal", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "factorial-trailing-zeroes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION trailingZeroes(n)  \n        SET count TO zero  \n        WHILE n GREATER THAN zero  \n            SET n TO the INTEGER DIVISION of n BY five  \n            INCREMENT count BY n  \n        END WHILE  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dungeon-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION calculateMinimumHP(dungeon)  \n        SET m TO the LENGTH OF dungeon  \n        SET n TO the LENGTH OF element at position zero of dungeon  \n        SET dp TO a two-dimensional list with m PLUS one rows and n PLUS one columns each initialized to positive infinity  \n        SET element at position m of dp and position n MINUS one TO one  \n        SET element at position m MINUS one of dp and position n TO one  \n        FOR i FROM m MINUS one DOWN TO zero  \n            FOR j FROM n MINUS one DOWN TO zero  \n                SET min_health TO the SMALLER OF element at position i PLUS one of dp and position j AND element at position i of dp and position j PLUS one MINUS element at position i of dungeon and position j  \n                IF min_health GREATER THAN one  \n                    SET element at position i of dp and position j TO min_health  \n                ELSE  \n                    SET element at position i of dp and position j TO one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position zero of dp and position zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestNumber(nums)  \n        SET nums_str TO a new list containing string conversions of each element in nums  \n        \n        FUNCTION compare(x, y)  \n            IF the concatenation of x WITH y is GREATER THAN the concatenation of y WITH x  \n                RETURN negative one  \n            ELSE IF the concatenation of x WITH y is LESS THAN the concatenation of y WITH x  \n                RETURN positive one  \n            ELSE  \n                RETURN zero  \n            END IF  \n        END FUNCTION  \n        \n        CALL the sort method on nums_str USING the comparison function compare as the key  \n        \n        IF element at position zero of nums_str EQUALS the string zero  \n            RETURN the string zero  \n        END IF  \n        \n        RETURN the concatenation of all elements in nums_str in order  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-words-in-a-string-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        CALL the reversal of the entire sequence s  \n        SET start TO zero  \n        FOR each end FROM zero TO the length of the sequence s MINUS one  \n            IF element at position end of sequence s EQUALS a space character  \n                CALL the reversal of the subsequence of s from position start TO position end MINUS one  \n                SET start TO end PLUS one  \n            END IF  \n        END FOR  \n        CALL the reversal of the subsequence of s from position start TO the last position of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "repeated-dna-sequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRepeatedDnaSequences WITH PARAMETER s  \n        SET sequence_count TO an empty dictionary that defaults to zero for any new key  \n        FOR index i FROM zero TO the length of s MINUS nine  \n            SET sequence TO the substring from position i TO position i PLUS ten MINUS one of s  \n            INCREMENT the value associated with sequence in sequence_count BY one  \n        END FOR  \n        SET repeated_sequences TO an empty list  \n        FOR each key sequence AND each value count IN the items of sequence_count  \n            IF count GREATER THAN one THEN  \n                APPEND sequence TO repeated_sequences  \n            END IF  \n        END FOR  \n        RETURN repeated_sequences  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(k  \n                      prices)  \n        IF length of prices EQUALS zero OR k EQUALS zero  \n            RETURN zero  \n        END IF  \n        \n        SET n TO length of prices  \n        \n        IF k GREATER THAN OR EQUAL TO n DIVIDED BY two  \n            SET profit TO zero  \n            FOR index FROM two TO n  \n                IF element at position index of prices GREATER THAN element at position index MINUS one of prices  \n                    INCREMENT profit BY element at position index of prices MINUS element at position index MINUS one of prices  \n                END IF  \n            END FOR  \n            RETURN profit  \n        END IF  \n        \n        SET hold TO a list of length k PLUS one FILLED with negative infinity  \n        SET release TO a list of length k PLUS one FILLED with zero  \n        \n        FOR each price IN prices  \n            FOR i FROM one TO k  \n                SET hold at position i TO the maximum of hold at position i AND release at position i MINUS one MINUS price  \n                SET release at position i TO the maximum of release at position i AND hold at position i PLUS price  \n            END FOR  \n        END FOR  \n        \n        RETURN release at position k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rotate(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET k TO the REMAINDER OF k DIVIDED BY n  \n        \n        FUNCTION reverse(start end)  \n            WHILE start LESS THAN end  \n                SET temporary TO element at position start of nums  \n                SET element at position start of nums TO element at position end of nums  \n                SET element at position end of nums TO temporary  \n                INCREMENT start BY one  \n                DECREMENT end BY one  \n            END WHILE  \n        END FUNCTION  \n        \n        CALL reverse WITH zero AND n MINUS one  \n        CALL reverse WITH zero AND k MINUS one  \n        CALL reverse WITH k AND n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "house-robber", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rob(nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN zero  \n        END IF  \n        IF the LENGTH OF nums EQUALS one  \n            RETURN the element at position zero of nums  \n        END IF  \n        SET dp TO a list of zeros with the LENGTH OF nums  \n        SET the element at position zero of dp TO the element at position zero of nums  \n        IF the element at position zero of nums GREATER THAN OR EQUAL TO the element at position one of nums  \n            SET the element at position one of dp TO the element at position zero of nums  \n        ELSE  \n            SET the element at position one of dp TO the element at position one of nums  \n        END IF  \n        FOR index i FROM two TO the LENGTH OF nums MINUS one  \n            IF the element at position i MINUS one of dp GREATER THAN OR EQUAL TO the element at position i MINUS two of dp PLUS the element at position i of nums  \n                SET the element at position i of dp TO the element at position i MINUS one of dp  \n            ELSE  \n                SET the element at position i of dp TO the element at position i MINUS two of dp PLUS the element at position i of nums  \n            END IF  \n        END FOR  \n        RETURN the element at the last position of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bitwise-and-of-numbers-range", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rangeBitwiseAnd(left PARAMETER, right PARAMETER)  \n        SET shift TO zero  \n        WHILE left LESS THAN right  \n            SET left TO the integer division of left BY two  \n            SET right TO the integer division of right BY two  \n            INCREMENT shift BY one  \n        END WHILE  \n        SET result TO the multiplication of left BY two RAISED TO THE power of shift  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-primes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canFinish(numCourses, prerequisites)  \n        CREATE graph AS a mapping from a key to a list of values with default empty list  \n        SET indegree TO a list of zeros with length equal to numCourses  \n        \n        FOR each pair of course and prereq IN prerequisites  \n            APPEND course TO list associated with prereq in graph  \n            INCREMENT value at position course of indegree BY one  \n        END FOR  \n        \n        CREATE queue AS a double ended queue initialized with each course in range from zero TO numCourses MINUS one WHERE value at position course of indegree EQUALS zero  \n        \n        WHILE queue is not empty  \n            REMOVE and RETURN leftmost element from queue TO current_course  \n            DECREMENT numCourses BY one  \n            \n            FOR each next_course IN list associated with current_course in graph  \n                DECREMENT value at position next_course of indegree BY one  \n                IF value at position next_course of indegree EQUALS zero  \n                    APPEND next_course TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN whether numCourses EQUALS zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-size-subarray-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSubArrayLen(target parameter, nums parameter)  \n        SET left TO zero  \n        SET current sum TO zero  \n        SET min length TO a quantity greater than any real number  \n        FOR right FROM zero TO the LENGTH OF nums MINUS one  \n            INCREMENT current sum BY the element at position right of nums  \n            WHILE current sum GREATER THAN OR EQUAL TO target parameter holds  \n                SET min length TO the lesser BETWEEN min length AND right MINUS left PLUS one  \n                DECREMENT current sum BY the element at position left of nums  \n                INCREMENT left BY one  \n            END WHILE  \n        END FOR  \n        IF min length NOT EQUALS a quantity greater than any real number THEN  \n            RETURN min length  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findOrder(numCourses, prerequisites)  \n        SET adj_list TO an empty collection mapping each course FROM zero TO numCourses MINUS one TO an empty list  \n        SET in_degrees TO a list of zeros WITH length numCourses  \n        \n        FOR each pair of destination_course AND source_course IN prerequisites  \n            APPEND destination_course TO the list at key source_course in adj_list  \n            INCREMENT in_degrees element at position destination_course BY one  \n        END FOR  \n        \n        SET queue TO a collection of courses FROM zero TO numCourses MINUS one WHERE the in_degrees element at position course EQUALS zero  \n        SET topological_order TO an empty list  \n        \n        WHILE queue is not empty  \n            SET current TO the first element removed FROM queue  \n            APPEND current TO topological_order  \n            \n            FOR each neighbor IN the list at key current IN adj_list  \n                DECREMENT in_degrees element at position neighbor BY one  \n                IF in_degrees element at position neighbor EQUALS zero  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        IF the length of topological_order EQUALS numCourses  \n            RETURN topological_order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "house-robber-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rob(nums)  \n        FUNCTION rob_linear(houses)  \n            IF the collection of houses IS EMPTY THEN  \n                RETURN zero  \n            END IF  \n            IF the LENGTH OF houses EQUALS one THEN  \n                RETURN the element at position one of houses  \n            END IF  \n            SET dp TO a new list of zeros with the LENGTH OF houses  \n            SET the element at position one of dp TO the element at position one of houses  \n            SET the element at position two of dp TO the GREATER OF the element at position one of houses AND the element at position two of houses  \n            FOR i FROM three TO the LENGTH OF houses  \n                SET the element at position i of dp TO the GREATER OF the element at position i MINUS one of dp AND the SUM OF the element at position i MINUS two of dp PLUS the element at position i of houses  \n            END FOR  \n            RETURN the element at the last position of dp  \n        END FUNCTION  \n        IF the collection nums IS EMPTY THEN  \n            RETURN zero  \n        END IF  \n        IF the LENGTH OF nums EQUALS one THEN  \n            RETURN the element at position one of nums  \n        END IF  \n        RETURN the GREATER OF the RESULT OF rob_linear with the SUBSEQUENCE of nums FROM position one TO the position BEFORE the last element AND the RESULT OF rob_linear with the SUBSEQUENCE of nums FROM the second element TO the last element  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-palindrome", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPalindrome(s)  \n        IF s EQUALS nothing  \n            RETURN s  \n        END IF  \n          \n        FUNCTION is_palindrome(check_str)  \n            RETURN check_str EQUALS reverse_of check_str  \n        END FUNCTION  \n          \n        FOR i FROM the LENGTH OF s DOWN TO zero  \n            IF is_palindrome(substring from position zero TO position i MINUS one of s)  \n                SET to_add TO reverse_of substring from position i TO the END OF s  \n                RETURN to_add PLUS s  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-largest-element-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findKthLargest(nums k)  \n        SET min_heap TO empty list  \n        FOR each num IN nums  \n            CALL push_element_in_heap min_heap num  \n            IF the LENGTH OF min_heap IS GREATER THAN k  \n                CALL pop_element_from_heap min_heap  \n            END IF  \n        END FOR  \n        RETURN element at position one of min_heap  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION push_element_in_heap(heap element)  \n    // abstract helper function for inserting element into heap  \nEND FUNCTION  \n\nFUNCTION pop_element_from_heap(heap)  \n    // abstract helper function for removing smallest element from heap  \nEND FUNCTION"}
{"task_id": "combination-sum-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum3(k n)  \n        FUNCTION backtrack(start path target k)  \n            IF target EQUALS zero AND k EQUALS zero  \n                APPEND copy of path TO result  \n                RETURN  \n            END IF  \n            IF target LESS THAN zero OR k LESS THAN zero  \n                RETURN  \n            END IF  \n            FOR i FROM start TO nine  \n                APPEND element i TO path  \n                CALL backtrack WITH arguments i PLUS one path target MINUS i k MINUS one  \n                REMOVE last element FROM path  \n            END FOR  \n        END FUNCTION  \n\n        SET result TO empty list  \n        CALL backtrack WITH arguments one empty list n k  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximal-square", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximalSquare(matrix)  \n        IF matrix EQUALS nothing OR element at position zero of matrix EQUALS nothing THEN  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET dp TO a list of lists of zeros with m PLUS one rows and n PLUS one columns  \n        SET max_side TO zero  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF element at position i MINUS one of matrix EQUALS nothing THEN CONTINUE // This line omitted as matrix check done before  \n                IF element at position j MINUS one of element at position i MINUS one of matrix EQUALS the character one THEN  \n                    SET dp at position i and j TO the MINIMUM OF dp at position i MINUS one and j AND dp at position i and j MINUS one AND dp at position i MINUS one and j MINUS one PLUS one  \n                    SET max_side TO the MAXIMUM OF max_side AND dp at position i and j  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_side MULTIPLIED BY max_side  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION computeArea(ax1 ay1 ax2 ay2 bx1 by1 bx2 by2)  \n        SET area1 TO the difference of ax2 MINUS ax1 MULTIPLIED BY the difference of ay2 MINUS ay1  \n        SET area2 TO the difference of bx2 MINUS bx1 MULTIPLIED BY the difference of by2 MINUS by1  \n        SET overlap_width TO the maximum of zero AND the difference of the minimum of ax2 AND bx2 MINUS the maximum of ax1 AND bx1  \n        SET overlap_height TO the maximum of zero AND the difference of the minimum of ay2 AND by2 MINUS the maximum of ay1 AND by1  \n        SET overlap_area TO overlap_width MULTIPLIED BY overlap_height  \n        SET total_area TO area1 PLUS area2 MINUS overlap_area  \n        RETURN total_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "majority-element-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each element m IN nums  \n            IF element m EQUALS value m1  \n                INCREMENT n1 BY one  \n            ELSE IF element m EQUALS value m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO element m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO element m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE the count of element m IN nums IS GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-digit-one", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countDigitOne(n)  \n        IF n LESS THAN OR EQUAL TO zero  \n            RETURN zero  \n        END IF  \n        \n        SET count TO zero  \n        SET factor TO one  \n        \n        WHILE factor LESS THAN OR EQUAL TO n  \n            SET lower_nums TO n MINUS n DIVIDED BY factor MULTIPLIED BY factor  \n            SET cur_num TO n DIVIDED BY factor MODULO ten  \n            SET higher_nums TO n DIVIDED BY factor MULTIPLIED BY ten  \n            \n            IF cur_num EQUALS zero  \n                INCREMENT count BY higher_nums MULTIPLIED BY factor  \n            ELSE IF cur_num EQUALS one  \n                INCREMENT count BY higher_nums MULTIPLIED BY factor PLUS lower_nums PLUS one  \n            ELSE  \n                INCREMENT count BY higher_nums PLUS one MULTIPLIED BY factor  \n            END IF  \n            \n            SET factor TO factor MULTIPLIED BY ten  \n        END WHILE  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "product-of-array-except-self", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION productExceptSelf(nums)  \n        SET n TO the LENGTH OF nums  \n        SET answer TO a list of one repeated n times  \n        SET left_product TO one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i of answer TO left_product  \n            SET left_product TO left_product MULTIPLIED BY element at position i of nums  \n        END FOR  \n        SET right_product TO one  \n        FOR i FROM n MINUS one DOWN TO zero  \n            SET element at position i of answer TO element at position i of answer MULTIPLIED BY right_product  \n            SET right_product TO right_product MULTIPLIED BY element at position i of nums  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-window-maximum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSlidingWindow(nums k)  \n        IF nums EQUALS empty OR k EQUALS zero  \n            RETURN empty list  \n        END IF  \n        ASSIGN reference TO an empty deque named deq  \n        ASSIGN reference TO an empty list named result  \n        FOR index i FROM zero TO the LENGTH OF nums MINUS one  \n            IF deq is not empty AND element at position zero of deq LESS THAN i MINUS k PLUS one  \n                REMOVE element at position zero FROM deq  \n            END IF  \n            WHILE deq is not empty AND element of nums at element at last position of deq LESS THAN element of nums at i  \n                REMOVE element at last position FROM deq  \n            END WHILE  \n            APPEND i TO deq  \n            IF i GREATER THAN OR EQUAL TO k MINUS one  \n                APPEND element of nums at element at position zero of deq TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "different-ways-to-add-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION diffWaysToCompute(expression)  \n        FUNCTION compute(left, right, operator)  \n            SET results TO an empty list  \n            FOR each l IN left  \n                FOR each r IN right  \n                    IF operator EQUALS the plus symbol  \n                        APPEND l PLUS r TO results  \n                    ELSE IF operator EQUALS the minus symbol  \n                        APPEND l MINUS r TO results  \n                    ELSE IF operator EQUALS the multiplication symbol  \n                        APPEND l MULTIPLIED BY r TO results  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        FUNCTION helper(sub_expr)  \n            IF the entirety of sub_expr CONSISTS OF DIGITS  \n                RETURN a list containing the integer value of sub_expr  \n            END IF  \n          \n            SET results TO an empty list  \n            FOR index i FROM zero TO the LENGTH OF sub_expr MINUS one  \n                IF the element at position i of sub_expr EQUALS any of the plus symbol OR the minus symbol OR the multiplication symbol  \n                    SET left_results TO helper(the substring of sub_expr from position zero TO position i MINUS one)  \n                    SET right_results TO helper(the substring of sub_expr from position i PLUS one TO the last position)  \n                    FOR each result IN compute(left_results, right_results, the element at position i of sub_expr)  \n                        APPEND result TO results  \n                    END FOR  \n                END IF  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n      \n        RETURN helper(expression)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-word-distance-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestWordDistance(wordsDict word_list OF STRINGS word1 word_string word2 word_string) RETURNS INTEGER  \n        SET min_distance TO positive infinity  \n        SET prev_word1 TO negative one  \n        SET prev_word2 TO negative one  \n        SET same_word TO word1 EQUALS word2  \n        \n        FOR each index i FROM zero TO the LENGTH OF wordsDict MINUS one  \n            SET word TO element at position i of wordsDict  \n            \n            IF word EQUALS word1  \n                IF same_word IS true  \n                    SET prev_word2 TO prev_word1  \n                END IF  \n                SET prev_word1 TO i  \n            END IF  \n            \n            IF word EQUALS word2  \n                IF same_word IS false  \n                    SET prev_word2 TO i  \n                END IF  \n            END IF  \n            \n            IF prev_word1 NOT EQUALS negative one AND prev_word2 NOT EQUALS negative one  \n                IF min_distance GREATER THAN absolute value of prev_word1 MINUS prev_word2  \n                    SET min_distance TO absolute value of prev_word1 MINUS prev_word2  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN min_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findStrobogrammatic WITH PARAMETER n  \n        FUNCTION dfs WITH PARAMETER u  \n            IF u EQUALS zero  \n                RETURN list containing empty string  \n            END IF  \n            IF u EQUALS one  \n                RETURN list containing string zero string one string eight  \n            END IF  \n            SET ans TO empty list  \n            FOR each v IN the result of dfs WITH PARAMETER u MINUS two  \n                FOR each pair l r IN the list of string pairs one one string eight eight string six nine string nine six  \n                    APPEND concatenation of l then v then r TO ans  \n                END FOR  \n                IF u NOT EQUALS n  \n                    APPEND concatenation of string zero then v then string zero TO ans  \n                END IF  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        RETURN dfs WITH PARAMETER n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            \n            IF n EQUALS one  \n                RETURN a list containing the string zero once the string one once the string eight  \n            END IF  \n            \n            SET middles TO the result of calling generate_strobogrammatic with arguments n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero PLUS middle PLUS zero TO result  \n                END IF  \n                APPEND the string one PLUS middle PLUS one TO result  \n                APPEND the string six PLUS middle PLUS nine TO result  \n                APPEND the string eight PLUS middle PLUS eight TO result  \n                APPEND the string nine PLUS middle PLUS six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN the result of calling generate_strobogrammatic with arguments length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of calling count_strobogrammatic with arguments low and high  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "group-shifted-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION groupStrings(strings)  \n        FUNCTION get_canonical_form(s)  \n            IF s EQUALS empty string  \n                RETURN empty string  \n            END IF  \n            SET canonical_form TO empty list  \n            FOR each character c IN s  \n                SET difference TO the character code of c MINUS the character code of element at position one of s  \n                SET wrapped_difference TO difference MODULO the cardinal number of letters in the English alphabet  \n                APPEND the string representation of wrapped_difference TO canonical_form  \n            END FOR  \n            SET joined_form TO the concatenation of elements of canonical_form separated by the single character comma  \n            RETURN joined_form  \n        END FUNCTION  \n        \n        SET groups TO a new default dictionary with default type of empty list  \n        \n        FOR each string s IN strings  \n            SET canonical_form TO get_canonical_form with argument s  \n            APPEND s TO element at key canonical_form OF groups  \n        END FOR  \n        \n        RETURN the list of all values contained in groups  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "factor-combinations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getFactors WITH parameter n  \n        FUNCTION backtrack WITH parameters start AND target  \n            FOR i FROM start TO the INTEGER PART OF the SQUARE ROOT OF target PLUS one  \n                IF the MODULO of target BY i EQUALS zero  \n                    APPEND the CONCATENATION of path AND the LIST containing i AND the QUOTIENT of target DIVIDED BY i TO result  \n                    APPEND i TO path  \n                    CALL backtrack WITH i AND the QUOTIENT of target DIVIDED BY i  \n                    REMOVE the LAST element FROM path  \n                END IF  \n            END FOR  \n        END FUNCTION  \n      \n        SET result TO an empty list  \n        SET path TO an empty list  \n        CALL backtrack WITH two AND n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "verify-preorder-sequence-in-binary-search-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION verifyPreorder(preorder)  \n        SET stack TO empty list  \n        SET lower_bound TO the smallest possible number  \n        \n        FOR each value IN preorder  \n            IF value LESS THAN lower_bound  \n                RETURN false  \n            END IF  \n            \n            WHILE the stack is not empty AND value GREATER THAN element at the last position of the stack  \n                SET lower_bound TO element at the last position of the stack  \n                REMOVE the element at the last position FROM stack  \n            END WHILE  \n            \n            APPEND value TO stack  \n        END FOR  \n        \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-house", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(costs)  \n        IF costs EQUALS no elements  \n            RETURN zero  \n        END IF  \n        \n        SET prev_red TO element at position zero first element of costs  \n        SET prev_blue TO element at position zero second element of costs  \n        SET prev_green TO element at position zero third element of costs  \n        \n        FOR index i FROM one TO the LENGTH OF costs MINUS one  \n            SET current_red TO element at position i first element of costs PLUS THE MINIMUM OF prev_blue AND prev_green  \n            SET current_blue TO element at position i second element of costs PLUS THE MINIMUM OF prev_red AND prev_green  \n            SET current_green TO element at position i third element of costs PLUS THE MINIMUM OF prev_red AND prev_blue  \n            \n            SET prev_red TO current_red  \n            SET prev_blue TO current_blue  \n            SET prev_green TO current_green  \n        END FOR  \n        \n        RETURN THE MINIMUM OF prev_red AND prev_blue AND prev_green  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "3sum-smaller", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION threeSumSmaller(nums PARAMETER, target PARAMETER) RETURNS integer  \n        CALL method sort ON nums  \n        SET count TO zero  \n        SET n TO the LENGTH OF nums  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET left TO i PLUS one  \n            SET right TO n MINUS one  \n            WHILE left LESS THAN right  \n                SET current_sum TO the element at position i of nums PLUS the element at position left of nums PLUS the element at position right of nums  \n                IF current_sum LESS THAN target  \n                    INCREMENT count BY right MINUS left  \n                    INCREMENT left BY one  \n                ELSE  \n                    DECREMENT right BY one  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "single-number-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION singleNumber(nums)  \n        SET xor_all TO zero  \n        FOR each num IN nums  \n            SET xor_all TO xor_all XOR num  \n        END FOR  \n        SET diff_bit TO the bitwise AND of xor_all AND the negative of xor_all  \n        SET num1 TO zero  \n        SET num2 TO zero  \n        FOR each num IN nums  \n            IF the bitwise AND of num AND diff_bit IS NOT EQUAL TO zero  \n                SET num1 TO num1 XOR num  \n            ELSE  \n                SET num2 TO num2 XOR num  \n            END IF  \n        END FOR  \n        RETURN list containing num1 AND num2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "graph-valid-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validTree(n, edges)  \n        IF the LENGTH OF edges NOT EQUALS the VALUE OF n MINUS one THEN  \n            RETURN false  \n        END IF  \n        \n        SET adj_list TO a MAPPING FROM each integer FROM zero TO n MINUS one TO an EMPTY LIST  \n        FOR each pair a AND b IN edges  \n            APPEND b TO the LIST at POSITION a OF adj_list  \n            APPEND a TO the LIST at POSITION b OF adj_list  \n        END FOR  \n        \n        SET visited TO an EMPTY SET  \n        \n        FUNCTION dfs(node)  \n            IF node IS AN ELEMENT OF visited THEN  \n                RETURN  \n            END IF  \n            ADD node TO visited  \n            FOR each neighbor IN the LIST at POSITION node OF adj_list  \n                CALL dfs WITH neighbor  \n            END FOR  \n        END FUNCTION  \n        \n        CALL dfs WITH zero  \n        \n        RETURN the LENGTH OF visited EQUALS n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ugly-number-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nthUglyNumber(n)  \n        SET ugly_numbers TO list containing the number one  \n        SET i2 TO zero  \n        SET i3 TO zero  \n        SET i5 TO zero  \n        WHILE the LENGTH OF ugly_numbers LESS THAN n  \n            SET next_multiple_of_2 TO element at position i2 of ugly_numbers MULTIPLIED BY two  \n            SET next_multiple_of_3 TO element at position i3 of ugly_numbers MULTIPLIED BY three  \n            SET next_multiple_of_5 TO element at position i5 of ugly_numbers MULTIPLIED BY five  \n            SET next_ugly_number TO the smallest value among next_multiple_of_2 next_multiple_of_3 and next_multiple_of_5  \n            APPEND next_ugly_number TO ugly_numbers  \n            IF next_ugly_number EQUALS next_multiple_of_2  \n                INCREMENT i2 BY one  \n            END IF  \n            IF next_ugly_number EQUALS next_multiple_of_3  \n                INCREMENT i3 BY one  \n            END IF  \n            IF next_ugly_number EQUALS next_multiple_of_5  \n                INCREMENT i5 BY one  \n            END IF  \n        END WHILE  \n        RETURN element at position n MINUS one of ugly_numbers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-house-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCostII(costs)  \n        IF costs EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF costs  \n        SET k TO the LENGTH OF element at position zero of costs  \n        \n        IF k EQUALS one  \n            IF n EQUALS one  \n                RETURN element at position zero at position zero of costs  \n            ELSE  \n                RETURN positive infinity  \n            END IF  \n        END IF  \n        \n        FOR i FROM one TO n MINUS one  \n            SET min_cost TO positive infinity  \n            SET min_cost_index TO negative one  \n            SET second_min_cost TO positive infinity  \n            \n            FOR j FROM zero TO k MINUS one  \n                IF element at position i MINUS one at position j of costs LESS THAN min_cost  \n                    SET second_min_cost TO min_cost  \n                    SET min_cost TO element at position i MINUS one at position j of costs  \n                    SET min_cost_index TO j  \n                ELSE IF element at position i MINUS one at position j of costs LESS THAN second_min_cost  \n                    SET second_min_cost TO element at position i MINUS one at position j of costs  \n                END IF  \n            END FOR  \n            \n            FOR j FROM zero TO k MINUS one  \n                IF j EQUALS min_cost_index  \n                    SET element at position i at position j of costs TO element at position i at position j of costs PLUS second_min_cost  \n                ELSE  \n                    SET element at position i at position j of costs TO element at position i at position j of costs PLUS min_cost  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET answer TO positive infinity  \n        FOR each cost IN element at position n MINUS one of costs  \n            IF cost LESS THAN answer  \n                SET answer TO cost  \n            END IF  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-permutation-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generatePalindromes WITH PARAMETER s  \n        FUNCTION dfs WITH PARAMETER t  \n            IF the LENGTH OF t EQUALS the LENGTH OF s  \n                APPEND t TO ans  \n                RETURN  \n            END IF  \n            FOR each character c AND its count v IN the items of cnt  \n                IF v GREATER THAN one  \n                    DECREMENT the count of character c in cnt BY two  \n                    CALL dfs WITH the concatenation of character c PLUS t PLUS character c  \n                    INCREMENT the count of character c in cnt BY two  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        ASSIGN cnt TO the counts of each character in s  \n        SET mid TO empty string  \n        FOR each character c AND its count v IN the items of cnt  \n            IF v MODULO two EQUALS one  \n                IF mid IS NOT empty string  \n                    RETURN empty list  \n                END IF  \n                SET mid TO character c  \n                DECREMENT the count of character c in cnt BY one  \n            END IF  \n        END FOR  \n        SET ans TO empty list  \n        CALL dfs WITH mid  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "h-index", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "h-index-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET n TO the LENGTH OF citations  \n        SET left TO zero  \n        SET right TO n MINUS one  \n        SET h_index TO zero  \n        \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS the DIFFERENCE BETWEEN right AND left DIVIDED BY two  \n            IF the element at position mid of citations IS GREATER THAN OR EQUAL TO n MINUS mid  \n                SET h_index TO n MINUS mid  \n                SET right TO mid MINUS one  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        \n        RETURN h_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-fence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numWays(n k)  \n        IF n EQUALS zero  \n            RETURN zero  \n        END IF  \n        IF n EQUALS one  \n            RETURN k  \n        END IF  \n        IF n EQUALS two  \n            RETURN k MULTIPLIED BY k  \n        END IF  \n        SET same TO k  \n        SET diff TO k MULTIPLIED BY the difference between k AND one  \n        SET total TO the sum of same AND diff  \n        FOR i FROM three TO the sum of n AND one  \n            SET new_same TO diff  \n            SET new_diff TO total MULTIPLIED BY the difference between k AND one  \n            SET same TO new_same  \n            SET diff TO new_diff  \n            SET total TO the sum of same AND diff  \n        END FOR  \n        RETURN total  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wiggle-sort", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wiggleSort(nums)  \n        SET less TO true  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one MINUS one  \n            IF less EQUALS true  \n                IF element at position i of nums GREATER THAN element at position i PLUS one of nums  \n                    SET temporary TO element at position i of nums  \n                    SET element at position i of nums TO element at position i PLUS one of nums  \n                    SET element at position i PLUS one of nums TO temporary  \n                END IF  \n            ELSE  \n                IF element at position i of nums LESS THAN element at position i PLUS one of nums  \n                    SET temporary TO element at position i of nums  \n                    SET element at position i of nums TO element at position i PLUS one of nums  \n                    SET element at position i PLUS one of nums TO temporary  \n                END IF  \n            END IF  \n            SET less TO NOT less  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "expression-add-operators", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION addOperators(num, target)  \n        FUNCTION dfs(index, path, value, prev)  \n            IF index EQUALS the LENGTH OF num  \n                IF value EQUALS target  \n                    APPEND path TO result  \n                END IF  \n                RETURN  \n            END IF  \n            \n            FOR i FROM index PLUS one TO the LENGTH OF num PLUS one  \n                SET operand TO the substring from position index TO position i MINUS one OF num  \n                IF the LENGTH OF operand GREATER THAN one AND the element at position one of operand EQUALS zero  \n                    CONTINUE TO the next iteration  \n                END IF  \n                \n                IF index EQUALS zero  \n                    CALL dfs WITH parameters i, operand, the integer value of operand, and the integer value of operand  \n                ELSE  \n                    CALL dfs WITH parameters i, the concatenation of path PLUS the plus operator PLUS operand, value PLUS the integer value of operand, and the integer value of operand  \n                    CALL dfs WITH parameters i, the concatenation of path PLUS the minus operator PLUS operand, value MINUS the integer value of operand, and the negative integer value of operand  \n                    CALL dfs WITH parameters i, the concatenation of path PLUS the multiplication operator PLUS operand, value MINUS prev PLUS prev MULTIPLIED BY the integer value of operand, prev MULTIPLIED BY the integer value of operand  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET result TO an empty list  \n        CALL dfs WITH parameters zero, an empty string, zero, zero  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "walls-and-gates", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wallsAndGates(rooms)  \n        IF rooms EQUALS empty OR the element at position zero of rooms EQUALS empty THEN  \n            RETURN  \n        END IF  \n        \n        SET rows TO the LENGTH OF rooms  \n        SET cols TO the LENGTH OF the element at position zero of rooms  \n        ASSIGN reference TO an empty double ended queue named queue  \n        \n        FOR r FROM zero TO rows MINUS one  \n            FOR c FROM zero TO cols MINUS one  \n                IF the element at position r of rooms AT position c EQUALS zero THEN  \n                    APPEND the tuple of r AND c TO queue  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        ASSIGN reference TO a list named directions CONTAINING the tuples of zero AND one, one AND zero, zero AND negative one, negative one AND zero  \n        \n        WHILE queue is NOT empty  \n            REMOVE AND RETURN the leftmost tuple FROM queue AND UNPACK INTO r AND c  \n            FOR each tuple in directions UNPACKED INTO dr AND dc  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF zero LESS THAN OR EQUAL TO nr AND nr LESS THAN rows AND zero LESS THAN OR EQUAL TO nc AND nc LESS THAN cols AND the element at position nr of rooms AT position nc EQUALS the integer two billion one hundred forty seven million four hundred eighty three thousand six hundred forty seven THEN  \n                    SET the element at position nr of rooms AT position nc TO the element at position r of rooms AT position c PLUS one  \n                    APPEND the tuple of nr AND nc TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-duplicate-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDuplicate(nums)  \n        FUNCTION f(x)  \n            SET count_of_values_less_than_or_equal_to_x TO zero  \n            FOR each value IN nums  \n                IF value LESS THAN OR EQUAL TO x  \n                    INCREMENT count_of_values_less_than_or_equal_to_x BY one  \n                END IF  \n            END FOR  \n            IF count_of_values_less_than_or_equal_to_x GREATER THAN x  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n        SET left_boundary TO zero  \n        SET right_boundary TO LENGTH OF nums MINUS one  \n        WHILE left_boundary LESS THAN right_boundary  \n            SET middle_point TO left_boundary PLUS right_boundary MINUS left_boundary DIVIDED BY two  \n            IF f(middle_point) EQUALS true  \n                SET right_boundary TO middle_point  \n            ELSE  \n                SET left_boundary TO middle_point PLUS one  \n            END IF  \n        END WHILE  \n        RETURN left_boundary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "game-of-life", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION gameOfLife(board)  \n        IF board EQUALS empty OR element at position zero of board EQUALS empty  \n            RETURN  \n        END IF  \n        \n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF element at position zero of board  \n        \n        SET directions TO the list containing pairs of values representing eight neighbor directions where first value is MINUS one AND second value is MINUS one PLUS first value MINUS one AND second value is zero PLUS first value MINUS one AND second value is one PLUS first value zero AND second value MINUS one PLUS first value zero AND second value one PLUS first value one AND second value MINUS one PLUS first value one AND second value zero PLUS first value one AND second value one  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET live_neighbors TO zero  \n                FOR each pair dx dy IN directions  \n                    SET ni TO i PLUS dx  \n                    SET nj TO j PLUS dy  \n                    IF ni GREATER THAN OR EQUAL TO zero AND ni LESS THAN m AND nj GREATER THAN OR EQUAL TO zero AND nj LESS THAN n AND (element at position ni of board at position nj EQUALS one OR element at position ni of board at position nj EQUALS three)  \n                        INCREMENT live_neighbors BY one  \n                    END IF  \n                END FOR  \n                \n                IF element at position i of board at position j EQUALS one  \n                    IF live_neighbors LESS THAN two OR live_neighbors GREATER THAN three  \n                        SET element at position i of board at position j TO three  \n                    END IF  \n                ELSE  \n                    IF live_neighbors EQUALS three  \n                        SET element at position i of board at position j TO two  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of board at position j EQUALS two  \n                    SET element at position i of board at position j TO one  \n                ELSE IF element at position i of board at position j EQUALS three  \n                    SET element at position i of board at position j TO zero  \n                END IF  \n            END FOR  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-pattern-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordPatternMatch(pattern pattern STRING, s s STRING) RETURNS BOOLEAN  \n        FUNCTION backtrack(pattern_index pattern_index INTEGER, string_index string_index INTEGER, mapping mapping DICTIONARY, used used SET) RETURNS BOOLEAN  \n            IF pattern_index EQUALS the LENGTH OF pattern AND string_index EQUALS the LENGTH OF s  \n                RETURN TRUE  \n            END IF  \n            IF pattern_index EQUALS the LENGTH OF pattern OR string_index EQUALS the LENGTH OF s  \n                RETURN FALSE  \n            END IF  \n            \n            SET current_char TO the element at position pattern_index of pattern  \n            IF current_char IS IN mapping  \n                SET word TO the value for key current_char in mapping  \n                IF the substring of s from position string_index TO position string_index PLUS the LENGTH OF word NOT EQUALS word  \n                    RETURN FALSE  \n                END IF  \n                IF backtrack with arguments pattern_index PLUS one, string_index PLUS the LENGTH OF word, mapping, used RETURNS TRUE  \n                    RETURN TRUE  \n                END IF  \n            ELSE  \n                FOR end FROM string_index PLUS one TO the LENGTH OF s PLUS one  \n                    SET word TO the substring of s from position string_index TO position end  \n                    IF word IS IN used  \n                        CONTINUE  \n                    END IF  \n                    SET the value for key current_char in mapping TO word  \n                    ADD word TO used  \n                    IF backtrack with arguments pattern_index PLUS one, end, mapping, used RETURNS TRUE  \n                        RETURN TRUE  \n                    END IF  \n                    REMOVE the key current_char FROM mapping  \n                    REMOVE word FROM used  \n                END FOR  \n            END IF  \n            \n            RETURN FALSE  \n        END FUNCTION  \n        \n        RETURN backtrack with arguments zero, zero, an empty dictionary, an empty set  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flip-game-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-meeting-point", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minTotalDistance(grid)  \n        SET rows TO empty list  \n        SET cols TO empty list  \n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position i of grid MINUS one  \n                IF element at position i of element at position j of grid EQUALS one  \n                    APPEND i TO rows  \n                    APPEND j TO cols  \n                END IF  \n            END FOR  \n        END FOR  \n        SORT rows  \n        SORT cols  \n        SET median_row TO element at position the LENGTH OF rows DIVIDED BY two of rows  \n        SET median_col TO element at position the LENGTH OF cols DIVIDED BY two of cols  \n        SET min_distance TO zero  \n        FOR each row IN rows  \n            SET difference TO row MINUS median_row  \n            IF difference LESS THAN zero  \n                SET difference TO difference MULTIPLIED BY negative one  \n            END IF  \n            INCREMENT min_distance BY difference  \n        END FOR  \n        FOR each col IN cols  \n            SET difference TO col MINUS median_col  \n            IF difference LESS THAN zero  \n                SET difference TO difference MULTIPLIED BY negative one  \n            END IF  \n            INCREMENT min_distance BY difference  \n        END FOR  \n        RETURN min_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulls-and-cows", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getHint(secret PARAMETER, guess PARAMETER)  \n        IMPORT a data structure that provides a dictionary with default zero values\n        \n        SET bulls TO zero  \n        SET cows TO zero  \n        \n        CREATE a dictionary named secret_count with default zero values  \n        CREATE a dictionary named guess_count with default zero values  \n        \n        FOR each element s and element g taken correspondingly from secret and guess  \n            IF element s EQUALS element g  \n                INCREMENT bulls BY one  \n            ELSE  \n                INCREMENT the value at key element s in secret_count BY one  \n                INCREMENT the value at key element g in guess_count BY one  \n            END IF  \n        END FOR  \n        \n        FOR each digit IN the keys of secret_count  \n            INCREMENT cows BY the smaller value BETWEEN the value at key digit in secret_count AND the value at key digit in guess_count  \n        END FOR  \n        \n        RETURN a string expressing bulls FOLLOWED BY the character representing bulls AND THEN cows FOLLOWED BY the character representing cows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-increasing-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLIS(nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN zero  \n        END IF  \n        \n        SET dp TO an empty list  \n        \n        FOR each num IN nums  \n            SET idx TO the insertion position found by locating the leftmost place of num in dp preserving order  \n            \n            IF idx EQUALS the LENGTH OF dp  \n                APPEND num TO dp  \n            ELSE  \n                SET the element at position idx of dp TO num  \n            END IF  \n        END FOR  \n        \n        RETURN the LENGTH OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-rectangle-enclosing-black-pixels", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minArea(image x y)  \n        IF image EQUALS empty OR element at position zero of image EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF image  \n        SET n TO the LENGTH OF element at position zero of image  \n        \n        FUNCTION hasBlackPixelInRow(row)  \n            FOR each pixel IN element at position row of image  \n                IF pixel EQUALS the character one  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        FUNCTION hasBlackPixelInColumn(col)  \n            FOR each row FROM zero TO m MINUS one  \n                IF element at position col of element at position row of image EQUALS the character one  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        FUNCTION findTop()  \n            SET low TO zero  \n            SET high TO x  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high DIVIDED BY two using integer division  \n                IF hasBlackPixelInRow(mid) EQUALS True  \n                    SET high TO mid  \n                ELSE  \n                    SET low TO mid PLUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        FUNCTION findBottom()  \n            SET low TO x  \n            SET high TO m MINUS one  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high PLUS one DIVIDED BY two using integer division  \n                IF hasBlackPixelInRow(mid) EQUALS True  \n                    SET low TO mid  \n                ELSE  \n                    SET high TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        FUNCTION findLeft()  \n            SET low TO zero  \n            SET high TO y  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high DIVIDED BY two using integer division  \n                IF hasBlackPixelInColumn(mid) EQUALS True  \n                    SET high TO mid  \n                ELSE  \n                    SET low TO mid PLUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        FUNCTION findRight()  \n            SET low TO y  \n            SET high TO n MINUS one  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high PLUS one DIVIDED BY two using integer division  \n                IF hasBlackPixelInColumn(mid) EQUALS True  \n                    SET low TO mid  \n                ELSE  \n                    SET high TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        SET top TO findTop()  \n        SET bottom TO findBottom()  \n        SET left TO findLeft()  \n        SET right TO findRight()  \n        \n        SET height TO bottom MINUS top PLUS one  \n        SET width TO right MINUS left PLUS one  \n        RETURN height MULTIPLIED BY width  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-islands-ii", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n\n    FUNCTION __init__(self)  \n        SET self.parent TO empty dictionary  \n        SET self.count TO zero  \n    END FUNCTION  \n\n    FUNCTION make_set(self, x)  \n        IF x NOT IN self.parent THEN  \n            SET element at position x of self.parent TO x  \n            INCREMENT self.count BY one  \n        END IF  \n    END FUNCTION  \n\n    FUNCTION find(self, x)  \n        IF element at position x of self.parent NOT EQUALS x THEN  \n            SET element at position x of self.parent TO self.find(the element at position x of self.parent)  \n        END IF  \n        RETURN element at position x of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, x, y)  \n        SET rootX TO self.find(x)  \n        SET rootY TO self.find(y)  \n        IF rootX NOT EQUALS rootY THEN  \n            SET element at position rootX of self.parent TO rootY  \n            DECREMENT self.count BY one  \n        END IF  \n    END FUNCTION  \n\nEND CLASS  \n\nCLASS Solution  \n\n    FUNCTION numIslands2(self, m, n, positions)  \n        \n        FUNCTION is_valid(x, y)  \n            RETURN the value of ((zero LESS THAN OR EQUAL TO x) AND (x LESS THAN m) AND (zero LESS THAN OR EQUAL TO y) AND (y LESS THAN n))  \n        END FUNCTION  \n        \n        SET directions TO list of pairs each consisting of an integer and zero or zero and integer for representing one step in each of four cardinal directions  \n        SET uf TO new instance of UnionFind  \n        SET grid TO list of m elements each being a list of n zeros  \n        SET result TO empty list  \n        \n        FOR each pair r comma c IN positions  \n            IF element at position r of grid at position c EQUALS one THEN  \n                APPEND uf.count TO result  \n                CONTINUE to next iteration of the loop  \n            END IF  \n            \n            SET element at position r of grid at position c TO one  \n            CALL uf.make_set with argument pair consisting of r and c  \n            \n            FOR each pair dr comma dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF is_valid(nr, nc) AND element at position nr of grid at position nc EQUALS one THEN  \n                    CALL uf.union with arguments pair consisting of r and c and pair consisting of nr and nc  \n                END IF  \n            END FOR  \n            \n            APPEND uf.count TO result  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \n\nEND CLASS"}
{"task_id": "additive-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isAdditiveNumber(num)  \n        FUNCTION is_valid_sequence(start, first, second)  \n            IF start EQUALS the LENGTH OF num  \n                RETURN True  \n            END IF  \n            \n            SET expected TO the STRING REPRESENTATION OF the SUM OF first PLUS second  \n            SET length TO the LENGTH OF expected  \n            \n            IF the SUM OF start PLUS length GREATER THAN the LENGTH OF num OR the SUBSTRING of num from position start TO the POSITION OF start PLUS length NOT EQUALS expected  \n                RETURN False  \n            END IF  \n            \n            RETURN the RESULT OF is_valid_sequence WITH the ARGUMENTS start PLUS length, second, the INTEGER REPRESENTATION OF expected  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF num  \n        FOR i FROM one TO the INTEGER DIVISION OF n BY two PLUS one  \n            FOR j FROM i PLUS one TO n  \n                SET first TO the SUBSTRING of num from position zero TO position i  \n                SET second TO the SUBSTRING of num from position i TO position j  \n                \n                IF the LENGTH OF first GREATER THAN one AND the FIRST CHARACTER of first EQUALS the CHARACTER zero OR the LENGTH OF second GREATER THAN one AND the FIRST CHARACTER of second EQUALS the CHARACTER zero  \n                    CONTINUE TO the NEXT ITERATION  \n                END IF  \n                \n                IF is_valid_sequence WITH the ARGUMENTS j, the INTEGER REPRESENTATION OF first, the INTEGER REPRESENTATION OF second EQUALS True  \n                    RETURN True  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-with-cooldown", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices)  \n        IF prices EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET n TO the LENGTH OF prices  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET hold TO negative infinity  \n        SET sold TO zero  \n        SET rest TO zero  \n        FOR each price IN prices  \n            SET new_hold TO the GREATER OF hold AND rest MINUS price  \n            SET new_sold TO hold PLUS price  \n            SET new_rest TO the GREATER OF rest AND sold  \n            SET hold TO new_hold  \n            SET sold TO new_sold  \n            SET rest TO new_rest  \n        END FOR  \n        RETURN the GREATER OF sold AND rest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sparse-matrix-multiplication", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION multiply(mat1, mat2)  \n        SET number_of_rows_in_mat1 TO the LENGTH OF mat1  \n        SET number_of_columns_in_mat1 TO the LENGTH OF element at position zero of mat1  \n        SET number_of_rows_in_mat2 TO the LENGTH OF mat2  \n        SET number_of_columns_in_mat2 TO the LENGTH OF element at position zero of mat2  \n        SET result TO an empty list  \n        FOR index_i FROM zero TO number_of_rows_in_mat1 MINUS one  \n            SET row TO an empty list  \n            FOR index_j FROM zero TO number_of_columns_in_mat2 MINUS one  \n                APPEND zero TO row  \n            END FOR  \n            APPEND row TO result  \n        END FOR  \n        FOR index_i FROM zero TO number_of_rows_in_mat1 MINUS one  \n            FOR index_j FROM zero TO number_of_columns_in_mat2 MINUS one  \n                FOR index_p FROM zero TO number_of_columns_in_mat1 MINUS one  \n                    SET element_at_position_index_i_of_result_at_position_index_j TO element at position index_i of result at position index_j PLUS element at position index_i of mat1 at position index_p MULTIPLIED BY element at position index_p of mat2 at position index_j  \n                    SET element at position index_i of result at position index_j TO element_at_position_index_i_of_result_at_position_index_j  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "burst-balloons", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxCoins(nums)  \n        SET nums TO a new list made by placing one at the beginning FOLLOWED BY all elements of nums FOLLOWED BY one at the end  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a two dimensional list of zeros with dimensions n BY n  \n        FOR length FROM two TO n MINUS one  \n            FOR i FROM zero TO n MINUS length MINUS one  \n                SET j TO i PLUS length  \n                FOR k FROM i PLUS one TO j MINUS one  \n                    SET coins TO element at position i of nums MULTIPLIED BY element at position k of nums MULTIPLIED BY element at position j of nums PLUS element at position i THEN k of dp PLUS element at position k THEN j of dp  \n                    IF element at position i THEN j of dp LESS THAN coins  \n                        SET element at position i THEN j of dp TO coins  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN element at position zero THEN n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-ugly-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nthSuperUglyNumber(n, primes)  \n        SET ugly_numbers TO a list containing one as the only element  \n        SET heap TO a list of pairs where each pair consists of an element from primes and its corresponding index in primes  \n        TRANSFORM heap INTO a min-heap structure  \n        SET indices TO a list of zeros with the length equal to the length of primes  \n        WHILE the LENGTH OF ugly_numbers IS LESS THAN n  \n            REMOVE the smallest pair from heap and DESTRUCTURE into next_ugly and prime_index  \n            IF next_ugly IS NOT EQUALS the last element of ugly_numbers  \n                APPEND next_ugly TO ugly_numbers  \n            END IF  \n            INCREMENT the element at position prime_index of indices BY one  \n            SET next_multiple TO the element at position prime_index of primes MULTIPLIED BY the element at the position indicated by the element at position prime_index of indices of ugly_numbers  \n            ADD the pair consisting of next_multiple and prime_index into the min-heap heap  \n        END WHILE  \n        RETURN the last element of ugly_numbers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-of-smaller-numbers-after-self", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSmaller(nums)  \n        SET sorted_nums TO a sorted list of unique elements of nums  \n        SET rank TO an empty dictionary  \n        SET index TO one  \n        FOR each value IN sorted_nums  \n            ASSIGN rank at key value TO index  \n            INCREMENT index BY one  \n        END FOR  \n        \n        SET bit TO a list of zeros of length the LENGTH OF sorted_nums PLUS one  \n        \n        FUNCTION get_sum(idx)  \n            SET res TO zero  \n            WHILE idx GREATER THAN zero  \n                INCREMENT res BY element at position idx of bit  \n                SET idx TO idx MINUS the bitwise AND of idx and the negative of idx (described as the largest power of two dividing idx)  \n            END WHILE  \n            RETURN res  \n        END FUNCTION  \n        \n        FUNCTION update(idx, delta)  \n            WHILE idx LESS THAN the LENGTH OF bit  \n                INCREMENT element at position idx of bit BY delta  \n                SET idx TO idx PLUS the bitwise AND of idx and the negative of idx (described as the largest power of two dividing idx)  \n            END WHILE  \n        END FUNCTION  \n        \n        SET counts TO an empty list  \n        FOR each number IN nums iterated from end to start  \n            SET r TO rank at key number  \n            APPEND the result of get_sum of r MINUS one TO counts  \n            CALL update with parameters r and one  \n        END FOR  \n        \n        RETURN counts reversed in order  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicate-letters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicateLetters(s)  \n        CREATE last_occurrence AS an empty dictionary mapping characters to indices  \n        FOR index FROM zero TO the LENGTH OF s MINUS one  \n            SET character TO element at position index of s  \n            SET the value associated to character in last_occurrence TO index  \n        END FOR  \n\n        CREATE stack AS an empty list  \n        CREATE in_stack AS an empty set  \n\n        FOR index FROM zero TO the LENGTH OF s MINUS one  \n            SET character TO element at position index of s  \n\n            IF character IS IN in_stack  \n                CONTINUE TO the next iteration  \n            END IF  \n\n            WHILE the LENGTH OF stack IS GREATER THAN zero AND character IS LESS THAN element at the last position of stack AND index IS LESS THAN the value associated to element at the last position of stack in last_occurrence  \n                SET removed_char TO the element popped from the end of stack  \n                REMOVE removed_char FROM in_stack  \n            END WHILE  \n\n            APPEND character TO stack  \n            ADD character TO in_stack  \n        END FOR  \n\n        SET result_string TO the concatenation of all elements in stack in order  \n        RETURN result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-distance-from-all-buildings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestDistance(grid)  \n        IF grid EQUALS the absence of any element OR element at position zero of grid EQUALS the absence of any element  \n            RETURN negative one  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET total_distance TO a two dimensional list of zeros with m rows and n columns  \n        SET reach_count TO a two dimensional list of zeros with m rows and n columns  \n        SET building_count TO zero  \n        \n        SET directions TO a list containing the pairs of one and zero, negative one and zero, zero and one, zero and negative one  \n        \n        FUNCTION bfs(start_x, start_y)  \n            SET queue TO a deque initialized with the tuple of start_x and start_y  \n            SET visited TO a two dimensional list of False values with m rows and n columns  \n            SET distance TO zero  \n            SET reachable TO zero  \n            \n            WHILE the LENGTH OF queue holds truth  \n                SET size TO the LENGTH OF queue  \n                INCREMENT distance BY one  \n                FOR each number FROM zero TO size MINUS one  \n                    SET x TO the first element of the tuple removed from the left of queue  \n                    SET y TO the second element of the tuple removed from the left of queue  \n                    FOR each pair dx, dy IN directions  \n                        SET nx TO x PLUS dx  \n                        SET ny TO y PLUS dy  \n                        IF nx LESS THAN m AND nx GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND ny GREATER THAN OR EQUAL TO zero AND element at position nx and ny of visited EQUALS False AND element at position nx and ny of grid EQUALS zero  \n                            SET element at position nx and ny of visited TO True  \n                            APPEND the tuple of nx and ny TO queue  \n                            INCREMENT element at position nx and ny of total_distance BY distance  \n                            INCREMENT element at position nx and ny of reach_count BY one  \n                            INCREMENT reachable BY one  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END WHILE  \n            RETURN reachable  \n        END FUNCTION  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i and j of grid EQUALS one  \n                    INCREMENT building_count BY one  \n                    IF bfs(i, j) LESS THAN building_count MINUS one  \n                        RETURN negative one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_distance TO infinity  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i and j of grid EQUALS zero AND element at position i and j of reach_count EQUALS building_count  \n                    IF element at position i and j of total_distance LESS THAN min_distance  \n                        SET min_distance TO element at position i and j of total_distance  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF min_distance NOT EQUALS infinity  \n            RETURN min_distance  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-word-lengths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters of word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the intersection of element at position i of word_sets AND element at position j of word_sets EQUALS empty set  \n                    SET product TO the LENGTH OF element at position i of words MULTIPLIED BY the LENGTH OF element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulb-switcher", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        RETURN the integer part of the square root of n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "generalized-abbreviation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generateAbbreviations(word)  \n        FUNCTION backtrack(index, path, count)  \n            IF index EQUALS the LENGTH OF word  \n                IF count GREATER THAN zero  \n                    APPEND the STRING REPRESENTATION OF count TO path  \n                END IF  \n                APPEND the CONCATENATION OF ELEMENTS IN path TO result  \n            ELSE  \n                IF count GREATER THAN zero  \n                    CALL backtrack WITH index PLUS one AS index argument  \n                        WITH path PLUS the STRING REPRESENTATION OF count PLUS the element at position index of word AS path argument  \n                        WITH zero AS count argument  \n                ELSE  \n                    CALL backtrack WITH index PLUS one AS index argument  \n                        WITH path PLUS the element at position index of word AS path argument  \n                        WITH zero AS count argument  \n                END IF  \n                CALL backtrack WITH index PLUS one AS index argument  \n                    WITH path AS path argument  \n                    WITH count PLUS one AS count argument  \n            END IF  \n        END FUNCTION  \n\n        SET result TO an empty list  \n        CALL backtrack WITH zero AS index argument  \n            WITH an empty list AS path argument  \n            WITH zero AS count argument  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "create-maximum-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxNumber(nums1 nums2 k)  \n        FUNCTION maxSingleArray(nums k)  \n            SET drop TO the LENGTH OF nums MINUS k  \n            SET stack TO an empty list  \n            FOR each num IN nums  \n                WHILE drop GREATER THAN zero AND the stack IS NOT empty AND the element at the last position of stack LESS THAN num  \n                    REMOVE the last element FROM stack  \n                    DECREMENT drop BY one  \n                END WHILE  \n                APPEND num TO stack  \n            END FOR  \n            RETURN the FIRST k elements OF stack  \n        END FUNCTION  \n  \n        FUNCTION merge(arr1 arr2)  \n            SET result TO an empty list  \n            WHILE the LENGTH OF arr1 PLUS the LENGTH OF arr2 GREATER THAN zero  \n                IF arr1 GREATER THAN arr2 IN LEXICOGRAPHICAL ORDER  \n                    APPEND the element at position zero of arr1 TO result  \n                    REMOVE the element at position zero FROM arr1  \n                ELSE  \n                    APPEND the element at position zero of arr2 TO result  \n                    REMOVE the element at position zero FROM arr2  \n                END IF  \n            END WHILE  \n            RETURN result  \n        END FUNCTION  \n  \n        SET max_number TO an empty list  \n        FOR i FROM zero TO k  \n            IF i LESS THAN OR EQUAL TO the LENGTH OF nums1 AND k MINUS i LESS THAN OR EQUAL TO the LENGTH OF nums2  \n                SET candidate TO the result of merging the result of maxSingleArray with nums1 and i AND the result of maxSingleArray with nums2 and k MINUS i  \n                IF max_number LESS THAN candidate IN LEXICOGRAPHICAL ORDER  \n                    SET max_number TO candidate  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_number  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-connected-components-in-an-undirected-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countComponents WITH PARAMETERS n edges  \n        SET graph TO an empty collection that maps each integer from zero TO n MINUS one TO an empty list  \n        FOR each pair a b IN edges  \n            APPEND element b TO the list at position a in graph  \n            APPEND element a TO the list at position b in graph  \n        END FOR  \n        SET visited TO an empty set  \n        FUNCTION dfs WITH PARAMETER node  \n            IF node IS IN visited THEN  \n                RETURN  \n            END IF  \n            ADD node TO visited  \n            FOR each neighbor IN the list at position node in graph  \n                CALL dfs WITH neighbor  \n            END FOR  \n        END FUNCTION  \n        SET components TO zero  \n        FOR node FROM zero TO n MINUS one  \n            IF node IS NOT IN visited THEN  \n                CALL dfs WITH node  \n                INCREMENT components BY one  \n            END IF  \n        END FOR  \n        RETURN components  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wiggle-sort-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wiggleSort(nums)  \n        CALL sort_nums_in_natural_order(nums)  \n        SET sorted_nums TO copy_of_all_elements_in nums  \n        SET n TO length_of nums  \n        SET left TO integer_division_of the difference of n AND one BY two  \n        SET right TO difference_of n AND one  \n        FOR i FROM zero TO difference_of n AND one  \n            IF remainder_of i DIVIDED BY two EQUALS zero  \n                SET element at position i of nums TO element at position left of sorted_nums  \n                DECREMENT left BY one  \n            ELSE  \n                SET element at position i of nums TO element at position right of sorted_nums  \n                DECREMENT right BY one  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-size-subarray-sum-equals-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSubArrayLen(nums k)  \n        SET cumulative sum index TO a dictionary with key zero assigned to value negative one  \n        SET cumulative sum TO zero  \n        SET max length TO zero  \n        FOR each index i AND each number num IN nums  \n            SET cumulative sum TO cumulative sum PLUS num  \n            IF cumulative sum MINUS k EXISTS AS A KEY IN cumulative sum index  \n                SET candidate length TO i MINUS the element at key cumulative sum MINUS k of cumulative sum index  \n                IF candidate length GREATER THAN max length  \n                    SET max length TO candidate length  \n                END IF  \n            END IF  \n            IF cumulative sum DOES NOT EXIST AS A KEY IN cumulative sum index  \n                ASSIGN the element at key cumulative sum of cumulative sum index TO i  \n            END IF  \n        END FOR  \n        RETURN max length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-of-range-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countRangeSum(nums, lower, upper)  \n        SET prefix_sums TO a list containing zero  \n        SET current_sum TO zero  \n        SET count TO zero  \n        \n        FOR each num IN nums  \n            SET current_sum TO current_sum PLUS num  \n            SET left TO current_sum MINUS upper  \n            SET right TO current_sum MINUS lower  \n            \n            SET count TO count PLUS the position returned by finding the rightmost insertion point for right in prefix_sums MINUS the position returned by finding the leftmost insertion point for left in prefix_sums  \n            \n            INSERT current_sum INTO prefix_sums maintaining sorted order  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-increasing-path-in-a-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestIncreasingPath(matrix)  \n        IF matrix EQUALS nothing OR element at position zero of matrix EQUALS nothing  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET directions TO the list containing the pairs of one and zero MINUS one and zero zero and one zero and MINUS one  \n        SET dp TO a list  \n        FOR index FROM zero TO m MINUS one  \n            SET row TO a list containing n times negative one  \n            APPEND row TO dp  \n        END FOR  \n        FUNCTION dfs(x, y)  \n            IF element at position x of dp at position y NOT EQUALS negative one  \n                RETURN element at position x of dp at position y  \n            END IF  \n            SET max_length TO one  \n            FOR each pair dx, dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of matrix at position ny GREATER THAN element at position x of matrix at position y  \n                    SET candidate TO one PLUS dfs(nx, ny)  \n                    IF candidate GREATER THAN max_length  \n                        SET max_length TO candidate  \n                    END IF  \n                END IF  \n            END FOR  \n            SET element at position x of dp at position y TO max_length  \n            RETURN max_length  \n        END FUNCTION  \n        SET longest_path TO zero  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET candidate_to_compare TO dfs(i, j)  \n                IF candidate_to_compare GREATER THAN longest_path  \n                    SET longest_path TO candidate_to_compare  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN longest_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "patching-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minPatches(nums n)  \n        SET missing TO the smallest positive number that cannot yet be formed from the numbers considered  \n        SET patches TO the count of numbers added to enable forming all numbers up to n  \n        SET i TO the current index in nums under consideration  \n        \n        WHILE missing LESS THAN OR EQUAL TO n  \n            IF i LESS THAN the LENGTH OF nums AND element at position i of nums LESS THAN OR EQUAL TO missing  \n                SET missing TO missing PLUS element at position i of nums  \n                INCREMENT i BY one  \n            ELSE  \n                SET missing TO missing PLUS missing  \n                INCREMENT patches BY one  \n            END IF  \n        END WHILE  \n        \n        RETURN patches  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "verify-preorder-serialization-of-a-binary-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isValidSerialization(preorder)  \n        SET nodes TO the list obtained by splitting preorder at each comma  \n        SET slots TO one  \n        FOR each node IN nodes  \n            IF slots EQUALS zero  \n                RETURN False  \n            END IF  \n            DECREMENT slots BY one  \n            IF node NOT EQUALS the single character hash symbol indicating null node  \n                INCREMENT slots BY two  \n            END IF  \n        END FOR  \n        RETURN slots EQUALS zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-itinerary", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findItinerary WITH parameter tickets  \n        SET graph TO a new mapping that produces an empty list for any new key  \n        FOR each pair of departure location named frm AND arrival location named to IN the tickets sorted in descending order  \n            APPEND to TO the list at key frm in graph  \n        END FOR  \n        \n        SET itinerary TO an empty list  \n        \n        FUNCTION visit WITH parameter airport  \n            WHILE the list at key airport in graph holds any elements  \n                CALL visit WITH argument the element removed from the end of the list at key airport in graph  \n            END WHILE  \n            APPEND airport TO itinerary  \n        END FUNCTION  \n        \n        CALL visit WITH argument the string representing the letters J F K  \n        RETURN the list itinerary in reversed order  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "increasing-triplet-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION increasingTriplet(nums)  \n        SET first TO positive infinity  \n        SET second TO positive infinity  \n        FOR each num IN nums  \n            IF num LESS THAN OR EQUAL TO first  \n                SET first TO num  \n            ELSE IF num LESS THAN OR EQUAL TO second  \n                SET second TO num  \n            ELSE  \n                RETURN true  \n            END IF  \n        END FOR  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "self-crossing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isSelfCrossing(distance)  \n        SET n TO the LENGTH OF distance  \n        IF n LESS THAN four  \n            RETURN False  \n        END IF  \n        FOR i FROM three TO n MINUS one  \n            IF element at position i of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance AND element at position i MINUS one of distance LESS THAN OR EQUAL TO element at position i MINUS three of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO four AND element at position i MINUS one of distance EQUALS element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO five AND element at position i MINUS two of distance GREATER THAN OR EQUAL TO element at position i MINUS four of distance AND element at position i MINUS three of distance GREATER THAN OR EQUAL TO element at position i MINUS one of distance AND element at position i MINUS one of distance PLUS element at position i MINUS five of distance GREATER THAN OR EQUAL TO element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-with-at-most-k-distinct-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLongestSubstringKDistinct(s parameter, k parameter)  \n        IF k parameter EQUALS zero  \n            RETURN zero  \n        END IF  \n        \n        SET char_map TO empty mapping  \n        SET left TO zero  \n        SET max_length TO zero  \n        \n        FOR right FROM zero TO the LENGTH OF s parameter MINUS one  \n            SET element at position right of s parameter IN char_map TO right  \n            \n            IF the LENGTH OF char_map GREATER THAN k parameter  \n                SET leftmost_char TO the key in char_map with the minimum value  \n                SET left TO the value corresponding to leftmost_char in char_map PLUS one  \n                REMOVE leftmost_char FROM char_map  \n            END IF  \n            \n            SET current_length TO right MINUS left PLUS one  \n            IF current_length GREATER THAN max_length  \n                SET max_length TO current_length  \n            END IF  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-break", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dp TO a list of zeros with the length of n PLUS one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            SET max_product TO zero  \n            FOR j FROM one TO i MINUS one  \n                SET product_one TO j MULTIPLIED BY element at position i MINUS j of dp  \n                SET product_two TO j MULTIPLIED BY i MINUS j  \n                IF max_product LESS THAN product_one AND max_product LESS THAN product_two  \n                    SET max_product TO the larger value BETWEEN product_one AND product_two  \n                ELSE IF max_product LESS THAN product_one  \n                    SET max_product TO product_one  \n                ELSE IF max_product LESS THAN product_two  \n                    SET max_product TO product_two  \n                END IF  \n            END FOR  \n            SET element at position i of dp TO max_product  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "top-k-frequent-elements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION topKFrequent(nums k)  \n        SET frequency_map TO an empty mapping with default value zero  \n        FOR each num IN nums  \n            INCREMENT the value at key num in frequency_map BY one  \n        END FOR  \n\n        SET max_frequency TO the maximum value among all values in frequency_map  \n        SET buckets TO a list of empty lists with length max_frequency PLUS one  \n\n        FOR each num AND freq IN the items of frequency_map  \n            APPEND num TO the element at position freq of buckets  \n        END FOR  \n\n        SET result TO an empty list  \n        FOR freq FROM max_frequency DOWN TO one  \n            IF the length of the element at position freq of buckets IS GREATER THAN zero THEN  \n                EXTEND result BY the element at position freq of buckets  \n                IF the length of result IS GREATER THAN OR EQUAL TO k THEN  \n                    RETURN the sublist of result from position one TO position k  \n                END IF  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "android-unlock-patterns", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfPatterns(m, n)  \n        ASSIGN jumps TO mapping of pairs to intermediary dots as follows:  \n            pair of one and three maps to two  \n            pair of one and seven maps to four  \n            pair of one and nine maps to five  \n            pair of two and eight maps to five  \n            pair of three and one maps to two  \n            pair of three and seven maps to five  \n            pair of three and nine maps to six  \n            pair of four and six maps to five  \n            pair of five and five maps to five  \n            pair of six and four maps to five  \n            pair of seven and one maps to four  \n            pair of seven and three maps to five  \n            pair of seven and nine maps to eight  \n            pair of eight and two maps to five  \n            pair of nine and one maps to five  \n            pair of nine and three maps to six  \n            pair of nine and seven maps to eight  \n        \n        FUNCTION countPatternsFromDot(current, visited, length)  \n            IF length EQUALS n THEN  \n                RETURN one  \n            END IF  \n            IF length GREATER THAN OR EQUAL TO m THEN  \n                SET count TO one  \n            ELSE  \n                SET count TO zero  \n            END IF  \n            FOR next_dot FROM one TO nine  \n                IF element at position next_dot of visited EQUALS False THEN  \n                    ASSIGN jump TO value in jumps at key of pair current and next_dot  \n                    IF jump IS NONE OR element at position jump of visited EQUALS True THEN  \n                        SET element at position next_dot of visited TO True  \n                        INCREMENT count BY result of countPatternsFromDot with arguments next_dot visited length PLUS one  \n                        SET element at position next_dot of visited TO False  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        ASSIGN visited TO list of ten elements each set to False  \n        SET result TO zero  \n        FOR i FROM one TO nine  \n            SET element at position i of visited TO True  \n            INCREMENT result BY result of countPatternsFromDot with arguments i visited one  \n            SET element at position i of visited TO False  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "russian-doll-envelopes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxEnvelopes(envelopes)  \n        CALL sort envelopes BY the first element of each item IN ascending order AND BY the second element of each item IN descending order  \n        SET dp TO an empty list  \n        FOR each element WITH second value h IN envelopes  \n            SET idx TO the position found by binary searching the leftmost place to insert h INTO dp  \n            IF idx EQUALS the LENGTH OF dp THEN  \n                APPEND h TO dp  \n            ELSE  \n                SET element at position idx of dp TO h  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "line-reflection", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isReflected(points)  \n        SET unique_points TO the SET OF each element CONVERTED TO tuple IN points  \n        SET min_x TO the MINIMUM OF element at position zero OF each element IN unique_points  \n        SET max_x TO the MAXIMUM OF element at position zero OF each element IN unique_points  \n        SET line_of_reflection TO min_x PLUS max_x DIVIDED BY two  \n        FOR each element IN unique_points  \n            SET x TO element at position zero OF element  \n            SET y TO element at position one OF element  \n            SET reflected_x TO two MULTIPLIED BY line_of_reflection MINUS x  \n            IF the PAIR composed of reflected_x AND y NOT IN unique_points  \n                RETURN False  \n            END IF  \n        END FOR  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-numbers-with-unique-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n INCLUSIVE  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            SET available_digits TO available_digits MINUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rearrange-string-k-distance-apart", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rearrangeString(s string k integer) RETURNS string  \n        IF k LESS THAN OR EQUAL TO one  \n            RETURN s  \n        END IF  \n        \n        SET freq TO a mapping of characters TO their frequency in s  \n        \n        SET max_heap TO a list of pairs formed by the negative frequency and the character FOR each character AND its count IN freq  \n        ORGANIZE max_heap INTO a heap structure based on the first element of each pair  \n        \n        SET wait_queue TO an empty list  \n        \n        SET result TO an empty list  \n        \n        WHILE max_heap is not empty  \n            REMOVE the pair with the smallest first element from max_heap AND ASSIGN its components TO count AND char  \n            APPEND char TO result  \n            \n            APPEND a pair consisting of count INCREMENTED BY one AND char TO wait_queue  \n            \n            IF the LENGTH OF wait_queue EQUALS k  \n                REMOVE the first pair from wait_queue AND ASSIGN its components TO count AND char  \n                IF count LESS THAN zero  \n                    ADD the pair count AND char BACK into max_heap maintaining heap property  \n                END IF  \n            END IF  \n        END WHILE  \n        \n        IF the LENGTH OF result DOES NOT EQUAL the LENGTH OF s  \n            RETURN an empty string  \n        END IF  \n        \n        RETURN the concatenation of all characters in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-transformed-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sortTransformedArray(nums a b c)  \n        FUNCTION quadratic(x)  \n            RETURN a MULTIPLIED BY x MULTIPLIED BY x PLUS b MULTIPLIED BY x PLUS c  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF nums  \n        SET result TO a list of zeroes of size n  \n        SET left TO zero  \n        SET right TO n MINUS one  \n\n        IF a GREATER THAN OR EQUAL TO zero  \n            SET index TO n MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                IF quadratic of element at position left of nums GREATER THAN quadratic of element at position right of nums  \n                    SET element at position index of result TO quadratic of element at position left of nums  \n                    INCREMENT left BY one  \n                ELSE  \n                    SET element at position index of result TO quadratic of element at position right of nums  \n                    DECREMENT right BY one  \n                END IF  \n                DECREMENT index BY one  \n            END WHILE  \n        ELSE  \n            SET index TO zero  \n            WHILE left LESS THAN OR EQUAL TO right  \n                IF quadratic of element at position left of nums LESS THAN quadratic of element at position right of nums  \n                    SET element at position index of result TO quadratic of element at position left of nums  \n                    INCREMENT left BY one  \n                ELSE  \n                    SET element at position index of result TO quadratic of element at position right of nums  \n                    DECREMENT right BY one  \n                END IF  \n                INCREMENT index BY one  \n            END WHILE  \n        END IF  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bomb-enemy", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxKilledEnemies(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET max_kills TO zero  \n        SET row_kills TO zero  \n        SET col_kills TO a list of zeros with the LENGTH n  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF j EQUALS zero OR element at position j MINUS one of element at position i of grid EQUALS the character represented as wall  \n                    SET row_kills TO zero  \n                    FOR k FROM j TO n MINUS one  \n                        IF element at position k of element at position i of grid EQUALS the character represented as enemy  \n                            INCREMENT row_kills BY one  \n                        ELSE IF element at position k of element at position i of grid EQUALS the character represented as wall  \n                            BREAK  \n                        END IF  \n                    END FOR  \n                END IF  \n                IF i EQUALS zero OR element at position i MINUS one of element at position j of grid EQUALS the character represented as wall  \n                    SET element at position j of col_kills TO zero  \n                    FOR k FROM i TO m MINUS one  \n                        IF element at position k of element at position j of grid EQUALS the character represented as enemy  \n                            INCREMENT element at position j of col_kills BY one  \n                        ELSE IF element at position k of element at position j of grid EQUALS the character represented as wall  \n                            BREAK  \n                        END IF  \n                    END FOR  \n                END IF  \n                IF element at position j of element at position i of grid EQUALS the character represented as zero  \n                    SET max_kills TO the GREATER VALUE BETWEEN max_kills AND the SUM OF row_kills AND element at position j of col_kills  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN max_kills  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-two-integers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getSum(a b)  \n        SET MAX TO the maximum positive integer value for thirty two bits  \n        SET mask TO the bit mask representing thirty two bits all set to one  \n        WHILE b NOT EQUALS zero  \n            SET carry TO the bitwise AND of a and b MULTIPLIED BY two  \n            SET a TO the bitwise XOR of a and b ANDed with mask  \n            SET b TO the bitwise AND of carry and mask  \n        END WHILE  \n        IF a LESS THAN OR EQUAL TO MAX  \n            RETURN a  \n        ELSE  \n            RETURN the bitwise negation of the bitwise XOR of a and mask  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-k-pairs-with-smallest-sums", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kSmallestPairs(nums1 nums2 k)  \n        IF the LENGTH OF nums1 EQUALS zero OR the LENGTH OF nums2 EQUALS zero OR k LESS THAN OR EQUAL TO zero  \n            RETURN an empty list  \n        END IF  \n\n        SET min_heap TO an empty list  \n\n        FOR i FROM zero TO the MINIMUM OF k AND the LENGTH OF nums1 MINUS one  \n            PUSH ONTO min_heap the tuple of the element at position i of nums1 PLUS the element at position zero of nums2 AND i AND zero  \n        END FOR  \n\n        SET result TO an empty list  \n\n        WHILE min_heap is not empty AND the LENGTH OF result LESS THAN k  \n            POP the smallest tuple from min_heap INTO underscore AND i AND j  \n            APPEND the list containing the element at position i of nums1 AND the element at position j of nums2 TO result  \n            IF j PLUS one LESS THAN the LENGTH OF nums2  \n                PUSH ONTO min_heap the tuple of the element at position i of nums1 PLUS the element at position j PLUS one of nums2 AND i AND j PLUS one  \n            END IF  \n        END WHILE  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "guess-number-higher-or-lower-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getMoneyAmount(n)  \n        FUNCTION dp(left, right)  \n            IF left GREATER THAN OR EQUAL TO right THEN  \n                RETURN zero  \n            END IF  \n            SET min_cost TO positive infinity  \n            FOR each pivot FROM left TO right  \n                SET left_cost TO dp(left, pivot MINUS one)  \n                SET right_cost TO dp(pivot PLUS one, right)  \n                SET max_cost TO left_cost IF left_cost GREATER THAN OR EQUAL TO right_cost OTHERWISE right_cost  \n                SET cost TO pivot PLUS max_cost  \n                SET min_cost TO cost IF cost LESS THAN min_cost OTHERWISE min_cost  \n            END FOR  \n            RETURN min_cost  \n        END FUNCTION  \n        RETURN dp(one, n)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wiggle-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wiggleMaxLength(nums)  \n        IF the LENGTH OF nums LESS THAN two  \n            RETURN the LENGTH OF nums  \n        END IF  \n        \n        SET up TO one  \n        SET down TO one  \n        \n        FOR index FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position index of nums GREATER THAN the element at position index MINUS one of nums  \n                SET up TO down PLUS one  \n            ELSE IF the element at position index of nums LESS THAN the element at position index MINUS one of nums  \n                SET down TO up PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN the GREATER VALUE OF up AND down  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum4(nums target)  \n        SET dp TO an empty list of zeros with the length of target PLUS one  \n        SET element at position zero of dp TO one  \n        FOR amount FROM one TO target  \n            FOR each num IN nums  \n                IF amount GREATER THAN OR EQUAL TO num  \n                    SET element at position amount of dp TO element at position amount of dp PLUS element at position amount MINUS num of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position target of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-element-in-a-sorted-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(matrix PARAMETER matrix TYPE List of List of integers k PARAMETER k TYPE integer) RETURNS integer  \n        FUNCTION countLessEqual(mid PARAMETER mid TYPE integer) RETURNS integer  \n            SET count TO zero  \n            SET row TO the LENGTH OF matrix MINUS one  \n            SET col TO zero  \n            WHILE row GREATER THAN OR EQUAL TO zero AND col LESS THAN the LENGTH OF matrix  \n                IF element at position row of matrix at position col LESS THAN OR EQUAL TO mid  \n                    INCREMENT count BY row PLUS one  \n                    INCREMENT col BY one  \n                ELSE  \n                    DECREMENT row BY one  \n                END IF  \n            END WHILE  \n            RETURN count  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF matrix  \n        SET low TO element at position zero of matrix at position zero  \n        SET high TO element at position n MINUS one of matrix at position n MINUS one  \n        \n        WHILE low LESS THAN high  \n            SET mid TO the INTEGER DIVISION of low PLUS high BY two  \n            IF countLessEqual with mid AS argument LESS THAN k  \n                SET low TO mid PLUS one  \n            ELSE  \n                SET high TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN low  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lexicographical-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lexicalOrder WITH PARAMETER n  \n        SET result TO an empty list  \n        \n        FUNCTION dfs WITH PARAMETER current  \n            IF current GREATER THAN n  \n                RETURN  \n            END IF  \n            APPEND current TO result  \n            FOR i FROM zero TO nine  \n                SET next_num TO current MULTIPLIED BY ten PLUS i  \n                IF next_num GREATER THAN n  \n                    RETURN  \n                END IF  \n                CALL dfs WITH PARAMETER next_num  \n            END FOR  \n        END FUNCTION  \n        \n        FOR i FROM one TO nine  \n            CALL dfs WITH PARAMETER i  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "elimination-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lastRemaining(n)  \n        SET remaining TO n  \n        SET step TO one  \n        SET left_to_right TO true  \n        SET head TO one  \n        \n        WHILE remaining GREATER THAN one  \n            IF left_to_right OR remaining MODULO two EQUALS one  \n                INCREMENT head BY step  \n            END IF  \n            SET step TO step MULTIPLIED BY two  \n            SET remaining TO remaining DIVIDED BY two  \n            SET left_to_right TO NOT left_to_right  \n        END WHILE  \n        \n        RETURN head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-rectangle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "utf-8-validation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validUtf8(data)  \n        FUNCTION get_byte_count(byte)  \n            IF the value obtained by shifting byte right BY seven BITS EQUALS zero  \n                RETURN one  \n            ELSE IF the value obtained by shifting byte right BY five BITS EQUALS the binary representation of one one zero  \n                RETURN two  \n            ELSE IF the value obtained by shifting byte right BY four BITS EQUALS the binary representation of one one one zero  \n                RETURN three  \n            ELSE IF the value obtained by shifting byte right BY three BITS EQUALS the binary representation of one one one one zero  \n                RETURN four  \n            ELSE  \n                RETURN minus one  \n            END IF  \n        END FUNCTION  \n      \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF data  \n            SET byte_count TO the result of get_byte_count with the element at position i of data  \n            IF byte_count EQUALS minus one  \n                RETURN False  \n            END IF  \n            IF i PLUS byte_count GREATER THAN the LENGTH OF data  \n                RETURN False  \n            END IF  \n            FOR j FROM i PLUS one TO i PLUS byte_count MINUS one  \n                IF the value obtained by shifting the element at position j of data right BY six BITS NOT EQUALS the binary representation of one zero  \n                    RETURN False  \n                END IF  \n            END FOR  \n            INCREMENT i BY byte_count  \n        END WHILE  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decode-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION decodeString WITH PARAMETER s  \n        SET stack TO empty list  \n        SET a TO empty string  \n        SET d TO empty string  \n        \n        FOR each character IN s  \n            IF character IS a digit THEN  \n                SET d TO d concatenated with character  \n            ELSE IF character IS an alphabetic letter THEN  \n                SET a TO a concatenated with character  \n            ELSE IF character IS equal to the left square bracket character THEN  \n                APPEND pair of a and the integer value of d TO stack  \n                SET a TO empty string  \n                SET d TO empty string  \n            ELSE IF character IS equal to the right square bracket character THEN  \n                SET pair TO the last element removed from stack  \n                SET p TO the first element of pair  \n                SET n TO the second element of pair  \n                SET a TO p concatenated with a repeated n times  \n            END IF  \n        END FOR  \n        \n        RETURN a  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-with-at-least-k-repeating-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestSubstring(s k)  \n        IF the LENGTH OF s LESS THAN k  \n            RETURN zero  \n        END IF  \n        SET count TO the FREQUENCY MAP OF characters IN s  \n        FOR each character IN the KEYS OF count  \n            IF the FREQUENCY OF character IN count LESS THAN k  \n                RETURN the MAXIMUM VALUE OVER the RESULTS OF longestSubstring CALLED WITH each substring OBTAINED BY SPLITTING s BY character AND k AS PARAMETERS  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-function", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxRotateFunction(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET total_sum TO the SUM OF all elements IN nums  \n        SET current_sum TO the SUM OF each index MULTIPLIED BY the element at that index IN nums  \n        SET max_value TO current_sum  \n        FOR k FROM one TO n MINUS one  \n            SET current_sum TO current_sum PLUS total_sum MINUS n MULTIPLIED BY the element at position n MINUS k OF nums  \n            SET max_value TO the GREATER OF max_value AND current_sum  \n        END FOR  \n        RETURN max_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-replacement", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION integerReplacement(n)  \n        SET count TO zero  \n        WHILE n NOT EQUALS one  \n            IF the remainder of n DIVIDED BY two EQUALS zero  \n                SET n TO n DIVIDED BY two  \n            ELSE IF n EQUALS three  \n                SET n TO n MINUS one  \n            ELSE IF the remainder of n PLUS one DIVIDED BY four EQUALS zero  \n                SET n TO n PLUS one  \n            ELSE  \n                SET n TO n MINUS one  \n            END IF  \n            INCREMENT count BY one  \n        END WHILE  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "nth-digit", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findNthDigit(n)  \n        SET length TO one  \n        SET count TO nine  \n        SET start TO one  \n        \n        WHILE n GREATER THAN length MULTIPLIED BY count  \n            SET n TO n MINUS length MULTIPLIED BY count  \n            INCREMENT length BY one  \n            SET count TO count MULTIPLIED BY ten  \n            SET start TO start MULTIPLIED BY ten  \n        END WHILE  \n        \n        SET start TO start PLUS the INTEGER DIVISION of n MINUS one BY length  \n        RETURN the digit AT the REMAINDER of n MINUS one DIVIDED BY length OF the string REPRESENTATION OF start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-k-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeKdigits(num parameter AS string, k parameter AS integer) RETURNS string  \n        SET stack TO an empty list  \n        FOR each digit IN num  \n            WHILE k GREATER THAN zero AND stack IS NOT empty AND the element at the last position of stack GREATER THAN digit  \n                REMOVE the element at the last position of stack  \n                DECREMENT k BY one  \n            END WHILE  \n            APPEND digit TO stack  \n        END FOR  \n        IF k GREATER THAN zero  \n            SET final_stack TO the elements of stack from the first position TO the position that is the LENGTH OF stack MINUS k  \n        ELSE  \n            SET final_stack TO stack  \n        END IF  \n        SET result TO the string formed by concatenating all elements of final_stack WITH all leading zero characters REMOVED  \n        IF the LENGTH OF result EQUALS zero  \n            RETURN the string that represents zero  \n        ELSE  \n            RETURN result  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-jump", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS empty OR the LENGTH OF stones LESS THAN two  \n            RETURN False  \n        END IF  \n        SET stone_set TO the SET of all elements in stones  \n        SET memo TO an EMPTY DICTIONARY  \n\n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the element at the last position of stones  \n                RETURN True  \n            END IF  \n            IF the TUPLE of position AND jump IS IN memo  \n                RETURN the VALUE associated with the TUPLE of position AND jump in memo  \n            END IF  \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the SUM of position AND next_jump IS IN stone_set  \n                    IF can_jump_to(the SUM of position AND next_jump, next_jump)  \n                        SET memo at key TUPLE of position AND jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            SET memo at key TUPLE of position AND jump TO False  \n            RETURN False  \n        END FUNCTION  \n\n        RETURN can_jump_to(the element at the first position of stones, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "queue-reconstruction-by-height", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reconstructQueue(people)  \n        SORT the collection people BY the negative value of element at position zero of person AND BY element at position one of person in ascending order  \n        SET queue TO an empty collection  \n        FOR each person IN people  \n            INSERT person INTO queue AT position element at position one of person  \n        END FOR  \n        RETURN queue  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "trapping-rain-water-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION trapRainWater(heightMap)  \n        IF heightMap EQUALS empty OR element at position zero of heightMap EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF heightMap  \n        SET n TO the LENGTH OF element at position zero of heightMap  \n        SET visited TO a list containing m elements each being a list of n elements each being False  \n        SET min_heap TO an empty list  \n        \n        FOR i FROM zero TO m MINUS one  \n            ADD a tuple of element at position i of heightMap at position zero AND i AND zero TO min_heap maintaining heap property  \n            ADD a tuple of element at position i of heightMap at position n MINUS one AND i AND n MINUS one TO min_heap maintaining heap property  \n            SET element at position i of visited at position zero TO True  \n            SET element at position i of visited at position n MINUS one TO True  \n        END FOR  \n        \n        FOR j FROM zero TO n MINUS one  \n            ADD a tuple of element at position zero of heightMap at position j AND zero AND j TO min_heap maintaining heap property  \n            ADD a tuple of element at position m MINUS one of heightMap at position j AND m MINUS one AND j TO min_heap maintaining heap property  \n            SET element at position zero of visited at position j TO True  \n            SET element at position m MINUS one of visited at position j TO True  \n        END FOR  \n        \n        SET directions TO a list containing the tuples of negative one AND zero AND one AND zero AND zero AND negative one AND zero AND one  \n        SET water_trapped TO zero  \n        \n        WHILE min_heap is not empty  \n            REMOVE and RETURN the smallest element from min_heap as a tuple of height AND x AND y  \n            \n            FOR each tuple of dx AND dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of visited at position ny EQUALS False  \n                    SET element at position nx of visited at position ny TO True  \n                    IF height GREATER THAN element at position nx of heightMap at position ny  \n                        INCREMENT water_trapped BY height MINUS element at position nx of heightMap at position ny  \n                    END IF  \n                    ADD a tuple of the greater value between height AND element at position nx of heightMap at position ny AND nx AND ny TO min_heap maintaining heap property  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN water_trapped  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-largest-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitArray(nums k)  \n        FUNCTION canSplit(max_sum)  \n            SET current_sum TO zero  \n            SET subarrays TO one  \n            FOR each num IN nums  \n                IF current_sum PLUS num GREATER THAN max_sum  \n                    INCREMENT subarrays BY one  \n                    SET current_sum TO num  \n                ELSE  \n                    INCREMENT current_sum BY num  \n                END IF  \n            END FOR  \n            RETURN subarrays LESS THAN OR EQUAL TO k  \n        END FUNCTION  \n\n        SET left TO the maximum element IN nums  \n        SET right TO the sum of all elements IN nums  \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right DIVIDED BY two  \n            IF canSplit(mid)  \n                SET right TO mid  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-unique-word-abbreviation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minAbbreviation(target, dictionary)  \n        FUNCTION is_valid_abbr(s, abbr)  \n            SET i TO zero  \n            SET j TO zero  \n            WHILE i LESS THAN the LENGTH OF s AND j LESS THAN the LENGTH OF abbr  \n                IF element at position j of abbr IS a digit  \n                    IF element at position j of abbr EQUALS zero as a digit  \n                        RETURN False  \n                    END IF  \n                    SET shift TO zero  \n                    WHILE j LESS THAN the LENGTH OF abbr AND element at position j of abbr IS a digit  \n                        SET shift TO shift MULTIPLIED BY ten PLUS the integer value of element at position j of abbr  \n                        INCREMENT j BY one  \n                    END WHILE  \n                    INCREMENT i BY shift  \n                ELSE  \n                    IF element at position i of s NOT EQUALS element at position j of abbr  \n                        RETURN False  \n                    END IF  \n                    INCREMENT i BY one  \n                    INCREMENT j BY one  \n                END IF  \n            END WHILE  \n            RETURN i EQUALS the LENGTH OF s AND j EQUALS the LENGTH OF abbr  \n        END FUNCTION  \n      \n        FUNCTION generate_abbrs(word, length, abbr empty string, index zero, skip_count zero)  \n            IF index EQUALS length  \n                IF skip_count GREATER THAN zero  \n                    SET abbr TO abbr PLUS the string representation of skip_count  \n                END IF  \n                APPEND abbr TO abbrs  \n                RETURN  \n            END IF  \n            CALL generate_abbrs WITH word, length, abbr, index PLUS one, skip_count PLUS one  \n            IF skip_count GREATER THAN zero  \n                SET abbr TO abbr PLUS the string representation of skip_count  \n            END IF  \n            CALL generate_abbrs WITH word, length, abbr PLUS element at position index of word, index PLUS one, zero  \n        END FUNCTION  \n      \n        FUNCTION find_unique_abbr()  \n            FOR length FROM one TO the LENGTH OF target  \n                CALL generate_abbrs WITH target, the LENGTH OF target  \n                SET min_abbr TO None  \n                SET min_length TO infinity  \n                FOR each abbr IN abbrs  \n                    IF for all word IN filtered_dict it is NOT the case that is_valid_abbr with word and abbr  \n                        IF the LENGTH OF abbr LESS THAN min_length  \n                            SET min_length TO the LENGTH OF abbr  \n                            SET min_abbr TO abbr  \n                        END IF  \n                    END IF  \n                END FOR  \n                IF min_abbr IS NOT None  \n                    RETURN min_abbr  \n                END IF  \n            END FOR  \n        END FUNCTION  \n      \n        SET filtered_dict TO an empty list  \n        FOR each word IN dictionary  \n            IF the LENGTH OF word EQUALS the LENGTH OF target  \n                APPEND word TO filtered_dict  \n            END IF  \n        END FOR  \n      \n        SET abbrs TO an empty list  \n        RETURN find_unique_abbr()  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "arithmetic-slices", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        IF the LENGTH OF nums LESS THAN three THEN  \n            RETURN zero  \n        END IF  \n        \n        SET total_slices TO zero  \n        SET current_length TO two  \n        \n        FOR i FROM three TO the LENGTH OF nums  \n            IF the element at position i of nums MINUS the element at position i MINUS one of nums EQUALS the element at position i MINUS one of nums MINUS the element at position i MINUS two of nums THEN  \n                INCREMENT current_length BY one  \n                INCREMENT total_slices BY current_length MINUS two  \n            ELSE  \n                SET current_length TO two  \n            END IF  \n        END FOR  \n        \n        RETURN total_slices  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-equal-subset-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canPartition(nums)  \n        SET total sum TO the sum of all elements in nums  \n        IF the remainder of total sum DIVIDED BY two NOT EQUALS zero  \n            RETURN false  \n        END IF  \n        SET target TO total sum DIVIDED BY two  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a list of boolean false repeated for each number FROM zero TO target INCLUSIVE  \n        SET element at position zero of dp TO true  \n        FOR each num IN nums  \n            FOR i FROM target DOWN TO num  \n                SET element at position i of dp TO element at position i of dp OR element at position i MINUS num of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position target of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sentence-screen-fitting", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        SET s TO the concatenation of all elements of sentence with a single space between each followed by a single space character  \n        SET total_length TO the LENGTH OF s  \n        SET position TO zero  \n        \n        FOR each iteration IN the range from one TO rows  \n            INCREMENT position BY cols  \n            \n            IF the element at position MODULO total_length of s EQUALS a space character  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position GREATER THAN zero AND the element at position MINUS one MODULO total_length of s NOT EQUALS a space character  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN position DIVIDED BY total_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "battleships-in-a-board", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countBattleships WITH PARAMETER board  \n        SET count TO zero  \n        FOR i FROM zero TO LENGTH OF board MINUS one  \n            FOR j FROM zero TO LENGTH OF element at position zero of board MINUS one  \n                IF element at position i of board at position j EQUALS letter X THEN  \n                    IF i EQUALS zero OR element at position i MINUS one of board at position j EQUALS dot AND j EQUALS zero OR element at position i of board at position j MINUS one EQUALS dot THEN  \n                        INCREMENT count BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strong-password-checker", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION strongPasswordChecker(password)  \n        SET n TO the LENGTH OF password  \n        \n        SET has_lower TO BOOLEAN VALUE OF WHETHER any character IN password is a lowercase letter  \n        SET has_upper TO BOOLEAN VALUE OF WHETHER any character IN password is an uppercase letter  \n        SET has_digit TO BOOLEAN VALUE OF WHETHER any character IN password is a digit  \n        \n        SET missing_types TO three MINUS the SUM OF has_lower PLUS has_upper PLUS has_digit  \n        \n        SET replace TO zero  \n        SET one TO zero  \n        SET two TO zero  \n        SET i TO two  \n        WHILE i LESS THAN n  \n            IF the character at position i of password EQUALS the character at position i MINUS one of password AND the character at position i of password EQUALS the character at position i MINUS two of password  \n                SET length TO two  \n                WHILE i LESS THAN n AND the character at position i of password EQUALS the character at position i MINUS one of password  \n                    INCREMENT length BY one  \n                    INCREMENT i BY one  \n                END WHILE  \n                INCREMENT replace BY the INTEGER DIVISION of length BY three  \n                IF the MODULO of length BY three EQUALS zero  \n                    INCREMENT one BY one  \n                ELSE IF the MODULO of length BY three EQUALS one  \n                    INCREMENT two BY one  \n                END IF  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        \n        IF n LESS THAN six  \n            RETURN the GREATER VALUE BETWEEN missing_types AND six MINUS n  \n        ELSE IF n LESS THAN OR EQUAL TO twenty  \n            RETURN the GREATER VALUE BETWEEN missing_types AND replace  \n        ELSE  \n            SET delete TO n MINUS twenty  \n            \n            SET replace TO replace MINUS the SMALLER VALUE BETWEEN delete AND one  \n            SET replace TO replace MINUS the INTEGER DIVISION BY two OF the SMALLER VALUE BETWEEN the GREATER VALUE BETWEEN delete MINUS one AND zero AND two MULTIPLIED BY two  \n            SET replace TO replace MINUS the INTEGER DIVISION BY three OF the GREATER VALUE BETWEEN delete MINUS one MINUS two MULTIPLIED BY two AND zero  \n            \n            RETURN delete PLUS the GREATER VALUE BETWEEN missing_types AND replace  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-xor-of-two-numbers-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaximumXOR(nums)  \n        SET max_xor TO zero  \n        FOR i FROM thirty-one TO zero DECREMENT BY one  \n            SET max_xor TO max_xor MULTIPLIED BY two  \n            SET current_candidate TO max_xor PLUS one  \n            SET prefixes TO empty set  \n            FOR each num IN nums  \n                SET prefix TO the integer division of num BY two RAISED TO THE POWER OF i  \n                ADD prefix TO prefixes  \n            END FOR  \n            FOR each prefix IN prefixes  \n                IF current_candidate XOR prefix IS IN prefixes THEN  \n                    SET max_xor TO current_candidate  \n                    BREAK  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN max_xor  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-repeating-character-replacement", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION characterReplacement(s k)  \n        INITIALIZE count AS a mapping from characters TO integer zero by default  \n        SET max_length TO zero  \n        SET max_count TO zero  \n        SET left TO zero  \n        FOR right FROM zero TO the LENGTH OF s MINUS one  \n            INCREMENT the value in count for the character at position right of s BY one  \n            SET max_count TO the GREATER OF max_count AND the value in count for the character at position right of s  \n            IF the quantity of right MINUS left PLUS one MINUS max_count IS GREATER THAN k THEN  \n                DECREMENT the value in count for the character at position left of s BY one  \n                INCREMENT left BY one  \n            END IF  \n            SET max_length TO the GREATER OF max_length AND the quantity of right MINUS left PLUS one  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordSquares(words)  \n        SET prefix_to_words TO an empty mapping from string to list of strings  \n        FOR each word IN words  \n            FOR index FROM zero TO the LENGTH OF word MINUS one  \n                SET prefix TO the substring of word from position zero TO position index MINUS one  \n                APPEND word TO the list at prefix_to_words corresponding to prefix  \n            END FOR  \n        END FOR  \n        \n        SET results TO an empty list  \n        \n        FUNCTION backtrack(square)  \n            IF the LENGTH OF square EQUALS the LENGTH OF the first element of words THEN  \n                APPEND square TO results  \n                RETURN  \n            END IF  \n            \n            SET prefix TO an empty string  \n            FOR each word_element IN square  \n                APPEND the element at position the LENGTH OF square of word_element TO prefix  \n            END FOR  \n            \n            FOR each candidate IN the list at prefix_to_words corresponding to prefix  \n                CALL backtrack WITH the argument of the concatenation of square with candidate as a new list element  \n            END FOR  \n        END FUNCTION  \n        \n        FOR each word IN words  \n            CALL backtrack WITH a list containing only word  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-genetic-mutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMutation(start, end, bank)  \n        SET s TO a set created from bank  \n        SET q TO a double ended queue initialized with a pair consisting of start and zero  \n        SET mp TO a mapping where the element 'A' maps to the sequence of 'T', 'C', and 'G' and the element 'T' maps to the sequence of 'A', 'C', and 'G' and the element 'C' maps to the sequence of 'A', 'T', and 'G' and the element 'G' maps to the sequence of 'A', 'T', and 'C'  \n        WHILE q is not empty  \n            REMOVE the first element of q and assign the first part to t and the second part to step  \n            IF t EQUALS end  \n                RETURN step  \n            END IF  \n            FOR each index i and corresponding character v in the ordered elements of t  \n                FOR each character j IN the sequence mapped by v in mp  \n                    SET next TO the concatenation of the substring from the beginning up to position i of t PLUS the character j PLUS the substring from position i plus one to the end of t  \n                    IF next is an element contained in s  \n                        APPEND the pair consisting of next and step PLUS one TO q  \n                        REMOVE next FROM s  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-overlapping-intervals", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION eraseOverlapIntervals(intervals)  \n        IF intervals EQUALS empty collection  \n            RETURN zero  \n        END IF  \n        SORT intervals BY the end element at position two of each interval  \n        SET end TO the end element at position two of the first interval in intervals  \n        SET count TO zero  \n        FOR index FROM two TO the LENGTH OF intervals  \n            IF the start element at position one of the interval at index IN intervals IS GREATER THAN OR EQUAL TO end  \n                SET end TO the end element at position two of the interval at index IN intervals  \n            ELSE  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-right-interval", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRightInterval(intervals)  \n        SET start_times TO an empty list  \n        FOR index FROM zero TO the LENGTH OF intervals MINUS one  \n            SET interval TO element at position index of intervals  \n            APPEND a pair consisting of the element at position zero of interval AND index TO start_times  \n        END FOR  \n        SORT start_times BY the first element of each pair in ascending order  \n        \n        SET result TO an empty list  \n        FOR each interval IN intervals  \n            SET end_value TO the element at position one of interval  \n            SET search_index TO the position found by binary searching for the smallest first element in start_times GREATER THAN OR EQUAL TO end_value  \n            IF search_index IS LESS THAN the LENGTH OF start_times THEN  \n                APPEND the second element of the pair at position search_index of start_times TO result  \n            ELSE  \n                APPEND negative one TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-all-anagrams-in-a-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findAnagrams WITH PARAMETERS s p  \n        SET length_of_s TO the LENGTH OF s  \n        SET length_of_p TO the LENGTH OF p  \n        IF length_of_p GREATER THAN length_of_s  \n            RETURN an EMPTY list  \n        END IF  \n        SET p_count TO the COUNTER OF all elements IN p  \n        SET s_count TO the COUNTER OF the substring of s FROM position zero TO position length_of_p MINUS one  \n        SET anagrams TO an EMPTY list  \n        IF s_count EQUALS p_count  \n            APPEND zero TO anagrams  \n        END IF  \n        FOR index FROM length_of_p TO length_of_s MINUS one  \n            INCREMENT the COUNT OF element at position index of s IN s_count BY one  \n            DECREMENT the COUNT OF element at position index MINUS length_of_p of s IN s_count BY one  \n            IF the COUNT OF element at position index MINUS length_of_p of s IN s_count EQUALS zero  \n                REMOVE element at position index MINUS length_of_p of s FROM s_count  \n            END IF  \n            IF s_count EQUALS p_count  \n                APPEND index MINUS length_of_p PLUS one TO anagrams  \n            END IF  \n        END FOR  \n        RETURN anagrams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-smallest-in-lexicographical-order", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findKthNumber(n k)  \n        FUNCTION count_steps(prefix n)  \n            SET next_prefix TO prefix PLUS one  \n            SET steps TO zero  \n            WHILE prefix IS LESS THAN OR EQUAL TO n  \n                INCREMENT steps BY the LESSER OF the DIFFERENCE BETWEEN n AND prefix PLUS one AND the DIFFERENCE BETWEEN next_prefix AND prefix  \n                SET prefix TO prefix MULTIPLIED BY ten  \n                SET next_prefix TO next_prefix MULTIPLIED BY ten  \n            END WHILE  \n            RETURN steps  \n        END FUNCTION  \n\n        SET current TO one  \n        DECREMENT k BY one  \n        WHILE k IS GREATER THAN zero  \n            SET steps TO count_steps WITH prefix current AND n n  \n            IF steps IS LESS THAN OR EQUAL TO k  \n                INCREMENT current BY one  \n                DECREMENT k BY steps  \n            ELSE  \n                SET current TO current MULTIPLIED BY ten  \n                DECREMENT k BY one  \n            END IF  \n        END WHILE  \n        RETURN current  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-all-duplicates-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDuplicates(nums)  \n        FOR index FROM zero TO the LENGTH OF nums MINUS one  \n            WHILE element at position index of nums NOT EQUALS element at position the element at position index of nums MINUS one of nums  \n                SET temporary_value TO element at position index of nums  \n                SET element at position index of nums TO element at position the element at position index of nums MINUS one of nums  \n                SET element at position the temporary_value MINUS one of nums TO temporary_value  \n            END WHILE  \n        END FOR  \n        SET result_list TO empty list  \n        FOR index FROM zero TO the LENGTH OF nums MINUS one  \n            SET current_value TO element at position index of nums  \n            IF current_value NOT EQUALS index PLUS one  \n                APPEND current_value TO result_list  \n            END IF  \n        END FOR  \n        RETURN result_list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-compression", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION compress(chars)  \n        IF the LENGTH OF chars EQUALS zero  \n            RETURN zero  \n        END IF  \n        SET write_index TO zero  \n        SET read_index TO zero  \n        WHILE read_index LESS THAN the LENGTH OF chars  \n            SET char TO element at position read_index of chars  \n            SET count TO zero  \n            WHILE read_index LESS THAN the LENGTH OF chars AND element at position read_index of chars EQUALS char  \n                INCREMENT read_index BY one  \n                INCREMENT count BY one  \n            END WHILE  \n            SET element at position write_index of chars TO char  \n            INCREMENT write_index BY one  \n            IF count GREATER THAN one  \n                FOR each digit IN the string formed by count  \n                    SET element at position write_index of chars TO digit  \n                    INCREMENT write_index BY one  \n                END FOR  \n            END IF  \n        END WHILE  \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sequence-reconstruction", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sequenceReconstruction(nums, sequences)  \n        SET n TO the LENGTH OF nums  \n        SET graph TO an empty default dictionary with list as default value  \n        SET indegree TO a list of zeros with the LENGTH OF n PLUS one  \n        \n        FOR each sequence IN sequences  \n            FOR i FROM zero TO the LENGTH OF sequence MINUS one MINUS one  \n                SET u TO element at position i of sequence  \n                SET v TO element at position i PLUS one of sequence  \n                APPEND v TO the list at key u in graph  \n                INCREMENT indegree at position v BY one  \n            END FOR  \n        END FOR  \n        \n        SET queue TO a deque containing each integer i FROM one TO n WHERE indegree at position i EQUALS zero  \n        \n        IF the LENGTH OF queue NOT EQUALS one  \n            RETURN false  \n        END IF  \n        \n        SET index TO zero  \n        WHILE queue is not empty  \n            IF the LENGTH OF queue NOT EQUALS one  \n                RETURN false  \n            END IF  \n            \n            SET node TO the first element removed FROM the left of queue  \n            IF node NOT EQUALS element at position index of nums  \n                RETURN false  \n            END IF  \n            INCREMENT index BY one  \n            \n            FOR each neighbor IN the list at key node in graph  \n                DECREMENT indegree at position neighbor BY one  \n                IF indegree at position neighbor EQUALS zero  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN index EQUALS n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "arithmetic-slices-ii-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n LESS THAN three  \n            RETURN zero  \n        END IF  \n        \n        SET dp TO a list OF default dictionaries EACH mapping integer TO integer WITH the LENGTH OF n  \n        SET total_count TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                SET d TO the element at position i of nums MINUS the element at position j of nums  \n                \n                IF dp at position j CONTAINS key d  \n                    INCREMENT the value at key d in dp at position i BY the value at key d in dp at position j PLUS one  \n                    INCREMENT total_count BY the value at key d in dp at position j  \n                ELSE  \n                    INCREMENT the value at key d in dp at position i BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-boomerangs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfBoomerangs(points)  \n        SET ans TO zero  \n        FOR each element named p1 IN points  \n            CREATE a new Counter named cnt  \n            FOR each element named p2 IN points  \n                SET dx TO element at position zero of p1 MINUS element at position zero of p2  \n                SET dy TO element at position one of p1 MINUS element at position one of p2  \n                SET d TO dx MULTIPLIED BY dx PLUS dy MULTIPLIED BY dy  \n                INCREMENT ans BY the value associated with d in cnt  \n                INCREMENT the value associated with d in cnt BY one  \n            END FOR  \n        END FOR  \n        RETURN ans MULTIPLIED BY two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-characters-by-frequency", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION frequencySort WITH PARAMETER s  \n        SET frequency TO the character frequency mapping of s  \n        SET sorted_characters TO the list of characters in frequency arranged in descending order according to their frequency values  \n        SET result TO an empty string  \n        FOR each character IN sorted_characters  \n            APPEND the character repeated the number of times equal to the frequency of the character TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-arrows-to-burst-balloons", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinArrowShots(points)  \n        SORT points BASED ON the end coordinate of each balloon  \n        SET arrows TO zero  \n        SET last_arrow_position TO negative infinity  \n        FOR each balloon IN points  \n            IF the starting coordinate of the current balloon GREATER THAN last_arrow_position  \n                INCREMENT arrows BY one  \n                SET last_arrow_position TO the ending coordinate of the current balloon  \n            END IF  \n        END FOR  \n        RETURN arrows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-equal-array-elements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMoves(nums)  \n        SET min_num TO the minimum element IN nums  \n        SET total_difference TO zero  \n        FOR each num IN nums  \n            INCREMENT total_difference BY num MINUS min_num  \n        END FOR  \n        RETURN total_difference  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "4sum-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fourSumCount(nums1  \n                          nums2  \n                          nums3  \n                          nums4)  \n        SET sum_ab TO empty dictionary  \n        FOR each element a IN nums1  \n            FOR each element b IN nums2  \n                SET current_sum TO a PLUS b  \n                IF current_sum EXISTS AS A KEY IN sum_ab THEN  \n                    INCREMENT value at key current_sum IN sum_ab BY one  \n                ELSE  \n                    SET value at key current_sum IN sum_ab TO one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET count TO zero  \n        FOR each element c IN nums3  \n            FOR each element d IN nums4  \n                SET target TO negative OF c PLUS d  \n                IF target EXISTS AS A KEY IN sum_ab THEN  \n                    INCREMENT count BY value at key target IN sum_ab  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "132-pattern", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION find132pattern(nums)  \n        SET second TO the smallest possible number  \n        SET stack TO an empty list  \n        FOR each num IN the elements of nums in reverse order  \n            IF num LESS THAN second  \n                RETURN True  \n            END IF  \n            WHILE the stack is not empty AND element at the last position of stack LESS THAN num  \n                SET second TO the element removed from the last position of stack  \n            END WHILE  \n            APPEND num TO stack  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "poor-pigs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION poorPigs(buckets minutesToDie minutesToTest)  \n        SET states TO the INTEGER RESULT OF minutesToTest DIVIDED BY minutesToDie PLUS one  \n        SET pigs TO the SMALLEST INTEGER GREATER THAN OR EQUAL TO the LOGARITHM OF buckets WITH BASE states  \n        RETURN pigs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-equal-array-elements-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMoves2(nums)  \n        CALL sort on nums to arrange elements in non decreasing order  \n        SET median TO element at position integer division of the LENGTH OF nums by two of nums  \n        SET moves TO zero  \n        FOR each num IN nums  \n            INCREMENT moves BY the absolute value of num MINUS median  \n        END FOR  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "can-i-win", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canIWin(maxChoosableInteger, desiredTotal)  \n        IF the product of maxChoosableInteger AND the sum of maxChoosableInteger PLUS one is divided by two is LESS THAN desiredTotal  \n            RETURN false  \n        END IF  \n        IF desiredTotal is LESS THAN OR EQUAL TO zero  \n            RETURN true  \n        END IF  \n        SET memo TO an empty collection  \n        FUNCTION can_win(current_total, used_numbers)  \n            IF the pair of current_total AND used_numbers EXISTS IN memo  \n                RETURN the value associated with the pair of current_total AND used_numbers in memo  \n            END IF  \n            FOR number FROM one TO maxChoosableInteger  \n                IF the bitwise AND of used_numbers AND two RAISED TO THE POWER of number equals zero  \n                    IF the sum of current_total AND number is GREATER THAN OR EQUAL TO desiredTotal OR the negation of can_win of the sum of current_total AND number AND the bitwise OR of used_numbers AND two RAISED TO THE POWER of number  \n                        SET the value associated with the pair of current_total AND used_numbers in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            SET the value associated with the pair of current_total AND used_numbers in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        RETURN can_win of zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "optimal-account-balancing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minTransfers(transactions)  \n        SET balance TO empty dictionary  \n        FOR each transaction IN transactions  \n            SET sender TO element at position zero of transaction  \n            SET receiver TO element at position one of transaction  \n            SET amount TO element at position two of transaction  \n            IF sender IS IN balance  \n                SET balance at key sender TO value at key sender MINUS amount  \n            ELSE  \n                SET balance at key sender TO negative amount  \n            END IF  \n            IF receiver IS IN balance  \n                SET balance at key receiver TO value at key receiver PLUS amount  \n            ELSE  \n                SET balance at key receiver TO amount  \n            END IF  \n        END FOR  \n        SET balances TO empty list  \n        FOR each net IN the values of balance  \n            IF net NOT EQUALS zero  \n                APPEND net TO balances  \n            END IF  \n        END FOR  \n        IF the LENGTH OF balances EQUALS zero  \n            RETURN zero  \n        END IF  \n        FUNCTION settle(start, cnt)  \n            WHILE start LESS THAN the LENGTH OF balances AND element at position start of balances EQUALS zero  \n                INCREMENT start BY one  \n            END WHILE  \n            IF start EQUALS the LENGTH OF balances  \n                RETURN cnt  \n            END IF  \n            SET min_cnt TO positive infinity  \n            FOR i FROM start PLUS one TO the LENGTH OF balances MINUS one  \n                IF element at position start of balances MULTIPLIED BY element at position i of balances LESS THAN zero  \n                    SET element at position i of balances TO element at position i of balances PLUS element at position start of balances  \n                    SET min_cnt TO the smaller BETWEEN min_cnt AND settle start PLUS one AND cnt PLUS one  \n                    SET element at position i of balances TO element at position i of balances MINUS element at position start of balances  \n                END IF  \n            END FOR  \n            RETURN min_cnt  \n        END FUNCTION  \n        RETURN settle zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-substrings-in-wraparound-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findSubstringInWraproundString s  \n        SET max_length TO a dictionary where each lowercase letter from a to z maps to zero  \n        SET current_length TO zero  \n        FOR index FROM zero TO the LENGTH OF s MINUS one  \n            IF index GREATER THAN zero AND the difference between the ordinal value of element at position index of s AND the ordinal value of element at position index MINUS one of s EQUALS one OR element at position index of s EQUALS the character a AND element at position index MINUS one of s EQUALS the character z  \n                INCREMENT current_length BY one  \n            ELSE  \n                SET current_length TO one  \n            END IF  \n            SET the value in max_length associated with element at position index of s TO the GREATER VALUE BETWEEN the current value associated with element at position index of s in max_length AND current_length  \n        END FOR  \n        SET total_count TO the sum of all values in max_length  \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "validate-ip-address", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validIPAddress(queryIP)  \n        FUNCTION is_valid_ipv4_block(block)  \n            IF block CONSISTS OF only DIGITS THEN  \n                SET num TO the INTEGER VALUE OF block  \n                IF num IS LESS THAN OR EQUAL TO two hundred fifty five AND the STRING REPRESENTATION OF num EQUALS block THEN  \n                    RETURN TRUE  \n                ELSE  \n                    RETURN FALSE  \n                END IF  \n            ELSE  \n                RETURN FALSE  \n            END IF  \n        END FUNCTION  \n      \n        FUNCTION is_valid_ipv6_block(block)  \n            IF the LENGTH OF block IS GREATER THAN OR EQUAL TO one AND the LENGTH OF block IS LESS THAN OR EQUAL TO four THEN  \n                TRY  \n                    CONVERT block TO an INTEGER VALUE USING BASE sixteen  \n                    RETURN TRUE  \n                CATCH conversion FAILURE  \n                    RETURN FALSE  \n                END TRY  \n            ELSE  \n                RETURN FALSE  \n            END IF  \n        END FUNCTION  \n      \n        SET parts_ipv4 TO the LIST OF SUBSTRINGS OF queryIP SPLIT BY the DOT CHARACTER  \n        SET parts_ipv6 TO the LIST OF SUBSTRINGS OF queryIP SPLIT BY the COLON CHARACTER  \n      \n        IF the LENGTH OF parts_ipv4 EQUALS four AND for EACH part IN parts_ipv4 the CALL TO is_valid_ipv4_block(part) RETURNS TRUE THEN  \n            RETURN the STRING indicating Internet Protocol version four  \n        ELSE IF the LENGTH OF parts_ipv6 EQUALS eight AND for EACH part IN parts_ipv6 the CALL TO is_valid_ipv6_block(part) RETURNS TRUE THEN  \n            RETURN the STRING indicating Internet Protocol version six  \n        ELSE  \n            RETURN the STRING indicating neither  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "convex-polygon", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isConvex(points)  \n        FUNCTION cross_product(o, a, b)  \n            SET first_difference_x TO element at position zero of a MINUS element at position zero of o  \n            SET second_difference_y TO element at position one of b MINUS element at position one of o  \n            SET first_term TO first_difference_x MULTIPLIED BY second_difference_y  \n            SET first_difference_y TO element at position one of a MINUS element at position one of o  \n            SET second_difference_x TO element at position zero of b MINUS element at position zero of o  \n            SET second_term TO first_difference_y MULTIPLIED BY second_difference_x  \n            SET cross_value TO first_term MINUS second_term  \n            RETURN cross_value  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF points  \n        \n        IF n LESS THAN OR EQUAL TO three  \n            RETURN True  \n        END IF  \n        \n        SET orientation TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET o TO element at position i of points  \n            SET a TO element at position of the remainder of i PLUS one DIVIDED BY n of points  \n            SET b TO element at position of the remainder of i PLUS two DIVIDED BY n of points  \n            SET cross TO cross_product(o, a, b)  \n            \n            IF cross NOT EQUALS zero  \n                IF orientation EQUALS zero  \n                    IF cross GREATER THAN zero  \n                        SET orientation TO one  \n                    ELSE  \n                        SET orientation TO minus one  \n                    END IF  \n                ELSE IF orientation EQUALS one AND cross LESS THAN zero  \n                    RETURN False  \n                ELSE IF orientation EQUALS minus one AND cross GREATER THAN zero  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "concatenated-words", "passing_rate": 1.0, "pseudocode": "CLASS Trie  \n    FUNCTION __init__(self)  \n        SET self.children TO list of None elements with length twenty six  \n        SET self.is_end TO False  \n    END FUNCTION  \n\n    FUNCTION insert(self, w)  \n        SET node TO self  \n        FOR each character c IN w  \n            SET idx TO the numeric value of character c MINUS the numeric value of the lowercase letter a  \n            IF element at position idx of node.children EQUALS None THEN  \n                SET element at position idx of node.children TO new instance of Trie  \n            END IF  \n            SET node TO element at position idx of node.children  \n        END FOR  \n        SET node.is_end TO True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findAllConcatenatedWordsInADict(self, words)  \n        FUNCTION dfs(w, start)  \n            IF start EQUALS the LENGTH OF w THEN  \n                RETURN True  \n            END IF  \n            SET node TO trie  \n            FOR i FROM start TO the LENGTH OF w MINUS one  \n                SET idx TO the numeric value of the character at position i of w MINUS the numeric value of the lowercase letter a  \n                IF element at position idx of node.children EQUALS None THEN  \n                    RETURN False  \n                END IF  \n                SET node TO element at position idx of node.children  \n                IF node.is_end EQUALS True AND dfs(w, i PLUS one) EQUALS True THEN  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n\n        SET trie TO new instance of Trie  \n        SET ans TO empty list  \n        SORT words by the LENGTH OF each word in ascending order  \n        FOR each w IN words  \n            IF w NOT EQUALS empty string THEN  \n                IF dfs(w, zero) EQUALS True THEN  \n                    APPEND w TO ans  \n                ELSE  \n                    CALL trie.insert with argument w  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "matchsticks-to-square", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION makesquare(matchsticks)  \n        SET total_length TO the sum of all elements in matchsticks  \n        IF the remainder of total_length DIVIDED BY four NOT EQUALS zero THEN  \n            RETURN false  \n        END IF  \n        SET side_length TO total_length DIVIDED BY four  \n        SORT matchsticks in descending order  \n        \n        FUNCTION can_form_sides(sides, index)  \n            IF index EQUALS the LENGTH OF matchsticks THEN  \n                FOR each side IN sides  \n                    IF side NOT EQUALS side_length THEN  \n                        RETURN false  \n                    END IF  \n                END FOR  \n                RETURN true  \n            END IF  \n            \n            FOR i FROM zero TO three  \n                IF the element at position i of sides PLUS the element at position index of matchsticks LESS THAN OR EQUAL TO side_length THEN  \n                    INCREMENT the element at position i of sides BY the element at position index of matchsticks  \n                    IF can_form_sides(sides, index PLUS one) THEN  \n                        RETURN true  \n                    END IF  \n                    DECREMENT the element at position i of sides BY the element at position index of matchsticks  \n                END IF  \n                IF the element at position i of sides EQUALS zero THEN  \n                    BREAK the FOR loop  \n                END IF  \n            END FOR  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN can_form_sides(a list of four zeros, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ones-and-zeroes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        SET dp TO a two dimensional list with the dimensions of m plus one by n plus one where each element is zero  \n        FOR each string s IN strs  \n            SET count_0 TO the number of elements EQUALS to zero in the string s  \n            SET count_1 TO the number of elements EQUALS to one in the string s  \n            FOR variable i FROM m DOWN TO count_0  \n                FOR variable j FROM n DOWN TO count_1  \n                    SET dp at position i and position j TO the maximum value between dp at position i and position j AND the value of dp at position i MINUS count_0 and position j MINUS count_1 PLUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp at position m and position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "heaters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRadius(houses, heaters)  \n        SORT houses IN ascending order  \n        SORT heaters IN ascending order  \n        \n        SET min_radius TO zero  \n        SET j TO zero  \n        \n        FOR each house IN houses  \n            WHILE j LESS THAN length of heaters MINUS one AND absolute value of element at position j of heaters MINUS house GREATER THAN OR EQUAL TO absolute value of element at position j PLUS one of heaters MINUS house  \n                INCREMENT j BY one  \n            END WHILE  \n            \n            SET min_radius TO maximum of min_radius AND absolute value of element at position j of heaters MINUS house  \n        END FOR  \n        \n        RETURN min_radius  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "total-hamming-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION totalHammingDistance(nums)  \n        SET total_distance TO zero  \n        FOR i FROM zero TO thirty-one  \n            SET count_ones TO zero  \n            FOR each num IN nums  \n                INCREMENT count_ones BY the bit at position i of num  \n            END FOR  \n            SET count_zeros TO the LENGTH OF nums MINUS count_ones  \n            INCREMENT total_distance BY count_ones MULTIPLIED BY count_zeros  \n        END FOR  \n        RETURN total_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-window-median", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION medianSlidingWindow(nums k)  \n        SET lo TO empty list  \n        SET hi TO empty list  \n\n        FUNCTION balance_heaps()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi PLUS one  \n                CALL heappush WITH the argument hi AND NEGATIVE of the result of heappop ON lo  \n            ELSE IF the LENGTH OF hi IS GREATER THAN the LENGTH OF lo  \n                CALL heappush WITH the argument lo AND NEGATIVE of the result of heappop ON hi  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION add_num(num)  \n            IF lo IS empty OR num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                CALL heappush WITH the argument lo AND NEGATIVE num  \n            ELSE  \n                CALL heappush WITH the argument hi AND num  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION remove_num(num)  \n            IF num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                REMOVE NEGATIVE num FROM lo  \n                IF lo IS NOT empty  \n                    CALL heapify WITH the argument lo  \n                END IF  \n            ELSE  \n                REMOVE num FROM hi  \n                IF hi IS NOT empty  \n                    CALL heapify WITH the argument hi  \n                END IF  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION get_median()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi  \n                RETURN NEGATIVE of element at position zero of lo  \n            END IF  \n            RETURN NEGATIVE of element at position zero of lo PLUS element at position zero of hi DIVIDED BY two  \n        END FUNCTION  \n\n        FOR i FROM zero TO k MINUS one  \n            CALL add_num WITH element at position i of nums  \n        END FOR  \n\n        SET medians TO a list containing the result of get_median()  \n\n        FOR i FROM k TO the LENGTH OF nums MINUS one  \n            CALL add_num WITH element at position i of nums  \n            CALL remove_num WITH element at position i MINUS k of nums  \n            APPEND the result of get_median() TO medians  \n        END FOR  \n\n        RETURN medians  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-permutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPermutation(s)  \n        SET result TO an empty list  \n        FOR each index i FROM zero TO the LENGTH OF s PLUS one MINUS one  \n            APPEND the value of index i PLUS one TO result  \n        END FOR  \n        SET start TO zero  \n        FOR each index end FROM zero TO the LENGTH OF s PLUS one MINUS one  \n            IF the value of index end EQUALS the LENGTH OF s OR the element at position end of s EQUALS the uppercase letter I THEN  \n                REVERSE the sublist of result FROM position start TO position end PLUS one  \n                SET start TO end PLUS one  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "zuma-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinStep(board, hand)  \n        FUNCTION clean(board)  \n            SET stack TO empty list  \n            FOR each ball IN the sequence of characters in board  \n                IF stack is not empty AND the first element at the last position of stack NOT EQUALS ball AND the second element at the last position of stack GREATER THAN OR EQUAL TO three  \n                    REMOVE the last element FROM stack  \n                END IF  \n                IF stack is empty OR the first element at the last position of stack NOT EQUALS ball  \n                    APPEND a pair of ball and one TO stack  \n                ELSE  \n                    INCREMENT the second element at the last position of stack BY one  \n                END IF  \n            END FOR  \n            IF stack is not empty AND the second element at the last position of stack GREATER THAN OR EQUAL TO three  \n                REMOVE the last element FROM stack  \n            END IF  \n            SET result TO an empty string  \n            FOR each pair of ball and count IN stack  \n                APPEND the sequence of ball repeated count times TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n\n        FUNCTION dfs(board, hand_counter)  \n            IF the sequence board is empty  \n                RETURN zero  \n            END IF  \n            SET min_steps TO positive infinity  \n            SET i TO zero  \n            WHILE i LESS THAN the length of board  \n                SET j TO i PLUS one  \n                WHILE j LESS THAN the length of board AND the element at position i of board EQUALS the element at position j of board  \n                    INCREMENT j BY one  \n                END WHILE  \n                SET increment TO three MINUS the difference of j MINUS i  \n                IF the value corresponding to the element at position i of board IN hand_counter GREATER THAN OR EQUAL TO increment  \n                    SET new_hand_counter TO a copy of hand_counter  \n                    DECREMENT the value corresponding to the element at position i of board IN new_hand_counter BY increment  \n                    SET new_board TO clean(the substring from position zero TO position i of board CONCATENATED WITH substring from position j TO the end of board)  \n                    SET steps TO dfs(new_board, new_hand_counter)  \n                    IF steps GREATER THAN OR EQUAL TO zero  \n                        SET min_steps TO the lesser of min_steps AND steps PLUS increment  \n                    END IF  \n                END IF  \n                SET i TO j  \n            END WHILE  \n            IF min_steps EQUALS positive infinity  \n                RETURN negative one  \n            ELSE  \n                RETURN min_steps  \n            END IF  \n        END FUNCTION  \n\n        SET hand_counter TO the count mapping of elements in hand  \n        RETURN dfs(board, hand_counter)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-maze", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hasPath maze start destination  \n        SET directions TO the list containing the pairs of zero and one one and zero zero and negative one negative one and zero  \n        SET m TO the length of maze  \n        SET n TO the length of the element at position zero of maze  \n        SET visited TO an empty set  \n        \n        FUNCTION dfs x y  \n            IF the pair of x and y is a member of visited THEN  \n                RETURN False  \n            END IF  \n            IF the list containing x and y EQUALS destination THEN  \n                RETURN True  \n            END IF  \n            ADD the pair of x and y TO visited  \n            \n            FOR each pair dx dy IN directions  \n                SET nx TO x  \n                SET ny TO y  \n                WHILE nx PLUS dx is greater than or EQUAL TO zero AND nx PLUS dx is LESS THAN m AND ny PLUS dy is greater than or EQUAL TO zero AND ny PLUS dy is LESS THAN n AND the element at position nx PLUS dx of maze at position ny PLUS dy EQUALS zero  \n                    INCREMENT nx BY dx  \n                    INCREMENT ny BY dy  \n                END WHILE  \n                IF dfs nx ny THEN  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN dfs the element at position zero of start the element at position one of start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-pairs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reversePairs(nums)  \n        FUNCTION merge_and_count(nums, start, end)  \n            IF start GREATER THAN OR EQUAL TO end THEN  \n                RETURN zero  \n            END IF  \n            \n            SET mid TO the result of the integer division of the sum of start and end BY two  \n            SET count TO the sum of the result of merge_and_count with parameters nums start mid AND the result of merge_and_count with parameters nums mid PLUS one end  \n            \n            SET j TO mid PLUS one  \n            FOR i FROM start TO mid  \n                WHILE j LESS THAN OR EQUAL TO end AND the element at position i of nums GREATER THAN two MULTIPLIED BY the element at position j of nums  \n                    INCREMENT j BY one  \n                END WHILE  \n                INCREMENT count BY j MINUS (mid PLUS one)  \n            END FOR  \n            \n            INITIALIZE merged AS an empty list  \n            SET left TO start  \n            SET right TO mid PLUS one  \n            WHILE left LESS THAN OR EQUAL TO mid AND right LESS THAN OR EQUAL TO end  \n                IF the element at position left of nums LESS THAN OR EQUAL TO the element at position right of nums THEN  \n                    APPEND the element at position left of nums TO merged  \n                    INCREMENT left BY one  \n                ELSE  \n                    APPEND the element at position right of nums TO merged  \n                    INCREMENT right BY one  \n                END IF  \n            END WHILE  \n            \n            FOR index FROM left TO mid  \n                APPEND the element at position index of nums TO merged  \n            END FOR  \n            FOR index FROM right TO end  \n                APPEND the element at position index of nums TO merged  \n            END FOR  \n            \n            FOR index FROM zero TO the LENGTH OF merged MINUS one  \n                SET the element at position start PLUS index of nums TO the element at position index of merged  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of merge_and_count with parameters nums zero the LENGTH OF nums MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "target-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findTargetSumWays(nums, target)  \n        FUNCTION dfs(index, current_sum, memo)  \n            IF index EQUALS the LENGTH OF nums  \n                IF current_sum EQUALS target  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF the tuple of index AND current_sum IS a KEY IN memo  \n                RETURN the value CORRESPONDING TO the tuple of index AND current_sum IN memo  \n            END IF  \n            SET positive TO the RESULT OF dfs WITH index INCREMENTED BY one AND current_sum INCREMENTED BY the element at position index OF nums AND memo  \n            SET negative TO the RESULT OF dfs WITH index INCREMENTED BY one AND current_sum DECREMENTED BY the element at position index OF nums AND memo  \n            SET the tuple of index AND current_sum IN memo TO positive PLUS negative  \n            RETURN the value CORRESPONDING TO the tuple of index AND current_sum IN memo  \n        END FUNCTION  \n        RETURN the RESULT OF dfs WITH zero AS index AND zero AS current_sum AND an empty dictionary AS memo  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "diagonal-traverse", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDiagonalOrder(mat)  \n        IF mat EQUALS empty OR element at position zero of mat EQUALS empty  \n            RETURN empty list  \n        END IF  \n        \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF element at position zero of mat  \n        SET result TO empty list  \n        SET r TO zero  \n        SET c TO zero  \n        SET direction TO one  \n        \n        FOR each iteration FROM one TO m MULTIPLIED BY n  \n            APPEND element at position r of mat at position c TO result  \n            IF direction EQUALS one  \n                SET new_r TO r MINUS one  \n                SET new_c TO c PLUS one  \n            ELSE  \n                SET new_r TO r PLUS one  \n                SET new_c TO c MINUS one  \n            END IF  \n            \n            IF new_r LESS THAN zero OR new_r EQUALS m OR new_c LESS THAN zero OR new_c EQUALS n  \n                IF direction EQUALS one  \n                    IF new_c EQUALS n  \n                        SET new_r TO r PLUS one  \n                        SET new_c TO c  \n                    ELSE  \n                        SET new_r TO zero  \n                        SET new_c TO c PLUS one  \n                    END IF  \n                ELSE  \n                    IF new_r EQUALS m  \n                        SET new_r TO r  \n                        SET new_c TO c PLUS one  \n                    ELSE  \n                        SET new_r TO r PLUS one  \n                        SET new_c TO zero  \n                    END IF  \n                END IF  \n                SET direction TO direction MULTIPLIED BY negative one  \n            END IF  \n            \n            SET r TO new_r  \n            SET c TO new_c  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-maze-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findShortestWay(maze, ball, hole)  \n        SET directions TO list of elements each containing zero zero and letter r, one zero and letter d, zero negative one and letter l, negative one zero and letter u  \n        SET m TO the LENGTH OF maze  \n        SET n TO the LENGTH OF the element at position zero of maze  \n        SET start TO ball converted into a tuple form  \n        SET hole TO hole converted into a tuple form  \n        SET pq TO list containing a tuple of zero, empty string, and start  \n        SET visited TO an empty set  \n        \n        WHILE pq holds  \n            EXTRACT dist path and position consisting of x and y FROM the element obtained by removing the smallest element from pq  \n            \n            IF x EQUALS the first element of hole AND y EQUALS the second element of hole THEN  \n                RETURN path  \n            END IF  \n            \n            IF position IN visited THEN  \n                CONTINUE to the next iteration of the WHILE loop  \n            END IF  \n            \n            ADD position TO visited  \n            \n            FOR each dx dy direction IN directions  \n                SET new_x TO x  \n                SET new_y TO y  \n                SET count TO zero  \n                \n                WHILE new_x PLUS dx IS GREATER THAN OR EQUAL TO zero AND new_x PLUS dx IS LESS THAN m AND new_y PLUS dy IS GREATER THAN OR EQUAL TO zero AND new_y PLUS dy IS LESS THAN n AND the element at position new_x PLUS dx of maze at position new_y PLUS dy EQUALS zero  \n                    SET new_x TO new_x PLUS dx  \n                    SET new_y TO new_y PLUS dy  \n                    INCREMENT count BY one  \n                    IF new_x EQUALS the first element of hole AND new_y EQUALS the second element of hole THEN  \n                        BREAK from the WHILE loop  \n                    END IF  \n                END WHILE  \n                \n                IF tuple of new_x and new_y NOT IN visited THEN  \n                    ADD a tuple consisting of dist PLUS count, path CONCATENATED WITH direction, and tuple of new_x and new_y TO pq using the heap push operation  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the string impossible  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ipo", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaximizedCapital(k INTEGER, w INTEGER, profits LIST OF INTEGER, capital LIST OF INTEGER) RETURNS INTEGER  \n        SET projects TO the LIST of PAIRS formed by pairing each element of capital with the corresponding element of profits  \n        SORT projects IN ascending order BY the first element of each PAIR representing capital  \n        \n        SET max_heap TO an empty LIST  \n        \n        SET i TO zero  \n        SET n TO the LENGTH OF projects  \n        \n        FOR each iteration FROM one TO k  \n            WHILE i LESS THAN n AND the first element of the PAIR at position i of projects LESS THAN OR EQUAL TO w  \n                ADD the NEGATIVE of the second element of the PAIR at position i of projects TO max_heap using heap insertion  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF max_heap IS empty  \n                EXIT the FOR loop  \n            END IF  \n            \n            SET w TO w PLUS the NEGATIVE of the value obtained by removing the smallest element from max_heap using heap removal  \n        END FOR  \n        \n        RETURN w  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-greater-element-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextGreaterElements(nums)  \n        SET n TO the LENGTH OF nums  \n        SET result TO a list of the LENGTH OF n FILLED WITH minus one  \n        SET stack TO an empty list  \n        \n        FOR i FROM zero TO two MULTIPLIED BY n MINUS one  \n            SET index TO the remainder of i DIVIDED BY n  \n            WHILE the LENGTH OF stack is GREATER THAN zero AND the element at position the last element of stack of nums is LESS THAN the element at position index of nums  \n                SET top_index TO the last element of stack  \n                REMOVE the last element FROM stack  \n                SET the element at position top_index of result TO the element at position index of nums  \n            END WHILE  \n            IF i is LESS THAN n  \n                APPEND index TO stack  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-maze-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestDistance(maze, start, destination)  \n        SET m TO the LENGTH OF maze  \n        SET n TO the LENGTH OF the element at position zero of maze  \n        SET directions TO the LIST containing the PAIRS of values one and zero MINUS one and zero zero and one zero and MINUS one  \n        SET start TO the TUPLE of start  \n        SET destination TO the TUPLE of destination  \n        SET visited TO an EMPTY SET  \n        SET pq TO the LIST containing the PAIR of zero and start  \n\n        WHILE pq is NOT EMPTY  \n            SET dist, position TO the RESULT OF REMOVING the SMALLEST ELEMENT FROM pq  \n            SET x TO the ELEMENT at position zero of position  \n            SET y TO the ELEMENT at position one of position  \n            \n            IF x EQUALS the ELEMENT at position zero of destination AND y EQUALS the ELEMENT at position one of destination  \n                RETURN dist  \n            END IF  \n            \n            IF position IS IN visited  \n                CONTINUE TO the NEXT ITERATION  \n            END IF  \n            \n            ADD position TO visited  \n            \n            FOR each dx, dy IN directions  \n                SET new_x TO x  \n                SET new_y TO y  \n                SET count TO zero  \n                WHILE new_x PLUS dx IS GREATER THAN OR EQUAL TO zero AND new_x PLUS dx IS LESS THAN m AND new_y PLUS dy IS GREATER THAN OR EQUAL TO zero AND new_y PLUS dy IS LESS THAN n AND the ELEMENT at position new_x PLUS dx of maze AT position new_y PLUS dy EQUALS zero  \n                    INCREMENT new_x BY dx  \n                    INCREMENT new_y BY dy  \n                    INCREMENT count BY one  \n                END WHILE  \n                \n                IF the TUPLE of new_x and new_y IS NOT IN visited  \n                    INSERT the PAIR of dist PLUS count and the TUPLE of new_x and new_y INTO pq maintaining ORDER BY the FIRST ELEMENT OF THE PAIR being the DISTANCE  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the NEGATIVE OF one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "freedom-trail", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRotateSteps(ring, key)  \n        CREATE empty dictionary named char_positions with default value as an empty list  \n        FOR each index i AND character char IN the ring string  \n            APPEND i TO the list at key char in char_positions  \n        END FOR  \n        \n        SET n TO the LENGTH OF ring  \n        \n        FUNCTION dp(i, prev_pos)  \n            IF i EQUALS the LENGTH OF key THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_steps TO a very large number representing infinite  \n            FOR each position pos IN the list at key at character at position i in key in char_positions  \n                SET clockwise TO position MINUS prev_pos MODULO n  \n                SET anticlockwise TO prev_pos MINUS position MODULO n  \n                SET steps TO the smaller value BETWEEN clockwise AND anticlockwise PLUS one PLUS dp with arguments i PLUS one AND position  \n                SET min_steps TO the smaller value BETWEEN min_steps AND steps  \n            END FOR  \n            \n            RETURN min_steps  \n        END FUNCTION  \n        \n        RETURN dp with arguments zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-palindromic-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindromeSubseq(s)  \n        SET n TO the LENGTH OF s  \n        SET dp TO a two dimensional list of size n BY n with all values SET TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i AT element at position i of dp TO one  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i AT element at position j of dp TO element at position i PLUS one AT element at position j MINUS one of dp PLUS two  \n                ELSE  \n                    IF element at position i PLUS one AT element at position j of dp GREATER THAN OR EQUAL TO element at position i AT element at position j MINUS one of dp  \n                        SET element at position i AT element at position j of dp TO element at position i PLUS one AT element at position j of dp  \n                    ELSE  \n                        SET element at position i AT element at position j of dp TO element at position i AT element at position j MINUS one of dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero AT element at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-washing-machines", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinMoves(machines)  \n        SET total_dresses TO zero  \n        FOR each dress_count IN machines  \n            INCREMENT total_dresses BY dress_count  \n        END FOR  \n        SET n TO the LENGTH OF machines  \n        IF the remainder when total_dresses IS DIVIDED BY n NOT EQUALS zero THEN  \n            RETURN minus one  \n        END IF  \n        SET target TO total_dresses DIVIDED BY n  \n        SET left_sum TO zero  \n        SET max_moves TO zero  \n        FOR i FROM zero TO n MINUS one  \n            SET left_excess TO left_sum MINUS target MULTIPLIED BY i  \n            SET right_excess TO total_dresses MINUS left_sum MINUS element at position i of machines MINUS target MULTIPLIED BY n MINUS i MINUS one  \n            SET current_moves TO the maximum value AMONG the absolute value of left_excess AND the absolute value of right_excess AND element at position i of machines MINUS target  \n            SET max_moves TO the maximum value BETWEEN max_moves AND current_moves  \n            INCREMENT left_sum BY element at position i of machines  \n        END FOR  \n        RETURN max_moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION change(amount parameter, coins parameter)  \n        SET a list named dp TO a list of zeros with the length equal to amount parameter PLUS one  \n        SET element at position zero of dp TO one  \n        FOR each coin element IN coins parameter  \n            FOR index x FROM the value of coin element TO amount parameter  \n                INCREMENT element at position x of dp BY element at position x MINUS coin element of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position amount parameter of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-uncommon-subsequence-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLUSlength(strs)  \n        FUNCTION is_subsequence(s, t)  \n            SET iterator_reference TO the iterator OVER t  \n            RETURN the logical AND of for each character in s TEST character IS IN iterator_reference  \n        END FUNCTION  \n        \n        SORT strs BY length in descending order AND lexicographically ascending order  \n        \n        FOR index i FROM zero TO the LENGTH OF strs MINUS one  \n            SET word TO element at position i of strs  \n            SET unique TO true  \n            \n            FOR index j FROM zero TO the LENGTH OF strs MINUS one  \n                SET other TO element at position j of strs  \n                IF i NOT EQUALS j AND is_subsequence of word IN other HOLDS true  \n                    SET unique TO false  \n                    BREAK the inner loop  \n                END IF  \n            END FOR  \n            \n            IF unique IS true  \n                RETURN the LENGTH OF word  \n            END IF  \n        END FOR  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "continuous-subarray-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkSubarraySum(nums k)  \n        SET remainder_map TO a dictionary mapping zero TO negative one  \n        SET current_sum TO zero  \n        FOR each index i AND each number num IN enumeration of nums  \n            INCREMENT current_sum BY num  \n            IF k NOT EQUALS zero  \n                SET current_sum TO current_sum MODULO k  \n            END IF  \n            IF current_sum EXISTS AS A KEY IN remainder_map  \n                IF i MINUS value at key current_sum in remainder_map GREATER THAN one  \n                    RETURN true  \n                END IF  \n            ELSE  \n                ASSIGN value at key current_sum in remainder_map TO i  \n            END IF  \n        END FOR  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary-through-deleting", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLongestWord(s, dictionary)  \n        FUNCTION is_subsequence(word, s)  \n            SET iterator_variable TO an iterator over the characters of s  \n            RETURN the result of testing for each character in word whether this character appears in the remaining elements of iterator_variable in order  \n        END FUNCTION  \n  \n        SORT the dictionary by ordering the words first by the negative value of their length so that longer words come before shorter ones AND if two words have the same length by the natural alphabetical order from the beginning of the words  \n  \n        FOR each word IN the dictionary  \n            IF the word is a subsequence of s according to is_subsequence function  \n                RETURN the current word  \n            END IF  \n        END FOR  \n  \n        RETURN an empty string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "contiguous-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxLength(nums)  \n        SET prefix_sum_index TO a dictionary with key zero and value negative one  \n        SET max_length TO zero  \n        SET count TO zero  \n        \n        FOR each index i AND element num IN nums  \n            IF num EQUALS one  \n                INCREMENT count BY one  \n            ELSE  \n                DECREMENT count BY one  \n            END IF  \n            \n            IF prefix_sum_index CONTAINS key count  \n                SET max_length TO the GREATER OF max_length AND index i MINUS element at key count of prefix_sum_index  \n            ELSE  \n                SET element at key count of prefix_sum_index TO index i  \n            END IF  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "beautiful-arrangement", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countArrangement(n)  \n        FUNCTION backtrack(used, index)  \n            IF index EQUALS n PLUS one  \n                RETURN one  \n            END IF  \n            SET count TO zero  \n            FOR i FROM one TO n  \n                IF element at position i of used EQUALS False AND (i MODULO index EQUALS zero OR index MODULO i EQUALS zero)  \n                    SET element at position i of used TO True  \n                    INCREMENT count BY backtrack(used, index PLUS one)  \n                    SET element at position i of used TO False  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        SET used TO list of False values repeated n PLUS one times  \n        RETURN backtrack(used, one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minesweeper", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION updateBoard(board, click)  \n        FUNCTION count_adjacent_mines(row, column)  \n            SET mine_count TO zero  \n            FOR each index_i FROM row MINUS one TO row PLUS one  \n                FOR each index_j FROM column MINUS one TO column PLUS one  \n                    IF index_i IS GREATER THAN OR EQUAL TO zero AND index_i IS LESS THAN the LENGTH OF board AND index_j IS GREATER THAN OR EQUAL TO zero AND index_j IS LESS THAN the LENGTH OF element at position zero of board AND element at position index_i and index_j of board EQUALS a mine designation  \n                        INCREMENT mine_count BY one  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN mine_count  \n        END FUNCTION  \n      \n        FUNCTION dfs(row, column)  \n            IF NOT (row IS GREATER THAN OR EQUAL TO zero AND row IS LESS THAN the LENGTH OF board AND column IS GREATER THAN OR EQUAL TO zero AND column IS LESS THAN the LENGTH OF element at position zero of board)  \n                RETURN  \n            END IF  \n            IF element at position row and column of board NOT EQUALS unexplored designation  \n                RETURN  \n            END IF  \n          \n            SET adjacent_mines TO count_adjacent_mines(row, column)  \n            IF adjacent_mines IS GREATER THAN zero  \n                SET element at position row and column of board TO the string representation of adjacent_mines  \n            ELSE  \n                SET element at position row and column of board TO blank designation  \n                FOR each index_i FROM row MINUS one TO row PLUS one  \n                    FOR each index_j FROM column MINUS one TO column PLUS one  \n                        CALL dfs with arguments index_i and index_j  \n                    END FOR  \n                END FOR  \n            END IF  \n        END FUNCTION  \n      \n        SET row TO the element at position zero of click  \n        SET col TO the element at position one of click  \n        IF element at position row and col of board EQUALS mine designation  \n            SET element at position row and col of board TO exploded designation  \n            RETURN board  \n        END IF  \n      \n        CALL dfs with arguments row and col  \n        RETURN board  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lonely-pixel-i", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLonelyPixel WITH PARAMETER picture  \n        IF picture EQUALS empty OR element at position zero of picture EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF picture  \n        SET n TO the LENGTH OF element at position zero of picture  \n        SET row_count TO a new list of zeroes with length m  \n        SET col_count TO a new list of zeroes with length n  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of picture EQUALS a list AND element at position j of element at position i of picture EQUALS a character that EQUALS the character represented by the letter B  \n                    INCREMENT element at position i of row_count BY one  \n                    INCREMENT element at position j of col_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET lonely_pixel_count TO zero  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of picture EQUALS a list AND element at position j of element at position i of picture EQUALS a character that EQUALS the character represented by the letter B AND element at position i of row_count EQUALS one AND element at position j of col_count EQUALS one  \n                    INCREMENT lonely_pixel_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN lonely_pixel_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-diff-pairs-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPairs(nums k)  \n        IF k LESS THAN zero THEN  \n            RETURN zero  \n        END IF  \n        SET num_counts TO an empty mapping from numbers to counts  \n        FOR each num IN nums  \n            IF num is a key in num_counts THEN  \n                INCREMENT the value associated with num by one  \n            ELSE  \n                SET the value associated with num to one  \n            END IF  \n        END FOR  \n        SET unique_pairs TO zero  \n        FOR each num IN the set of keys in num_counts  \n            IF k EQUALS zero THEN  \n                IF the value associated with num in num_counts GREATER THAN one THEN  \n                    INCREMENT unique_pairs BY one  \n                END IF  \n            ELSE  \n                IF the sum of num PLUS k is a key in num_counts THEN  \n                    INCREMENT unique_pairs BY one  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN unique_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lonely-pixel-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findBlackPixel(picture, target)  \n        IF picture EQUALS nothing OR element at position zero of picture EQUALS nothing  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF picture  \n        SET n TO the LENGTH OF element at position zero of picture  \n        SET row_count TO list of zeros with length m  \n        SET col_count TO list of zeros with length n  \n        SET row_patterns TO a new mapping from string to integer with default value zero  \n        \n        FOR r FROM zero TO m MINUS one  \n            SET pattern TO concatenation of all elements of element at position r of picture as a single string  \n            INCREMENT the value in row_patterns at key pattern BY one  \n            FOR c FROM zero TO n MINUS one  \n                IF element at position c of element at position r of picture EQUALS the character representing a black pixel  \n                    INCREMENT element at position r of row_count BY one  \n                    INCREMENT element at position c of col_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET lonely_pixels TO zero  \n        \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                IF element at position c of element at position r of picture EQUALS the character representing a black pixel  \n                    SET pattern TO concatenation of all elements of element at position r of picture as a single string  \n                    IF element at position r of row_count EQUALS target AND element at position c of col_count EQUALS target AND the value in row_patterns at key pattern EQUALS target  \n                        INCREMENT lonely_pixels BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN lonely_pixels  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "complex-number-multiplication", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION complexNumberMultiply(num1  \n                                   num2)  \n        FUNCTION parse_complex(num)  \n            SET parts TO the result of splitting num BY the plus sign  \n            SET real TO the integer representation of element at position zero of parts  \n            SET imaginary_string TO element at position one of parts  \n            SET imaginary TO the integer representation of the substring of imaginary_string FROM position zero TO the position before the last character  \n            RETURN real AND imaginary  \n        END FUNCTION  \n        \n        SET real1 AND imag1 TO the result of calling parse_complex WITH num1  \n        SET real2 AND imag2 TO the result of calling parse_complex WITH num2  \n        \n        SET real_part TO real1 MULTIPLIED BY real2 MINUS imag1 MULTIPLIED BY imag2  \n        SET imaginary_part TO real1 MULTIPLIED BY imag2 PLUS imag1 MULTIPLIED BY real2  \n        \n        RETURN the concatenation of the string representation of real_part PLUS the plus sign PLUS the string representation of imaginary_part PLUS the letter i  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-difference", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET split_result TO the list of elements obtained by splitting time at the position of the colon character  \n            SET hours TO the integer conversion of the element at position zero of split_result  \n            SET minutes TO the integer conversion of the element at position one of split_result  \n            RETURN the result of multiplication of hours by the number of minutes in one hour PLUS minutes  \n        END FUNCTION  \n        \n        SET minutes_list TO the list obtained by applying the function to_minutes to each element in timePoints  \n        SORT minutes_list in ascending order  \n        SET min_diff TO positive infinity  \n        FOR index FROM one TO the length of minutes_list MINUS one  \n            SET current_difference TO the element at position index of minutes_list MINUS the element at position index MINUS one of minutes_list  \n            IF current_difference LESS THAN min_diff  \n                SET min_diff TO current_difference  \n            END IF  \n        END FOR  \n        SET circular_difference TO the result of subtracting the element at the last position of minutes_list FROM the number of minutes in a full day PLUS the element at the first position of minutes_list  \n        IF circular_difference LESS THAN min_diff  \n            SET min_diff TO circular_difference  \n        END IF  \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "single-element-in-a-sorted-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION singleNonDuplicate(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS the DIFFERENCE BETWEEN right AND left DIVIDED BY two  \n            \n            IF the remainder of mid DIVIDED BY two EQUALS one  \n                DECREMENT mid BY one  \n            END IF  \n            \n            IF the element at position mid of nums EQUALS the element at position mid PLUS one of nums  \n                SET left TO mid PLUS two  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN the element at position left of nums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "01-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION updateMatrix WITH parameter mat  \n        IF mat EQUALS empty OR element at position zero of mat EQUALS empty  \n            RETURN mat  \n        END IF  \n        \n        SET rows TO the LENGTH OF mat  \n        SET cols TO the LENGTH OF element at position zero of mat  \n        \n        SET dist TO a new list  \n        FOR index r FROM zero TO rows MINUS one  \n            SET row_list TO a new list  \n            FOR index c FROM zero TO cols MINUS one  \n                APPEND infinity TO row_list  \n            END FOR  \n            APPEND row_list TO dist  \n        END FOR  \n        \n        SET queue TO an empty queue structure  \n        \n        FOR index r FROM zero TO rows MINUS one  \n            FOR index c FROM zero TO cols MINUS one  \n                IF element at position r of mat AT position c EQUALS zero  \n                    SET element at position r of dist AT position c TO zero  \n                    APPEND the tuple of r and c TO queue  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET directions TO a list of tuples each containing  \n            the first tuple with negative one and zero  \n            the second tuple with one and zero  \n            the third tuple with zero and negative one  \n            the fourth tuple with zero and one  \n        \n        WHILE queue is not empty  \n            SET current_position TO the removal of the first element FROM queue  \n            SET r TO the first element of current_position  \n            SET c TO the second element of current_position  \n            FOR each tuple dr, dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN rows AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN cols  \n                    AND element at position nr of dist AT position nc GREATER THAN element at position r of dist AT position c PLUS one  \n                    SET element at position nr of dist AT position nc TO element at position r of dist AT position c PLUS one  \n                    APPEND the tuple of nr and nc TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN dist  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "output-contest-matches", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        SET teams TO an empty list  \n        FOR number FROM one TO n  \n            APPEND the string representation of number TO teams  \n        END FOR  \n        WHILE n GREATER THAN one  \n            FOR i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO the concatenation of an open parenthesis concatenated with the element at position i of teams concatenated with a comma concatenated with the element at position n MINUS one MINUS i of teams concatenated with a close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN the element at position zero of teams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-boxes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeBoxes(boxes)  \n        FUNCTION dp(l, r, k, memo)  \n            IF l GREATER THAN r THEN  \n                RETURN zero  \n            END IF  \n            IF the tuple of l r k IS IN memo THEN  \n                RETURN the element at the tuple of l r k IN memo  \n            END IF  \n            WHILE r GREATER THAN l AND the element at position r of boxes EQUALS the element at position r MINUS one of boxes DO  \n                DECREMENT r BY one  \n                INCREMENT k BY one  \n            END WHILE  \n            SET res TO the result of dp WITH parameters l r MINUS one zero memo PLUS the product of the sum of k PLUS one AND the sum of k PLUS one  \n            FOR i FROM l TO r MINUS one DO  \n                IF the element at position i of boxes EQUALS the element at position r of boxes THEN  \n                    SET res TO the maximum OF res AND the sum of dp WITH parameters l i k PLUS one memo AND dp WITH parameters i PLUS one r MINUS one zero memo  \n                END IF  \n            END FOR  \n            SET the element at the tuple of l r k IN memo TO res  \n            RETURN res  \n        END FUNCTION  \n        RETURN dp WITH parameters zero the length OF boxes MINUS one zero an empty dictionary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-provinces", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findCircleNum(isConnected)  \n        FUNCTION dfs(city)  \n            FOR neighbor FROM zero TO n MINUS one  \n                IF element at position city of isConnected AT position neighbor EQUALS one AND NOT element at position neighbor of visited  \n                    SET element at position neighbor of visited TO True  \n                    CALL dfs WITH neighbor  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF isConnected  \n        SET visited TO a list of False repeated n times  \n        SET province_count TO zero  \n\n        FOR city FROM zero TO n MINUS one  \n            IF NOT element at position city of visited  \n                CALL dfs WITH city  \n                INCREMENT province_count BY one  \n            END IF  \n        END FOR  \n\n        RETURN province_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-with-equal-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitArray(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n LESS THAN seven  \n            RETURN False  \n        END IF  \n        \n        SET prefix_sum TO a list of zeros of LENGTH n  \n        SET element at position zero of prefix_sum TO element at position zero of nums  \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of prefix_sum TO element at position i MINUS one of prefix_sum PLUS element at position i of nums  \n        END FOR  \n        \n        FOR j FROM three TO n MINUS three MINUS one  \n            SET seen TO an empty set  \n            FOR i FROM one TO j MINUS one MINUS one  \n                IF element at position i MINUS one of prefix_sum EQUALS element at position j MINUS one of prefix_sum MINUS element at position i of prefix_sum  \n                    ADD element at position i MINUS one of prefix_sum TO seen  \n                END IF  \n            END FOR  \n            \n            FOR k FROM j PLUS two TO n MINUS one MINUS one  \n                IF element at position n MINUS one of prefix_sum MINUS element at position k of prefix_sum EQUALS element at position k MINUS one of prefix_sum MINUS element at position j of prefix_sum AND element at position k MINUS one of prefix_sum MINUS element at position j of prefix_sum IS IN seen  \n                    RETURN True  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "student-attendance-record-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkRecord(n)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a three dimensional list of zeroes with dimensions n PLUS one BY two BY three  \n        SET element at position zero BY zero BY zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO one  \n                FOR k FROM zero TO two  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp PLUS element at position i MINUS one BY j BY k of dp  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp MODULO MOD  \n                    IF j EQUALS zero  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp PLUS element at position i MINUS one BY zero BY k of dp  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp MODULO MOD  \n                    END IF  \n                    IF k LESS THAN two  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp PLUS element at position i MINUS one BY j BY k of dp  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        SET result TO zero  \n        FOR j FROM zero TO one  \n            FOR k FROM zero TO two  \n                SET result TO result PLUS element at position n BY j BY k of dp  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "brick-wall", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION leastBricks(wall)  \n        SET gap_counts TO a new mapping that returns zero for any missing key  \n        FOR each row IN wall  \n            SET total TO zero  \n            FOR each brick IN all elements of row except the last element  \n                SET total TO total PLUS brick  \n                INCREMENT the value in gap_counts at key total BY one  \n            END FOR  \n        END FOR  \n        SET max_gaps TO the maximum value found among all values in gap_counts or zero if gap_counts is empty  \n        RETURN the number of elements in wall MINUS max_gaps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-concatenated-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitLoopedString(strs)  \n        FOR index FROM zero TO the LENGTH OF strs MINUS one  \n            SET reversed_str TO the string formed by characters of element at position index of strs in reverse order  \n            IF reversed_str IS GREATER THAN the element at position index of strs  \n                SET element at position index of strs TO reversed_str  \n            END IF  \n        END FOR  \n        \n        SET doubled_strs TO the concatenation of strs WITH strs  \n        \n        SET max_string TO empty string  \n        \n        FOR index FROM zero TO the LENGTH OF strs MINUS one  \n            FOR each is_reversed IN the list containing FALSE and TRUE  \n                IF is_reversed IS TRUE  \n                    SET current TO the string formed by characters of element at position index of strs in reverse order  \n                ELSE  \n                    SET current TO the element at position index of strs  \n                END IF  \n                \n                SET remaining TO the concatenation of elements from position index plus one TO position index plus the LENGTH OF strs IN doubled_strs  \n                \n                FOR cut_position FROM zero TO the LENGTH OF current  \n                    SET candidate TO the concatenation of substring from position cut_position TO the end of current WITH remaining WITH substring from position zero TO position cut_position of current  \n                    IF candidate IS GREATER THAN max_string  \n                        SET max_string TO candidate  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN max_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-greater-element-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextGreaterElement(n)  \n        SET digits TO the list of each character obtained by converting n to a string  \n        SET length TO the number of elements in digits  \n        SET i TO length MINUS two  \n        WHILE i GREATER THAN OR EQUAL TO zero AND element at position i of digits GREATER THAN OR EQUAL TO element at position i PLUS one of digits  \n            DECREMENT i BY one  \n        END WHILE  \n        IF i EQUALS negative one  \n            RETURN negative one  \n        END IF  \n        SET j TO length MINUS one  \n        WHILE element at position j of digits LESS THAN OR EQUAL TO element at position i of digits  \n            DECREMENT j BY one  \n        END WHILE  \n        SET temporary TO element at position i of digits  \n        SET element at position i of digits TO element at position j of digits  \n        SET element at position j of digits TO temporary  \n        SET digits FROM position i PLUS one TO the end TO the reverse of the elements from position i PLUS one TO the end of digits  \n        SET result TO the integer obtained by concatenating all elements of digits in order  \n        IF result GREATER THAN two TO THE POWER OF thirty ONE MINUS one  \n            RETURN negative one  \n        END IF  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subarray-sum-equals-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subarraySum(nums k)  \n        SET cumulative_sum_freq TO a dictionary with key zero mapped to value one  \n        SET current_sum TO zero  \n        SET count TO zero  \n        \n        FOR each num IN nums  \n            SET current_sum TO current_sum PLUS num  \n            IF there EXISTS a key EQUALS current_sum MINUS k IN cumulative_sum_freq  \n                INCREMENT count BY the value of cumulative_sum_freq at key current_sum MINUS k  \n            END IF  \n            IF there EXISTS a key EQUALS current_sum IN cumulative_sum_freq  \n                INCREMENT the value of cumulative_sum_freq at key current_sum BY one  \n            ELSE  \n                SET the value of cumulative_sum_freq at key current_sum TO one  \n            END IF  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-line-of-consecutive-one-in-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestLine(mat)  \n        IF mat EQUALS none OR element at position zero of mat EQUALS none THEN  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF element at position zero of mat  \n        SET directions TO list containing tuples representing zero AND one PLUS zero AND zero, one AND zero PLUS zero, one AND one PLUS zero, one AND negative one PLUS zero  \n        SET max_length TO zero  \n        \n        FUNCTION check(x, y, dx, dy)  \n            SET length TO zero  \n            WHILE x GREATER THAN OR EQUAL TO zero AND x LESS THAN m AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n AND element at position x of mat AT position y EQUALS one  \n                INCREMENT length BY one  \n                SET x TO x PLUS dx  \n                SET y TO y PLUS dy  \n            END WHILE  \n            RETURN length  \n        END FUNCTION  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of mat AT position j EQUALS one THEN  \n                    FOR each tuple dx AND dy IN directions  \n                        IF i MINUS dx LESS THAN zero OR j MINUS dy LESS THAN zero OR j MINUS dy GREATER THAN OR EQUAL TO n OR element at position i MINUS dx of mat AT position j MINUS dy EQUALS zero THEN  \n                            SET max_length TO the GREATER OF max_length AND check(i, j, dx, dy)  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-closest-palindrome", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nearestPalindromic(n)  \n        SET length TO the LENGTH OF n  \n        IF length EQUALS one  \n            SET numeric_value TO integer VALUE OF n  \n            RETURN string REPRESENTATION OF numeric_value MINUS one  \n        END IF  \n        \n        SET candidates TO an EMPTY SET  \n        \n        SET power_length TO TEN RAISED TO THE power OF length  \n        SET power_length_minus_one TO TEN RAISED TO THE power OF length MINUS one  \n        \n        ADD the VALUE OF power_length PLUS one TO candidates  \n        ADD the VALUE OF power_length_minus_one MINUS one TO candidates  \n        \n        SET prefix TO integer VALUE OF substring FROM position one TO position (length PLUS one) DIVIDED BY two of n  \n        \n        FOR i FROM negative one TO positive one  \n            SET new_prefix_numeric TO prefix PLUS i  \n            SET new_prefix TO string REPRESENTATION OF new_prefix_numeric  \n            \n            IF length MODULO two EQUALS zero  \n                SET reversed_part TO the REVERSED STRING OF new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH reversed_part  \n            ELSE  \n                SET substring_reversed TO the REVERSED STRING OF substring FROM position one TO LENGTH OF new_prefix MINUS one of new_prefix  \n                SET candidate_string TO new_prefix CONCATENATED WITH substring_reversed  \n            END IF  \n            \n            SET candidate_numeric TO integer VALUE OF candidate_string  \n            ADD candidate_numeric TO candidates  \n        END FOR  \n        \n        SET original_number TO integer VALUE OF n  \n        REMOVE original_number FROM candidates IF IT EXISTS  \n        \n        SET closest TO NULL  \n        SET smallest_distance TO INFINITY  \n        FOR each number IN candidates  \n            SET current_distance TO the ABSOLUTE VALUE OF number MINUS original_number  \n            IF current_distance LESS THAN smallest_distance OR (current_distance EQUALS smallest_distance AND number LESS THAN closest)  \n                SET closest TO number  \n                SET smallest_distance TO current_distance  \n            END IF  \n        END FOR  \n        \n        RETURN string REPRESENTATION OF closest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "array-nesting", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION arrayNesting(nums)  \n        SET visited TO a list of Boolean false values with the length EQUAL TO the LENGTH OF nums  \n        SET max_length TO zero  \n        FOR index i FROM zero TO the LENGTH OF nums MINUS one  \n            IF the element at position i of visited EQUALS false  \n                SET current_length TO zero  \n                SET variable k TO i  \n                WHILE the element at position k of visited EQUALS false  \n                    SET the element at position k of visited TO true  \n                    SET variable k TO the element at position k of nums  \n                    INCREMENT current_length BY one  \n                END WHILE  \n                IF max_length LESS THAN current_length  \n                    SET max_length TO current_length  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutation-in-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkInclusion(s1 parameter, s2 parameter)  \n        SET length of s1 TO length of s1  \n        SET length of s2 TO length of s2  \n        \n        IF length of s1 GREATER THAN length of s2 THEN  \n            RETURN false  \n        END IF  \n        \n        SET count of characters in s1 TO the frequency count of each character in s1  \n        SET count of characters in the first window of s2 TO the frequency count of each character in the substring from position one TO position length of s1 of s2  \n        \n        IF count of characters in s1 EQUALS count of characters in the first window of s2 THEN  \n            RETURN true  \n        END IF  \n        \n        FOR variable i FROM length of s1 PLUS one TO length of s2 DO  \n            INCREMENT the count of the character at position i of s2 BY one in the count of characters in the current window  \n            DECREMENT the count of the character at position i MINUS length of s1 of s2 BY one in the count of characters in the current window  \n            \n            IF the count of the character at position i MINUS length of s1 of s2 IN the count of characters in the current window EQUALS zero THEN  \n                REMOVE the character at position i MINUS length of s1 of s2 FROM the count of characters in the current window  \n            END IF  \n            \n            IF count of characters in s1 EQUALS count of characters in the current window THEN  \n                RETURN true  \n            END IF  \n        END FOR  \n        \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-vacation-days", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxVacationDays(flights days)  \n        SET n TO the LENGTH OF flights  \n        SET k TO the LENGTH OF the FIRST element of days  \n        \n        SET dp TO a list of length n with all elements SET TO negative one  \n        SET the element at position zero of dp TO zero  \n        \n        SET graph TO an empty mapping from each index from zero TO n MINUS one TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of flights AT position j EQUALS one  \n                    APPEND j TO the list mapped from i in graph  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR week FROM zero TO k MINUS one  \n            SET new_dp TO a list of length n with all elements SET TO negative one  \n            FOR i FROM zero TO n MINUS one  \n                IF element at position i of dp EQUALS negative one  \n                    CONTINUE to next iteration  \n                END IF  \n                SET element at position i of new_dp TO the GREATER BETWEEN element at position i of new_dp AND element at position i of dp PLUS element at position i of days AT position week  \n                FOR each j IN the list mapped from i in graph  \n                    SET element at position j of new_dp TO the GREATER BETWEEN element at position j of new_dp AND element at position i of dp PLUS element at position j of days AT position week  \n                END FOR  \n            END FOR  \n            ASSIGN dp TO new_dp  \n        END FOR  \n        \n        SET maximum_vacation_days TO the GREATEST VALUE in dp  \n        RETURN maximum_vacation_days  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "squirrel-simulation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(height PARAMETER height INTEGER, width PARAMETER width INTEGER, tree PARAMETER tree LIST OF INTEGER, squirrel PARAMETER squirrel LIST OF INTEGER, nuts PARAMETER nuts LIST OF LIST OF INTEGER) RETURNS INTEGER  \n        FUNCTION distance(p1 PARAMETER p1 LIST OF INTEGER, p2 PARAMETER p2 LIST OF INTEGER) RETURNS INTEGER  \n            SET horizontal_difference TO element at position zero of p1 MINUS element at position zero of p2  \n            IF horizontal_difference LESS THAN zero  \n                SET horizontal_difference TO horizontal_difference MULTIPLIED BY negative one  \n            END IF  \n            SET vertical_difference TO element at position one of p1 MINUS element at position one of p2  \n            IF vertical_difference LESS THAN zero  \n                SET vertical_difference TO vertical_difference MULTIPLIED BY negative one  \n            END IF  \n            RETURN horizontal_difference PLUS vertical_difference  \n        END FUNCTION  \n        \n        SET total_distance TO zero  \n        SET max_save TO negative infinity  \n        \n        FOR each nut IN nuts  \n            INCREMENT total_distance BY two MULTIPLIED BY distance(nut, tree)  \n            SET first_nut_distance TO distance(squirrel, nut) PLUS distance(nut, tree)  \n            SET later_nut_distance TO two MULTIPLIED BY distance(nut, tree)  \n            SET save TO later_nut_distance MINUS first_nut_distance  \n            IF save GREATER THAN max_save  \n                SET max_save TO save  \n            END IF  \n        END FOR  \n        \n        RETURN total_distance MINUS max_save  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "out-of-boundary-paths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPaths WITH PARAMETERS m n maxMove startRow startColumn  \n        SET MOD TO the integer one followed by nine zeros PLUS seven  \n        SET directions TO the collection of four pairs representing zero and one zero and minus one one and zero and minus one and zero  \n        INITIALIZE dp AS a three dimensional collection WITH zero VALUES with outer dimension of size m inner dimension of size n and innermost dimension of size maxMove PLUS one  \n        FOR k FROM one TO maxMove  \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    FOR each pair di dj IN directions  \n                        SET ni TO i PLUS di  \n                        SET nj TO j PLUS dj  \n                        IF ni LESS THAN zero OR ni GREATER THAN OR EQUAL TO m OR nj LESS THAN zero OR nj GREATER THAN OR EQUAL TO n  \n                            SET dp element at position i THEN j THEN k TO dp element at position i THEN j THEN k PLUS one MODULO MOD  \n                        ELSE  \n                            SET dp element at position i THEN j THEN k TO dp element at position i THEN j THEN k PLUS dp element at position ni THEN nj THEN k MINUS one MODULO MOD  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp element at position startRow THEN startColumn THEN maxMove  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-unsorted-continuous-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findUnsortedSubarray(nums)  \n        SET sorted_nums TO the result of sorting nums in ascending order  \n        SET start TO negative one  \n        SET end TO negative two  \n        FOR index FROM zero TO the length of nums MINUS one  \n            IF the element at position index of nums NOT EQUALS the element at position index of sorted_nums  \n                IF start EQUALS negative one  \n                    SET start TO index  \n                END IF  \n                SET end TO index  \n            END IF  \n        END FOR  \n        SET result TO end MINUS start PLUS one  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-operation-for-two-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        SET m TO the LENGTH OF word1  \n        SET n TO the LENGTH OF word2  \n        \n        CREATE a two dimensional list named dp with dimensions m PLUS one and n PLUS one  \n        FOR each index i FROM one TO m  \n            FOR each index j FROM one TO n  \n                IF the element at position i MINUS one of word1 EQUALS the element at position j MINUS one of word2  \n                    SET the element at position i and position j of dp TO the element at position i MINUS one and position j MINUS one of dp PLUS one  \n                ELSE  \n                    SET the element at position i and position j of dp TO the GREATER VALUE BETWEEN the element at position i MINUS one and position j of dp AND the element at position i and position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET lcs_length TO the element at position m and position n of dp  \n        \n        RETURN the value of m MINUS lcs_length PLUS the value of n MINUS lcs_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "erect-the-fence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION outerTrees(trees)  \n        FUNCTION cross(i, j, k)  \n            SET a TO element at position i of trees  \n            SET b TO element at position j of trees  \n            SET c TO element at position k of trees  \n            RETURN the difference between the product of the difference of the first element of b and the first element of a and the difference of the second element of c and the second element of b AND the product of the difference of the second element of b and the second element of a and the difference of the first element of c and the first element of b  \n        END FUNCTION  \n\n        SET n TO the length of trees  \n        IF n LESS THAN four THEN  \n            RETURN trees  \n        END IF  \n\n        SORT trees in ascending order  \n        SET vis TO a list of boolean false of length n  \n        SET stk TO a list containing zero  \n\n        FOR i FROM one TO n MINUS one  \n            WHILE the length of stk GREATER THAN one AND cross of element at position length of stk MINUS two of stk element AND element at position length of stk MINUS one of stk element AND i LESS THAN zero holds  \n                SET the boolean value at position of the last element removed from stk in vis TO false  \n            END WHILE  \n            SET the boolean value at position i in vis TO true  \n            APPEND i TO stk  \n        END FOR  \n\n        SET m TO the length of stk  \n        FOR i FROM n MINUS two DOWN TO zero BY the negative of one  \n            IF the boolean value at position i in vis IS true THEN  \n                CONTINUE to the next iteration  \n            END IF  \n            WHILE the length of stk GREATER THAN m AND cross of element at position length of stk MINUS two of stk element AND element at position length of stk MINUS one of stk element AND i LESS THAN zero holds  \n                REMOVE the last element FROM stk  \n            END WHILE  \n            APPEND i TO stk  \n        END FOR  \n\n        REMOVE the last element FROM stk  \n        RETURN the list of elements at each index in stk from trees  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-square", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validSquare(p1 p2 p3 p4)  \n        FUNCTION squared_distance(point1 point2)  \n            SET difference_along_x TO element at position zero of point1 MINUS element at position zero of point2  \n            SET difference_along_y TO element at position one of point1 MINUS element at position one of point2  \n            SET square_of_difference_along_x TO difference_along_x MULTIPLIED BY difference_along_x  \n            SET square_of_difference_along_y TO difference_along_y MULTIPLIED BY difference_along_y  \n            SET result TO square_of_difference_along_x PLUS square_of_difference_along_y  \n            RETURN result  \n        END FUNCTION  \n        SET points TO list containing p1 p2 p3 p4  \n        SET distances TO empty set  \n        FOR index i FROM zero TO three  \n            FOR index j FROM i PLUS one TO three  \n                SET dist TO squared_distance of element at position i of points and element at position j of points  \n                IF dist EQUALS zero  \n                    RETURN False  \n                END IF  \n                ADD dist TO distances  \n            END FOR  \n        END FOR  \n        IF LENGTH OF distances EQUALS two  \n            RETURN True  \n        ELSE  \n            RETURN False  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-negative-integers-without-consecutive-ones", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findIntegers(n)  \n        SET binary_representation TO convert the number n to its binary representation as a string of characters representing digits in base two from left to right  \n        SET length TO the number of characters in binary_representation  \n        CREATE a list dp of length plus one initialized with zeroes  \n        SET the element at position zero in dp TO one  \n        SET the element at position one in dp TO two  \n        FOR index i FROM two TO length  \n            SET the element at position i in dp TO the element at position i minus one in dp PLUS the element at position i minus two in dp  \n        END FOR  \n        SET result TO zero  \n        SET previous_bit TO zero  \n        FOR index i FROM zero TO length minus one  \n            IF element at position i in binary_representation EQUALS character representing one  \n                INCREMENT result BY the element at position length minus i minus one in dp  \n                IF previous_bit EQUALS one  \n                    DECREMENT result BY one  \n                    BREAK the loop  \n                END IF  \n            END IF  \n            SET previous_bit TO one IF element at position i in binary_representation EQUALS character representing one ELSE zero  \n        END FOR  \n        RETURN result PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-duplicate-file-in-system", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDuplicate(paths)  \n        SET content_to_paths TO empty mapping from content to list of file paths  \n        FOR each path IN paths  \n            SET parts TO the list of elements obtained by splitting path at spaces  \n            SET directory TO the first element in parts  \n            FOR each file_info IN the elements of parts starting from the second element TO the last element  \n                SET file_name TO the substring of file_info before the opening parenthesis  \n                SET content TO the substring of file_info from the position after the opening parenthesis TO the position before the closing parenthesis  \n                APPEND the concatenation of directory word slash word file_name TO the list in content_to_paths at key content  \n            END FOR  \n        END FOR  \n        SET result TO empty list  \n        FOR each group_of_paths IN the values of content_to_paths  \n            IF the length of group_of_paths is GREATER THAN one  \n                APPEND group_of_paths TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-triangle-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION triangleNumber(nums)  \n        CALL sort the elements of nums in ascending order  \n        SET count TO zero  \n        SET n TO the length of nums  \n        \n        FOR k FROM n MINUS one DOWN TO two  \n            SET i TO zero  \n            SET j TO k MINUS one  \n            WHILE i LESS THAN j  \n                IF element at position i of nums PLUS element at position j of nums GREATER THAN element at position k of nums  \n                    INCREMENT count BY j MINUS i  \n                    DECREMENT j BY one  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "add-bold-tag-in-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION addBoldTag(s STRING, words LIST OF STRING) RETURNS STRING  \n        IF the LENGTH OF words EQUALS zero THEN  \n            RETURN s  \n        END IF  \n        \n        SET n TO the LENGTH OF s  \n        SET mask TO a list of boolean False values of length n  \n        \n        FOR each word IN words  \n            SET start TO zero  \n            WHILE start IS LESS THAN OR EQUAL TO n MINUS the LENGTH OF word  \n                SET start TO the POSITION OF word IN s STARTING FROM start  \n                IF start EQUALS negative one THEN  \n                    BREAK  \n                END IF  \n                FOR i FROM start TO start PLUS the LENGTH OF word MINUS one  \n                    SET the element at position i OF mask TO True  \n                END FOR  \n                INCREMENT start BY one  \n            END WHILE  \n        END FOR  \n        \n        SET result TO an empty list  \n        SET i TO zero  \n        WHILE i IS LESS THAN n  \n            IF the element at position i OF mask IS True THEN  \n                APPEND the string indicating the start of a bold tag TO result  \n                WHILE i IS LESS THAN n AND the element at position i OF mask IS True  \n                    APPEND the element at position i OF s TO result  \n                    INCREMENT i BY one  \n                END WHILE  \n                APPEND the string indicating the end of a bold tag TO result  \n            ELSE  \n                APPEND the element at position i OF s TO result  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        \n        RETURN the concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "task-scheduler", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION leastInterval(tasks, n)  \n        SET task_counts TO the frequency count of each element in tasks  \n        SET max_heap TO a list containing each element of task_counts values converted to negative values  \n        TRANSFORM max_heap into a heap structure for efficient retrieval of the smallest element  \n        \n        SET time TO zero  \n        SET queue TO an empty list storing pairs of time plus n plus one and task count  \n        \n        WHILE max_heap is not empty OR queue is not empty  \n            WHILE queue is not empty AND the first element of the first pair in queue EQUALS time  \n                REMOVE the first pair from queue and unpack into discard_time and count  \n                IF count LESS THAN zero  \n                    ADD count into max_heap maintaining the heap property  \n                END IF  \n            END WHILE  \n            \n            IF max_heap is not empty  \n                REMOVE the smallest element from max_heap and assign to count  \n                SET count TO count PLUS one  \n                IF count LESS THAN zero  \n                    APPEND a pair consisting of time PLUS n PLUS one and count to queue  \n                END IF  \n            END IF  \n            \n            INCREMENT time BY one  \n        END WHILE  \n        \n        RETURN time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-distance-in-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxDistance(arrays)  \n        SET min_val TO element at position zero of element at position zero of arrays  \n        SET max_val TO element at position negative one of element at position zero of arrays  \n        SET max_distance TO zero  \n        FOR i FROM one TO the LENGTH OF arrays MINUS one  \n            SET current_array TO element at position i of arrays  \n            SET current_min TO element at position zero of current_array  \n            SET current_max TO element at position negative one of current_array  \n            SET max_distance TO the maximum of max_distance AND the absolute value of current_max MINUS min_val AND the absolute value of max_val MINUS current_min  \n            SET min_val TO the minimum of min_val AND current_min  \n            SET max_val TO the maximum of max_val AND current_max  \n        END FOR  \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-factorization", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestFactorization(num)  \n        IF num EQUALS one  \n            RETURN one  \n        END IF  \n        \n        SET factors TO empty list  \n        \n        FOR digit FROM nine TO two DECREMENTING BY one  \n            WHILE the remainder of num DIVIDED BY digit EQUALS zero  \n                APPEND digit TO factors  \n                SET num TO the quotient of num DIVIDED BY digit  \n            END WHILE  \n        END FOR  \n        \n        IF num NOT EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        SORT factors IN ascending order  \n        \n        SET result TO the integer formed by concatenating each element as a digit in factors IN ORDER  \n        \n        IF result GREATER THAN the maximum value of a thirty two bit signed integer  \n            RETURN zero  \n        END IF  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-inverse-pairs-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kInversePairs(n, k)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a two dimensional list of zeros with dimension n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp  \n                IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                IF j GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of element at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                SET element at position j of element at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION scheduleCourse(courses)  \n        SORT courses BY the second element of each course representing the last day of the course  \n        SET max_heap TO an empty list  \n        SET current_end_day TO zero  \n        FOR each course IN courses  \n            SET duration TO the first element of course representing the duration of the course  \n            SET last_day TO the second element of course representing the last day of the course  \n            IF current_end_day PLUS duration LESS THAN OR EQUAL TO last_day THEN  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n                INCREMENT current_end_day BY duration  \n            ELSE IF max_heap IS NOT empty AND the negation of the first element of max_heap GREATER THAN duration THEN  \n                INCREMENT current_end_day BY duration PLUS the heap pop operation result from max_heap  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n            END IF  \n        END FOR  \n        RETURN the length of max_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-range-covering-elements-from-k-lists", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestRange(nums)  \n        SET min_heap TO empty list  \n        SET max_value TO negative infinity  \n        FOR index FROM zero TO the LENGTH OF nums MINUS one  \n            PUSH INTO min_heap the tuple consisting of element at position zero of the element at position index of nums AND index AND zero  \n            SET max_value TO the GREATER THAN VALUE BETWEEN max_value AND element at position zero of the element at position index of nums  \n        END FOR  \n        SET smallest_range TO infinity  \n        SET result TO the list containing the first negative one hundred thousand AND the positive one hundred thousand  \n        WHILE min_heap is not empty  \n            POP the smallest tuple from min_heap INTO min_value AND list_index AND element_index  \n            IF max_value MINUS min_value LESS THAN smallest_range  \n                SET smallest_range TO max_value MINUS min_value  \n                SET result TO the list containing min_value AND max_value  \n            END IF  \n            IF element_index PLUS one LESS THAN the LENGTH OF the element at position list_index of nums  \n                SET next_value TO element at position element_index PLUS one of the element at position list_index of nums  \n                PUSH INTO min_heap the tuple consisting of next_value AND list_index AND element_index PLUS one  \n                SET max_value TO the GREATER THAN VALUE BETWEEN max_value AND next_value  \n            ELSE  \n                BREAK the loop  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-square-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET left TO zero  \n        SET right TO integer VALUE OF the SQUARE ROOT OF c  \n        WHILE left LESS THAN OR EQUAL TO right holds  \n            SET current_sum TO left MULTIPLIED BY left PLUS right MULTIPLIED BY right  \n            IF current_sum EQUALS c THEN  \n                RETURN true  \n            ELSE IF current_sum LESS THAN c THEN  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "exclusive-time-of-functions", "passing_rate": 1.0, "pseudocode": "CLASS Solution\n    FUNCTION exclusiveTime(n parameter, logs parameter)\n        SET exclusive_time TO an empty list\n        FOR index FROM zero TO n MINUS one\n            APPEND zero TO exclusive_time\n        END FOR\n        SET stack TO an empty list\n        \n        FOR each log IN logs\n            SPLIT log INTO function_id string AND action string AND timestamp string USING delimiter colon\n            SET function_id TO the integer conversion of function_id string\n            SET timestamp TO the integer conversion of timestamp string\n            \n            IF action EQUALS start\n                IF the LENGTH OF stack IS GREATER THAN zero\n                    SET prev_function_id TO the function identifier AT the last element of stack\n                    SET prev_timestamp TO the timestamp AT the last element of stack\n                    INCREMENT exclusive_time at prev_function_id BY timestamp MINUS prev_timestamp\n                END IF\n                APPEND the pair consisting of function_id AND timestamp TO stack\n            ELSE\n                SET prev_function_id TO the function identifier AT the last element of stack\n                SET prev_timestamp TO the timestamp AT the last element of stack\n                REMOVE the last element FROM stack\n                INCREMENT exclusive_time at prev_function_id BY timestamp MINUS prev_timestamp PLUS one\n                IF the LENGTH OF stack IS GREATER THAN zero\n                    SET the timestamp element of the last element of stack TO timestamp PLUS one\n                END IF\n            END IF\n        END FOR\n        \n        RETURN exclusive_time\n    END FUNCTION\nEND CLASS"}
{"task_id": "solve-the-equation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solveEquation(equation)  \n        FUNCTION parse_side(side)  \n            SET tokens TO the result of replacing plus signs in side with delimiter plus sign and replacing minus signs in side with delimiter minus sign and splitting the resulting string by the delimiter  \n            SET x_count TO zero  \n            SET num_sum TO zero  \n            FOR each token IN tokens  \n                IF token is an empty string THEN  \n                    CONTINUE to the next token  \n                END IF  \n                IF the character x exists in token THEN  \n                    IF token is equal to x OR token is equal to plus sign followed by x THEN  \n                        INCREMENT x_count BY one  \n                    ELSE IF token is equal to minus sign followed by x THEN  \n                        DECREMENT x_count BY one  \n                    ELSE  \n                        INCREMENT x_count BY the integer value of token with character x removed  \n                    END IF  \n                ELSE  \n                    INCREMENT num_sum BY the integer value of token  \n                END IF  \n            END FOR  \n            RETURN x_count and num_sum  \n        END FUNCTION  \n\n        SET left_side and right_side TO the parts of equation separated by the equal sign  \n        SET left_x and left_num TO the result of calling parse_side with left_side  \n        SET right_x and right_num TO the result of calling parse_side with right_side  \n\n        SET total_x TO left_x MINUS right_x  \n        SET total_num TO right_num MINUS left_num  \n\n        IF total_x EQUALS zero THEN  \n            IF total_num EQUALS zero THEN  \n                RETURN the string Infinite solutions  \n            ELSE  \n                RETURN the string No solution  \n            END IF  \n        ELSE  \n            RETURN the string formed by the character x equals the integer result of total_num DIVIDED BY total_x  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-length-of-pair-chain", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLongestChain(pairs)  \n        SORT pairs IN ORDER OF the second element of each pair FROM LOWEST TO HIGHEST  \n        SET current_end TO negative infinity  \n        SET chain_length TO zero  \n        FOR each pair IN pairs  \n            SET start TO the first element of pair  \n            SET end TO the second element of pair  \n            IF start IS GREATER THAN current_end  \n                SET current_end TO end  \n                INCREMENT chain_length BY one  \n            END IF  \n        END FOR  \n        RETURN chain_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindromic-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSubstrings(s)  \n        FUNCTION expand_around_center(left, right)  \n            SET count TO zero  \n            WHILE left GREATER THAN OR EQUAL TO zero AND right LESS THAN the LENGTH OF s AND element at position left of s EQUALS element at position right of s  \n                INCREMENT count BY one  \n                DECREMENT left BY one  \n                INCREMENT right BY one  \n            END WHILE  \n            RETURN count  \n        END FUNCTION  \n\n        SET total_palindromes TO zero  \n        FOR i FROM zero TO the LENGTH OF s MINUS one  \n            INCREMENT total_palindromes BY expand_around_center(i, i)  \n            INCREMENT total_palindromes BY expand_around_center(i, i PLUS one)  \n        END FOR  \n        RETURN total_palindromes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "replace-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION replaceWords(dictionary PARAMETER AS List of strings, sentence PARAMETER AS string) RETURNS string  \n        SORT dictionary BY the LENGTH OF each element FROM the SMALLEST TO the LARGEST  \n        SET words TO the LIST OF WORDS OBTAINED BY SPLITTING sentence BY SPACES  \n        FUNCTION replace(word PARAMETER AS string) RETURNS string  \n            FOR each root IN dictionary  \n                IF the BEGINNING OF word EQUALS root THEN  \n                    RETURN root  \n                END IF  \n            END FOR  \n            RETURN word  \n        END FUNCTION  \n        SET replaced_words TO an EMPTY list  \n        FOR each word IN words  \n            APPEND the RESULT OF replace APPLIED TO word TO replaced_words  \n        END FOR  \n        SET result_sentence TO the STRING OBTAINED BY JOINING replaced_words WITH SPACES AS SEPARATORS  \n        RETURN result_sentence  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dota2-senate", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        ASSIGN reference TO new double-ended queue named radiant  \n        ASSIGN reference TO new double-ended queue named dire  \n\n        FOR each index i AND character s IN senate  \n            IF character s EQUALS the character representing Radiant party  \n                APPEND index i TO radiant  \n            ELSE  \n                APPEND index i TO dire  \n            END IF  \n        END FOR  \n\n        WHILE radiant is not empty AND dire is not empty  \n            REMOVE and ASSIGN the first element from radiant TO r_index  \n            REMOVE and ASSIGN the first element from dire TO d_index  \n\n            IF r_index LESS THAN d_index  \n                APPEND r_index PLUS the length of senate TO radiant  \n            ELSE  \n                APPEND d_index PLUS the length of senate TO dire  \n            END IF  \n        END WHILE  \n\n        IF radiant is not empty  \n            RETURN the word Radiant  \n        ELSE  \n            RETURN the word Dire  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "2-keys-keyboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSteps WITH parameter n  \n        IF n EQUALS one THEN  \n            RETURN zero  \n        END IF  \n        \n        SET operations TO zero  \n        SET factor TO two  \n        \n        WHILE n GREATER THAN one DO  \n            WHILE the remainder of n DIVIDED BY factor EQUALS zero DO  \n                INCREMENT operations BY factor  \n                SET n TO the quotient of n DIVIDED BY factor  \n            END WHILE  \n            INCREMENT factor BY one  \n        END WHILE  \n        \n        RETURN operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-k-closest-elements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findClosestElements(arr parameter of type List of integers k parameter of type integer x parameter of type integer) RETURNS List of integers  \n        SET left TO the result of the operation bisect left in arr of x MINUS one  \n        SET right TO left PLUS one  \n        WHILE the result of right MINUS left MINUS one IS LESS THAN k  \n            IF left EQUALS negative one OR right IS LESS THAN the LENGTH OF arr AND the absolute value of element at position right of arr MINUS x IS LESS THAN the absolute value of element at position left of arr MINUS x  \n                INCREMENT right BY one  \n            ELSE  \n                DECREMENT left BY one  \n            END IF  \n        END WHILE  \n        RETURN the slice of arr from position left PLUS one TO position right MINUS one inclusive  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-into-consecutive-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isPossible(nums)  \n        SET num_count TO a mapping of numbers to their frequencies in nums  \n        SET end_with TO a mapping of numbers to the counts of subsequences ending with that number  \n        \n        FOR each num IN nums  \n            IF the frequency count of num in num_count EQUALS zero  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            IF the count of subsequences ending with the number which is one less than num in end_with IS GREATER THAN zero  \n                DECREMENT the count of subsequences ending with the number which is one less than num in end_with BY one  \n                INCREMENT the count of subsequences ending with num in end_with BY one  \n            ELSE IF the frequency count of the number which is one greater than num in num_count IS GREATER THAN zero AND the frequency count of the number which is two greater than num in num_count IS GREATER THAN zero  \n                DECREMENT the frequency count of the number which is one greater than num in num_count BY one  \n                DECREMENT the frequency count of the number which is two greater than num in num_count BY one  \n                INCREMENT the count of subsequences ending with the number which is two greater than num in end_with BY one  \n            ELSE  \n                RETURN false  \n            END IF  \n            \n            DECREMENT the frequency count of num in num_count BY one  \n        END FOR  \n        \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strange-printer", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION strangePrinter(s)  \n        FUNCTION dp(i, j, memo)  \n            IF i GREATER THAN j THEN  \n                RETURN zero  \n            END IF  \n            IF memo CONTAINS key consisting of i AND j THEN  \n                RETURN value AT key consisting of i AND j IN memo  \n            END IF  \n            SET result TO CALL dp WITH i AND j MINUS one AND memo PLUS one  \n            FOR k FROM i TO j MINUS one  \n                IF character AT position k OF s EQUALS character AT position j OF s THEN  \n                    SET temp TO CALL dp WITH i AND k MINUS one AND memo PLUS CALL dp WITH k AND j MINUS one AND memo  \n                    IF temp LESS THAN result THEN  \n                        SET result TO temp  \n                    END IF  \n                END IF  \n            END FOR  \n            SET value AT key consisting of i AND j IN memo TO result  \n            RETURN result  \n        END FUNCTION  \n        RETURN CALL dp WITH zero AND the LENGTH OF s MINUS one AND an empty dictionary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "path-sum-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pathSum(nums)  \n        SET tree TO an empty collection of key value pairs  \n        FOR each element num IN nums  \n            SET depth TO the value of num DIVIDED BY one hundred rounded down to the nearest whole number  \n            SET pos TO the result of num DIVIDED BY ten rounded down to the nearest whole number MODULO ten  \n            SET value TO the remainder of num DIVIDED BY ten  \n            ASSIGN reference TO value in tree with key composed of depth and pos  \n        END FOR  \n  \n        FUNCTION dfs(depth, pos, path_sum)  \n            SET current_value TO the value in tree at key composed of depth and pos  \n            IF current_value EQUALS to none  \n                RETURN zero  \n            END IF  \n            SET new_path_sum TO path_sum PLUS current_value  \n            SET left_child TO a pair composed of depth PLUS one and pos MULTIPLIED BY two MINUS one  \n            SET right_child TO a pair composed of depth PLUS one and pos MULTIPLIED BY two  \n            IF left_child NOT IN tree AND right_child NOT IN tree  \n                RETURN new_path_sum  \n            END IF  \n            SET left_sum TO the result of dfs called with the first element of left_child, the second element of left_child, and new_path_sum  \n            SET right_sum TO the result of dfs called with the first element of right_child, the second element of right_child, and new_path_sum  \n            RETURN left_sum PLUS right_sum  \n        END FUNCTION  \n  \n        RETURN the result of dfs called with one for depth, one for pos, and zero for path_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-number-in-multiplication-table", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findKthNumber(m n k)  \n        FUNCTION enough(x)  \n            SET count TO zero  \n            FOR i FROM one TO m  \n                INCREMENT count BY the MINIMUM VALUE BETWEEN the INTEGER RESULT OF x DIVIDED BY i AND n  \n            END FOR  \n            RETURN count GREATER THAN OR EQUAL TO k  \n        END FUNCTION  \n        SET low TO one  \n        SET high TO m MULTIPLIED BY n  \n        WHILE low LESS THAN high  \n            SET mid TO the INTEGER RESULT OF low PLUS high DIVIDED BY two  \n            IF enough(mid)  \n                SET high TO mid  \n            ELSE  \n                SET low TO mid PLUS one  \n            END IF  \n        END WHILE  \n        RETURN low  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-swap", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumSwap(num)  \n        SET digits TO list of string characters representing num  \n        SET last TO empty dictionary  \n        FOR each index i AND digit character d IN digits  \n            SET integer_digit TO integer value of d  \n            SET last at key integer_digit TO i  \n        END FOR  \n        FOR each index i AND digit character d IN digits  \n            SET current_digit TO integer value of d  \n            FOR digit d2 FROM nine DOWN TO current_digit PLUS one  \n                IF last at key d2 EXISTS AND last at key d2 GREATER THAN i THEN  \n                    SET temporary TO element at position i of digits  \n                    SET element at position i of digits TO element at position last at key d2 of digits  \n                    SET element at position last at key d2 of digits TO temporary  \n                    SET result_string TO concatenation of all elements in digits as string  \n                    SET result_number TO integer value of result_string  \n                    RETURN result_number  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN num  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulb-switcher-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION flipLights(n, presses)  \n        SET n TO the minimum value BETWEEN n AND six  \n        IF presses EQUALS zero  \n            RETURN one  \n        END IF  \n        IF n EQUALS one  \n            RETURN two  \n        END IF  \n        IF n EQUALS two  \n            IF presses EQUALS one  \n                RETURN three  \n            ELSE  \n                RETURN four  \n            END IF  \n        END IF  \n        IF presses EQUALS one  \n            RETURN four  \n        END IF  \n        IF presses EQUALS two  \n            RETURN seven  \n        END IF  \n        RETURN eight  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-longest-increasing-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findNumberOfLIS(nums)  \n        IF nums EQUALS empty list THEN  \n            RETURN zero  \n        END IF  \n              \n        SET n TO the LENGTH OF nums  \n        SET lengths TO a list of the value one REPEATED n times  \n        SET counts TO a list of the value one REPEATED n times  \n              \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF element at position i of nums GREATER THAN element at position j of nums THEN  \n                    IF element at position j of lengths PLUS one GREATER THAN element at position i of lengths THEN  \n                        SET element at position i of lengths TO element at position j of lengths PLUS one  \n                        SET element at position i of counts TO element at position j of counts  \n                    ELSE IF element at position j of lengths PLUS one EQUALS element at position i of lengths THEN  \n                        INCREMENT element at position i of counts BY element at position j of counts  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n              \n        SET longest TO the MAXIMUM value IN lengths  \n        SET total_count TO zero  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of lengths EQUALS longest THEN  \n                INCREMENT total_count BY element at position i of counts  \n            END IF  \n        END FOR  \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cut-off-trees-for-golf-event", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION cutOffTree(forest)  \n        IF the LENGTH OF forest EQUALS zero OR the LENGTH OF element at position zero of forest EQUALS zero THEN  \n            RETURN the negative of one  \n        END IF  \n          \n        SET trees TO an empty list  \n        FOR index i FROM zero TO the LENGTH OF forest MINUS one  \n            FOR index j FROM zero TO the LENGTH OF element at position zero of forest MINUS one  \n                IF the element at position i of forest at position j GREATER THAN one THEN  \n                    APPEND a tuple consisting of the element at position i of forest at position j FOLLOWED BY i FOLLOWED BY j TO trees  \n                END IF  \n            END FOR  \n        END FOR  \n        SORT trees in ascending order  \n          \n        FUNCTION bfs(start, end)  \n            IF start EQUALS end THEN  \n                RETURN zero  \n            END IF  \n            SET m TO the LENGTH OF forest  \n            SET n TO the LENGTH OF element at position zero of forest  \n            SET queue TO a new deque containing start  \n            SET visited TO a new set containing start  \n            SET steps TO zero  \n              \n            WHILE the queue is not empty DO  \n                FOR each element in the current queue size DO  \n                    SET x TO the first element of the dequeued position  \n                    SET y TO the second element of the dequeued position  \n                    FOR each pair dx, dy in the list of pairs consisting of negative one and zero THEN one and zero THEN zero and negative one THEN zero and one DO  \n                        SET nx TO x PLUS dx  \n                        SET ny TO y PLUS dy  \n                        IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the tuple consisting of nx and ny is not in visited AND the element at position nx of forest at position ny NOT EQUALS zero THEN  \n                            IF the tuple consisting of nx and ny EQUALS end THEN  \n                                RETURN steps PLUS one  \n                            END IF  \n                            ADD the tuple consisting of nx and ny TO visited  \n                            APPEND the tuple consisting of nx and ny TO queue  \n                        END IF  \n                    END FOR  \n                END FOR  \n                INCREMENT steps BY one  \n            END WHILE  \n              \n            RETURN the negative of one  \n        END FUNCTION  \n          \n        SET x TO zero  \n        SET y TO zero  \n        SET total_steps TO zero  \n          \n        FOR each tuple consisting of height, tx, ty IN trees DO  \n            SET steps TO bfs with parameters the tuple consisting of x and y and the tuple consisting of tx and ty  \n            IF steps EQUALS the negative of one THEN  \n                RETURN the negative of one  \n            END IF  \n            INCREMENT total_steps BY steps  \n            SET x TO tx  \n            SET y TO ty  \n        END FOR  \n          \n        RETURN total_steps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-parenthesis-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkValidString(s)  \n        SET low TO zero  \n        SET high TO zero  \n        FOR each char IN s  \n            IF char EQUALS open parenthesis  \n                INCREMENT low BY one  \n                INCREMENT high BY one  \n            ELSE IF char EQUALS close parenthesis  \n                DECREMENT low BY one  \n                DECREMENT high BY one  \n            ELSE  \n                DECREMENT low BY one  \n                INCREMENT high BY one  \n            END IF  \n            IF high LESS THAN zero  \n                RETURN false  \n            END IF  \n            SET low TO the maximum value BETWEEN low AND zero  \n        END FOR  \n        RETURN whether low EQUALS zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "24-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION judgePoint24(cards)  \n        FUNCTION solve(nums)  \n            IF the LENGTH OF nums EQUALS one  \n                RETURN the ABSOLUTE VALUE OF the ELEMENT at position zero of nums MINUS twenty four LESS THAN one times ten TO THE power of negative six  \n            END IF  \n            FOR i FROM zero TO the LENGTH OF nums MINUS one  \n                FOR j FROM zero TO the LENGTH OF nums MINUS one  \n                    IF i NOT EQUALS j  \n                        SET new_nums TO an empty list  \n                        FOR k FROM zero TO the LENGTH OF nums MINUS one  \n                            IF k NOT EQUALS i AND k NOT EQUALS j  \n                                APPEND the ELEMENT at position k of nums TO new_nums  \n                            END IF  \n                        END FOR  \n                        FOR each op IN the collection of operators truediv mul add sub  \n                            IF (op EQUALS add OR op EQUALS mul) AND j GREATER THAN i  \n                                CONTINUE TO next iteration of the loop  \n                            END IF  \n                            IF op NOT EQUALS truediv OR the ELEMENT at position j of nums NOT EQUALS zero  \n                                APPEND the RESULT OF op APPLIED TO the ELEMENTS at positions i and j of nums TO new_nums  \n                                IF solve(new_nums)  \n                                    RETURN true  \n                                END IF  \n                                REMOVE the last element FROM new_nums  \n                            END IF  \n                        END FOR  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN false  \n        END FUNCTION  \n        RETURN solve(cards)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-empty-slots", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kEmptySlots(bulbs PARAMETERS bulbs AS list of integers k AS integer)  \n        SET bloom_days TO empty list  \n        FOR day FROM one TO the LENGTH OF bulbs  \n            SET position TO element at position day MINUS one of bulbs  \n            SET i TO the insertion position of position in bloom_days to maintain sorted order  \n            IF i GREATER THAN zero AND position MINUS element at position i MINUS one of bloom_days MINUS one EQUALS k  \n                RETURN day  \n            END IF  \n            IF i LESS THAN the LENGTH OF bloom_days AND element at position i of bloom_days MINUS position MINUS one EQUALS k  \n                RETURN day  \n            END IF  \n            INSERT position INTO bloom_days AT position i to maintain sorted order  \n        END FOR  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "redundant-connection", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self parent TO list of integers from zero TO size MINUS one  \n        SET self rank TO list of size length filled with one  \n    END FUNCTION  \n\n    FUNCTION find(self, p)  \n        IF element at position p of self parent NOT EQUALS p  \n            SET element at position p of self parent TO the result of calling find with argument element at position p of self parent  \n        END IF  \n        RETURN element at position p of self parent  \n    END FUNCTION  \n\n    FUNCTION union(self, p, q)  \n        SET rootP TO the result of calling find with argument p  \n        SET rootQ TO the result of calling find with argument q  \n        IF rootP EQUALS rootQ  \n            RETURN False  \n        END IF  \n        IF element at position rootP of self rank GREATER THAN element at position rootQ of self rank  \n            SET element at position rootQ of self parent TO rootP  \n        ELSE IF element at position rootP of self rank LESS THAN element at position rootQ of self rank  \n            SET element at position rootP of self parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of self parent TO rootP  \n            INCREMENT element at position rootP of self rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findRedundantConnection(self, edges)  \n        SET uf TO new instance of UnionFind with argument the LENGTH OF edges PLUS one  \n        FOR each pair u and v IN edges  \n            IF the result of calling union method of uf with arguments u and v EQUALS False  \n                RETURN the list consisting of u and v  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "repeated-string-match", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        SET minimum repetitions TO the smallest integer greater than or equal to the LENGTH OF b DIVIDED BY the LENGTH OF a  \n        IF string b IS a substring of string a repeated minimum repetitions times  \n            RETURN minimum repetitions  \n        END IF  \n        IF string b IS a substring of string a repeated minimum repetitions PLUS one times  \n            RETURN minimum repetitions PLUS one  \n        END IF  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "knight-probability-in-chessboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION knightProbability(n k row column)  \n        SET moves TO list of pairs describing each of the eight possible knight movements with two positions each: negative two and negative one negative two and positive one negative one and negative two negative one and positive two positive one and negative two positive one and positive two positive two and negative one positive two and positive one  \n        SET dp TO two dimensional list with dimensions n by n with all elements set to zero  \n        SET element at position row and column of dp TO one  \n        FOR each iteration FROM one TO k  \n            SET new_dp TO two dimensional list with dimensions n by n with all elements set to zero  \n            FOR each r FROM zero TO n MINUS one  \n                FOR each c FROM zero TO n MINUS one  \n                    IF element at position r and c of dp EQUALS zero THEN  \n                        CONTINUE to the next iteration of the inner loop  \n                    END IF  \n                    FOR each pair dr dc IN moves  \n                        SET nr TO r PLUS dr  \n                        SET nc TO c PLUS dc  \n                        IF nr IS GREATER THAN OR EQUAL TO zero AND nr IS LESS THAN n AND nc IS GREATER THAN OR EQUAL TO zero AND nc IS LESS THAN n THEN  \n                            SET element at position nr and nc of new_dp TO element at position nr and nc of new_dp PLUS element at position r and c of dp DIVIDED BY eight  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n            SET dp TO new_dp  \n        END FOR  \n        SET total_probability TO zero  \n        FOR each single_row IN dp  \n            SET row_sum TO zero  \n            FOR each value IN single_row  \n                INCREMENT row_sum BY value  \n            END FOR  \n            INCREMENT total_probability BY row_sum  \n        END FOR  \n        RETURN total_probability  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stickers-to-spell-word", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minStickers WITH PARAMETERS stickers AND target  \n        SET stickers TO list of frequency counters for each sticker IN stickers  \n        SORT stickers BY the negative of the maximum frequency value in each counter  \n        SET queue TO a deque containing a tuple of target AND zero  \n        SET memo TO a dictionary with key target AND value zero  \n        WHILE the queue is not empty  \n            EXTRACT current_target AND used_stickers FROM the front element of queue  \n            FOR each sticker IN stickers  \n                IF the first character of current_target IS NOT PRESENT AS key IN sticker THEN  \n                    CONTINUE to the next iteration  \n                END IF  \n                SET remaining TO a counter of characters in current_target  \n                DECREMENT counts in remaining BY counts in sticker  \n                SET new_target TO a string formed by concatenating characters sorted from the elements of remaining  \n                IF new_target EQUALS empty string THEN  \n                    RETURN used_stickers PLUS one  \n                END IF  \n                IF new_target IS NOT PRESENT AS key IN memo THEN  \n                    SET memo at new_target TO used_stickers PLUS one  \n                    APPEND tuple of new_target AND used_stickers PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "top-k-frequent-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION topKFrequent(words AS List of strings, k AS integer) RETURNS List of strings  \n        SET count TO the result of counting the frequency of each word in words  \n        SET heap TO an empty list  \n        FOR each word AND corresponding frequency IN count items  \n            APPEND a pair of negative frequency and word TO heap  \n        END FOR  \n        TRANSFORM heap into a heap structure  \n        SET result TO an empty list  \n        FOR repetition FROM one TO k  \n            REMOVE the smallest element from heap as a pair  \n            APPEND the word part of this pair TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands(grid)  \n        FUNCTION dfs(i, j, direction)  \n            IF i GREATER THAN OR EQUAL TO zero AND i LESS THAN the LENGTH OF grid AND j GREATER THAN OR EQUAL TO zero AND j LESS THAN the LENGTH OF element at position zero of grid AND element at position i of grid at position j EQUALS one  \n                SET element at position i of grid at position j TO zero  \n                APPEND direction TO path  \n                CALL dfs WITH the arguments i PLUS one j direction equal to the lowercase letter dee  \n                CALL dfs WITH the arguments i MINUS one j direction equal to the lowercase letter you  \n                CALL dfs WITH the arguments i j PLUS one direction equal to the lowercase letter are  \n                CALL dfs WITH the arguments i j MINUS one direction equal to the lowercase letter el  \n                APPEND the lowercase letter bee TO path  \n            END IF  \n            RETURN path  \n        END FUNCTION  \n\n        SET unique_islands TO an empty set  \n        \n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET path TO an empty list  \n                    ADD the result of dfs called with i j direction equal to the lowercase letter oh converted to a tuple TO unique_islands  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN the LENGTH OF unique_islands  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-area-of-island", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxAreaOfIsland(grid)  \n        IF grid EQUALS nothing OR the LENGTH OF grid EQUALS zero  \n            RETURN zero  \n        END IF  \n\n        SET max_area TO zero  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n\n        FUNCTION dfs(r, c)  \n            IF r LESS THAN zero OR r GREATER THAN OR EQUAL TO rows OR c LESS THAN zero OR c GREATER THAN OR EQUAL TO cols OR element at position r of grid AT position c EQUALS zero  \n                RETURN zero  \n            END IF  \n            SET element at position r of grid AT position c TO zero  \n            SET area TO one  \n            INCREMENT area BY dfs(r PLUS one, c)  \n            INCREMENT area BY dfs(r MINUS one, c)  \n            INCREMENT area BY dfs(r, c PLUS one)  \n            INCREMENT area BY dfs(r, c MINUS one)  \n            RETURN area  \n        END FUNCTION  \n\n        FOR r FROM zero TO rows MINUS one  \n            FOR c FROM zero TO cols MINUS one  \n                IF element at position r of grid AT position c EQUALS one  \n                    SET max_area TO the GREATER OF max_area AND dfs(r, c)  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-to-k-equal-sum-subsets", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canPartitionKSubsets(nums, k)  \n        SET total_sum TO the SUM of all elements IN nums  \n        IF total_sum MODULO k NOT EQUALS zero THEN  \n            RETURN false  \n        END IF  \n        SET target TO total_sum DIVIDED BY k  \n        SORT nums IN descending order  \n        \n        FUNCTION can_partition(index, k_remaining, current_sum, used_flags)  \n            IF k_remaining EQUALS zero THEN  \n                RETURN true  \n            END IF  \n            IF current_sum EQUALS target THEN  \n                RETURN the RESULT of can_partition WITH parameters zero, k_remaining MINUS one, zero, used_flags  \n            END IF  \n            \n            FOR each position FROM index TO the LENGTH of nums MINUS one  \n                IF the element at position IN used_flags IS false AND current_sum PLUS the element at position IN nums IS LESS THAN OR EQUAL TO target THEN  \n                    SET the element at position IN used_flags TO true  \n                    IF the RESULT of can_partition WITH parameters position PLUS one, k_remaining, current_sum PLUS the element at position IN nums, used_flags IS true THEN  \n                        RETURN true  \n                    END IF  \n                    SET the element at position IN used_flags TO false  \n                END IF  \n            END FOR  \n            RETURN false  \n        END FUNCTION  \n        \n        SET used TO a list OF boolean false values WITH the LENGTH of nums  \n        RETURN the RESULT of can_partition WITH parameters zero, k, zero, used  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "falling-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fallingSquares(positions)  \n        SET max_heights TO an empty list  \n        SET intervals TO an empty list  \n        SET current_max_height TO zero  \n        FOR each element in positions  \n            SET left TO the first value of element  \n            SET side_length TO the second value of element  \n            SET right TO left PLUS side_length MINUS one  \n            SET height TO side_length  \n            FOR each interval_element IN intervals  \n                SET interval_left TO the first value of interval_element  \n                SET interval_right TO the second value of interval_element  \n                SET interval_height TO the third value of interval_element  \n                IF left LESS THAN OR EQUAL TO interval_right AND right GREATER THAN OR EQUAL TO interval_left THEN  \n                    IF height LESS THAN side_length PLUS interval_height THEN  \n                        SET height TO side_length PLUS interval_height  \n                    END IF  \n                END IF  \n            END FOR  \n            APPEND the tuple consisting of left right and height TO intervals  \n            IF current_max_height LESS THAN height THEN  \n                SET current_max_height TO height  \n            END IF  \n            APPEND current_max_height TO max_heights  \n        END FOR  \n        RETURN max_heights  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subarray-product-less-than-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSubarrayProductLessThanK(nums k) RETURNS integer  \n        IF k LESS THAN OR EQUAL TO one THEN  \n            RETURN zero  \n        END IF  \n        SET product TO one  \n        SET left TO zero  \n        SET count TO zero  \n        FOR right FROM zero TO the LENGTH OF nums MINUS one  \n            SET product TO product MULTIPLIED BY element at position right of nums  \n            WHILE product GREATER THAN OR EQUAL TO k AND left LESS THAN OR EQUAL TO right  \n                SET product TO product DIVIDED BY element at position left of nums  \n                INCREMENT left BY one  \n            END WHILE  \n            INCREMENT count BY right MINUS left PLUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-with-transaction-fee", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices, fee)  \n        SET cash TO zero  \n        SET hold TO negative infinity  \n        FOR each price IN prices  \n            IF cash GREATER THAN OR EQUAL TO hold PLUS price MINUS fee  \n                SET cash TO cash  \n            ELSE  \n                SET cash TO hold PLUS price MINUS fee  \n            END IF  \n            IF hold GREATER THAN OR EQUAL TO cash MINUS price  \n                SET hold TO hold  \n            ELSE  \n                SET hold TO cash MINUS price  \n            END IF  \n        END FOR  \n        RETURN cash  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-length-of-repeated-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLength(nums1 nums2)  \n        SET dp TO a two dimensional list with the number of rows EQUAL TO the length of nums1 PLUS one AND the number of columns EQUAL TO the length of nums2 PLUS one FILLED WITH zero  \n        SET max_length TO zero  \n        FOR i FROM one TO the length of nums1  \n            FOR j FROM one TO the length of nums2  \n                IF the element at position i MINUS one of nums1 EQUALS the element at position j MINUS one of nums2  \n                    SET the element at position i and position j of dp TO the element at position i MINUS one and position j MINUS one of dp PLUS one  \n                    IF max_length LESS THAN the element at position i and position j of dp  \n                        SET max_length TO the element at position i and position j of dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-k-th-smallest-pair-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestDistancePair(nums WITH TYPE List of integer, k WITH TYPE integer) RETURNS integer  \n        SET nums TO the list nums sorted in ascending order  \n        SET n TO the LENGTH OF the list nums  \n        \n        FUNCTION count(mid WITH TYPE integer) RETURNS integer  \n            SET count TO zero  \n            SET left TO zero  \n            FOR right FROM zero TO n MINUS one  \n                WHILE the element at position right of nums MINUS the element at position left of nums GREATER THAN mid  \n                    INCREMENT left BY one  \n                END WHILE  \n                INCREMENT count BY right MINUS left  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO the element at the last position of nums MINUS the element at the first position of nums  \n        WHILE left LESS THAN right  \n            SET mid TO the integer division of the sum of left AND right BY two  \n            IF count(mid) LESS THAN k  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN LEXICOGRAPHICAL ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO an empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from position one TO position LENGTH OF word MINUS one IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "accounts-merge", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.root TO empty list  \n        FOR index FROM zero TO size MINUS one  \n            APPEND index TO self.root  \n        END FOR  \n        SET self.rank TO empty list  \n        FOR index FROM zero TO size MINUS one  \n            APPEND one TO self.rank  \n        END FOR  \n    END FUNCTION  \n  \n    FUNCTION find(self, x)  \n        IF element at position x of self.root EQUALS x THEN  \n            RETURN x  \n        END IF  \n        SET element at position x of self.root TO self.find(element at position x of self.root)  \n        RETURN element at position x of self.root  \n    END FUNCTION  \n  \n    FUNCTION union(self, x, y)  \n        SET rootX TO self.find(x)  \n        SET rootY TO self.find(y)  \n        IF rootX NOT EQUALS rootY THEN  \n            IF element at position rootX of self.rank GREATER THAN element at position rootY of self.rank THEN  \n                SET element at position rootY of self.root TO rootX  \n            ELSE IF element at position rootX of self.rank LESS THAN element at position rootY of self.rank THEN  \n                SET element at position rootX of self.root TO rootY  \n            ELSE  \n                SET element at position rootY of self.root TO rootX  \n                INCREMENT element at position rootX of self.rank BY one  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION accountsMerge(self, accounts)  \n        SET email_to_id TO empty dictionary  \n        SET uf TO new UnionFind with the length of accounts  \n        \n        FOR each index i AND account at position i of accounts  \n            SET name TO element at position zero of account  \n            SET emails TO elements of account from position one TO the end  \n            FOR each email IN emails  \n                IF email NOT IN email_to_id THEN  \n                    ASSIGN email_to_id at key email TO i  \n                ELSE  \n                    CALL uf.union(i, email_to_id at key email)  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET merged_emails TO empty dictionary with default value of empty list  \n        FOR each email AND account_id IN email_to_id items  \n            SET root_id TO uf.find(account_id)  \n            APPEND email TO list at key root_id of merged_emails  \n        END FOR  \n        \n        SET result TO empty list  \n        FOR each account_id AND emails IN merged_emails items  \n            SET name TO element at position zero of element at position account_id of accounts  \n            SET sorted_emails TO emails sorted in ascending order  \n            APPEND a new list consisting of name FOLLOWED BY all elements of sorted_emails TO result  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-comments", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeComments(source)  \n        SET in_block_comment TO false  \n        SET result TO empty list  \n        SET current_line TO empty list  \n\n        FOR each line IN source  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF line  \n                IF in_block_comment  \n                    IF the substring from position i TO position i PLUS one of line EQUALS the sequence of characters star followed by slash  \n                        SET in_block_comment TO false  \n                        INCREMENT i BY one  \n                    END IF  \n                ELSE  \n                    IF the substring from position i TO position i PLUS one of line EQUALS the sequence of characters slash followed by slash  \n                        BREAK the WHILE loop  \n                    ELSE IF the substring from position i TO position i PLUS one of line EQUALS the sequence of characters slash followed by star  \n                        SET in_block_comment TO true  \n                        INCREMENT i BY one  \n                    ELSE  \n                        APPEND the element at position i of line TO current_line  \n                    END IF  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF the LENGTH OF current_line GREATER THAN zero AND in_block_comment EQUALS false  \n                APPEND the concatenation of elements in current_line TO result  \n                SET current_line TO empty list  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-atoms", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countOfAtoms(formula)  \n        FUNCTION parse(segment)  \n            SET atom_count TO a mapping with default zero integer value  \n            SET elements TO the list of all matches of pattern of one uppercase letter followed by zero or more lowercase letters and zero or more digits IN segment  \n            FOR each element and count IN elements  \n                IF count EQUALS empty string  \n                    INCREMENT atom_count mapped by element BY one  \n                ELSE  \n                    INCREMENT atom_count mapped by element BY the integer value of count  \n                END IF  \n            END FOR  \n            RETURN atom_count  \n        END FUNCTION  \n        \n        FUNCTION multiply_counts(counts, multiplier)  \n            FOR each element IN counts  \n                SET counts mapped by element TO counts mapped by element MULTIPLIED BY multiplier  \n            END FOR  \n            RETURN counts  \n        END FUNCTION  \n        \n        SET stack TO a list containing one mapping with default zero integer value  \n        SET i TO zero  \n        WHILE i LESS THAN the length of formula  \n            IF the element at position i of formula EQUALS open parenthesis  \n                APPEND a mapping with default zero integer value TO stack  \n                INCREMENT i BY one  \n            ELSE IF the element at position i of formula EQUALS close parenthesis  \n                SET segment_count TO a mapping with default zero integer value  \n                SET j TO i PLUS one  \n                WHILE j LESS THAN the length of formula AND the element at position j of formula IS a digit  \n                    INCREMENT j BY one  \n                END WHILE  \n                IF j GREATER THAN i PLUS one  \n                    SET multiplier TO the integer value of the substring of formula from position i PLUS one TO position j MINUS one  \n                ELSE  \n                    SET multiplier TO one  \n                END IF  \n                SET segment_count TO multiply_counts(applied to popping the last element from stack, multiplier)  \n                FOR each element IN segment_count  \n                    INCREMENT stack at the last element mapped by element BY segment_count mapped by element  \n                END FOR  \n                SET i TO j  \n            ELSE  \n                SET j TO i PLUS one  \n                WHILE j LESS THAN the length of formula AND (the element at position j of formula IS a lowercase letter OR the element at position j of formula IS a digit)  \n                    INCREMENT j BY one  \n                END WHILE  \n                SET segment_count TO parse(applied to the substring of formula from position i TO position j MINUS one)  \n                FOR each element IN segment_count  \n                    INCREMENT stack at the last element mapped by element BY segment_count mapped by element  \n                END FOR  \n                SET i TO j  \n            END IF  \n        END WHILE  \n        \n        SET final_count TO popping the last element from stack  \n        SET result_string TO empty string  \n        FOR each element IN the sorted keys of final_count  \n            APPEND element TO result_string  \n            IF final_count mapped by element GREATER THAN one  \n                APPEND the string representation of final_count mapped by element TO result_string  \n            END IF  \n        END FOR  \n        RETURN result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-window-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minWindow(s1, s2)  \n        SET min_len TO a very large number representing infinity  \n        SET min_start TO negative one  \n        SET len1 TO the LENGTH OF s1  \n        SET len2 TO the LENGTH OF s2  \n        \n        FOR i FROM zero TO len1 MINUS one  \n            SET j TO zero  \n            FOR k FROM i TO len1 MINUS one  \n                IF element at position k of s1 EQUALS element at position j of s2  \n                    INCREMENT j BY one  \n                    IF j EQUALS len2  \n                        IF k MINUS i PLUS one LESS THAN min_len  \n                            SET min_len TO k MINUS i PLUS one  \n                            SET min_start TO i  \n                        END IF  \n                        BREAK the inner FOR loop  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF min_start EQUALS negative one  \n            RETURN the empty string represented by absence of characters  \n        ELSE  \n            RETURN the substring of s1 starting at position min_start UP TO position min_start PLUS min_len MINUS one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-different-palindromic-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences WITH PARAMETER s  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        \n        SET next_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        SET prev_occurrence TO a two dimensional list of four lists each containing n times negative one  \n        \n        FOR each c FROM zero TO three  \n            SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n            SET last TO negative one  \n            FOR each i FROM zero TO n MINUS one  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of prev_occurrence TO last  \n            END FOR  \n            \n            SET last TO negative one  \n            FOR each i FROM n MINUS one DOWN TO zero  \n                IF element at position i of s EQUALS char THEN  \n                    SET last TO i  \n                END IF  \n                SET element at position i of element at position c of next_occurrence TO last  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a two dimensional list of n lists each containing n times zero  \n        \n        FOR each i FROM zero TO n MINUS one  \n            SET element at position i of element at position i of dp TO one  \n        END FOR  \n        \n        FOR each length FROM two TO n  \n            FOR each i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                FOR each c FROM zero TO three  \n                    SET char TO the character representing the code point of the character representing the code point of lowercase a PLUS c  \n                    SET left TO element at position i of element at position c of next_occurrence  \n                    SET right TO element at position j of element at position c of prev_occurrence  \n                    \n                    IF left GREATER THAN j OR right LESS THAN i THEN  \n                        CONTINUE TO next iteration of the innermost loop  \n                    ELSE IF left EQUALS right THEN  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS one is divided by MOD  \n                    ELSE  \n                        SET element at position i of element at position j of dp TO the remainder when the sum of element at position i of element at position j of dp PLUS element at position left PLUS one of element at position right MINUS one of dp PLUS two is divided by MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero of element at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "asteroid-collision", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION asteroidCollision WITH PARAMETER asteroids  \n        SET stack TO an empty list  \n        FOR each asteroid IN asteroids  \n            WHILE the LENGTH OF stack is greater than zero AND asteroid is LESS THAN zero AND element at position the LENGTH OF stack MINUS one of stack is GREATER THAN zero  \n                IF element at position the LENGTH OF stack MINUS one of stack is LESS THAN the NEGATIVE of asteroid  \n                    REMOVE the last element FROM stack  \n                    CONTINUE to the next iteration of the WHILE loop  \n                ELSE IF element at position the LENGTH OF stack MINUS one of stack EQUALS the NEGATIVE of asteroid  \n                    REMOVE the last element FROM stack  \n                END IF  \n                BREAK the WHILE loop  \n            END WHILE  \n            IF the WHILE loop did not break prematurely  \n                APPEND asteroid TO stack  \n            END IF  \n        END FOR  \n        RETURN stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "monotone-increasing-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION monotoneIncreasingDigits(n)  \n        SET digits TO the list of characters representing the string form of n  \n        SET length TO the number of elements in digits  \n        SET marker TO length  \n        FOR i FROM length MINUS one DOWN TO one  \n            IF the element at position i of digits converted to number LESS THAN the element at position i MINUS one of digits converted to number  \n                SET the element at position i MINUS one of digits TO the string form of the element at position i MINUS one of digits converted to number MINUS one  \n                SET marker TO i  \n            END IF  \n        END FOR  \n        FOR i FROM marker TO length MINUS one  \n            SET the element at position i of digits TO the character representing number nine  \n        END FOR  \n        SET result_string TO the concatenation of all elements of digits in order  \n        SET result_number TO the numeric form of result_string  \n        RETURN result_number  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "daily-temperatures", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION dailyTemperatures WITH parameter temperatures  \n        SET n TO the LENGTH OF temperatures  \n        SET answer TO a LIST of n elements each SET TO zero  \n        SET stack TO an EMPTY LIST  \n        FOR i FROM zero TO n MINUS one  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND element at position i of temperatures IS GREATER THAN element at position element at position the LENGTH OF stack MINUS one of stack of temperatures  \n                SET prev_index TO the LAST element REMOVED FROM stack  \n                SET element at position prev_index of answer TO i MINUS prev_index  \n            END WHILE  \n            APPEND i TO stack  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-and-earn", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION deleteAndEarn(nums)  \n        SET count TO the mapping of each number in nums to its total occurrences  \n        SET unique_nums TO the sorted list of all unique numbers from count  \n        SET dp TO a list of zeros with length equal to the length of unique_nums plus one  \n        SET the element at position one of dp TO the product of the element at position zero of unique_nums AND the count of the element at position zero of unique_nums  \n        FOR index FROM two TO the length of unique_nums plus one  \n            SET num TO the element at position index MINUS one of unique_nums  \n            IF the value of num EQUALS the element at position index MINUS two of unique_nums PLUS one  \n                SET the element at position index of dp TO the larger value between the element at position index MINUS one of dp AND the element at position index MINUS two of dp PLUS the product of num AND the count of num  \n            ELSE  \n                SET the element at position index of dp TO the sum of the element at position index MINUS one of dp AND the product of num AND the count of num  \n            END IF  \n        END FOR  \n        RETURN the last element of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cherry-pickup", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET n TO the LENGTH OF grid  \n        IF the element at position zero of grid at position zero EQUALS negative one OR the element at position n MINUS one of grid at position n MINUS one EQUALS negative one  \n            RETURN zero  \n        END IF  \n        \n        SET dp TO a three dimensional collection of size n BY n BY n FILLED WITH negative one  \n        SET element at position zero of dp at position zero at position zero TO the element at position zero of grid at position zero  \n        \n        SET directions TO a collection containing the pair consisting of zero and one AND the pair consisting of one and zero  \n        \n        FOR t FROM one TO two MULTIPLIED BY n MINUS one MINUS one  \n            FOR i1 FROM the MAXIMUM OF zero AND t MINUS (n MINUS one) TO the MINIMUM OF n AND t PLUS one MINUS one  \n                FOR i2 FROM the MAXIMUM OF zero AND t MINUS (n MINUS one) TO the MINIMUM OF n AND t PLUS one MINUS one  \n                    SET j1 TO t MINUS i1  \n                    SET j2 TO t MINUS i2  \n                    IF the element at position i1 of grid at position j1 EQUALS negative one OR the element at position i2 of grid at position j2 EQUALS negative one  \n                        CONTINUE TO the next iteration  \n                    END IF  \n                    \n                    SET prev_max TO negative one  \n                    FOR each pair consisting of di1 AND dj1 IN directions  \n                        FOR each pair consisting of di2 AND dj2 IN directions  \n                            SET pi1 TO i1 MINUS di1  \n                            SET pj1 TO j1 MINUS dj1  \n                            SET pi2 TO i2 MINUS di2  \n                            SET pj2 TO j2 MINUS dj2  \n                            IF pi1 IS GREATER THAN OR EQUAL TO zero AND pi1 IS LESS THAN n AND pj1 IS GREATER THAN OR EQUAL TO zero AND pj1 IS LESS THAN n AND pi2 IS GREATER THAN OR EQUAL TO zero AND pi2 IS LESS THAN n AND pj2 IS GREATER THAN OR EQUAL TO zero AND pj2 IS LESS THAN n  \n                                SET prev_max TO the MAXIMUM OF prev_max AND the element at position pi1 of dp at position pi2 at position pj1  \n                            END IF  \n                        END FOR  \n                    END FOR  \n                    \n                    IF prev_max IS GREATER THAN OR EQUAL TO zero  \n                        IF i1 EQUALS i2  \n                            SET cherries TO the element at position i1 of grid at position j1  \n                        ELSE  \n                            SET cherries TO the element at position i1 of grid at position j1 PLUS the element at position i2 of grid at position j2  \n                        END IF  \n                        SET the element at position i1 of dp at position i2 at position j1 TO prev_max PLUS cherries  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN the MAXIMUM OF zero AND the element at position n MINUS one of dp at position n MINUS one at position n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "network-delay-time", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION networkDelayTime(times AS List of List of Integer, n AS Integer, k AS Integer) RETURNS Integer  \n        SET graph TO empty dictionary  \n        FOR index FROM one TO n  \n            SET element at position index of graph TO empty list  \n        END FOR  \n        \n        FOR each triple consisting of u v w IN times  \n            APPEND pair consisting of v and w TO element at position u of graph  \n        END FOR  \n        \n        SET dist TO empty dictionary  \n        FOR index FROM one TO n  \n            SET element at position index of dist TO infinity  \n        END FOR  \n        SET element at position k of dist TO zero  \n        \n        SET min_heap TO list containing pair consisting of zero and k  \n        \n        WHILE min_heap is not empty  \n            SET current_dist and node TO the pair popped from min_heap according to minimum first element  \n            \n            IF current_dist IS GREATER THAN element at position node of dist  \n                CONTINUE to next iteration  \n            END IF  \n            \n            FOR each pair consisting of neighbor and weight IN element at position node of graph  \n                SET distance TO current_dist PLUS weight  \n                \n                IF distance IS LESS THAN element at position neighbor of dist  \n                    SET element at position neighbor of dist TO distance  \n                    PUSH pair consisting of distance and neighbor INTO min_heap maintaining heap property  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        SET max_time TO the maximum value among all values in dist  \n        \n        IF max_time IS NOT EQUAL TO infinity  \n            RETURN max_time  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "contain-virus", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION containVirus(isInfected)  \n        FUNCTION neighbors(r, c)  \n            RETURN list containing element formed by sum of r AND one AND c  \n                   element formed by difference of r AND one AND c  \n                   element formed by r AND sum of c AND one  \n                   element formed by r AND difference of c AND one  \n        END FUNCTION  \n\n        FUNCTION bfs(r, c)  \n            SET infected TO empty set  \n            SET threatened TO empty set  \n            SET queue TO deque initialized with element formed by r AND c  \n            SET visited TO set initialized with element formed by r AND c  \n            WHILE queue holds elements  \n                SET element at front of queue TO tuple containing x AND y  \n                REMOVE front element FROM queue  \n                ADD tuple of x AND y TO infected  \n                FOR each tuple nx AND ny IN neighbors(x, y)  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND tuple of nx AND ny NOT IN visited THEN  \n                        ADD tuple of nx AND ny TO visited  \n                        IF element at position nx of isInfected AND element at position ny of that element EQUALS one THEN  \n                            ADD tuple of nx AND ny TO end of queue  \n                        ELSE IF element at position nx of isInfected AND element at position ny of that element EQUALS zero THEN  \n                            ADD tuple of nx AND ny TO threatened  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            RETURN infected AND threatened  \n        END FUNCTION  \n\n        FUNCTION build_walls(infected)  \n            SET walls TO zero  \n            FOR each tuple x AND y IN infected  \n                FOR each tuple nx AND ny IN neighbors(x, y)  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of isInfected AND element at position ny of that element EQUALS zero THEN  \n                        INCREMENT walls BY one  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN walls  \n        END FUNCTION  \n\n        FUNCTION spread_virus(threatened)  \n            FOR each tuple x AND y IN threatened  \n                SET element at position x of isInfected AND element at position y of that element TO one  \n            END FOR  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF isInfected  \n        SET n TO the LENGTH OF element at position zero of isInfected  \n        SET total_walls TO zero  \n\n        WHILE true holds  \n            SET regions TO empty list  \n            SET visited TO empty set  \n            FOR r FROM zero TO m MINUS one  \n                FOR c FROM zero TO n MINUS one  \n                    IF element at position r of isInfected AND element at position c of that element EQUALS one AND tuple of r AND c NOT IN visited THEN  \n                        SET infected AND threatened TO result of bfs with parameters r AND c  \n                        APPEND tuple formed by infected AND threatened TO regions  \n                        UNION visited WITH infected  \n                    END IF  \n                END FOR  \n            END FOR  \n\n            IF regions IS empty THEN  \n                BREAK the WHILE loop  \n            END IF  \n\n            SORT regions IN descending order BY the LENGTH OF the second element of each tuple  \n\n            INCREMENT total_walls BY result of build_walls applied to first element of first tuple in regions  \n\n            FOR each tuple x AND y IN first element of first tuple in regions  \n                SET element at position x of isInfected AND element at position y of that element TO minus one  \n            END FOR  \n\n            FOR i FROM one TO LENGTH OF regions MINUS one  \n                APPLY spread_virus TO the second element of element at position i of regions  \n            END FOR  \n        END WHILE  \n\n        RETURN total_walls  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-corner-rectangles", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countCornerRectangles(grid)  \n        IF grid EQUALS no elements OR element at position zero of grid EQUALS no elements  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET count TO zero  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM i PLUS one TO m MINUS one  \n                SET cols_with_ones TO zero  \n                FOR k FROM zero TO n MINUS one  \n                    IF element at position i of grid at position k EQUALS one AND element at position j of grid at position k EQUALS one  \n                        INCREMENT cols_with_ones BY one  \n                    END IF  \n                END FOR  \n                \n                IF cols_with_ones GREATER THAN OR EQUAL TO two  \n                    INCREMENT count BY cols_with_ones MULTIPLIED BY cols_with_ones MINUS one DIVIDED BY two  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ip-to-cidr", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION ipToCIDR(ip, n)  \n        FUNCTION ip_to_int(ip)  \n            SET parts TO list of integers obtained by splitting ip string by the dot character  \n            SET res TO zero  \n            FOR each part IN parts  \n                SET res TO res MULTIPLIED BY two HUNDRED FIFTY SIX PLUS part  \n            END FOR  \n            RETURN res  \n        END FUNCTION  \n        \n        FUNCTION int_to_ip(num)  \n            SET ip_parts TO empty list  \n            FOR i FROM three DOWN TO zero  \n                SET part TO the element obtained by dividing num RIGHT SHIFTED BY eight MULTIPLIED BY i THEN MODULO two HUNDRED FIFTY SIX  \n                APPEND string representation of part TO ip_parts  \n            END FOR  \n            RETURN all elements of ip_parts joined by the dot character  \n        END FUNCTION  \n        \n        FUNCTION largest_cidr_size(start, n)  \n            IF the bitwise AND of start AND one EQUALS one THEN  \n                RETURN one  \n            END IF  \n            SET x TO one  \n            WHILE x LESS THAN OR EQUAL TO n AND the bitwise AND of start AND x MINUS one EQUALS zero DO  \n                SET x TO x MULTIPLIED BY two  \n            END WHILE  \n            RETURN x DIVIDED BY two  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        SET start_ip TO ip_to_int applied to ip  \n        \n        WHILE n GREATER THAN zero DO  \n            SET size TO largest_cidr_size applied to start_ip AND n  \n            SET cidr_suffix TO thirty TWO MINUS the bit length of size MINUS one  \n            SET cidr_string TO the int_to_ip applied to start_ip concatenated with the forward slash character concatenated with string representation of cidr_suffix  \n            APPEND cidr_string TO result  \n            INCREMENT start_ip BY size  \n            DECREMENT n BY size  \n        END WHILE  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reach-a-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reachNumber(target)  \n        SET target TO the absolute value of target  \n        SET k TO zero  \n        SET sum_steps TO zero  \n        WHILE sum_steps LESS THAN target  \n            INCREMENT k BY one  \n            INCREMENT sum_steps BY k  \n        END WHILE  \n        IF the difference between sum_steps and target MODULO two EQUALS zero  \n            RETURN k  \n        ELSE  \n            IF k MODULO two EQUALS zero  \n                RETURN k PLUS one  \n            ELSE  \n                RETURN k PLUS two  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pour-water", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN zero AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            INCREMENT element at position k of heights BY one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pyramid-transition-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pyramidTransition(bottom, allowed)  \n        SET allowed_map TO a default dictionary where each key maps to a default dictionary that maps to a list  \n        FOR each rule IN allowed  \n            SET left TO the element at position zero of rule  \n            SET right TO the element at position one of rule  \n            SET top TO the element at position two of rule  \n            APPEND top TO the list at allowed_map at key left at key right  \n        END FOR  \n        \n        FUNCTION can_build_pyramid(current_bottom, current_top)  \n            IF the length of current_bottom EQUALS one  \n                RETURN True  \n            END IF  \n            IF the length of current_top EQUALS the length of current_bottom MINUS one  \n                RETURN the result of calling can_build_pyramid with current_top and an empty list  \n            END IF  \n            \n            SET left TO the element at position the length of current_top of current_bottom  \n            SET right TO the element at position the length of current_top PLUS one of current_bottom  \n            IF left EXISTS as a key in allowed_map AND right EXISTS as a key in allowed_map at key left  \n                FOR each top IN the list at allowed_map at key left at key right  \n                    IF the result of calling can_build_pyramid with current_bottom and current_top concatenated with top is True  \n                        RETURN True  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN the result of calling can_build_pyramid with bottom and an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bold-words-in-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution\n    FUNCTION boldWords(words, s)\n        SET bold TO a list of Boolean false values with the length equal to the length of s\n        FOR each word IN words\n            SET start TO the position of the first occurrence of word in s\n            WHILE start is not equal to negative one\n                FOR i FROM start TO start PLUS the length of word MINUS one\n                    SET element at position i of bold TO true\n                END FOR\n                SET start TO the position of the next occurrence of word in s starting from position start PLUS one\n            END WHILE\n        END FOR\n\n        SET result TO an empty list\n        SET i TO zero\n        WHILE i is less than the length of s\n            IF the element at position i of bold is true\n                APPEND the string denoting the opening bold tag to result\n                WHILE i is less than the length of s AND the element at position i of bold is true\n                    APPEND the element at position i of s to result\n                    INCREMENT i BY one\n                END WHILE\n                APPEND the string denoting the closing bold tag to result\n            ELSE\n                APPEND the element at position i of s to result\n                INCREMENT i BY one\n            END IF\n        END WHILE\n\n        RETURN the concatenation of all elements in result\n    END FUNCTION\nEND CLASS"}
{"task_id": "special-binary-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION makeLargestSpecial(s)  \n        FUNCTION dfs(s)  \n            SET count TO zero  \n            SET start TO zero  \n            SET specials TO empty list  \n            FOR each index i AND character char IN the enumeration of s  \n                IF character char EQUALS the character one  \n                    INCREMENT count BY one  \n                ELSE  \n                    DECREMENT count BY one  \n                END IF  \n                IF count EQUALS zero  \n                    APPEND the concatenation of the character one PLUS the result of calling dfs on the substring of s from position start incremented by one TO position i PLUS the character zero TO the list specials  \n                    SET start TO index i incremented by one  \n                END IF  \n            END FOR  \n            SORT the list specials in reverse lexicographical order  \n            RETURN the concatenation of all elements in specials  \n        END FUNCTION  \n        RETURN the result of calling dfs on s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-labels", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION partitionLabels(s)  \n        SET last_occurrence TO an empty dictionary  \n        FOR each index i FROM zero TO the length of s MINUS one  \n            SET character char TO element at position i of s  \n            SET last_occurrence at key char TO i  \n        END FOR  \n        SET start TO zero  \n        SET end TO zero  \n        SET partition_sizes TO an empty list  \n        FOR each index i FROM zero TO the length of s MINUS one  \n            SET character char TO element at position i of s  \n            IF end LESS THAN last_occurrence at key char  \n                SET end TO last_occurrence at key char  \n            END IF  \n            IF i EQUALS end  \n                SET partition_size TO end MINUS start PLUS one  \n                APPEND partition_size TO partition_sizes  \n                SET start TO i PLUS one  \n            END IF  \n        END FOR  \n        RETURN partition_sizes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-plus-sign", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION orderOfLargestPlusSign(n, mines)  \n        SET mines_set TO an empty set  \n        FOR each mine IN mines  \n            ADD the tuple consisting of the elements of mine TO mines_set  \n        END FOR  \n  \n        SET dp TO a two dimensional list with n rows and n columns where each element is a list of four zeros  \n  \n        SET directions TO the list containing the pairs zero PLUS one, one PLUS zero, zero MINUS one, and minus one PLUS zero  \n  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the pair consisting of i and j IS NOT IN mines_set THEN  \n                    IF j IS GREATER THAN zero THEN  \n                        SET element at position zero of element at position j MINUS one of element at position i of dp TO element at position zero of element at position j MINUS one of element at position i of dp PLUS one  \n                    END IF  \n                    IF i IS GREATER THAN zero THEN  \n                        SET element at position one of element at position j of element at position i MINUS one of dp TO element at position one of element at position j of element at position i MINUS one of dp PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n  \n        SET result TO zero  \n  \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM n MINUS one DOWN TO zero  \n                IF the pair consisting of i and j IS NOT IN mines_set THEN  \n                    IF j IS LESS THAN n MINUS one THEN  \n                        SET element at position two of element at position j PLUS one of element at position i of dp TO element at position two of element at position j PLUS one of element at position i of dp PLUS one  \n                    END IF  \n                    IF i IS LESS THAN n MINUS one THEN  \n                        SET element at position three of element at position j of element at position i PLUS one of dp TO element at position three of element at position j of element at position i PLUS one of dp PLUS one  \n                    END IF  \n  \n                    SET plus_sign_order TO the minimum value among the elements of element at position j of element at position i of dp  \n  \n                    IF plus_sign_order IS GREATER THAN result THEN  \n                        SET result TO plus_sign_order  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "couples-holding-hands", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSwapsCouples(row)  \n        SET position TO an empty dictionary mapping each person to their index in the row  \n        SET swaps TO zero  \n        FOR i FROM zero TO the LENGTH OF row MINUS one STEP two  \n            SET correct_pair TO the element at position i of row MINUS one MULTIPLIED BY one PLUS one IF the element at position i of row IS EVEN OTHERWISE the element at position i of row MINUS one  \n            IF the element at position i PLUS one of row NOT EQUALS correct_pair  \n                SET swap_idx TO the index associated with correct_pair in position  \n                SET element at position swap_idx of row TO the element at position i PLUS one of row  \n                SET element at position i PLUS one of row TO correct_pair  \n                SET position associated with element at position swap_idx of row TO swap_idx  \n                SET position associated with element at position i PLUS one of row TO i PLUS one  \n                INCREMENT swaps BY one  \n            END IF  \n        END FOR  \n        RETURN swaps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-chunks-to-make-sorted", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxChunksToSorted(arr)  \n        SET max_so_far TO zero  \n        SET chunks TO zero  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET element_at_i TO element at position i of arr  \n            SET max_so_far TO the GREATER THAN value BETWEEN max_so_far AND element_at_i  \n            IF max_so_far EQUALS i THEN  \n                INCREMENT chunks BY one  \n            END IF  \n        END FOR  \n        RETURN chunks  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "basic-calculator-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION calculate(s)  \n        FUNCTION helper(s)  \n            SET stack TO an empty list  \n            SET num TO zero  \n            SET sign TO the plus character  \n            WHILE the LENGTH OF s GREATER THAN zero HOLDS  \n                SET char TO the element at position zero of s  \n                REMOVE the element at position zero FROM s  \n                IF char IS a digit character  \n                    SET num TO num MULTIPLIED BY ten PLUS the integer value of char  \n                END IF  \n                IF char EQUALS the opening parenthesis character  \n                    SET num TO CALL helper WITH s  \n                END IF  \n                IF char IS one of the plus character OR minus character OR multiplication character OR division character OR opening parenthesis character OR closing parenthesis character OR the LENGTH OF s EQUALS zero  \n                    IF sign EQUALS the plus character  \n                        APPEND num TO stack  \n                    ELSE IF sign EQUALS the minus character  \n                        APPEND the negative of num TO stack  \n                    ELSE IF sign EQUALS the multiplication character  \n                        SET the element at the last position of stack TO the element at the last position of stack MULTIPLIED BY num  \n                    ELSE IF sign EQUALS the division character  \n                        SET the element at the last position of stack TO the integer truncation towards zero of the element at the last position of stack DIVIDED BY num  \n                    END IF  \n                    SET sign TO char  \n                    SET num TO zero  \n                END IF  \n                IF char EQUALS the closing parenthesis character  \n                    BREAK the WHILE loop  \n                END IF  \n            END WHILE  \n            RETURN the sum of all elements in stack  \n        END FUNCTION  \n        SET s TO the list of characters from s  \n        RETURN CALL helper WITH s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-puzzle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION slidingPuzzle(board)  \n        SET start TO tuple of tuples where each tuple is each row in board  \n        SET target TO tuple of tuples representing one two three and four five zero  \n        \n        SET neighbors TO dictionary mapping zero position zero TO positions one and three  \n            position one TO positions zero two and four  \n            position two TO positions one and five  \n            position three TO positions zero and four  \n            position four TO positions one three and five  \n            position five TO positions two and four  \n        \n        FOR variable i FROM zero TO one  \n            FOR variable j FROM zero TO two  \n                IF element at position j of element at position i of start EQUALS zero  \n                    SET zero_pos TO i MULTIPLIED BY three PLUS j  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET queue TO double ended queue containing tuple of start zero_pos and zero  \n        SET visited TO set containing start  \n        \n        WHILE queue is not empty  \n            REMOVE and SET state zero_pos moves TO the leftmost element of queue  \n            \n            IF state EQUALS target  \n                RETURN moves  \n            END IF  \n            \n            FOR each neighbor IN elements mapped by zero_pos in neighbors  \n                SET new_state TO list of lists where each element is list version of each element in state  \n                SET i TO zero_pos DIVIDED BY three  \n                SET j TO zero_pos MODULO three  \n                SET ni TO neighbor DIVIDED BY three  \n                SET nj TO neighbor MODULO three  \n                \n                SET temporary TO element at position j of element at position i of new_state  \n                SET element at position j of element at position i of new_state TO element at position nj of element at position ni of new_state  \n                SET element at position nj of element at position ni of new_state TO temporary  \n                \n                SET new_tuple_state TO tuple of tuples where each tuple is each row in new_state  \n                \n                IF new_tuple_state is not an element of visited  \n                    ADD new_tuple_state TO visited  \n                    APPEND tuple of new_tuple_state neighbor moves PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the negative of one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-max-distance-to-gas-station", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minmaxGasDist(stations parameter OF TYPE List of integers k parameter OF TYPE integer) RETURNS floating point number  \n        FUNCTION possible(max_dist parameter OF TYPE floating point number) RETURNS boolean  \n            SET additional_stations TO zero  \n            FOR index FROM one TO the LENGTH OF stations MINUS one  \n                INCREMENT additional_stations BY the INTEGER PART OF the element at position index of stations MINUS the element at position index MINUS one of stations DIVIDED BY max_dist  \n            END FOR  \n            RETURN additional_stations LESS THAN OR EQUAL TO k  \n        END FUNCTION  \n\n        SET left TO zero  \n        SET right TO one HUNDRED MILLION  \n        WHILE right MINUS left GREATER THAN zero POINT zero zero zero zero zero one  \n            SET mid TO left PLUS right DIVIDED BY two  \n            IF possible(mid) IS true  \n                SET right TO mid  \n            ELSE  \n                SET left TO mid  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "global-and-local-inversions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isIdealPermutation(nums)  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF the ABSOLUTE VALUE OF the ELEMENT at position i of nums MINUS i GREATER THAN one  \n                RETURN False  \n            END IF  \n        END FOR  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swap-adjacent-in-lr-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-symbol-in-grammar", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthGrammar(n k)  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET length_of_previous_row TO two MULTIPLIED BY two RAISED TO THE POWER OF n MINUS two MINUS one  \n        IF k LESS THAN OR EQUAL TO length_of_previous_row  \n            RETURN call kthGrammar WITH n MINUS one AND k  \n        ELSE  \n            SET previous_value TO call kthGrammar WITH n MINUS one AND k MINUS length_of_previous_row  \n            SET complement_value TO one MINUS previous_value  \n            RETURN complement_value  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rabbits-in-forest", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numRabbits WITH parameter answers  \n        SET answer_counts TO the count of occurrences of each element IN answers  \n        SET total_rabbits TO zero  \n        FOR each answer AND count pair IN the items of answer_counts  \n            SET group_size TO answer PLUS one  \n            SET groups TO the result of dividing count PLUS answer BY group_size  \n            INCREMENT total_rabbits BY groups MULTIPLIED BY group_size  \n        END FOR  \n        RETURN total_rabbits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "transform-to-chessboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION movesToChessboard(board)  \n        SET N TO the LENGTH OF board  \n        \n        SET rowSum TO zero  \n        SET colSum TO zero  \n        SET rowSwap TO zero  \n        SET colSwap TO zero  \n        \n        FOR i FROM zero TO N MINUS one  \n            FOR j FROM zero TO N MINUS one  \n                IF the element at position i of board AND the element at position j of element at position i of board NOT EQUALS the element at position i of element at position zero of board AND the element at position j of element at position zero of board NOT EQUALS the element at position j of element at position zero of board AND the element at position zero of element at position zero of board  \n                    RETURN minus one  \n                END IF  \n            END FOR  \n            \n            INCREMENT rowSum BY the element at position zero of element at position i of board  \n            INCREMENT colSum BY the element at position i of element at position zero of board  \n            \n            IF the element at position zero of element at position i of board EQUALS the remainder of i DIVIDED BY two  \n                INCREMENT rowSwap BY one  \n            END IF  \n            \n            IF the element at position i of element at position zero of board EQUALS the remainder of i DIVIDED BY two  \n                INCREMENT colSwap BY one  \n            END IF  \n        END FOR  \n        \n        IF the integer division of N BY two GREATER THAN rowSum OR rowSum GREATER THAN the integer division of N PLUS one BY two  \n            RETURN minus one  \n        END IF  \n        \n        IF the integer division of N BY two GREATER THAN colSum OR colSum GREATER THAN the integer division of N PLUS one BY two  \n            RETURN minus one  \n        END IF  \n        \n        IF the remainder of N DIVIDED BY two NOT EQUALS zero  \n            IF the remainder of rowSwap DIVIDED BY two NOT EQUALS zero  \n                SET rowSwap TO N MINUS rowSwap  \n            END IF  \n            \n            IF the remainder of colSwap DIVIDED BY two NOT EQUALS zero  \n                SET colSwap TO N MINUS colSwap  \n            END IF  \n        ELSE  \n            SET rowSwap TO the MINIMUM OF rowSwap AND N MINUS rowSwap  \n            SET colSwap TO the MINIMUM OF colSwap AND N MINUS colSwap  \n        END IF  \n        \n        RETURN the integer division of the SUM OF rowSwap AND colSwap BY two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "is-graph-bipartite", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        SET n TO the LENGTH OF graph  \n        SET color TO a list of zeros with LENGTH n  \n        \n        FUNCTION dfs(node c)  \n            SET the element at position node of color TO c  \n            FOR each neighbor IN the element at position node of graph  \n                IF the element at position neighbor of color EQUALS c  \n                    RETURN False  \n                END IF  \n                IF the element at position neighbor of color EQUALS zero  \n                    IF dfs(neighbor the NEGATION OF c) EQUALS False  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of color EQUALS zero  \n                IF dfs(i one) EQUALS False  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-smallest-prime-fraction", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPrimeFraction(arr, k)  \n        SET n TO the LENGTH OF arr  \n        SET min_heap TO an empty list  \n        FOR i FROM zero TO n MINUS one MINUS one  \n            PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position n MINUS one of arr AND i AND n MINUS one  \n        END FOR  \n        FOR iteration FROM zero TO k MINUS one MINUS one  \n            POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n            IF j MINUS one IS GREATER THAN i THEN  \n                PUSH TO min_heap a tuple containing the fraction of element at position i of arr DIVIDED BY element at position j MINUS one of arr AND i AND j MINUS one  \n            END IF  \n        END FOR  \n        POP the smallest element FROM min_heap AND ASSIGN the values to unused_variable AND i AND j  \n        RETURN a list containing element at position i of arr AND element at position j of arr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotated-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rotatedDigits WITH parameter n  \n        SET change_digits TO the collection containing the characters two five six nine  \n        SET same_digits TO the collection containing the characters zero one eight  \n        \n        FUNCTION is_good_number WITH parameter num  \n            SET num_str TO the string representation of num  \n            IF each character IN num_str belongs TO the union of change_digits and same_digits THEN  \n                IF at least one character IN num_str belongs TO change_digits THEN  \n                    RETURN true  \n                ELSE  \n                    RETURN false  \n                END IF  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n        \n        SET good_count TO zero  \n        FOR each i FROM one TO n  \n            IF is_good_number WITH argument i RETURNS true THEN  \n                INCREMENT good_count BY one  \n            END IF  \n        END FOR  \n        RETURN good_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-the-ghosts", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION escapeGhosts(ghosts PARAMETER, target PARAMETER)  \n        SET player_distance TO the absolute value of element at position zero of target PLUS the absolute value of element at position one of target  \n        FOR each ghost IN ghosts  \n            SET ghost_distance TO the absolute value of element at position zero of ghost MINUS element at position zero of target PLUS the absolute value of element at position one of ghost MINUS element at position one of target  \n            IF ghost_distance LESS THAN OR EQUAL TO player_distance  \n                RETURN False  \n            END IF  \n        END FOR  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO the one billion PLUS seven  \n        \n        SET dp TO a list of zeros with LENGTH n PLUS one  \n        SET dp1 TO a list of zeros with LENGTH n PLUS one  \n        \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder of the sum of element at position i MINUS one of dp PLUS element at position i MINUS two of dp PLUS two MULTIPLIED BY element at position i MINUS one of dp1 when divided by MOD  \n            SET element at position i of dp1 TO the remainder of the sum of element at position i MINUS two of dp PLUS element at position i MINUS one of dp1 when divided by MOD  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "custom-sort-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION customSortString(order, s)  \n        SET dictionary d TO empty mapping  \n        FOR index i FROM zero TO the LENGTH OF order MINUS one  \n            SET element at position i of order TO character c  \n            SET element at position c of dictionary d TO i  \n        END FOR  \n        SET list_of_characters TO the characters of s sorted BY for each character x the value obtained by GETTING FROM dictionary d the value at character x IF IT EXISTS OTHERWISE zero  \n        SET result_string TO the concatenation of characters in list_of_characters in order  \n        RETURN result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-matching-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numMatchingSubseq s words  \n        SET waiting TO an empty dictionary  \n        FOR each character IN the set of unique characters of s  \n            ASSIGN reference TO an empty double-ended queue  \n            SET the element at key character of waiting TO the empty double-ended queue  \n        END FOR  \n        \n        FOR each word IN words  \n            ASSIGN reference TO the iterator of word  \n            SET first_letter TO the next element from the iterator of word or None if exhausted  \n            IF first_letter IS NOT equal to None AND first_letter IS an element of waiting  \n                APPEND the iterator reference TO the double-ended queue stored at key first_letter of waiting  \n            END IF  \n        END FOR  \n        \n        SET match_count TO zero  \n        \n        FOR each character c IN s  \n            IF character c IS an element of waiting  \n                ASSIGN reference TO the double-ended queue stored at key c of waiting  \n                ASSIGN reference TO an empty double-ended queue  \n                SET the element at key c of waiting TO the empty double-ended queue  \n                FOR each iterator it IN the previous double-ended queue stored at key c  \n                    SET next_char TO the next element from iterator it or None if exhausted  \n                    IF next_char IS equal to None  \n                        INCREMENT match_count BY one  \n                    ELSE  \n                        IF next_char IS an element of waiting  \n                            APPEND iterator it TO the double-ended queue stored at key next_char of waiting  \n                        END IF  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN match_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-tic-tac-toe-state", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-subarrays-with-bounded-maximum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSubarrayBoundedMax(nums PARAMETERS left PARAMETERS right)  \n        FUNCTION count(max_value)  \n            SET count TO zero  \n            SET current_length TO zero  \n            FOR each num IN nums  \n                IF num LESS THAN OR EQUAL TO max_value  \n                    INCREMENT current_length BY one  \n                    INCREMENT count BY current_length  \n                ELSE  \n                    SET current_length TO zero  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN the result of count called with right MINUS the result of count called with left MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "all-paths-from-source-to-target", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION allPathsSourceTarget(graph)  \n        SET n TO the LENGTH OF graph  \n        SET q TO an empty double ended queue containing a list with element zero  \n        SET ans TO an empty list  \n        WHILE the LENGTH OF q is GREATER THAN zero  \n            SET path TO the element removed from the left end of q  \n            SET u TO the element at position the LENGTH OF path MINUS one of path  \n            IF u EQUALS n MINUS one  \n                APPEND path TO ans  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            FOR each v IN the element at position u of graph  \n                APPEND a new list consisting of the elements of path FOLLOWED BY v TO q  \n            END FOR  \n        END WHILE  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "champagne-tower", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION champagneTower(poured, query_row, query_glass)  \n        SET current_row TO a list containing poured as the only element  \n        FOR row FROM one TO query_row  \n            SET next_row TO a list of zeros with length equal to row PLUS one  \n            FOR i FROM zero TO the LENGTH OF current_row MINUS one  \n                IF element at position i of current_row GREATER THAN one  \n                    SET excess TO element at position i of current_row MINUS one DIVIDED BY two  \n                    INCREMENT element at position i of next_row BY excess  \n                    INCREMENT element at position i PLUS one of next_row BY excess  \n                END IF  \n            END FOR  \n            ASSIGN reference TO object next_row INTO current_row  \n        END FOR  \n        IF element at position query_glass of current_row LESS THAN OR EQUAL TO one  \n            RETURN element at position query_glass of current_row  \n        ELSE  \n            RETURN one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-swaps-to-make-sequences-increasing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSwap(nums1 parameter, nums2 parameter)  \n        SET n TO the LENGTH OF nums1  \n        INITIALIZE dp AS a list of size n each containing a list of two zeros  \n        \n        SET element at position zero at position zero of dp TO zero  \n        SET element at position zero at position one of dp TO one  \n        \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of nums1 GREATER THAN element at position i MINUS one of nums1 AND element at position i of nums2 GREATER THAN element at position i MINUS one of nums2  \n                IF element at position i of nums1 GREATER THAN element at position i MINUS one of nums2 AND element at position i of nums2 GREATER THAN element at position i MINUS one of nums1  \n                    SET element at position i at position zero of dp TO the MINIMUM OF element at position i MINUS one at position zero of dp AND element at position i MINUS one at position one of dp  \n                    SET element at position i at position one of dp TO element at position i at position zero of dp PLUS one  \n                ELSE  \n                    SET element at position i at position zero of dp TO element at position i MINUS one at position zero of dp  \n                    SET element at position i at position one of dp TO element at position i MINUS one at position one of dp PLUS one  \n                END IF  \n            ELSE  \n                IF element at position i of nums1 GREATER THAN element at position i MINUS one of nums2 AND element at position i of nums2 GREATER THAN element at position i MINUS one of nums1  \n                    SET element at position i at position zero of dp TO element at position i MINUS one at position one of dp  \n                    SET element at position i at position one of dp TO element at position i MINUS one at position zero of dp PLUS one  \n                ELSE  \n                    SET element at position i at position zero of dp TO element at position i MINUS one at position one of dp  \n                    SET element at position i at position one of dp TO element at position i MINUS one at position zero of dp PLUS one  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN the MINIMUM OF element at position n MINUS one at position zero of dp AND element at position n MINUS one at position one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-with-same-average", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitArraySameAverage(nums)  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO the SUM OF nums  \n        \n        IF n EQUALS one  \n            RETURN false  \n        END IF  \n        \n        SET dp TO a list of empty sets with LENGTH EQUAL TO n DIVIDED BY two PLUS one  \n        ADD zero TO the element at position zero of dp  \n        \n        FOR each num IN nums  \n            FOR size FROM n DIVIDED BY two DOWN TO one  \n                FOR each s IN the element at position size MINUS one of dp  \n                    SET new_sum TO s PLUS num  \n                    IF new_sum MULTIPLIED BY n EQUALS size MULTIPLIED BY total_sum  \n                        RETURN true  \n                    END IF  \n                    ADD new_sum TO the element at position size of dp  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "soup-servings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred THEN  \n            RETURN one point zero  \n        END IF  \n        SET n TO n PLUS twenty four DIVIDED BY twenty five  \n        SET memo TO empty dictionary  \n        FUNCTION dp(a, b)  \n            IF tuple of a AND b EXISTS IN memo THEN  \n                RETURN value of tuple of a AND b IN memo  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point five  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero THEN  \n                RETURN one point zero  \n            END IF  \n            IF b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point zero  \n            END IF  \n            SET prob TO zero point two five MULTIPLIED BY sum of dp of a MINUS four AND b PLUS dp of a MINUS three AND b MINUS one PLUS dp of a MINUS two AND b MINUS two PLUS dp of a MINUS one AND b MINUS three  \n            SET value of tuple of a AND b IN memo TO prob  \n            RETURN prob  \n        END FUNCTION  \n        RETURN dp of n AND n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "expressive-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION expressiveWords(s, words)  \n        FUNCTION compress(word)  \n            IF word EQUALS empty  \n                RETURN empty list  \n            END IF  \n            SET count TO one  \n            SET compressed TO empty list  \n            FOR index FROM one TO the LENGTH OF word MINUS one  \n                IF element at position index of word EQUALS element at position index MINUS one of word  \n                    INCREMENT count BY one  \n                ELSE  \n                    APPEND pair of element at position index MINUS one of word AND count TO compressed  \n                    SET count TO one  \n                END IF  \n            END FOR  \n            APPEND pair of element at last position of word AND count TO compressed  \n            RETURN compressed  \n        END FUNCTION  \n        \n        FUNCTION is_stretchy(s_compressed, word_compressed)  \n            IF the LENGTH OF s_compressed NOT EQUALS the LENGTH OF word_compressed  \n                RETURN false  \n            END IF  \n            FOR each pair of sc AND sc_count IN s_compressed AND pair of wc AND wc_count IN word_compressed IN PARALLEL  \n                IF sc NOT EQUALS wc  \n                    RETURN false  \n                END IF  \n                IF sc_count NOT EQUALS wc_count AND (sc_count LESS THAN three OR sc_count LESS THAN wc_count)  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        SET s_compressed TO compress applied to s  \n        SET stretchy_count TO zero  \n        \n        FOR each word IN words  \n            SET word_compressed TO compress applied to word  \n            IF is_stretchy applied to s_compressed AND word_compressed  \n                INCREMENT stretchy_count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN stretchy_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "chalkboard-xor-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION xorGame(nums)  \n        SET total_xor TO zero  \n        FOR each num IN nums  \n            SET total_xor TO total_xor XOR num  \n        END FOR  \n        IF total_xor EQUALS zero  \n            RETURN True  \n        END IF  \n        IF LENGTH OF nums MODULO two EQUALS zero  \n            RETURN True  \n        END IF  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subdomain-visit-count", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subdomainVisits(cpdomains)  \n        ASSIGN reference TO a new mapping with default integer zero named domain_count  \n        \n        FOR each cpdomain IN cpdomains  \n            SET count_and_domain TO the SPLIT of cpdomain BY whitespace  \n            SET count TO the conversion of the first element of count_and_domain TO integer  \n            SET domain TO the second element of count_and_domain  \n            SET subdomains TO the SPLIT of domain BY the period word  \n            \n            FOR index FROM zero TO the LENGTH OF subdomains MINUS one  \n                SET subdomain_parts TO the slice of subdomains FROM index TO the end  \n                SET subdomain TO the JOIN of subdomain_parts USING the period word  \n                INCREMENT the value at subdomain in domain_count BY count  \n            END FOR  \n        END FOR  \n        \n        SET result_list TO an empty list  \n        FOR each domain and count IN the items of domain_count  \n            SET formatted_string TO the concatenation of the string representation of count, a single space word, and the domain  \n            APPEND formatted_string TO result_list  \n        END FOR  \n        \n        RETURN result_list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-sum-of-averages", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestSumOfAverages(nums PARAMETER, k PARAMETER)  \n        SET n TO the LENGTH OF nums  \n        SET prefix_sum TO a list of zeros with LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix_sum TO element at position i of prefix_sum PLUS element at position i of nums  \n        END FOR  \n        \n        FUNCTION average(i PARAMETER, j PARAMETER)  \n            SET total_sum TO element at position j PLUS one of prefix_sum MINUS element at position i of prefix_sum  \n            SET length_subarray TO j MINUS i PLUS one  \n            SET average_value TO total_sum DIVIDED BY length_subarray  \n            RETURN average_value  \n        END FUNCTION  \n        \n        SET dp TO a two dimensional list of zeros with dimensions n PLUS one BY k PLUS one  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position one of element at position i of dp TO CALL average WITH arguments i AND n MINUS one  \n        END FOR  \n        \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR partitions FROM two TO k  \n                FOR j FROM i PLUS one TO n MINUS one  \n                    SET current_value TO element at position partitions of element at position i of dp  \n                    SET candidate_value TO element at position partitions MINUS one of element at position j of dp PLUS CALL average WITH arguments i AND j MINUS one  \n                    IF candidate_value GREATER THAN current_value THEN  \n                        SET element at position partitions of element at position i of dp TO candidate_value  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position k of element at position zero of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bus-routes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from keys to empty lists  \n        FOR each bus WITH index bus_index AND route IN routes  \n            FOR each stop IN route  \n                APPEND bus_index TO the list corresponding to stop IN stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at the source stop FROM stop_to_buses  \n            APPEND the tuple consisting of bus AND one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element FROM bus_queue AND ASSIGN the elements TO current_bus AND bus_count  \n\n            FOR each stop IN the route at position current_bus OF routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop NOT IN visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop FROM stop_to_buses  \n                        IF next_bus NOT IN visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the tuple consisting of next_bus AND bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ambiguous-coordinates", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION ambiguousCoordinates WITH PARAMETER s  \n        FUNCTION make WITH PARAMETER frag  \n            SET n TO the LENGTH OF frag  \n            FOR d FROM one TO n  \n                SET left TO substring from position one TO position d of frag  \n                SET right TO substring from position d PLUS one TO the LENGTH OF frag of frag  \n                IF left DOES NOT START WITH zero OR left EQUALS zero AND right DOES NOT END WITH zero  \n                    RETURN CONCATENATION OF left AND IF d IS NOT EQUAL TO n THEN a period OTHERWISE an empty string AND right  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        SET s TO substring from position two TO the LENGTH OF s MINUS one of s  \n        RETURN a list of strings formed by CONCATENATION OF an opening parenthesis WITH a A COMMA WITH A SPACE B closing parenthesis WHERE  \n            i RUNS FROM one TO the LENGTH OF s MINUS one  \n            a AND b ARE every combination FROM the CARTESIAN PRODUCT OF make APPLIED TO substring from position one TO position i of s AND make APPLIED TO substring from position i PLUS one TO the LENGTH OF s of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "race-car", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION racecar(target)  \n        ASSIGN reference TO a new double ended queue containing a single tuple of zero for position one for speed and zero for steps  \n        ASSIGN reference TO a new empty set  \n        ADD a tuple of zero for position and one for speed TO the set  \n        \n        WHILE the queue is not empty  \n            REMOVE and ASSIGN a tuple from the left side of the queue TO position speed and steps  \n            \n            IF position EQUALS target  \n                RETURN steps  \n            END IF  \n            \n            SET next_position TO position PLUS speed  \n            SET next_speed TO speed MULTIPLIED BY two  \n            IF the tuple of next_position and next_speed NOT IN the set AND next_position IS GREATER THAN OR EQUAL TO zero AND next_position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of next_position and next_speed TO the set  \n                APPEND the tuple of next_position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n            \n            IF speed IS GREATER THAN zero  \n                SET next_speed TO negative one  \n            ELSE  \n                SET next_speed TO one  \n            END IF  \n            IF the tuple of position and next_speed NOT IN the set AND position IS GREATER THAN OR EQUAL TO zero AND position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of position and next_speed TO the set  \n                APPEND the tuple of position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "short-encoding-of-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumLengthEncoding(words)  \n        SET list_of_reversed_words TO the sorted list of each word REVERSED in words  \n        SET total_length TO zero  \n        FOR index FROM zero TO the LENGTH OF list_of_reversed_words MINUS one  \n            IF index PLUS one EQUALS the LENGTH OF list_of_reversed_words OR NOT the element at position index PLUS one of list_of_reversed_words STARTS WITH the element at position index of list_of_reversed_words  \n                INCREMENT total_length BY the LENGTH OF the element at position index of list_of_reversed_words PLUS one  \n            END IF  \n        END FOR  \n        RETURN total_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "card-flipping-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-trees-with-factors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "most-profit-assigning-work", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfitAssignment(difficulty, profit, worker)  \n        SET jobs TO empty list  \n        FOR index FROM zero TO the LENGTH OF difficulty MINUS one  \n            APPEND pair consisting of element at position index of difficulty AND element at position index of profit TO jobs  \n        END FOR  \n        SORT jobs BY the first element of each pair in ascending order  \n        SORT worker IN ascending order  \n        SET max_profit TO zero  \n        SET best_profit TO zero  \n        SET job_index TO zero  \n        SET n TO the LENGTH OF jobs  \n        FOR each ability IN worker  \n            WHILE job_index LESS THAN n AND the first element of element at position job_index of jobs LESS THAN OR EQUAL TO ability  \n                IF the second element of element at position job_index of jobs GREATER THAN best_profit  \n                    SET best_profit TO the second element of element at position job_index of jobs  \n                END IF  \n                INCREMENT job_index BY one  \n            END WHILE  \n            INCREMENT max_profit BY best_profit  \n        END FOR  \n        RETURN max_profit  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "making-a-large-island", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestIsland(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET n TO the LENGTH OF grid  \n        SET directions TO the LIST OF the TUPLES zero and one and one and zero and zero and MINUS one and MINUS one and zero  \n        \n        FUNCTION is_valid(x y)  \n            RETURN zero LESS THAN OR EQUAL TO x AND x LESS THAN n AND zero LESS THAN OR EQUAL TO y AND y LESS THAN n  \n        END FUNCTION  \n        \n        FUNCTION dfs(x y index)  \n            SET area TO one  \n            SET element at position x and y of grid TO index  \n            FOR each dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF is_valid(nx ny) AND element at position nx and ny of grid EQUALS one  \n                    INCREMENT area BY dfs(nx ny index)  \n                END IF  \n            END FOR  \n            RETURN area  \n        END FUNCTION  \n        \n        SET island_areas TO empty MAP  \n        SET index TO two  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i and j of grid EQUALS one  \n                    SET element at key index of island_areas TO dfs(i j index)  \n                    INCREMENT index BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF island_areas IS empty  \n            RETURN one  \n        END IF  \n        \n        SET max_island_size TO the maximum VALUE in island_areas  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i and j of grid EQUALS zero  \n                    SET neighbors TO empty SET  \n                    FOR each dx dy IN directions  \n                        SET nx TO i PLUS dx  \n                        SET ny TO j PLUS dy  \n                        IF is_valid(nx ny) AND element at position nx and ny of grid GREATER THAN one  \n                            ADD element at position nx and ny of grid TO neighbors  \n                        END IF  \n                    END FOR  \n                    SET current_island_size TO one PLUS the SUM OF element at key index of island_areas FOR each index IN neighbors  \n                    IF current_island_size GREATER THAN max_island_size  \n                        SET max_island_size TO current_island_size  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN max_island_size  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "consecutive-numbers-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION consecutiveNumbersSum(n)  \n        SET count TO zero  \n        FOR k FROM one TO n PLUS one MINUS one  \n            IF two MULTIPLIED BY n MODULO k EQUALS zero  \n                SET m TO (two MULTIPLIED BY n DIVIDED BY k MINUS k PLUS one) DIVIDED BY two  \n                IF m GREATER THAN zero AND m EQUALS m CONVERTED TO INTEGER  \n                    INCREMENT count BY one  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "masking-personal-information", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maskPII WITH PARAMETER s  \n        IF s CONTAINS character AT symbol of email  \n            SET local TO substring before character AT symbol of email in s  \n            SET domain TO substring after character AT symbol of email in s  \n            SET masked_local TO concatenation of first character of local PLUS five repetitions of asterisk PLUS last character of local  \n            RETURN lowercase form of masked_local concatenated with character AT symbol PLUS lowercase form of domain  \n        ELSE  \n            SET digits TO empty string  \n            FOR each character IN s  \n                IF character IS a digit  \n                    APPEND character TO digits  \n                END IF  \n            END FOR  \n            SET local_number TO concatenation of three asterisks MINUS three asterisks MINUS last four characters of digits  \n            IF LENGTH OF digits EQUALS ten  \n                RETURN local_number  \n            ELSE  \n                SET country_code_length TO LENGTH OF digits MINUS ten  \n                SET country_code TO concatenation of plus sign PLUS asterisk repeated country_code_length times PLUS minus sign  \n                RETURN concatenation of country_code PLUS local_number  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-distances-in-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumOfDistancesInTree(n, edges)  \n        CREATE a new graph as a default dictionary with lists as default values  \n        FOR each pair of nodes a and b IN edges  \n            APPEND node b TO the adjacency list of node a in graph  \n            APPEND node a TO the adjacency list of node b in graph  \n        END FOR  \n\n        CREATE a list named count with size n and INITIALIZE every element TO one  \n        CREATE a list named dist with size n and INITIALIZE every element TO zero  \n\n        FUNCTION dfs1(u, p)  \n            FOR each node v IN the adjacency list of node u in graph  \n                IF node v NOT EQUALS node p THEN  \n                    CALL dfs1 with parameters v and u  \n                    INCREMENT count at position u BY count at position v  \n                    INCREMENT dist at position u BY dist at position v PLUS count at position v  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        CALL dfs1 with parameters zero and negative one  \n\n        FUNCTION dfs2(u, p)  \n            FOR each node v IN the adjacency list of node u in graph  \n                IF node v NOT EQUALS node p THEN  \n                    SET dist at position v TO dist at position u MINUS count at position v PLUS n MINUS count at position v  \n                    CALL dfs2 with parameters v and u  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        CALL dfs2 with parameters zero and negative one  \n\n        RETURN dist  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "image-overlap", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestOverlap(img1, img2)  \n        SET n TO the LENGTH OF img1  \n        SET points1 TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of img1 at position j EQUALS one THEN  \n                    APPEND a pair of i and j TO points1  \n                END IF  \n            END FOR  \n        END FOR  \n        SET points2 TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of img2 at position j EQUALS one THEN  \n                    APPEND a pair of i and j TO points2  \n                END IF  \n            END FOR  \n        END FOR  \n        SET overlap_count TO a default dictionary with integer default values  \n        FOR each pair x1 and y1 IN points1  \n            FOR each pair x2 and y2 IN points2  \n                SET dx TO x2 MINUS x1  \n                SET dy TO y2 MINUS y1  \n                INCREMENT the value at key of a pair dx and dy in overlap_count BY one  \n            END FOR  \n        END FOR  \n        SET max_overlap TO zero  \n        FOR each value count IN the values of overlap_count  \n            IF count GREATER THAN max_overlap THEN  \n                SET max_overlap TO count  \n            END IF  \n        END FOR  \n        RETURN max_overlap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "new-21-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION new21Game(n INTEGER PARAMETER k INTEGER PARAMETER maxPts INTEGER PARAMETER) RETURNS FLOAT  \n        FUNCTION dfs(i INTEGER PARAMETER) RETURNS FLOAT  \n            IF i GREATER THAN OR EQUAL TO k THEN  \n                IF i LESS THAN OR EQUAL TO n THEN  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF i EQUALS k MINUS one THEN  \n                IF n MINUS k PLUS one LESS THAN maxPts THEN  \n                    RETURN (n MINUS k PLUS one) DIVIDED BY maxPts  \n                ELSE  \n                    RETURN one  \n                END IF  \n            END IF  \n            SET first_call TO dfs(i PLUS one)  \n            SET second_call TO dfs(i PLUS maxPts PLUS one)  \n            SET result TO first_call PLUS (first_call MINUS second_call) DIVIDED BY maxPts  \n            RETURN result  \n        END FUNCTION  \n        RETURN dfs(zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "push-dominoes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pushDominoes(dominoes)  \n        SET n TO the LENGTH OF dominoes  \n        SET forces TO a LIST of size n FILLED WITH zeroes  \n\n        SET force TO zero  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of dominoes EQUALS uppercase letter R  \n                SET force TO n  \n            ELSE IF element at position i of dominoes EQUALS uppercase letter L  \n                SET force TO zero  \n            ELSE  \n                SET force TO the GREATER value BETWEEN force MINUS one AND zero  \n            END IF  \n            INCREMENT element at position i of forces BY force  \n        END FOR  \n\n        SET force TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at position i of dominoes EQUALS uppercase letter L  \n                SET force TO n  \n            ELSE IF element at position i of dominoes EQUALS uppercase letter R  \n                SET force TO zero  \n            ELSE  \n                SET force TO the GREATER value BETWEEN force MINUS one AND zero  \n            END IF  \n            DECREMENT element at position i of forces BY force  \n        END FOR  \n\n        SET result TO an EMPTY LIST  \n        FOR each f IN forces  \n            IF f GREATER THAN zero  \n                APPEND uppercase letter R TO result  \n            ELSE IF f LESS THAN zero  \n                APPEND uppercase letter L TO result  \n            ELSE  \n                APPEND period character TO result  \n            END IF  \n        END FOR  \n\n        RETURN the CONCATENATION of all elements in result AS a STRING  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "magic-squares-in-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numMagicSquaresInside(grid)  \n        FUNCTION is_magic(i, j)  \n            IF element at position i of grid at position j NOT EQUALS five  \n                RETURN False  \n            END IF  \n            SET numbers TO empty set  \n            FOR x FROM i MINUS one TO i PLUS one  \n                FOR y FROM j MINUS one TO j PLUS one  \n                    IF element at position x of grid at position y LESS THAN one OR element at position x of grid at position y GREATER THAN nine OR element at position x of grid at position y IN numbers  \n                        RETURN False  \n                    END IF  \n                    ADD element at position x of grid at position y TO numbers  \n                END FOR  \n            END FOR  \n            FOR start FROM i MINUS one TO i PLUS one  \n                IF sum of element at position start of grid at position j MINUS one PLUS element at position start of grid at position j PLUS element at position start of grid at position j PLUS one NOT EQUALS fifteen OR sum of element at position i MINUS one of grid at position start PLUS element at position i of grid at position start PLUS element at position i PLUS one of grid at position start NOT EQUALS fifteen  \n                    RETURN False  \n                END IF  \n            END FOR  \n            IF sum of element at position i MINUS one of grid at position j MINUS one PLUS element at position i of grid at position j PLUS element at position i PLUS one of grid at position j PLUS one NOT EQUALS fifteen OR sum of element at position i MINUS one of grid at position j PLUS one PLUS element at position i of grid at position j PLUS element at position i PLUS one of grid at position j MINUS one NOT EQUALS fifteen  \n                RETURN False  \n            END IF  \n            RETURN True  \n        END FUNCTION  \n        SET count TO zero  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        FOR i FROM one TO rows MINUS one  \n            FOR j FROM one TO cols MINUS one  \n                IF is_magic(i, j)  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "keys-and-rooms", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canVisitAllRooms(rooms)  \n        SET visited TO empty set  \n        SET stack TO list containing zero  \n        WHILE the LENGTH OF stack GREATER THAN zero  \n            SET current_room TO the last element of stack  \n            REMOVE the last element FROM stack  \n            ADD current_room TO visited  \n            FOR each key IN the element at position current_room of rooms  \n                IF key NOT IN visited  \n                    ADD key TO stack  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the LENGTH OF visited EQUALS the LENGTH OF rooms  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-into-fibonacci-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS the character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE TO the next iteration of the loop  \n                END IF  \n                SET next_num TO the integer value of the substring of num from position start TO position end MINUS one  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at the position LENGTH OF path MINUS one of path PLUS the element at the position LENGTH OF path MINUS two of path  \n                    SET result TO the call of backtrack WITH parameters end AND the concatenation of path AND the list containing next_num  \n                    IF result IS NOT an empty list  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        RETURN the call of backtrack WITH parameters zero AND an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-mountain-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestMountain(arr)  \n        SET n TO the LENGTH OF arr  \n        SET longest TO zero  \n        SET i TO one  \n        WHILE i LESS THAN n MINUS one  \n            IF element at position i MINUS one of arr LESS THAN element at position i of arr AND element at position i of arr GREATER THAN element at position i PLUS one of arr  \n                SET left TO i MINUS one  \n                SET right TO i PLUS one  \n                WHILE left GREATER THAN zero AND element at position left MINUS one of arr LESS THAN element at position left of arr  \n                    DECREMENT left BY one  \n                END WHILE  \n                WHILE right LESS THAN n MINUS one AND element at position right of arr GREATER THAN element at position right PLUS one of arr  \n                    INCREMENT right BY one  \n                END WHILE  \n                IF longest LESS THAN right MINUS left PLUS one  \n                    SET longest TO right MINUS left PLUS one  \n                END IF  \n                SET i TO right  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        RETURN longest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "hand-of-straights", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isNStraightHand(hand, groupSize)  \n        IF the LENGTH OF hand MODULO groupSize NOT EQUALS zero THEN  \n            RETURN false  \n        END IF  \n        SET count TO the FREQUENCY COUNT of each element IN hand  \n        SET unique_cards TO the SORTED LIST OF the UNIQUE ELEMENTS IN count  \n        FOR each card IN unique_cards  \n            IF the VALUE ASSOCIATED WITH card IN count GREATER THAN zero THEN  \n                SET needed TO the VALUE ASSOCIATED WITH card IN count  \n                FOR i FROM zero TO groupSize MINUS one  \n                    IF the VALUE ASSOCIATED WITH the ELEMENT EQUAL TO card PLUS i IN count LESS THAN needed THEN  \n                        RETURN false  \n                    END IF  \n                    SET the VALUE ASSOCIATED WITH the ELEMENT EQUAL TO card PLUS i IN count TO the VALUE ASSOCIATED WITH the ELEMENT EQUAL TO card PLUS i IN count MINUS needed  \n                END FOR  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-visiting-all-nodes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathLength(graph)  \n        IF graph EQUALS empty collection THEN  \n            RETURN zero  \n        END IF  \n      \n        SET n TO the LENGTH OF graph  \n        SET queue TO a new double-ended queue containing pairs of each node in the range from zero TO n MINUS one together with a value obtained by ONE SHIFTED LEFT BY node  \n        SET visited TO a new set containing the same pairs as in queue  \n      \n        SET steps TO zero  \n        SET all_nodes_visited TO ONE SHIFTED LEFT BY n MINUS one  \n      \n        WHILE queue is not empty  \n            SET current_level_size TO the LENGTH OF queue  \n            FOR iteration FROM one TO current_level_size  \n                REMOVE the leftmost element from queue and DESCTRUCTURE INTO current_node and visited_nodes  \n              \n                IF visited_nodes EQUALS all_nodes_visited THEN  \n                    RETURN steps  \n                END IF  \n              \n                FOR each neighbor IN the element at position current_node of graph  \n                    SET next_visited_nodes TO visited_nodes OR ONE SHIFTED LEFT BY neighbor  \n                    SET next_state TO pair of neighbor and next_visited_nodes  \n                  \n                    IF next_state NOT IN visited THEN  \n                        ADD next_state TO visited  \n                        APPEND next_state TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n          \n            INCREMENT steps BY one  \n        END WHILE  \n      \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-distance-to-closest-person", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxDistToClosest(seats)  \n        SET max_distance TO zero  \n        SET start TO zero  \n        SET end TO zero  \n        SET n TO the LENGTH OF seats  \n        \n        WHILE start LESS THAN n AND the element at position start of seats EQUALS zero  \n            INCREMENT start BY one  \n        END WHILE  \n        \n        SET end TO n MINUS one  \n        WHILE end GREATER THAN OR EQUAL TO zero AND the element at position end of seats EQUALS zero  \n            DECREMENT end BY one  \n        END WHILE  \n        \n        IF max_distance LESS THAN start  \n            SET max_distance TO start  \n        END IF  \n        \n        IF max_distance LESS THAN n MINUS end MINUS one  \n            SET max_distance TO n MINUS end MINUS one  \n        END IF  \n        \n        SET current_distance TO zero  \n        FOR i FROM start TO end  \n            IF the element at position i of seats EQUALS zero  \n                INCREMENT current_distance BY one  \n                IF max_distance LESS THAN the integer division of current_distance PLUS one BY two  \n                    SET max_distance TO the integer division of current_distance PLUS one BY two  \n                END IF  \n            ELSE  \n                SET current_distance TO zero  \n            END IF  \n        END FOR  \n        \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rectangleArea(rectangles)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET y_coords TO an empty set  \n        FOR each quadruple x1 y1 x2 y2 IN rectangles  \n            ADD y1 TO y_coords  \n            ADD y2 TO y_coords  \n        END FOR  \n        SET y_coords TO the sorted list of y_coords  \n        SET y_index TO an empty dictionary  \n        FOR each index i AND value y IN the enumeration of y_coords  \n            SET element at position y of y_index TO i  \n        END FOR  \n        SET count TO a list of zeros with the length equal to the length of y_coords  \n        SET events TO an empty list  \n        FOR each quadruple x1 y1 x2 y2 IN rectangles  \n            APPEND a tuple of x1 one y1 y2 TO events  \n            APPEND a tuple of x2 minus one y1 y2 TO events  \n        END FOR  \n        SORT events by the first element of each tuple in ascending order  \n        SET prev_x TO zero  \n        SET area TO zero  \n        FOR each tuple x eventType y1 y2 IN events  \n            SET current_length TO zero  \n            FOR integer i FROM one TO the length of count MINUS one  \n                IF the element at position i MINUS one of count is GREATER THAN zero  \n                    INCREMENT current_length BY the element at position i of y_coords MINUS the element at position i MINUS one of y_coords  \n                END IF  \n            END FOR  \n            INCREMENT area BY current_length MULTIPLIED BY x MINUS prev_x  \n            SET area TO area MODULO MOD  \n            IF eventType EQUALS one  \n                FOR integer i FROM the element at position y1 of y_index TO the element at position y2 MINUS one of y_index  \n                    INCREMENT the element at position i of count BY one  \n                END FOR  \n            ELSE  \n                FOR integer i FROM the element at position y1 of y_index TO the element at position y2 MINUS one of y_index  \n                    DECREMENT the element at position i of count BY one  \n                END FOR  \n            END IF  \n            SET prev_x TO x  \n        END FOR  \n        RETURN area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "loud-and-rich", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION loudAndRich(richer, quiet)  \n        SET graph TO a new default dictionary with list as the default value type  \n        FOR each pair of elements named a and b IN the collection richer  \n            APPEND element a TO the list associated with key b in graph  \n        END FOR  \n        \n        SET n TO the length of the collection quiet  \n        SET answer TO a list of length n filled with minus one values  \n        \n        FUNCTION dfs(person)  \n            IF the element at position person of answer EQUALS minus one THEN  \n                SET the element at position person of answer TO person  \n                FOR each element neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs with argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position of answer at person of quiet THEN  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        \n        FOR index i FROM zero TO n MINUS one  \n            CALL dfs with argument i  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "peak-index-in-a-mountain-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION peakIndexInMountainArray(arr)  \n        SET left TO zero  \n        SET right TO the LENGTH OF arr MINUS one  \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right DIVIDED BY two  \n            IF the element at position mid of arr LESS THAN the element at position mid PLUS one of arr  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "car-fleet", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION carFleet(target position speed)  \n        SET paired_list TO the list of elements obtained by pairing each element at each position in position WITH the element at the corresponding position in speed  \n        SORT paired_list in order from the greatest element of the first component to the smallest element of the first component  \n\n        SET time_to_target TO an empty list  \n        FOR each pair IN paired_list  \n            SET p TO the first component of pair  \n            SET s TO the second component of pair  \n            SET time TO target MINUS p DIVIDED BY s  \n            APPEND time TO time_to_target  \n        END FOR  \n\n        SET fleets TO zero  \n        SET current_max_time TO zero  \n\n        FOR each time IN time_to_target  \n            IF time GREATER THAN current_max_time  \n                INCREMENT fleets BY one  \n                SET current_max_time TO time  \n            END IF  \n        END FOR  \n\n        RETURN fleets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-similar-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kSimilarity(s1 AS string s2 AS string) RETURNS integer  \n        FUNCTION neighbors(s AS string)  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF s AND element at position i of s EQUALS element at position i of s2  \n                INCREMENT i BY one  \n            END WHILE  \n            FOR j FROM i PLUS one TO the LENGTH OF s MINUS one  \n                IF element at position j of s EQUALS element at position i of s2 AND element at position j of s NOT EQUALS element at position j of s2  \n                    YIELD a string formed by concatenating substring from position zero TO position i MINUS one of s PLUS element at position j of s PLUS substring from position i PLUS one TO position j MINUS one of s PLUS element at position i of s PLUS substring from position j PLUS one TO the end of s  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET queue TO a double ended queue containing a tuple of s1 and zero  \n        SET visited TO a set initialized with s1  \n        \n        WHILE queue is not empty  \n            REMOVE the first element from queue and ASSIGN to variables s and swaps  \n            IF s EQUALS s2  \n                RETURN swaps  \n            END IF  \n            FOR each neighbor IN neighbors(s)  \n                IF neighbor NOT IN visited  \n                    ADD neighbor TO visited  \n                    APPEND a tuple of neighbor and swaps PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "score-of-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION scoreOfParentheses(s)  \n        SET stack TO empty list  \n        SET score TO zero  \n        FOR each character IN s  \n            IF character EQUALS opening parenthesis  \n                APPEND score TO stack  \n                SET score TO zero  \n            ELSE  \n                SET score TO element at last position REMOVED FROM stack PLUS one IF score EQUALS zero OTHERWISE two MULTIPLIED BY score  \n            END IF  \n        END FOR  \n        RETURN score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-hire-k-workers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION mincostToHireWorkers(quality, wage, k)  \n        SET workers TO list of pairs of wage element DIVIDED BY quality element AND quality element FOR each element FROM wage and quality collections combined in corresponding order  \n        SORT workers IN ascending order ACCORDING TO the first element of each pair  \n        SET max_heap TO empty collection  \n        SET total_quality TO zero  \n        SET min_cost TO positive infinity  \n        FOR each pair ratio quality_value IN workers  \n            PUSH negative quality_value TO max_heap  \n            INCREMENT total_quality BY quality_value  \n            IF the LENGTH OF max_heap GREATER THAN k THEN  \n                REMOVE element FROM max_heap WHICH IS the smallest element  \n                INCREMENT total_quality BY the removed element  \n            END IF  \n            IF the LENGTH OF max_heap EQUALS k THEN  \n                SET current_cost TO total_quality MULTIPLIED BY ratio  \n                IF current_cost LESS THAN min_cost THEN  \n                    SET min_cost TO current_cost  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN min_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "mirror-reflection", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION mirrorReflection(p INTEGER PARAMETER q INTEGER PARAMETER) RETURNS INTEGER  \n        DEFINE FUNCTION gcd(a INTEGER PARAMETER b INTEGER PARAMETER) RETURNS INTEGER  \n            WHILE b NOT EQUALS zero  \n                SET temporary_variable TO b  \n                SET b TO a MODULO b  \n                SET a TO temporary_variable  \n            END WHILE  \n            RETURN a  \n        END FUNCTION  \n\n        SET lcm TO p MULTIPLIED BY q DIVIDED BY the RESULT OF gcd WITH PARAMETERS p AND q  \n        SET vertical_reflections TO lcm DIVIDED BY p  \n        SET horizontal_reflections TO lcm DIVIDED BY q  \n\n        IF vertical_reflections MODULO two EQUALS zero  \n            RETURN zero  \n        ELSE IF horizontal_reflections MODULO two NOT EQUALS zero  \n            RETURN one  \n        ELSE  \n            RETURN two  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-subarray-with-sum-at-least-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestSubarray(nums, k)  \n        SET prefix_sum TO list containing zero as its only element  \n        FOR each num IN nums  \n            APPEND to prefix_sum the element at position one less than the LENGTH OF prefix_sum PLUS num  \n        END FOR  \n        ASSIGN reference TO empty double ended queue dq  \n        SET min_length TO infinite value  \n        FOR each i and current_sum IN enumeration of prefix_sum  \n            WHILE dq is not empty AND current_sum MINUS element at position element at the front of dq of prefix_sum IS GREATER THAN OR EQUAL TO k  \n                SET min_length TO the smaller value BETWEEN min_length AND i MINUS removed element from the front of dq  \n            END WHILE  \n            WHILE dq is not empty AND current_sum IS LESS THAN OR EQUAL TO element at position element at the back of dq of prefix_sum  \n                REMOVE element from the back of dq  \n            END WHILE  \n            APPEND i TO dq  \n        END FOR  \n        IF min_length IS NOT EQUAL TO infinite value  \n            RETURN min_length  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-to-get-all-keys", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO the list of pairs representing movement right one step left one step down one step and up one step  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO no value assigned  \n        SET num_keys TO zero  \n        FOR i FROM zero TO the value m MINUS one  \n            FOR j FROM zero TO the value n MINUS one  \n                IF element at position i of grid at position j EQUALS the character at sign at symbol  \n                    SET start TO the pair of values i and j  \n                ELSE IF element at position i of grid at position j IS a lowercase letter  \n                    INCREMENT num_keys BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET queue TO a new double ended queue containing the single element of the tuple of value at position zero of start value at position one of start zero zero  \n        SET visited TO a new set containing the single element of the tuple of value at position zero of start value at position one of start zero  \n        WHILE queue is not empty  \n            SET x y keys steps TO the tuple removed from the front of queue  \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid at position ny  \n                    IF cell EQUALS the hash symbol  \n                        CONTINUE to next iteration of FOR loop  \n                    END IF  \n                    IF cell IS an uppercase letter  \n                        SET key_needed TO one SHIFTED LEFT BY the Unicode code point of the lowercase form of cell MINUS the Unicode code point of letter a  \n                        IF the result of keys AND key_needed EQUALS zero  \n                            CONTINUE to next iteration of FOR loop  \n                        END IF  \n                    END IF  \n                    IF cell IS a lowercase letter  \n                        SET new_keys TO the result of keys OR one SHIFTED LEFT BY the Unicode code point of cell MINUS the Unicode code point of letter a  \n                        IF new_keys EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                    IF the tuple nx ny new_keys IS NOT in visited  \n                        ADD the tuple nx ny new_keys TO visited  \n                        APPEND the tuple nx ny new_keys steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reordered-power-of-2", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reorderedPowerOf2(n)  \n        SET power_of_two_sorted_digits TO empty collection of unique tuples  \n        SET power_of_two TO one  \n        WHILE power_of_two LESS THAN OR EQUAL TO ten RAISED TO THE POWER OF nine holds  \n            SET sorted_digits TO the tuple of the digits of power_of_two arranged in ascending order  \n            ADD sorted_digits TO power_of_two_sorted_digits  \n            SET power_of_two TO power_of_two MULTIPLIED BY two  \n        END WHILE  \n        SET sorted_n_digits TO the tuple of the digits of n arranged in ascending order  \n        RETURN whether sorted_n_digits is contained IN power_of_two_sorted_digits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-refueling-stops", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minRefuelStops(target startFuel stations)  \n        SET max_heap TO an empty list  \n        SET current_fuel TO startFuel  \n        SET stops TO zero  \n        APPEND a list containing target and zero TO stations  \n\n        FOR each element IN stations  \n            SET position TO element at position zero of element  \n            SET fuel TO element at position one of element  \n\n            WHILE the LENGTH OF max_heap is greater than zero AND current_fuel LESS THAN position  \n                SET largest_available_fuel TO the element REMOVED FROM max_heap with the greatest value  \n                DECREMENT current_fuel BY negative largest_available_fuel  \n                INCREMENT stops BY one  \n            END WHILE  \n\n            IF current_fuel LESS THAN position  \n                RETURN negative one  \n            END IF  \n\n            ADD negative fuel TO max_heap WITH heap insertion behavior  \n        END FOR  \n\n        RETURN stops  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "length-of-longest-fibonacci-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lenLongestFibSubseq(arr)  \n        SET index TO empty mapping  \n        FOR each position i FROM zero TO the length of arr MINUS one  \n            ASSIGN reference TO i FOR element at position i of arr IN index  \n        END FOR  \n        SET dp TO empty mapping  \n        SET max_length TO zero  \n        \n        FOR each position k FROM zero TO the length of arr MINUS one  \n            FOR each position j FROM zero TO k MINUS one  \n                SET difference TO element at position k of arr MINUS element at position j of arr  \n                SET i TO the value in index for difference OR minus one if not present  \n                IF i GREATER THAN OR EQUAL TO zero AND i LESS THAN j THEN  \n                    SET previous_length TO the value in dp for the pair of i and j OR two if not present  \n                    SET dp value for the pair of j and k TO previous_length PLUS one  \n                    IF dp value for the pair of j and k GREATER THAN max_length THEN  \n                        SET max_length TO dp value for the pair of j and k  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF max_length GREATER THAN OR EQUAL TO three THEN  \n            RETURN max_length  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "walking-robot-simulation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION robotSim(commands, obstacles)  \n        SET directions TO list of pairs of integers representing north as zero one east as one zero south as zero negative one west as negative one zero  \n        SET x TO zero  \n        SET y TO zero  \n        SET dir_index TO zero  \n        SET obstacles_set TO set of tuples created by converting each element of obstacles list to a tuple  \n        SET max_distance TO zero  \n        FOR each command IN commands  \n            IF command EQUALS negative two  \n                SET dir_index TO remainder of dir_index MINUS one DIVIDED BY four  \n            ELSE IF command EQUALS negative one  \n                SET dir_index TO remainder of dir_index PLUS one DIVIDED BY four  \n            ELSE  \n                SET dx TO element at position dir_index of directions list at position zero  \n                SET dy TO element at position dir_index of directions list at position one  \n                FOR step_count FROM one TO command  \n                    SET next_x TO x PLUS dx  \n                    SET next_y TO y PLUS dy  \n                    IF tuple consisting of next_x and next_y IS IN obstacles_set  \n                        BREAK  \n                    END IF  \n                    SET x TO next_x  \n                    SET y TO next_y  \n                END FOR  \n                SET distance_squared TO x MULTIPLIED BY x PLUS y MULTIPLIED BY y  \n                IF distance_squared GREATER THAN max_distance  \n                    SET max_distance TO distance_squared  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "koko-eating-bananas", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minEatingSpeed WITH PARAMETERS piles AND h  \n        FUNCTION canFinish WITH PARAMETER k  \n            SET hours TO zero  \n            FOR each pile IN piles  \n                INCREMENT hours BY the smallest integer greater than or equal to the result of pile DIVIDED BY k  \n            END FOR  \n            RETURN whether hours is LESS THAN OR EQUAL TO h  \n        END FUNCTION  \n\n        SET left TO one  \n        SET right TO the greatest element in piles  \n\n        WHILE left is LESS THAN OR EQUAL TO right  \n            SET mid TO the integer result of left PLUS right DIVIDED BY two  \n            IF canFinish WITH ARGUMENT mid RETURNS true  \n                SET right TO mid MINUS one  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n\n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGame(piles)  \n        FUNCTION dfs(i, j)  \n            IF i GREATER THAN j THEN  \n                RETURN zero  \n            END IF  \n            SET left_choice TO element at position i of piles MINUS dfs(i PLUS one, j)  \n            SET right_choice TO element at position j of piles MINUS dfs(i, j MINUS one)  \n            SET result TO the GREATER OF left_choice AND right_choice  \n            RETURN result  \n        END FUNCTION  \n        SET game_result TO dfs(zero, the LENGTH OF piles MINUS one) GREATER THAN zero  \n        RETURN game_result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "nth-magical-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nthMagicalNumber(n a b)  \n        SET MOD TO one billion PLUS seven  \n        \n        FUNCTION gcd(x y)  \n            WHILE y NOT EQUALS zero  \n                SET temporary TO y  \n                SET y TO x MODULO y  \n                SET x TO temporary  \n            END WHILE  \n            RETURN x  \n        END FUNCTION  \n        \n        FUNCTION lcm(x y)  \n            RETURN x MULTIPLIED BY y DIVIDED BY gcd(x y)  \n        END FUNCTION  \n        \n        SET L TO lcm(a b)  \n        \n        SET left TO one  \n        SET right TO n MULTIPLIED BY the smaller VALUE BETWEEN a AND b  \n        \n        WHILE left LESS THAN right  \n            SET mid TO the INTEGER DIVISION RESULT OF left PLUS right DIVIDED BY two  \n            SET count TO the INTEGER DIVISION RESULT OF mid DIVIDED BY a PLUS the INTEGER DIVISION RESULT OF mid DIVIDED BY b MINUS the INTEGER DIVISION RESULT OF mid DIVIDED BY L  \n            \n            IF count LESS THAN n  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN left MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decoded-string-at-index", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION decodeAtIndex(s, k)  \n        SET length TO zero  \n        FOR each character IN s  \n            IF character IS A DIGIT  \n                SET length TO length MULTIPLIED BY numeric value of character  \n            ELSE  \n                INCREMENT length BY one  \n            END IF  \n        END FOR  \n        FOR each character IN s IN REVERSE ORDER  \n            SET k TO k MODULO length  \n            IF k EQUALS zero AND character IS A LETTER  \n                RETURN character  \n            END IF  \n            IF character IS A DIGIT  \n                SET length TO length DIVIDED BY numeric value of character  \n            ELSE  \n                DECREMENT length BY one  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "boats-to-save-people", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numRescueBoats(people AS List of integers, limit AS integer) RETURNS integer  \n        SORT the list people IN ascending order BY their weights  \n        SET left TO zero  \n        SET right TO the length of people MINUS one  \n        SET boats TO zero  \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            IF the element at position left of people PLUS the element at position right of people IS LESS THAN OR EQUAL TO limit  \n                INCREMENT left BY one  \n            END IF  \n            DECREMENT right BY one  \n            INCREMENT boats BY one  \n        END WHILE  \n        RETURN boats  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reachable-nodes-in-subdivided-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reachableNodes(edges parameter AS List OF List OF Integer, maxMoves parameter AS Integer, n parameter AS Integer) RETURNS Integer  \n        SET graph TO empty mapping FROM integers TO lists  \n        FOR each index FROM zero TO n MINUS one  \n            SET element at position index of graph TO empty list  \n        END FOR  \n        FOR each element consisting of u parameter v parameter cnt parameter IN edges  \n            APPEND pair consisting of v parameter and cnt parameter TO element at position u parameter of graph  \n            APPEND pair consisting of u parameter and cnt parameter TO element at position v parameter of graph  \n        END FOR  \n        SET distances TO list consisting of n repetitions of infinity value  \n        SET element at position zero of distances TO zero  \n        SET priority_queue TO list containing pair consisting of zero and zero  \n        WHILE priority_queue holds  \n            EXTRACT pair consisting of dist parameter and node parameter WITH the smallest first element FROM priority_queue  \n            IF dist parameter GREATER THAN element at position node parameter of distances THEN  \n                CONTINUE to next iteration of loop  \n            END IF  \n            FOR each pair consisting of neighbor parameter and cnt parameter IN element at position node parameter of graph  \n                SET new_dist TO dist parameter PLUS cnt parameter PLUS one  \n                IF new_dist LESS THAN element at position neighbor parameter of distances THEN  \n                    SET element at position neighbor parameter of distances TO new_dist  \n                    INSERT pair consisting of new_dist and neighbor parameter INTO priority_queue maintaining heap property  \n                END IF  \n            END FOR  \n        END WHILE  \n        SET reachable_nodes TO zero  \n        FOR each d parameter IN distances  \n            IF d parameter LESS THAN OR EQUAL TO maxMoves parameter THEN  \n                INCREMENT reachable_nodes BY one  \n            END IF  \n        END FOR  \n        SET used_edges TO empty mapping  \n        FOR each element consisting of u parameter v parameter cnt parameter IN edges  \n            SET moves_u TO maximum of zero and maxMoves parameter MINUS element at position u parameter of distances  \n            SET moves_v TO maximum of zero and maxMoves parameter MINUS element at position v parameter of distances  \n            SET reachable_new_nodes TO minimum of cnt parameter and moves_u PLUS moves_v  \n            INCREMENT reachable_nodes BY reachable_new_nodes  \n            ASSIGN reference in used_edges at key consisting of pair u parameter and v parameter TO reachable_new_nodes  \n        END FOR  \n        RETURN reachable_nodes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "spiral-matrix-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION spiralMatrixIII(rows rStart cols cStart)  \n        SET directions TO list of pairs zero one one zero zero minus one minus one zero  \n        SET direction_index TO zero  \n        SET steps TO zero  \n        SET increment TO zero  \n        SET visited TO empty list  \n        SET x TO rStart  \n        SET y TO cStart  \n        WHILE the LENGTH OF visited LESS THAN rows MULTIPLIED BY cols  \n            IF increment MODULO two EQUALS zero  \n                INCREMENT steps BY one  \n            END IF  \n            FOR each element FROM one TO steps  \n                IF x GREATER THAN OR EQUAL TO zero AND x LESS THAN rows AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN cols  \n                    APPEND list containing x and y TO visited  \n                END IF  \n                SET dx TO element at position direction_index in directions first element  \n                SET dy TO element at position direction_index in directions second element  \n                SET x TO x PLUS dx  \n                SET y TO y PLUS dy  \n            END FOR  \n            SET direction_index TO (direction_index PLUS one) MODULO four  \n            INCREMENT increment BY one  \n        END WHILE  \n        RETURN visited  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-egg-drop", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        SET dp TO a list of zeros with length k PLUS one  \n        SET moves TO zero  \n        WHILE element at position k of dp LESS THAN n holds  \n            INCREMENT moves BY one  \n            FOR eggs FROM k DOWN TO one  \n                SET element at position eggs of dp TO one PLUS element at position eggs MINUS one of dp PLUS element at position eggs of dp  \n            END FOR  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-subsequence-widths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MOD TO one billion PLUS seven  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list of length n FILLED WITH one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO element at position i MINUS one of power MULTIPLIED BY two MODULO MOD  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS element at position i of nums MULTIPLIED BY element at position i of power MINUS element at position n MINUS i MINUS one of power  \n            SET total_sum TO total_sum MODULO MOD  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "orderly-queue", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION orderlyQueue(s k)  \n        IF k GREATER THAN one  \n            RETURN the concatenation of the elements of the string s arranged in ascending lexicographical order  \n        ELSE  \n            SET n TO the LENGTH OF s  \n            SET smallest TO s  \n            FOR i FROM one TO n MINUS one  \n                SET rotated TO the substring from position i TO the end of s CONCATENATED WITH the substring from position zero TO position i MINUS one of s  \n                IF rotated LESS THAN smallest  \n                    SET smallest TO rotated  \n                END IF  \n            END FOR  \n            RETURN smallest  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "numbers-at-most-n-given-digit-set", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION count_numbers_with_length(length)  \n            RETURN the LENGTH OF digits RAISED TO THE POWER OF length  \n        END FUNCTION  \n        \n        FUNCTION count_numbers_up_to_n(n)  \n            SET str_n TO the string representation of n  \n            SET length TO the LENGTH OF str_n  \n            SET count TO zero  \n            \n            FOR l FROM one TO length MINUS one  \n                INCREMENT count BY count_numbers_with_length(l)  \n            END FOR  \n            \n            FOR i FROM zero TO length MINUS one  \n                SET current_digit TO the integer value of the element at position i of str_n  \n                FOR each digit IN digits  \n                    IF the integer value of digit LESS THAN current_digit THEN  \n                        INCREMENT count BY count_numbers_with_length(length MINUS i MINUS one)  \n                    ELSE IF the integer value of digit EQUALS current_digit THEN  \n                        IF i EQUALS length MINUS one THEN  \n                            INCREMENT count BY one  \n                        END IF  \n                    ELSE IF the integer value of digit GREATER THAN current_digit THEN  \n                        BREAK the inner loop  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN count_numbers_up_to_n(n)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-permutations-for-di-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numPermsDISequence(s)  \n        SET MOD TO ten TO THE POWER OF nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        CREATE dp AS a two dimensional list of zeroes with n PLUS one rows and n PLUS one columns  \n        \n        FOR j FROM zero TO n  \n            SET element at position j of row zero of dp TO one  \n        END FOR  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            IF the element at position i MINUS one of s EQUALS the character I THEN  \n                FOR j FROM zero TO n PLUS one MINUS i MINUS one  \n                    SET prefix_sum TO prefix_sum PLUS the element at position j of row i MINUS one of dp MODULO MOD  \n                    SET element at position j of row i of dp TO prefix_sum  \n                END FOR  \n            ELSE  \n                FOR j FROM n MINUS i DOWN TO zero  \n                    SET prefix_sum TO prefix_sum PLUS the element at position j PLUS one of row i MINUS one of dp MODULO MOD  \n                    SET element at position j of row i of dp TO prefix_sum  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        SET result TO the SUM OF the elements at row n of dp MODULO MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-palindromes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION superpalindromesInRange(left right)  \n        FUNCTION is_palindrome(num)  \n            RETURN string representation of num EQUALS string representation of num REVERSED  \n        END FUNCTION  \n        \n        FUNCTION generate_palindromes(limit)  \n            INITIALIZE palindromes AS empty list  \n            FOR i FROM one TO one hundred thousand MINUS one  \n                SET s TO string representation of i  \n                APPEND integer conversion of concatenation of s AND substring of s from position length of s MINUS two DOWN TO zero stepping minus one TO palindromes  \n                APPEND integer conversion of concatenation of s AND string representation of s REVERSED TO palindromes  \n            END FOR  \n            RETURN list of elements of palindromes WHERE element LESS THAN OR EQUAL TO limit  \n        END FUNCTION  \n        \n        SET left TO integer conversion of left  \n        SET right TO integer conversion of right  \n        SET limit TO integer conversion of the value of right RAISED TO THE POWER OF one DIVIDED BY two PLUS one  \n        SET palindromes TO generate_palindromes(limit)  \n        \n        SET count TO zero  \n        FOR each p IN palindromes  \n            SET square TO p MULTIPLIED BY p  \n            IF left LESS THAN OR EQUAL TO square AND square LESS THAN OR EQUAL TO right AND is_palindrome(square)  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-music-playlists", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numMusicPlaylists(n, goal, k)  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE dp AS a two dimensional list with goal PLUS one rows AND n PLUS one columns FILLED WITH zero  \n        SET element at position zero of list at position zero of dp TO one  \n        FOR i FROM one TO goal  \n            FOR j FROM one TO n  \n                ADD TO element at position j of list at position i of dp THE product of element at position j MINUS one of list at position i MINUS one of dp AND the difference of n MINUS j MINUS one  \n                SET element at position j of list at position i of dp TO element at position j of list at position i of dp MODULO MOD  \n                IF j IS GREATER THAN k THEN  \n                    ADD TO element at position j of list at position i of dp THE product of element at position j of list at position i MINUS one of dp AND j MINUS k  \n                    SET element at position j of list at position i of dp TO element at position j of list at position i of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of list at position goal of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-malware-spread", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMalwareSpread(graph, initial)  \n        FUNCTION dfs(node, component)  \n            IF node IS IN visited  \n                RETURN  \n            END IF  \n            APPEND node TO visited  \n            APPEND node TO component  \n            FOR neighbor FROM zero TO LENGTH OF graph MINUS one  \n                IF element at position node of graph at position neighbor EQUALS one AND neighbor IS NOT IN visited  \n                    CALL dfs WITH neighbor AND component  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET visited TO empty set  \n        SET components TO empty list  \n        FOR node FROM zero TO LENGTH OF graph MINUS one  \n            IF node IS NOT IN visited  \n                SET component TO empty set  \n                CALL dfs WITH node AND component  \n                APPEND component TO components  \n            END IF  \n        END FOR  \n\n        SET infected_count TO list of zeros with length LENGTH OF graph  \n        FOR each node IN initial  \n            SET element at position node OF infected_count TO one  \n        END FOR  \n\n        SET component_infected_count TO list of zeros with length LENGTH OF components  \n        FOR each node IN initial  \n            FOR each index i AND element component IN components  \n                IF node IS IN component  \n                    INCREMENT element at position i OF component_infected_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n\n        SET max_saving TO zero  \n        SET best_node TO the minimum value IN initial  \n        FOR each node IN initial  \n            FOR each index i AND element component IN components  \n                IF node IS IN component AND element at position i OF component_infected_count EQUALS one  \n                    SET saving TO the LENGTH OF component  \n                    IF saving GREATER THAN max_saving OR (saving EQUALS max_saving AND node LESS THAN best_node)  \n                        SET max_saving TO saving  \n                        SET best_node TO node  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN best_node  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stamping-the-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION movesToStamp(stamp string, target string) RETURNS list of integers  \n        SET m TO the LENGTH OF stamp  \n        SET n TO the LENGTH OF target  \n        SET indeg TO a list of size n MINUS m PLUS one where each element is m  \n        SET q TO an empty double ended queue  \n        SET g TO a list of size n where each element is an empty list  \n        FOR i FROM zero TO n MINUS m  \n            FOR j FROM zero TO m MINUS one  \n                SET c TO element at position j of stamp  \n                IF element at position i PLUS j of target EQUALS c THEN  \n                    DECREMENT element at position i of indeg BY one  \n                    IF element at position i of indeg EQUALS zero THEN  \n                        APPEND i TO q  \n                    END IF  \n                ELSE  \n                    APPEND i TO element at position i PLUS j of g  \n                END IF  \n            END FOR  \n        END FOR  \n        SET ans TO an empty list  \n        SET vis TO a list of size n where each element is False  \n        WHILE q is not empty  \n            SET i TO the element removed from the left of q  \n            APPEND i TO ans  \n            FOR j FROM zero TO m MINUS one  \n                IF element at position i PLUS j of vis EQUALS False THEN  \n                    SET element at position i PLUS j of vis TO True  \n                    FOR each k IN element at position i PLUS j of g  \n                        DECREMENT element at position k of indeg BY one  \n                        IF element at position k of indeg EQUALS zero THEN  \n                            APPEND k TO q  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n        IF all elements of vis are True THEN  \n            RETURN ans in reverse order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        SET MOD TO ten POWER nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        SET dp TO a list OF zeroes WITH LENGTH n PLUS one  \n        SET the element at position zero of dp TO one  \n        SET last TO an empty mapping  \n        FOR i FROM one TO n  \n            SET char TO the element at position i MINUS one of s  \n            SET the element at position i of dp TO the element at position i MINUS one of dp MULTIPLIED BY two  \n            SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            IF char EXISTS IN the keys OF last  \n                SET the element at position i of dp TO the element at position i of dp MINUS the element at position last at char MINUS one of dp PLUS MOD  \n                SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            END IF  \n            ASSIGN last at char TO i  \n        END FOR  \n        RETURN the element at position n of dp MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tallest-billboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION tallestBillboard(rods)  \n        SET dp TO a dictionary with key zero and value zero  \n        FOR each rod IN rods  \n            SET new_dp TO a copy of dp  \n            FOR each pair of key difference and value y IN dp  \n                SET key to the sum of difference PLUS rod  \n                SET value to the maximum of the element at key of new_dp IF key EXISTS OTHERWISE zero AND y  \n                ASSIGN value TO element at key of new_dp  \n                SET absolute_difference TO difference MINUS rod IF difference GREATER THAN rod OTHERWISE rod MINUS difference  \n                SET key to absolute_difference  \n                SET value to the maximum of the element at key of new_dp IF key EXISTS OTHERWISE zero AND y PLUS the minimum of difference AND rod  \n                ASSIGN value TO element at key of new_dp  \n            END FOR  \n            ASSIGN new_dp TO dp  \n        END FOR  \n        RETURN the element at key zero of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-columns-to-make-sorted-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDeletionSize(strs)  \n        SET m TO the LENGTH OF strs  \n        SET n TO the LENGTH OF element at position zero of strs  \n        SET dp TO a list of length n with each element SET TO one  \n        FOR i FROM one TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF for every k FROM zero TO m MINUS one the element at position k of strs at position j is LESS THAN OR EQUAL TO the element at position k of strs at position i  \n                    SET dp at position i TO the greater value BETWEEN dp at position i AND dp at position j PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN n MINUS the greatest value in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "least-operators-to-express-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION leastOpsExpressTarget(x, target)  \n        FUNCTION dp(target_inner)  \n            IF target_inner EQUALS zero  \n                RETURN negative one  \n            END IF  \n            \n            IF target_inner LESS THAN x  \n                RETURN the minimum BETWEEN the expression two MULTIPLIED BY target_inner MINUS one AND the expression two MULTIPLIED BY the difference BETWEEN x MINUS target_inner  \n            END IF  \n            \n            SET power TO one  \n            WHILE x RAISED TO power IS LESS THAN OR EQUAL TO target_inner  \n                INCREMENT power BY one  \n            END WHILE  \n            DECREMENT power BY one  \n            \n            SET result TO the value returned BY dp WITH the argument target_inner MINUS x RAISED TO power PLUS power  \n            \n            IF the expression x RAISED TO the sum OF power PLUS one MINUS target_inner IS LESS THAN target_inner  \n                SET result TO the minimum BETWEEN result AND the value returned BY dp WITH the argument x RAISED TO the sum OF power PLUS one MINUS target_inner PLUS power PLUS one  \n            END IF  \n            \n            RETURN result  \n        END FUNCTION  \n        \n        RETURN the value returned BY dp WITH the argument target  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-rational-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean  \n        SET ratios TO a list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number  \n            IF position of opening parenthesis in s EQUALS negative one  \n                RETURN the conversion of s TO a floating point number  \n            END IF  \n\n            SET leftParenIndex TO position of opening parenthesis in s  \n            SET rightParenIndex TO position of closing parenthesis in s  \n            SET dotIndex TO position of decimal point in s  \n\n            SET integerAndNonRepeating TO the conversion TO floating point number OF the substring of s from the start TO the position leftParenIndex minus one  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the conversion TO integer OF the substring of s from position leftParenIndex PLUS one TO position rightParenIndex MINUS one  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY the number one DIVIDED BY ten RAISED TO the power of nonRepeatingLength MULTIPLIED BY element at position repeatingLength OF the list ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of valueOf of s MINUS valueOf of t LESS THAN one DIVIDED BY ten RAISED TO the power of nine  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION uniquePathsIII(grid)  \n        FUNCTION dfs(x, y, steps)  \n            IF element at position x of grid at position y EQUALS two THEN  \n                RETURN steps EQUALS zero  \n            END IF  \n            SET original TO element at position x of grid at position y  \n            SET element at position x of grid at position y TO negative two  \n            SET count TO zero  \n            FOR each pair dx and dy IN collection of pairs consisting of negative one and zero, one and zero, zero and negative one, zero and one  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of grid at position ny GREATER THAN OR EQUAL TO zero THEN  \n                    INCREMENT count BY result of calling dfs with nx ny steps MINUS one  \n                END IF  \n            END FOR  \n            SET element at position x of grid at position y TO original  \n            RETURN count  \n        END FUNCTION  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start_x TO zero  \n        SET start_y TO zero  \n        SET empty_squares TO one  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid at position j EQUALS one THEN  \n                    SET start_x TO i  \n                    SET start_y TO j  \n                ELSE IF element at position i of grid at position j EQUALS zero THEN  \n                    INCREMENT empty_squares BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN result of calling dfs with start_x start_y empty_squares  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "triples-with-bitwise-and-equal-to-zero", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        SET pair_and_count TO a new default dictionary of integers  \n        FOR each element i IN nums  \n            FOR each element j IN nums  \n                SET current_key TO the bitwise AND of i AND j  \n                INCREMENT the value at current_key in pair_and_count BY one  \n            END FOR  \n        END FOR  \n        SET triplet_count TO zero  \n        FOR each element k IN nums  \n            FOR each key pair_and and associated count IN pair_and_count items  \n                IF the bitwise AND of pair_and AND k EQUALS zero THEN  \n                    INCREMENT triplet_count BY count  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN triplet_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subarrays-with-k-different-integers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subarraysWithKDistinct(nums AS list OF integer, k AS integer) RETURNS integer  \n        FUNCTION atMostKDistinct(t AS integer) RETURNS integer  \n            SET count TO an empty mapping with default integer zero  \n            SET left TO zero  \n            SET result TO zero  \n            FOR each right FROM zero TO the length of nums MINUS one  \n                INCREMENT the value in count for the element at position right of nums BY one  \n                WHILE the number of keys in count IS GREATER THAN t  \n                    DECREMENT the value in count for the element at position left of nums BY one  \n                    IF the value in count for the element at position left of nums EQUALS zero  \n                        REMOVE the element at position left of nums FROM count  \n                    END IF  \n                    INCREMENT left BY one  \n                END WHILE  \n                INCREMENT result BY right MINUS left PLUS one  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        RETURN the result of atMostKDistinct with parameter k MINUS the result of atMostKDistinct with parameter k MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-k-consecutive-bit-flips", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minKBitFlips(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET flip_count TO zero  \n        SET flipped TO a list of zeros of LENGTH n PLUS one  \n        SET flip_state TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET flip_state TO flip_state XOR element at position i of flipped  \n            \n            IF element at position i of nums EQUALS flip_state  \n                IF i PLUS k GREATER THAN n  \n                    RETURN negative one  \n                END IF  \n                SET flip_state TO flip_state XOR one  \n                SET element at position i PLUS k of flipped TO element at position i PLUS k of flipped XOR one  \n                INCREMENT flip_count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN flip_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-squareful-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSquarefulPerms(nums)  \n        FUNCTION is_square(n)  \n            RETURN integer part of the square root of n MULTIPLIED BY integer part of the square root of n EQUALS n  \n        END FUNCTION  \n        \n        FUNCTION backtrack(path, count)  \n            IF the LENGTH OF path EQUALS the LENGTH OF nums  \n                RETURN one  \n            END IF  \n            \n            SET ans TO zero  \n            FOR each element x IN count  \n                IF the value at x in count GREATER THAN zero AND (the LENGTH OF path EQUALS zero OR is_square(the element at the last position of path PLUS x))  \n                    DECREMENT the value at x in count BY one  \n                    INCREMENT ans BY backtrack(the concatenation of path AND the list containing x, count)  \n                    INCREMENT the value at x in count BY one  \n                END IF  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        \n        SET count TO the frequency count of elements in nums  \n        RETURN backtrack(empty list, count)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "grid-illumination", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION gridIllumination(n, lamps, queries)  \n        SET row_count TO an empty dictionary with default integer zero  \n        SET col_count TO an empty dictionary with default integer zero  \n        SET diag_count TO an empty dictionary with default integer zero  \n        SET anti_diag_count TO an empty dictionary with default integer zero  \n        SET lamp_positions TO an empty set  \n        \n        FOR each pair r c IN the elements of lamps  \n            IF the tuple of r and c is not in lamp_positions  \n                ADD the tuple of r and c TO lamp_positions  \n                INCREMENT the value at key r in row_count BY one  \n                INCREMENT the value at key c in col_count BY one  \n                INCREMENT the value at key the subtraction of c from r in diag_count BY one  \n                INCREMENT the value at key the sum of r and c in anti_diag_count BY one  \n            END IF  \n        END FOR  \n        \n        SET directions TO the list of pairs negative one negative one negative one zero negative one one zero negative one zero zero zero zero one one negative one one zero one one one  \n        \n        SET result TO an empty list  \n        \n        FOR each pair r c IN the elements of queries  \n            IF the value at key r in row_count is greater than zero OR the value at key c in col_count is greater than zero OR the value at key the subtraction of c from r in diag_count is greater than zero OR the value at key the sum of r and c in anti_diag_count is greater than zero  \n                APPEND one TO result  \n            ELSE  \n                APPEND zero TO result  \n            END IF  \n            \n            FOR each pair dr dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF the tuple of nr and nc is in lamp_positions  \n                    REMOVE the tuple of nr and nc FROM lamp_positions  \n                    DECREMENT the value at key nr in row_count BY one  \n                    DECREMENT the value at key nc in col_count BY one  \n                    DECREMENT the value at key the subtraction of nc from nr in diag_count BY one  \n                    DECREMENT the value at key the sum of nr and nc in anti_diag_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "numbers-with-repeated-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDupDigitsAtMostN(n)  \n        FUNCTION count_unique_digits(x)  \n            SET s TO the string representation of x  \n            SET length TO the length of s  \n            SET count TO zero  \n            FOR i FROM one TO length MINUS one  \n                INCREMENT count BY nine MULTIPLIED BY perm of nine MINUS one PLUS one MINUS i  \n            END FOR  \n            SET seen TO an empty set  \n            SET i TO zero  \n            WHILE i LESS THAN length  \n                SET digit TO the element at position i of s converted to integer  \n                SET start_value TO zero  \n                IF i EQUALS zero  \n                    SET start_value TO one  \n                END IF  \n                FOR d FROM start_value TO digit MINUS one  \n                    IF d NOT IN seen  \n                        INCREMENT count BY perm of nine MINUS i AND length MINUS i MINUS one  \n                    END IF  \n                END FOR  \n                IF digit IN seen  \n                    BREAK the loop  \n                END IF  \n                ADD digit TO seen  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i EQUALS length  \n                INCREMENT count BY one  \n            END IF  \n            RETURN count  \n        END FUNCTION  \n        RETURN n MINUS count_unique_digits of n  \n    END FUNCTION  \n\n    FUNCTION perm(m, n)  \n        IF n EQUALS zero  \n            RETURN one  \n        END IF  \n        SET result TO one  \n        FOR i FROM zero TO n MINUS one  \n            SET result TO result MULTIPLIED BY m MINUS i  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-a-large-maze", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isEscapePossible(blocked, source, target)  \n        IF blocked EQUALS empty THEN  \n            RETURN True  \n        END IF  \n\n        SET blocked_set TO set of tuples converted from each block in blocked  \n        SET n TO the LENGTH OF blocked  \n        SET max_steps TO n MULTIPLIED BY n MINUS one DIVIDED BY two  \n\n        FUNCTION bfs(start, end)  \n            SET queue TO a double ended queue initialized with the tuple converted from start  \n            SET visited TO a set initialized with the elements of queue  \n\n            WHILE the LENGTH OF queue GREATER THAN zero  \n                SET x, y TO the elements taken from the left end of queue  \n\n                IF the LENGTH OF visited GREATER THAN max_steps OR x EQUALS the element at position zero of end AND y EQUALS the element at position one of end THEN  \n                    RETURN True  \n                END IF  \n\n                FOR each pair dx, dy IN the list containing the pairs zero and one zero and zero and minus one and one and zero and minus one and zero  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n\n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN ten TO THE POWER OF six AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN ten TO THE POWER OF six AND the tuple nx and ny NOT IN blocked_set AND the tuple nx and ny NOT IN visited THEN  \n                        ADD the tuple nx and ny TO visited  \n                        APPEND the tuple nx and ny TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n\n            RETURN False  \n        END FUNCTION  \n\n        RETURN the result of bfs with arguments source and target AND the result of bfs with arguments target and source  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-duplicate-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestDupSubstring(s)  \n        FUNCTION search(length)  \n            SET seen TO an empty set  \n            FOR i FROM zero TO the LENGTH OF s MINUS length PLUS one  \n                SET substring TO the substring from position i TO position i PLUS length MINUS one of s  \n                IF substring IS IN seen  \n                    RETURN substring  \n                END IF  \n                ADD substring TO seen  \n            END FOR  \n            RETURN an empty string  \n        END FUNCTION  \n        \n        SET left TO one  \n        SET right TO the LENGTH OF s MINUS one  \n        SET longest TO an empty string  \n        \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            SET mid TO the INTEGER DIVISION OF left PLUS right BY two  \n            SET candidate TO the RESULT OF search WITH PARAMETER mid  \n            IF candidate IS NOT an empty string  \n                SET longest TO candidate  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        RETURN longest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-valid-subarrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validSubarrays(nums)  \n        SET stack TO empty list  \n        SET count TO zero  \n        FOR each num IN nums  \n            WHILE the LENGTH OF stack is greater than zero AND element at the last position of stack GREATER THAN num  \n                REMOVE element at the last position FROM stack  \n            END WHILE  \n            APPEND num TO stack  \n            INCREMENT count BY the LENGTH OF stack  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "digit-count-in-range", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION digitsCount(d, low, high)  \n        FUNCTION count_digit(n, digit)  \n            SET count TO zero  \n            SET power_of_10 TO one  \n            SET current TO n  \n            WHILE current GREATER THAN zero  \n                SET last TO element at position current MODULO ten of the sequence of digits counting from zero  \n                SET current TO current DIVIDED BY ten with integer division  \n                SET full_cycles TO current  \n                IF digit EQUALS zero  \n                    SET full_cycles TO full_cycles MINUS one  \n                END IF  \n                INCREMENT count BY full_cycles MULTIPLIED BY power_of_10  \n                IF last GREATER THAN digit  \n                    INCREMENT count BY power_of_10  \n                ELSE IF last EQUALS digit  \n                    INCREMENT count BY n MODULO power_of_10 PLUS one  \n                END IF  \n                SET power_of_10 TO power_of_10 MULTIPLIED BY ten  \n            END WHILE  \n            RETURN count  \n        END FUNCTION  \n        RETURN count_digit(high, d) MINUS count_digit(low MINUS one, d)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-submatrices-that-sum-to-target", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSubmatrixSumTarget(matrix parameter, target parameter) RETURNS integer  \n        FUNCTION subarraySum(nums parameter, target parameter) RETURNS integer  \n            SET count TO zero  \n            SET seen_sums TO empty mapping from integer TO integer  \n            SET cumulative_sum TO zero  \n            FOR each num IN nums parameter  \n                SET cumulative_sum TO cumulative_sum PLUS num  \n                IF cumulative_sum EQUALS target parameter  \n                    INCREMENT count BY one  \n                END IF  \n                IF cumulative_sum MINUS target parameter IS A KEY IN seen_sums  \n                    INCREMENT count BY the value ASSOCIATED TO cumulative_sum MINUS target parameter IN seen_sums  \n                END IF  \n                INCREMENT the value ASSOCIATED TO cumulative_sum IN seen_sums BY one  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        SET rows TO the number OF elements IN matrix parameter  \n        SET cols TO the number OF elements IN element at position zero of matrix parameter  \n        SET total_count TO zero  \n        \n        FOR top FROM zero TO rows MINUS one  \n            SET current_cols TO a list OF cols elements each initialized TO zero  \n            FOR bottom FROM top TO rows MINUS one  \n                FOR col FROM zero TO cols MINUS one  \n                    SET element at position col of current_cols TO element at position col of current_cols PLUS element at position bottom of matrix parameter at position col  \n                END FOR  \n                SET total_count TO total_count PLUS subarraySum(current_cols, target parameter)  \n            END FOR  \n        END FOR  \n        \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "confusing-number-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION confusingNumberII(n)  \n        SET rotate_map TO mapping of digit zero TO zero digit one TO one digit six TO nine digit eight TO eight digit nine TO six  \n        SET valid_digits TO list of digit zero digit one digit six digit eight digit nine  \n        \n        FUNCTION is_confusing(num)  \n            SET original_num TO num  \n            SET rotated_num TO zero  \n            WHILE num GREATER THAN zero holds  \n                SET digit TO remainder of num DIVIDED BY ten  \n                SET rotated_num TO rotated_num MULTIPLIED BY ten PLUS value at key digit of rotate_map  \n                SET num TO quotient of num DIVIDED BY ten  \n            END WHILE  \n            RETURN whether rotated_num is NOT EQUALS TO original_num  \n        END FUNCTION  \n        \n        FUNCTION count_confusing_numbers(limit current)  \n            IF current GREATER THAN limit THEN  \n                RETURN zero  \n            END IF  \n            SET count TO one IF current IS NOT EQUALS TO zero AND is_confusing(current) IS true OTHERWISE zero  \n            FOR each digit IN valid_digits  \n                SET new_number TO current MULTIPLIED BY ten PLUS digit  \n                IF new_number IS EQUALS TO zero THEN  \n                    CONTINUE TO next digit  \n                END IF  \n                INCREMENT count BY count_confusing_numbers(limit new_number)  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN count_confusing_numbers(n zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parsing-a-boolean-expression", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each c IN expression  \n            IF c EQUALS character representing true OR c EQUALS character representing false OR c EQUALS character representing not OR c EQUALS character representing and OR c EQUALS character representing or  \n                APPEND c TO stk  \n            ELSE IF c EQUALS character representing closing parenthesis  \n                SET count_true TO zero  \n                SET count_false TO zero  \n                WHILE the element at the last position of stk EQUALS character representing true OR the element at the last position of stk EQUALS character representing false  \n                    IF the element at the last position of stk EQUALS character representing true  \n                        INCREMENT count_true BY one  \n                    END IF  \n                    IF the element at the last position of stk EQUALS character representing false  \n                        INCREMENT count_false BY one  \n                    END IF  \n                    REMOVE the element at the last position FROM stk  \n                END WHILE  \n                SET op TO the element at the last position of stk  \n                REMOVE the element at the last position FROM stk  \n                IF op EQUALS character representing not  \n                    IF count_false GREATER THAN zero  \n                        SET c TO character representing true  \n                    ELSE  \n                        SET c TO character representing false  \n                    END IF  \n                ELSE IF op EQUALS character representing and  \n                    IF count_false GREATER THAN zero  \n                        SET c TO character representing false  \n                    ELSE  \n                        SET c TO character representing true  \n                    END IF  \n                ELSE IF op EQUALS character representing or  \n                    IF count_true GREATER THAN zero  \n                        SET c TO character representing true  \n                    ELSE  \n                        SET c TO character representing false  \n                    END IF  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stk EQUALS character representing true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "divide-array-into-increasing-sequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canDivideIntoSubsequences(nums k)  \n        SET freq TO the frequency count of each element in nums  \n        SET max_freq TO the maximum value among the frequency counts in freq  \n        IF the length of nums DIVIDED BY k IS GREATER THAN OR EQUAL TO max_freq  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-chunked-palindrome-decomposition", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestDecomposition(text)  \n        SET left TO zero  \n        SET right TO the LENGTH OF text MINUS one  \n        SET left_part TO empty string  \n        SET right_part TO empty string  \n        SET k TO zero  \n        \n        WHILE left IS LESS THAN right  \n            SET left_part TO left_part PLUS the element at position left of text  \n            SET right_part TO the element at position right of text PLUS right_part  \n            \n            IF left_part EQUALS right_part  \n                INCREMENT k BY two  \n                SET left_part TO empty string  \n                SET right_part TO empty string  \n            END IF  \n            \n            INCREMENT left BY one  \n            DECREMENT right BY one  \n        END WHILE  \n        \n        IF left_part IS NOT empty string OR left EQUALS right  \n            INCREMENT k BY one  \n        END IF  \n        \n        RETURN k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-transforms-into-another-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO an empty mapping from characters to characters  \n        FOR each pair of characters char1 and char2 FROM str1 AND str2 in order  \n            IF char1 IS IN conversion_map  \n                IF the value mapped from char1 in conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET the value mapped from char1 in conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the number of unique characters IN str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "last-substring-in-lexicographical-order", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "optimize-water-distribution-in-a-village", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCostToSupplyWater(n, wells, pipes)  \n        FOR index FROM zero TO n MINUS one  \n            APPEND list containing zero AND index PLUS one AND element at position index of wells TO pipes  \n        END FOR  \n        SORT pipes BASED ON the third element of each item IN ascending order  \n        SET parent TO list of integers FROM zero TO n  \n        FUNCTION find(x)  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO result of find WITH argument element at position x of parent  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n        FUNCTION union(x, y)  \n            SET rootX TO result of find WITH argument x  \n            SET rootY TO result of find WITH argument y  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootX of parent TO rootY  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n        SET min_cost TO zero  \n        FOR each element IN pipes  \n            LET house1 BE first element of current element  \n            LET house2 BE second element of current element  \n            LET cost BE third element of current element  \n            IF union WITH arguments house1 AND house2 RETURNS True  \n                INCREMENT min_cost BY cost  \n            END IF  \n        END FOR  \n        RETURN min_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ones", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumNumberOfOnes(width parameter, height parameter, sideLength parameter, maxOnes parameter)  \n        SET freq TO list of zeros with length equal to sideLength MULTIPLIED BY sideLength  \n        FOR i FROM zero TO width MINUS one  \n            FOR j FROM zero TO height MINUS one  \n                SET pos TO the remainder of i DIVIDED BY sideLength MULTIPLIED BY sideLength PLUS the remainder of j DIVIDED BY sideLength  \n                INCREMENT element at position pos of freq BY one  \n            END FOR  \n        END FOR  \n        SORT freq IN descending order  \n        SET total TO zero  \n        FOR index FROM zero TO maxOnes MINUS one  \n            INCREMENT total BY element at position index of freq  \n        END FOR  \n        RETURN total  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "make-array-strictly-increasing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION makeArrayIncreasing(arr1, arr2)  \n        CALL sort arr2 in ascending order  \n        SET dp TO a dictionary with key negative one and value zero  \n        \n        FOR each num IN arr1  \n            SET new_dp TO an empty dictionary  \n            \n            FOR each last_num and ops IN items of dp  \n                IF num GREATER THAN last_num  \n                    SET the value at key num in new_dp TO the minimum value between the current value at key num in new_dp or infinity AND ops  \n                END IF  \n                \n                SET idx TO the position to insert last_num in arr2 to keep arr2 sorted on the right side  \n                IF idx LESS THAN the length of arr2  \n                    SET the value at key element at position idx of arr2 in new_dp TO the minimum value between the current value at that key in new_dp or infinity AND ops PLUS one  \n                END IF  \n            END FOR  \n            \n            IF new_dp is empty  \n                RETURN negative one  \n            END IF  \n            \n            SET dp TO new_dp  \n        END FOR  \n        \n        RETURN the minimum value among all values in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "critical-connections-in-a-network", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION criticalConnections(n, connections)  \n        FUNCTION dfs(node, parent, disc, low, time, graph, critical)  \n            SET element at position node of disc TO element at position zero of time  \n            SET element at position node of low TO element at position zero of time  \n            INCREMENT element at position zero of time BY one  \n            \n            FOR each neighbor IN element at position node of graph  \n                IF element at position neighbor of disc EQUALS negative one THEN  \n                    CALL dfs WITH arguments neighbor parent disc low time graph critical  \n                    SET element at position node of low TO the smaller value BETWEEN element at position node of low AND element at position neighbor of low  \n                    IF element at position neighbor of low GREATER THAN element at position node of disc THEN  \n                        APPEND list containing node AND neighbor TO critical  \n                    END IF  \n                ELSE IF neighbor NOT EQUALS parent THEN  \n                    SET element at position node of low TO the smaller value BETWEEN element at position node of low AND element at position neighbor of disc  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET graph TO new empty list of empty lists repeated n times  \n        FOR each pair u AND v IN connections  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n        \n        SET disc TO new list of negative one repeated n times  \n        SET low TO new list of negative one repeated n times  \n        SET time TO list containing zero  \n        \n        SET critical TO new empty list  \n        \n        FOR each node FROM zero TO n MINUS one  \n            IF element at position node of disc EQUALS negative one THEN  \n                CALL dfs WITH arguments node negative one disc low time graph critical  \n            END IF  \n        END FOR  \n        \n        RETURN critical  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-build-blocks", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minBuildTime WITH parameters blocks AND split  \n        CALL heapify TO transform blocks INTO a heap structure  \n        WHILE the LENGTH OF blocks IS GREATER THAN one  \n            SET first TO the element removed from blocks with the smallest value  \n            SET second TO the element removed from blocks with the smallest value  \n            SET combined_time TO split PLUS second  \n            INSERT combined_time INTO blocks maintaining heap property  \n        END WHILE  \n        RETURN the element at position zero of blocks  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-items-by-groups-respecting-dependencies", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sortItems(n, m, group, beforeItems)  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of group EQUALS minus one  \n                SET element at position i of group TO m  \n                INCREMENT m BY one  \n            END IF  \n        END FOR  \n        \n        SET group_items TO a mapping from keys to empty lists  \n        SET group_graph TO a mapping from keys to empty lists  \n        SET item_graph TO a mapping from keys to empty lists  \n        SET item_in_degree TO a list consisting of zero repeated n times  \n        SET group_in_degree TO a list consisting of zero repeated m times  \n        \n        FOR i FROM zero TO n MINUS one  \n            APPEND i TO list at key element at position i of group in group_items  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR each before_element IN element at position i of beforeItems  \n                IF element at position before_element of group EQUALS element at position i of group  \n                    APPEND i TO list at key before_element in item_graph  \n                    INCREMENT element at position i of item_in_degree BY one  \n                ELSE  \n                    APPEND element at position i of group TO list at key element at position before_element of group in group_graph  \n                    INCREMENT element at position element at position i of group of group_in_degree BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION topological_sort(graph, in_degree, items)  \n            SET queue TO a double-ended queue initialized with elements from items WHERE element at position element of in_degree EQUALS zero  \n            SET result TO empty list  \n            \n            WHILE queue is not empty  \n                REMOVE element from front of queue and assign to u  \n                APPEND u TO result  \n                FOR each v IN list at key u in graph  \n                    DECREMENT element at position v of in_degree BY one  \n                    IF element at position v of in_degree EQUALS zero  \n                        APPEND v TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            IF LENGTH OF result EQUALS LENGTH OF items  \n                RETURN result  \n            ELSE  \n                RETURN empty list  \n            END IF  \n        END FUNCTION  \n        \n        SET sorted_within_groups TO empty list  \n        FOR each items_list IN all values of group_items  \n            SET sorted_items TO topological_sort(item_graph, item_in_degree, items_list)  \n            IF LENGTH OF sorted_items EQUALS zero  \n                RETURN empty list  \n            END IF  \n            EXTEND sorted_within_groups BY sorted_items  \n        END FOR  \n        \n        SET sorted_groups TO topological_sort(group_graph, group_in_degree, list of elements from zero TO m MINUS one)  \n        IF LENGTH OF sorted_groups EQUALS zero  \n            RETURN empty list  \n        END IF  \n        \n        SET group_to_items_map TO a mapping from keys to empty lists  \n        FOR each item IN sorted_within_groups  \n            APPEND item TO list at key element at position item of group in group_to_items_map  \n        END FOR  \n        \n        SET result TO empty list  \n        FOR each grp IN sorted_groups  \n            EXTEND result BY list at key grp in group_to_items_map  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-reach-target-with-rotations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumMoves(grid)  \n        SET n TO the LENGTH OF grid  \n        SET queue TO a new empty double ended queue with the single element consisting of the values zero zero zero one zero  \n        SET visited TO a new empty set containing the single tuple of values zero zero zero one  \n        \n        WHILE the queue is not empty  \n            REMOVE and RETURN the first element of queue and ASSIGN the resulting five values to r1 c1 r2 c2 steps  \n            \n            IF the value of r1 EQUALS the value of n MINUS one AND the value of c1 EQUALS the value of n MINUS two AND the value of r2 EQUALS the value of n MINUS one AND the value of c2 EQUALS the value of n MINUS one THEN  \n                RETURN steps  \n            END IF  \n            \n            IF the value of c2 PLUS one LESS THAN n AND the element at position r1 of grid at position c1 PLUS one EQUALS zero AND the element at position r2 of grid at position c2 PLUS one EQUALS zero AND the tuple of values r1 c1 PLUS one r2 c2 PLUS one NOT IN visited THEN  \n                ADD the tuple of values r1 c1 PLUS one r2 c2 PLUS one TO visited  \n                APPEND the tuple of values r1 c1 PLUS one r2 c2 PLUS one steps PLUS one TO queue  \n            END IF  \n            \n            IF the value of r2 PLUS one LESS THAN n AND the element at position r1 PLUS one of grid at position c1 EQUALS zero AND the element at position r2 PLUS one of grid at position c2 EQUALS zero AND the tuple of values r1 PLUS one c1 r2 PLUS one c2 NOT IN visited THEN  \n                ADD the tuple of values r1 PLUS one c1 r2 PLUS one c2 TO visited  \n                APPEND the tuple of values r1 PLUS one c1 r2 PLUS one c2 steps PLUS one TO queue  \n            END IF  \n            \n            IF the value of r1 EQUALS the value of r2 AND the value of r1 PLUS one LESS THAN n AND the element at position r1 PLUS one of grid at position c1 EQUALS zero AND the element at position r1 PLUS one of grid at position c2 EQUALS zero AND the tuple of values r1 c1 r1 PLUS one c1 NOT IN visited THEN  \n                ADD the tuple of values r1 c1 r1 PLUS one c1 TO visited  \n                APPEND the tuple of values r1 c1 r1 PLUS one c1 steps PLUS one TO queue  \n            END IF  \n            \n            IF the value of c1 EQUALS the value of c2 AND the value of c1 PLUS one LESS THAN n AND the element at position r1 of grid at position c1 PLUS one EQUALS zero AND the element at position r2 of grid at position c2 PLUS one EQUALS zero AND the tuple of values r1 c1 r1 c1 PLUS one NOT IN visited THEN  \n                ADD the tuple of values r1 c1 r1 c1 PLUS one TO visited  \n                APPEND the tuple of values r1 c1 r1 c1 PLUS one steps PLUS one TO queue  \n            END IF  \n        END WHILE  \n        \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-palindrome-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isValidPalindrome(s, k)  \n        FUNCTION longest_palindromic_subseq(s)  \n            SET n TO the LENGTH OF s  \n            SET dp TO a two dimensional list of size n by n FILLED WITH zero  \n            \n            FOR index i FROM zero TO n MINUS one  \n                SET element at position i at position i of dp TO one  \n            END FOR  \n            \n            FOR length FROM two TO n  \n                FOR index i FROM zero TO n MINUS length  \n                    SET index j TO i PLUS length MINUS one  \n                    IF element at position i of s EQUALS element at position j of s  \n                        SET element at position i at position j of dp TO element at position i PLUS one at position j MINUS one of dp PLUS two  \n                    ELSE  \n                        SET element at position i at position j of dp TO the GREATER OF element at position i PLUS one at position j of dp AND element at position i at position j MINUS one of dp  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN element at position zero at position n MINUS one of dp  \n        END FUNCTION  \n        \n        SET longest_palindrome_length TO longest_palindromic_subseq(s)  \n        RETURN the LENGTH OF s MINUS longest_palindrome_length LESS THAN OR EQUAL TO k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-vowels-permutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each index FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder when a_next is DIVIDED BY MOD  \n            SET e TO the remainder when e_next is DIVIDED BY MOD  \n            SET i TO the remainder when i_next is DIVIDED BY MOD  \n            SET o TO the remainder when o_next is DIVIDED BY MOD  \n            SET u TO the remainder when u_next is DIVIDED BY MOD  \n        END FOR  \n        SET total_count TO the sum of a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO the remainder when total_count is DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dice-roll-simulation", "passing_rate": 1.0, "pseudocode": "CLASS Solution\n    FUNCTION dieSimulator(n, rollMax)\n        SET MOD TO one billion PLUS seven\n\n        SET dp TO a three dimensional list of zeros with dimensions of n PLUS one BY six BY maximum value in rollMax PLUS one\n\n        FOR j FROM zero TO five\n            SET element at position one of list at position j of list at position one of dp TO one\n        END FOR\n\n        FOR i FROM two TO n\n            FOR j FROM zero TO five\n                FOR k FROM one TO element at position j of rollMax\n                    IF k GREATER THAN one\n                        SET element at position k of list at position j of list at position i of dp TO element at position k MINUS one of list at position j of list at position i MINUS one of dp\n                    ELSE\n                        SET total_sum TO zero\n                        FOR x FROM zero TO five\n                            IF x NOT EQUALS j\n                                FOR y FROM one TO element at position x of rollMax\n                                    INCREMENT total_sum BY element at position y of list at position x of list at position i MINUS one of dp\n                                END FOR\n                            END IF\n                        END FOR\n                        SET element at position k of list at position j of list at position i of dp TO total_sum MODULO MOD\n                    END IF\n                END FOR\n            END FOR\n        END FOR\n\n        SET result TO zero\n        FOR j FROM zero TO five\n            FOR k FROM one TO element at position j of rollMax\n                INCREMENT result BY element at position k of list at position j of list at position n of dp\n            END FOR\n        END FOR\n\n        RETURN result MODULO MOD\n    END FUNCTION\nEND CLASS"}
{"task_id": "maximum-equal-frequency", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxEqualFreq(nums)  \n        SET count TO a new empty counter mapping each number to zero  \n        SET freq TO a new empty counter mapping each frequency to zero  \n        SET max_len TO zero  \n        \n        FOR each index i AND element num IN nums with enumeration starting from zero  \n            INCREMENT the value associated with num in count by one  \n            \n            IF the value associated with num in count is GREATER THAN one THEN  \n                DECREMENT the value associated with the value associated with num in count MINUS one in freq by one  \n                IF the value associated with the value associated with num in count MINUS one in freq EQUALS zero THEN  \n                    REMOVE the entry for the value associated with num in count MINUS one FROM freq  \n                END IF  \n            END IF  \n            \n            INCREMENT the value associated with the value associated with num in count in freq by one  \n            \n            IF the number of distinct keys in freq EQUALS one AND (freq has key one OR the single value in freq EQUALS one) THEN  \n                SET max_len TO i PLUS one  \n            ELSE IF the number of distinct keys in freq EQUALS two AND ((freq has key one AND the value for key one in freq EQUALS one) OR (the difference between the maximum key in freq AND the minimum key in freq EQUALS one AND the value for the maximum key in freq EQUALS one)) THEN  \n                SET max_len TO i PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN max_len  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "divide-chocolate", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximizeSweetness(sweetness list OF integer k integer) RETURNS integer  \n        FUNCTION canDivide(min_sweet integer) RETURNS boolean  \n            SET pieces TO zero  \n            SET current_sweet TO zero  \n            FOR each sweet IN sweetness  \n                SET current_sweet TO current_sweet PLUS sweet  \n                IF current_sweet GREATER THAN OR EQUAL TO min_sweet  \n                    INCREMENT pieces BY one  \n                    SET current_sweet TO zero  \n                    IF pieces GREATER THAN k  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN pieces GREATER THAN k  \n        END FUNCTION  \n\n        SET left TO the smallest element IN sweetness  \n        SET right TO the total sum OF all elements IN sweetness DIVIDED BY the value of k PLUS one  \n        SET result TO zero  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the integer value of left PLUS right DIVIDED BY two  \n            IF canDivide(mid) IS True  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-profit-in-job-scheduling", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION jobScheduling(startTime, endTime, profit)  \n        SET jobs TO a list created by combining corresponding elements of startTime endTime and profit into tuples each containing start time end time and profit  \n        SORT jobs by the end time element of each tuple in ascending order  \n        SET end_times TO a list containing the end time element of each job in jobs  \n        SET dp TO a list of zero with the length equal to the length of jobs PLUS one  \n        FOR i FROM one TO the length of jobs inclusive  \n            SET j TO the position where the start time element of the job at position i MINUS one in jobs would be inserted to maintain the order in end_times using binary search to the right  \n            SET dp at position i TO the maximum of dp at position i MINUS one AND the sum of dp at position j AND the profit element of the job at position i MINUS one in jobs  \n        END FOR  \n        RETURN the element of dp at the last position  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tiling-a-rectangle-with-the-fewest-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION tilingRectangle(n parameter, m parameter)  \n        FUNCTION backtrack(heights parameter, moves parameter)  \n            IF all elements of heights ARE EQUAL TO n parameter THEN  \n                SET min_moves TO the smaller value BETWEEN min_moves AND moves parameter  \n                RETURN  \n            END IF  \n            \n            IF moves parameter IS GREATER THAN OR EQUAL TO min_moves THEN  \n                RETURN  \n            END IF  \n            \n            SET min_height TO the smallest value IN heights parameter  \n            SET left TO the position of min_height IN heights parameter  \n            SET right TO left  \n            WHILE right IS LESS THAN m parameter AND element at position right of heights parameter IS EQUAL TO min_height DO  \n                INCREMENT right BY one  \n            END WHILE  \n            \n            FOR size FROM the difference BETWEEN right AND left DOWN TO one DO  \n                IF for every i FROM zero TO size MINUS one the element at position left PLUS i of heights parameter PLUS size IS LESS THAN OR EQUAL TO n parameter THEN  \n                    SET new_heights TO a copy OF heights parameter  \n                    FOR i FROM zero TO size MINUS one DO  \n                        INCREMENT element at position left PLUS i of new_heights BY size  \n                    END FOR  \n                    CALL backtrack WITH new_heights AND moves parameter PLUS one  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET min_moves TO positive infinity  \n        CALL backtrack WITH a list of m parameter zeros AND zero  \n        RETURN min_moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-removal", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumMoves(arr)  \n        SET n TO the LENGTH OF arr  \n        SET dp TO a two dimensional list of zeros with dimensions n BY n  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i AT position i OF dp TO one  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS two  \n            IF element at position i OF arr EQUALS element at position i PLUS one OF arr THEN  \n                SET element at position i AT position i PLUS one OF dp TO one  \n            ELSE  \n                SET element at position i AT position i PLUS one OF dp TO two  \n            END IF  \n        END FOR  \n        \n        FOR length FROM three TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                IF element at position i OF arr EQUALS element at position j OF arr THEN  \n                    SET element at position i AT position j OF dp TO element at position i PLUS one AT position j MINUS one OF dp  \n                ELSE  \n                    SET element at position i AT position j OF dp TO infinity  \n                    FOR k FROM i TO j MINUS one  \n                        SET candidate_value TO element at position i AT position k OF dp PLUS element at position k PLUS one AT position j OF dp  \n                        IF candidate_value LESS THAN element at position i AT position j OF dp THEN  \n                            SET element at position i AT position j OF dp TO candidate_value  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero AT position n MINUS one OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-it-is-a-good-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isGoodArray(nums)  \n        SET total_gcd TO reduce the greatest common divisor FUNCTION over nums  \n        IF total_gcd EQUALS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-move-a-box-to-their-target-location", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minPushBox(grid)  \n        SET directions TO list of pairs consisting of minus one and zero one and zero minus one and zero and zero and one  \n        FOR i FROM zero TO the length of grid MINUS one  \n            FOR j FROM zero TO the length of the element at position zero of grid MINUS one  \n                IF the element at position i of grid AT position j EQUALS uppercase letter S  \n                    SET player_start TO pair consisting of i and j  \n                ELSE IF the element at position i of grid AT position j EQUALS uppercase letter B  \n                    SET box_start TO pair consisting of i and j  \n                ELSE IF the element at position i of grid AT position j EQUALS uppercase letter T  \n                    SET target TO pair consisting of i and j  \n                END IF  \n            END FOR  \n        END FOR  \n        SET queue TO a new deque containing a tuple of player_start box_start and zero  \n        SET visited TO a new empty set  \n        ADD tuple of player_start and box_start TO visited  \n        WHILE the length of queue is greater than zero  \n            SET player_pos box_pos push_count TO the element removed from the left of queue  \n            IF the value of box_pos EQUALS the value of target  \n                RETURN push_count  \n            END IF  \n            FOR each pair dx dy IN directions  \n                SET new_player_pos TO a pair consisting of the first element of player_pos PLUS dx and the second element of player_pos PLUS dy  \n                IF the result of calling is_valid_position with arguments new_player_pos and grid  \n                    IF new_player_pos EQUALS box_pos  \n                        SET new_box_pos TO a pair consisting of the first element of box_pos PLUS dx and the second element of box_pos PLUS dy  \n                        IF the result of calling is_valid_position with arguments new_box_pos and grid AND the tuple of new_player_pos and new_box_pos NOT IN visited  \n                            ADD tuple of new_player_pos and new_box_pos TO visited  \n                            APPEND tuple of new_player_pos new_box_pos push_count PLUS one TO queue  \n                        END IF  \n                    ELSE  \n                        IF the tuple of new_player_pos and box_pos NOT IN visited  \n                            ADD tuple of new_player_pos and box_pos TO visited  \n                            APPEND tuple of new_player_pos box_pos push_count TO queue  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN minus one  \n    END FUNCTION  \n    FUNCTION is_valid_position(position grid)  \n        SET x TO the first element of position  \n        SET y TO the second element of position  \n        RETURN the expression zero LESS THAN OR EQUAL TO x AND x LESS THAN the length of grid AND zero LESS THAN OR EQUAL TO y AND y LESS THAN the length of the element at position zero of grid AND the element at position x of grid AT position y NOT EQUALS the character number sign  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-stay-in-the-same-place-after-some-steps", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numWays(steps arrLen)  \n        SET MOD TO one billion PLUS seven  \n        SET max_index TO the minimum OF steps DIVIDED BY two AND arrLen MINUS one  \n        SET dp TO a list OF zeros WITH length max_index PLUS one  \n        SET element at position zero OF dp TO one  \n        FOR each step IN steps FROM one TO steps  \n            SET prev_dp TO a copy OF dp  \n            FOR i FROM zero TO max_index  \n                SET element at position i OF dp TO element at position i OF prev_dp  \n                IF i GREATER THAN zero  \n                    SET element at position i OF dp TO the sum OF element at position i OF dp PLUS element at position i MINUS one OF prev_dp MODULO MOD  \n                END IF  \n                IF i LESS THAN max_index  \n                    SET element at position i OF dp TO the sum OF element at position i OF dp PLUS element at position i PLUS one OF prev_dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position zero OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION palindromePartition(s, k)  \n        FUNCTION min_changes_to_palindrome(sub)  \n            SET i TO zero  \n            SET j TO the LENGTH OF sub MINUS one  \n            SET changes TO zero  \n            WHILE i LESS THAN j  \n                IF element at position i of sub NOT EQUALS element at position j of sub  \n                    INCREMENT changes BY one  \n                END IF  \n                INCREMENT i BY one  \n                DECREMENT j BY one  \n            END WHILE  \n            RETURN changes  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF s  \n        SET dp TO a two dimensional list where each element is infinity with size n PLUS one BY k PLUS one  \n        SET element at position zero position zero of dp TO zero  \n\n        FOR i FROM one TO n  \n            FOR j FROM one TO the MINIMUM OF k AND i  \n                FOR start FROM zero TO i MINUS one  \n                    SET changes TO min_changes_to_palindrome(substring from position start TO position i MINUS one of s)  \n                    SET element at position i position j of dp TO the MINIMUM OF element at position i position j of dp AND element at position start position j MINUS one of dp PLUS changes  \n                END FOR  \n            END FOR  \n        END FOR  \n\n        RETURN element at position n position k of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minFlips(mat)  \n        FUNCTION flip(matrix x y)  \n            SET directions TO list of pairs of minus one and zero PLUS one and zero PLUS zero and minus one PLUS zero and one PLUS zero and zero  \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n  \n                    SET element at position nx of matrix at position ny TO one MINUS element at position nx of matrix at position ny  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION matrix_to_tuple(matrix)  \n            SET result TO empty tuple  \n            FOR each row IN matrix  \n                APPEND tuple of row TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF element at position zero of mat  \n        SET target TO tuple of tuples of zero repeated n times repeated m times  \n        SET initial_state TO matrix_to_tuple applied to mat  \n        SET queue TO list containing pair initial_state and zero  \n        SET visited TO empty set  \n        ADD initial_state TO visited  \n\n        WHILE the LENGTH OF queue GREATER THAN zero  \n            SET current_state TO element at position zero of element at position zero of queue  \n            SET steps TO element at position one of element at position zero of queue  \n            REMOVE element at position zero FROM queue  \n            IF current_state EQUALS target  \n                RETURN steps  \n            END IF  \n\n            SET current_matrix TO list of lists of each row in current_state  \n\n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    SET next_matrix TO deep copy of current_matrix  \n                    CALL flip with next_matrix i j  \n                    SET next_state TO matrix_to_tuple applied to next_matrix  \n                    IF next_state NOT IN visited  \n                        ADD next_state TO visited  \n                        APPEND pair next_state and steps PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n\n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-in-a-grid-with-obstacles-elimination", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPath(grid, k)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN the negative of one  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF k GREATER THAN OR EQUAL TO m PLUS n MINUS two  \n            RETURN m PLUS n MINUS two  \n        END IF  \n        \n        SET directions TO the list containing the elements: a pair of zero and one, a pair of one and zero, a pair of zero and negative one, a pair of negative one and zero  \n        \n        SET queue TO a double-ended queue initialized with a tuple containing zero zero k zero  \n        \n        SET visited TO a set initialized with the tuple containing zero zero k  \n        \n        WHILE queue is not empty  \n            SET x y remaining_k steps TO the first element removed from the left of queue  \n            \n            IF x EQUALS m MINUS one AND y EQUALS n MINUS one  \n                RETURN steps  \n            END IF  \n            \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n  \n                    SET new_k TO remaining_k MINUS element at position nx of grid at position ny  \n                    IF new_k GREATER THAN OR EQUAL TO zero AND the tuple containing nx ny new_k NOT IN visited  \n                        ADD the tuple containing nx ny new_k TO visited  \n                        APPEND the tuple containing nx ny new_k steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the negative of one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-insertion-steps-to-make-a-string-palindrome", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minInsertions with parameter s  \n        FUNCTION longest_palindromic_subsequence with parameter s  \n            SET n TO the LENGTH OF s  \n            CREATE dp AS two dimensional array of size n by n FILLED WITH zero  \n            FOR i FROM zero TO n MINUS one  \n                SET element at position i of element at position i of dp TO one  \n            END FOR  \n            FOR cl FROM two TO n  \n                FOR i FROM zero TO n MINUS cl  \n                    SET j TO i PLUS cl MINUS one  \n                    IF element at position i of s EQUALS element at position j of s AND cl EQUALS two THEN  \n                        SET element at position i of element at position j of dp TO two  \n                    ELSE IF element at position i of s EQUALS element at position j of s THEN  \n                        SET element at position i of element at position j of dp TO element at position i PLUS one of element at position j MINUS one of dp PLUS two  \n                    ELSE  \n                        SET element at position i of element at position j of dp TO the GREATER OF element at position i of element at position j MINUS one of dp AND element at position i PLUS one of element at position j of dp  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN element at position zero of element at position n MINUS one of dp  \n        END FUNCTION  \n        SET result TO the LENGTH OF s MINUS longest_palindromic_subsequence with argument s  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-echo-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION distinctEchoSubstrings(text)  \n        SET n TO the LENGTH OF text  \n        SET substrings TO an empty set  \n\n        FOR length FROM one TO n DIVIDED BY two INCLUSIVE  \n            FOR start FROM zero TO n MINUS two MULTIPLIED BY length INCLUSIVE  \n                SET a TO the substring of text from position start TO position start PLUS length MINUS one  \n                SET b TO the substring of text from position start PLUS length TO position start PLUS two MULTIPLIED BY length MINUS one  \n                IF a EQUALS b  \n                    ADD the concatenation of a and b TO substrings  \n                END IF  \n            END FOR  \n        END FOR  \n\n        SET result TO the number of elements in substrings  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-distance-to-type-a-word-using-two-fingers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDistance(word)  \n        FUNCTION distance(c1 c2)  \n            IF c1 EQUALS None  \n                RETURN zero  \n            END IF  \n            SET x1 TO the result of dividing the numerical Unicode position of character c1 MINUS the numerical Unicode position of character A by six  \n            SET y1 TO the remainder of the numerical Unicode position of character c1 MINUS the numerical Unicode position of character A DIVIDED BY six  \n            SET x2 TO the result of dividing the numerical Unicode position of character c2 MINUS the numerical Unicode position of character A by six  \n            SET y2 TO the remainder of the numerical Unicode position of character c2 MINUS the numerical Unicode position of character A DIVIDED BY six  \n            RETURN the absolute value of x1 MINUS x2 PLUS the absolute value of y1 MINUS y2  \n        END FUNCTION  \n          \n        FUNCTION dp(i f1 f2)  \n            IF i EQUALS the length of word  \n                RETURN zero  \n            END IF  \n            SET c TO the element at position i of word  \n            SET d1 TO the result of distance between f1 and c PLUS the result of dp with parameters i PLUS one c f2  \n            SET d2 TO the result of distance between f2 and c PLUS the result of dp with parameters i PLUS one f1 c  \n            IF d1 LESS THAN d2  \n                RETURN d1  \n            ELSE  \n                RETURN d2  \n            END IF  \n        END FUNCTION  \n          \n        RETURN dp with parameters zero None None  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-subarray-to-maximize-array-value", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxValueAfterReverse(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS two  \n            RETURN the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position one of nums  \n        END IF  \n        \n        SET initial_value TO zero  \n        FOR i FROM one TO n MINUS one  \n            INCREMENT initial_value BY the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n        END FOR  \n        \n        SET max_edge_gain TO zero  \n        FOR i FROM one TO n MINUS one  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position zero of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i of nums MINUS element at position i MINUS one of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET possible_gain TO the ABSOLUTE VALUE OF element at position n MINUS one of nums MINUS element at position i of nums MINUS the ABSOLUTE VALUE OF element at position i PLUS one of nums MINUS element at position i of nums  \n            IF possible_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO possible_gain  \n            END IF  \n        END FOR  \n        \n        SET min_pair TO the MINIMUM VALUE among for each i FROM zero TO n MINUS two the MAXIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        SET max_pair TO the MAXIMUM VALUE among for each i FROM zero TO n MINUS two the MINIMUM VALUE between element at position i of nums AND element at position i PLUS one of nums  \n        \n        SET general_gain TO the MAXIMUM VALUE between zero AND two MULTIPLIED BY the DIFFERENCE between max_pair AND min_pair  \n        \n        RETURN initial_value PLUS the MAXIMUM VALUE between max_edge_gain AND general_gain  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-difficulty-of-a-job-schedule", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDifficulty(jobDifficulty, d)  \n        SET n TO the LENGTH OF jobDifficulty  \n        \n        IF n LESS THAN d  \n            RETURN negative one  \n        END IF  \n        \n        FUNCTION dp(i, d)  \n            IF d EQUALS one  \n                RETURN the MAXIMUM value IN the SUBLIST of jobDifficulty from position i TO the END  \n            END IF  \n            \n            SET min_difficulty TO positive infinity  \n            SET current_max TO zero  \n            \n            FOR each j FROM i TO n MINUS d  \n                SET current_max TO the GREATER BETWEEN current_max AND element at position j OF jobDifficulty  \n                SET candidate TO current_max PLUS dp(j PLUS one, d MINUS one)  \n                IF candidate LESS THAN min_difficulty  \n                    SET min_difficulty TO candidate  \n                END IF  \n            END FOR  \n            \n            RETURN min_difficulty  \n        END FUNCTION  \n        \n        RETURN dp(zero, d)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game-v", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxJumps(arr parameter AS list OF integer, d parameter AS integer) RETURNS integer  \n        FUNCTION dp(i parameter AS integer) RETURNS integer  \n            SET max_jumps TO one  \n            FOR x FROM one TO d parameter  \n                IF the sum of i parameter AND x is LESS THAN the length of arr parameter THEN  \n                    IF the element at position the sum of i parameter AND x of arr parameter is GREATER THAN OR EQUAL TO the element at position i parameter of arr parameter THEN  \n                        BREAK  \n                    END IF  \n                    SET max_jumps TO the greater value BETWEEN max_jumps AND the sum of one AND the result of dp function called with the sum of i parameter AND x  \n                END IF  \n            END FOR  \n            FOR x FROM one TO d parameter  \n                IF the difference of i parameter MINUS x is GREATER THAN OR EQUAL TO zero THEN  \n                    IF the element at position the difference of i parameter MINUS x of arr parameter is GREATER THAN OR EQUAL TO the element at position i parameter of arr parameter THEN  \n                        BREAK  \n                    END IF  \n                    SET max_jumps TO the greater value BETWEEN max_jumps AND the sum of one AND the result of dp function called with the difference of i parameter MINUS x  \n                END IF  \n            END FOR  \n            RETURN max_jumps  \n        END FUNCTION  \n        RETURN the maximum value of dp function called with i parameter FOR i parameter FROM zero TO the difference between the length of arr parameter AND one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minJumps(arr)  \n        SET n TO the LENGTH OF arr  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        SET value_indices TO an empty DEFAULT DICTIONARY mapping to lists  \n        FOR each i FROM zero TO n MINUS one  \n            APPEND i TO the list at key element at position i of arr in value_indices  \n        END FOR  \n        \n        SET queue TO an empty DOUBLE ENDED QUEUE  \n        APPEND a tuple of zero AND zero TO queue  \n        SET visited TO a set containing zero  \n        \n        WHILE queue is not empty  \n            REMOVE the first element from queue AND ASSIGN its first item to current_index AND second item to steps  \n            \n            IF current_index EQUALS n MINUS one  \n                RETURN steps  \n            END IF  \n            \n            SET next_indices TO a list containing current_index PLUS one AND current_index MINUS one  \n            APPEND all elements in the list at key element at position current_index of arr in value_indices TO next_indices  \n            \n            FOR each next_index IN next_indices  \n                IF next_index GREATER THAN OR EQUAL TO zero AND next_index LESS THAN n AND next_index NOT IN visited  \n                    ADD next_index TO visited  \n                    APPEND a tuple of next_index AND steps PLUS one TO queue  \n                END IF  \n            END FOR  \n            \n            SET the list at key element at position current_index of arr in value_indices TO an empty list  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-students-taking-exam", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxStudents(seats)  \n        SET m TO the LENGTH OF seats  \n        SET n TO the LENGTH OF element at position zero of seats  \n        \n        SET broken TO a list of zero repeated m times  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position j of element at position i of seats EQUALS the symbol for broken seat  \n                    SET element at position i of broken TO the value of element at position i of broken PLUS two RAISED TO the power of j  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION is_valid(arrangement)  \n            RETURN THE BITWISE AND OF arrangement AND THE BITWISE RIGHT SHIFT OF arrangement BY one EQUALS zero  \n        END FUNCTION  \n        \n        SET dp TO a list of empty dictionary repeated m times  \n        \n        FOR arrangement FROM zero TO two RAISED TO THE power of n MINUS one  \n            IF is_valid(arrangement) AND THE BITWISE AND OF arrangement AND element at position zero of broken EQUALS zero  \n                ASSIGN TO element at position zero of dp with key arrangement THE NUMBER OF ONES IN THE BINARY REPRESENTATION OF arrangement  \n            END IF  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            FOR arrangement FROM zero TO two RAISED TO THE power of n MINUS one  \n                IF is_valid(arrangement) AND THE BITWISE AND OF arrangement AND element at position i of broken EQUALS zero  \n                    SET max_students TO zero  \n                    FOR each prev_arrangement IN the keys of element at position i MINUS one of dp  \n                        IF THE BITWISE AND OF arrangement AND THE BITWISE RIGHT SHIFT OF prev_arrangement BY one EQUALS zero AND THE BITWISE AND OF arrangement AND THE BITWISE LEFT SHIFT OF prev_arrangement BY one EQUALS zero  \n                            IF element at position i MINUS one of dp with key prev_arrangement GREATER THAN max_students  \n                                SET max_students TO element at position i MINUS one of dp with key prev_arrangement  \n                            END IF  \n                        END IF  \n                    END FOR  \n                    ASSIGN TO element at position i of dp with key arrangement THE VALUE OF max_students PLUS THE NUMBER OF ONES IN THE BINARY REPRESENTATION OF arrangement  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF element at position m MINUS one of dp IS NOT EMPTY  \n            RETURN THE MAXIMUM VALUE IN THE VALUES OF element at position m MINUS one of dp  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-target-array-with-multiple-sums", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isPossible(target)  \n        SET max_heap TO an empty list  \n        FOR each num IN target  \n            APPEND the NEGATION of num TO max_heap  \n        END FOR  \n        TRANSFORM max_heap INTO a heap structure  \n        \n        SET total_sum TO the sum of elements in target  \n        \n        WHILE the element at position zero of max_heap LESS THAN NEGATION of one holds  \n            SET largest TO the NEGATION of the element extracted from max_heap  \n            SET rest_sum TO total_sum MINUS largest  \n            \n            IF largest LESS THAN OR EQUAL TO rest_sum OR rest_sum EQUALS zero THEN  \n                RETURN False  \n            END IF  \n            \n            SET new_value TO the remainder of largest DIVIDED BY rest_sum  \n            \n            IF new_value EQUALS zero AND rest_sum NOT EQUALS one THEN  \n                RETURN False  \n            END IF  \n            \n            SET total_sum TO rest_sum PLUS new_value  \n            INSERT the NEGATION of new_value INTO max_heap maintaining heap order  \n        END WHILE  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-multiple-of-three", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO the frequency counter of digits  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder after dividing total_sum BY three  \n        IF remainder EQUALS one  \n            FOR each digit d IN the list consisting of one four seven  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of two five eight  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit d IN the list consisting of two five eight  \n                IF the frequency count of digit d IS GREATER THAN zero  \n                    DECREMENT the frequency count of digit d BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            ELSE  \n                FOR each digit d IN the list consisting of one four seven  \n                    IF the frequency count of digit d IS GREATER THAN one  \n                        DECREMENT the frequency count of digit d BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END ELSE  \n        END IF  \n        SET result TO an empty list  \n        FOR each digit d FROM nine DOWN TO zero  \n            APPEND the string representation of digit d REPEATED frequency count of digit d times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF the length of final_number IS GREATER THAN zero AND the element at position zero of final_number EQUALS zero  \n            RETURN the string zero  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO a LIST containing four PAIRS as follows  \n            PAIR of zero PLUS zero AND one PLUS zero  \n            PAIR of zero PLUS zero AND MINUS one PLUS zero  \n            PAIR of one PLUS zero AND zero PLUS zero  \n            PAIR of MINUS one PLUS zero AND zero PLUS zero  \n        SET costs TO an EMPTY LIST  \n        FOR each element IN range FROM zero TO m MINUS one  \n            APPEND a LIST of length n where each element IS positive infinity TO costs  \n        END FOR  \n        SET element at position zero of element at position zero of costs TO zero  \n        SET pq TO a LIST containing one TRIPLE of zero PLUS zero PLUS zero  \n        SET visited TO an EMPTY SET  \n        WHILE pq is NOT empty  \n            REMOVE the SMALLEST element FROM pq AND DESTRUCTURE INTO cost PLUS i PLUS j  \n            IF PAIR of i AND j IS IN visited  \n                CONTINUE to next iteration OF THE WHILE LOOP  \n            END IF  \n            ADD PAIR of i AND j TO visited  \n            IF i EQUALS m MINUS one AND j EQUALS n MINUS one  \n                RETURN cost  \n            END IF  \n            FOR each index k PLUS pair di AND dj IN directions USING enumeration  \n                SET ni TO i PLUS di  \n                SET nj TO j PLUS dj  \n                IF ni IS GREATER THAN OR EQUAL TO zero AND ni IS LESS THAN m AND nj IS GREATER THAN OR EQUAL TO zero AND nj IS LESS THAN n  \n                    SET new_cost TO cost PLUS one IF k PLUS one IS NOT EQUAL TO element at position i of element at position j of grid OTHERWISE zero  \n                    IF new_cost IS LESS THAN element at position ni of element at position nj of costs  \n                        SET element at position ni of element at position nj of costs TO new_cost  \n                        INSERT TRIPLE new_cost PLUS ni PLUS nj INTO pq MAINTAINING PRIORITY ORDER BY THE FIRST ELEMENT  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-position-after-t-seconds", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION frogPosition(n, edges, t, target)  \n        IF n EQUALS one  \n            RETURN one  \n        END IF  \n        \n        SET graph TO a new default dictionary mapping each key to an empty list  \n        FOR each pair of values u AND v IN edges  \n            APPEND v TO the list associated with u in graph  \n            APPEND u TO the list associated with v in graph  \n        END FOR  \n        \n        SET queue TO a new double ended queue containing a tuple of the integer one the floating point number one and the integer zero  \n        SET visited TO a new set containing the integer one  \n        \n        WHILE queue is not empty  \n            REMOVE AND RETURN the leftmost element of queue assigning it in order to current_node current_probability AND current_time  \n            \n            IF current_time EQUALS t OR current_node NOT EQUALS one AND the LENGTH OF the list associated with current_node in graph EQUALS one  \n                IF current_node EQUALS target  \n                    RETURN current_probability  \n                ELSE  \n                    CONTINUE to the next iteration of the WHILE loop  \n                END IF  \n            END IF  \n            \n            IF current_node EQUALS one  \n                SET possible_moves TO the LENGTH OF the list associated with current_node in graph  \n            ELSE  \n                SET possible_moves TO the LENGTH OF the list associated with current_node in graph MINUS one  \n            END IF  \n            \n            FOR each neighbor IN the list associated with current_node in graph  \n                IF neighbor NOT IN visited  \n                    ADD neighbor TO visited  \n                    APPEND a tuple of neighbor current_probability DIVIDED BY possible_moves AND current_time PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-performance-of-a-team", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxPerformance(n speed efficiency k)  \n        SET engineers TO list of pairs of element at position index of efficiency AND element at position index of speed FOR index FROM the first TO the last position in efficiency  \n        SORT engineers BY the first element of each pair IN descending order  \n        SET speed_heap TO empty list  \n        SET speed_sum TO zero  \n        SET max_performance TO zero  \n        FOR each pair IN engineers  \n            SET eff TO the first element of pair  \n            SET spd TO the second element of pair  \n            ADD spd TO speed_heap USING heap push operation  \n            INCREMENT speed_sum BY spd  \n            IF the LENGTH OF speed_heap GREATER THAN k THEN  \n                SET smallest_speed TO the result of heap pop operation on speed_heap  \n                DECREMENT speed_sum BY smallest_speed  \n            END IF  \n            SET current_performance TO speed_sum MULTIPLIED BY eff  \n            IF current_performance GREATER THAN max_performance THEN  \n                SET max_performance TO current_performance  \n            END IF  \n        END FOR  \n        RETURN max_performance MODULO the result of ten RAISED TO THE POWER OF nine PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pizza-with-3n-slices", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSizeSlices(slices)  \n        SET n TO the LENGTH OF slices DIVIDED BY three  \n        \n        FUNCTION dp(start, end, k)  \n            IF k EQUALS zero OR start GREATER THAN end THEN  \n                RETURN zero  \n            END IF  \n            SET pick TO element at position start of slices PLUS dp(start PLUS two, end, k MINUS one)  \n            SET skip TO dp(start PLUS one, end, k)  \n            RETURN the GREATER OF pick AND skip  \n        END FUNCTION  \n        \n        SET case1 TO dp(one, the LENGTH OF slices MINUS one, n)  \n        SET case2 TO dp(zero, the LENGTH OF slices MINUS two, n)  \n        \n        RETURN the GREATER OF case1 AND case2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-happy-prefix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPrefix(s)  \n        SET n TO the LENGTH OF s  \n        SET lps TO a list of zero VALUES with LENGTH n  \n        SET j TO zero  \n        FOR i FROM one TO n MINUS one  \n            WHILE j GREATER THAN zero AND element at position i of s NOT EQUALS element at position j of s  \n                SET j TO element at position j MINUS one of lps  \n            END WHILE  \n            IF element at position i of s EQUALS element at position j of s  \n                INCREMENT j BY one  \n                SET element at position i of lps TO j  \n            END IF  \n        END FOR  \n        SET longest_happy_prefix_length TO element at position n MINUS one of lps  \n        RETURN substring from position zero TO position longest_happy_prefix_length MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reducing-dishes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSatisfaction(satisfaction)  \n        SORT the elements of satisfaction IN descending order  \n        SET max_satisfaction TO zero  \n        SET current_satisfaction TO zero  \n        SET total_satisfaction TO zero  \n        FOR each element s IN satisfaction  \n            INCREMENT current_satisfaction BY s  \n            INCREMENT total_satisfaction BY current_satisfaction  \n            IF total_satisfaction GREATER THAN max_satisfaction THEN  \n                SET max_satisfaction TO total_satisfaction  \n            END IF  \n        END FOR  \n        RETURN max_satisfaction  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGameIII(stoneValue)  \n        SET n TO the LENGTH OF stoneValue  \n        INITIALIZE dp AS a list of zeroes with LENGTH n PLUS one  \n        FOR index i FROM n MINUS one DOWN TO zero  \n            SET dp at position i TO element at position i of stoneValue MINUS dp at position i PLUS one  \n            IF i PLUS two IS LESS THAN OR EQUAL TO n THEN  \n                SET dp at position i TO the GREATER OF dp at position i AND element at position i of stoneValue PLUS element at position i PLUS one of stoneValue MINUS dp at position i PLUS two  \n            END IF  \n            IF i PLUS three IS LESS THAN OR EQUAL TO n THEN  \n                SET dp at position i TO the GREATER OF dp at position i AND element at position i of stoneValue PLUS element at position i PLUS one of stoneValue PLUS element at position i PLUS two of stoneValue MINUS dp at position i PLUS three  \n            END IF  \n        END FOR  \n        IF dp at position zero IS GREATER THAN zero THEN  \n            RETURN the string Alice  \n        ELSE IF dp at position zero IS LESS THAN zero THEN  \n            RETURN the string Bob  \n        ELSE  \n            RETURN the string Tie  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-paint-n-3-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numOfWays(n)  \n        SET MOD TO one billion PLUS seven  \n        SET a TO six  \n        SET b TO six  \n        FOR each index FROM two TO n  \n            SET new_a TO three MULTIPLIED BY a PLUS two MULTIPLIED BY b  \n            SET new_a TO new_a MODULO MOD  \n            SET new_b TO two MULTIPLIED BY a PLUS two MULTIPLIED BY b  \n            SET new_b TO new_b MODULO MOD  \n            SET a TO new_a  \n            SET b TO new_b  \n        END FOR  \n        SET result TO a PLUS b  \n        SET result TO result MODULO MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-the-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numOfArrays(n parameter n, m parameter m, k parameter k) RETURNS integer  \n        SET MOD TO the number one billion PLUS seven  \n        \n        INITIALIZE dp AS three dimensional list WITH dimensions n PLUS one BY m PLUS one BY k PLUS one FILLED WITH zero  \n        \n        FOR each j FROM one TO m  \n            SET element at position one of dp AT position j AT position one TO one  \n        END FOR  \n        \n        FOR each i FROM two TO n  \n            FOR each j FROM one TO m  \n                FOR each p FROM one TO k  \n                    FOR each x FROM one TO j MINUS one  \n                        SET element at position i of dp AT position j AT position p TO remainder after division of element at position i of dp AT position j AT position p PLUS element at position i MINUS one of dp AT position x AT position p MINUS one BY MOD  \n                    END FOR  \n                    SET element at position i of dp AT position j AT position p TO remainder after division of element at position i of dp AT position j AT position p PLUS element at position i MINUS one of dp AT position j AT position p MULTIPLIED BY j BY MOD  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        SET result TO zero  \n        FOR each j FROM one TO m  \n            SET result TO remainder after division of result PLUS element at position n of dp AT position j AT position k BY MOD  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "constrained-subsequence-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION constrainedSubsetSum(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a list of zeroes with the LENGTH OF nums  \n        SET the element at position zero of dp TO the element at position zero of nums  \n        SET max_sum TO the element at position zero of nums  \n        \n        SET q TO a deque containing zero  \n        \n        FOR i FROM one TO n MINUS one  \n            IF the element at position zero of q IS NOT EMPTY AND the element at position at the element at position zero of q of dp IS GREATER THAN zero  \n                SET dp at position i TO the element at position i of nums PLUS the element at position at the element at position zero of q of dp  \n            ELSE  \n                SET dp at position i TO the element at position i of nums  \n            END IF  \n            \n            IF max_sum IS LESS THAN dp at position i  \n                SET max_sum TO dp at position i  \n            END IF  \n            \n            WHILE q IS NOT EMPTY AND dp at position i IS GREATER THAN OR EQUAL TO dp at position at the element at the last position of q  \n                REMOVE the element at the last position FROM q  \n            END WHILE  \n            \n            APPEND i TO q  \n            \n            IF the element at position zero of q EQUALS i MINUS k  \n                REMOVE the element at position zero FROM q  \n            END IF  \n        END FOR  \n        \n        RETURN max_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF the element at position zero of mat  \n        SET initial_sum TO zero  \n        FOR each row IN mat  \n            INCREMENT initial_sum BY the element at position zero of row  \n        END FOR  \n        SET initial_indices TO a tuple of zero repeated m times  \n        SET min_heap TO a list containing a tuple of initial_sum and initial_indices  \n        SET visited TO a set containing initial_indices  \n        \n        WHILE k GREATER THAN zero  \n            EXTRACT the tuple containing current_sum and indices by removing the smallest element from min_heap  \n            DECREMENT k BY one  \n            \n            IF k EQUALS zero  \n                RETURN current_sum  \n            END IF  \n            \n            FOR i FROM zero TO m MINUS one  \n                IF the element at position i of indices PLUS one LESS THAN n  \n                    SET new_indices_list TO a list converted from indices  \n                    INCREMENT the element at position i of new_indices_list BY one  \n                    SET new_indices_tuple TO a tuple converted from new_indices_list  \n                    SET new_sum TO current_sum MINUS the element at position i of mat AT the element at position i of indices PLUS the element at position i of mat AT the element at position i of new_indices_tuple  \n                    \n                    IF new_indices_tuple NOT IN visited  \n                        ADD new_indices_tuple TO visited  \n                        ADD the tuple containing new_sum and new_indices_tuple TO min_heap  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-darts-inside-of-a-circular-dartboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numPoints(darts, r)  \n        FUNCTION distance(p1, p2)  \n            RETURN the square root of the sum of the square of the element at position zero of p1 MINUS the element at position zero of p2 AND the square of the element at position one of p1 MINUS the element at position one of p2  \n        END FUNCTION  \n          \n        FUNCTION circle_center(p1, p2, r)  \n            SET d TO the result of distance with p1 AND p2  \n            IF d GREATER THAN 2 MULTIPLIED BY r  \n                RETURN None  \n            END IF  \n            SET a TO the square root of r MULTIPLIED BY r MINUS the square of d DIVIDED BY two  \n            SET h TO a list containing the element at position zero of p1 PLUS the element at position zero of p2 DIVIDED BY two AND the element at position one of p1 PLUS the element at position one of p2 DIVIDED BY two  \n            SET dx TO the difference of the element at position one of p2 MINUS the element at position one of p1 MULTIPLIED BY a DIVIDED BY d  \n            SET dy TO the difference of the element at position zero of p2 MINUS the element at position zero of p1 MULTIPLIED BY a DIVIDED BY d  \n            RETURN a list containing a tuple of the element at position zero of h MINUS dx AND the element at position one of h PLUS dy AND a tuple of the element at position zero of h PLUS dx AND the element at position one of h MINUS dy  \n        END FUNCTION  \n          \n        FUNCTION is_inside(circle, point, r)  \n            RETURN the result of distance with circle AND point LESS THAN OR EQUAL TO r  \n        END FUNCTION  \n          \n        SET n TO the length of darts  \n        IF n EQUALS one  \n            RETURN one  \n        END IF  \n          \n        SET max_count TO one  \n          \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET centers TO the result of circle_center with element at position i of darts AND element at position j of darts AND r  \n                IF centers NOT EQUALS None  \n                    FOR each center IN centers  \n                        SET count TO zero  \n                        FOR each dart IN darts  \n                            IF is_inside with center AND dart AND r  \n                                INCREMENT count BY one  \n                            END IF  \n                        END FOR  \n                        IF count GREATER THAN max_count  \n                            SET max_count TO count  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        RETURN max_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-dot-product-of-two-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxDotProduct(nums1 PARAMETER, nums2 PARAMETER)  \n        SET m TO the LENGTH OF nums1  \n        SET n TO the LENGTH OF nums2  \n        SET dp TO a new list of lists where each inner list has n PLUS one elements each set TO negative infinity and the outer list has m PLUS one such inner lists  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                SET current_product TO the element at position i MINUS one of nums1 MULTIPLIED BY the element at position j MINUS one of nums2  \n                SET dp element at position i element at position j TO the maximum of the following four values  \n                    current_product  \n                    dp element at position i MINUS one element at position j  \n                    dp element at position i element at position j MINUS one  \n                    dp element at position i MINUS one element at position j MINUS one PLUS current_product  \n            END FOR  \n        END FOR  \n        RETURN dp element at position m element at position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cherry-pickup-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dp(r c1 c2)  \n            IF c1 LESS THAN zero OR c1 GREATER THAN OR EQUAL TO cols OR c2 LESS THAN zero OR c2 GREATER THAN OR EQUAL TO cols THEN  \n                RETURN zero  \n            END IF  \n            \n            IF c1 EQUALS c2 THEN  \n                SET cherries TO element at position r of grid element at position c1  \n            ELSE  \n                SET cherries TO element at position r of grid element at position c1 PLUS element at position r of grid element at position c2  \n            END IF  \n            \n            IF r EQUALS rows MINUS one THEN  \n                RETURN cherries  \n            END IF  \n            \n            SET max_cherries TO zero  \n            FOR each dc1 IN list containing negative one zero and one  \n                FOR each dc2 IN list containing negative one zero and one  \n                    SET possible TO dp(r PLUS one c1 PLUS dc1 c2 PLUS dc2)  \n                    IF possible GREATER THAN max_cherries THEN  \n                        SET max_cherries TO possible  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN cherries PLUS max_cherries  \n        END FUNCTION  \n        \n        RETURN dp(zero zero cols MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-house-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost WITH parameters houses cost m n target  \n        FUNCTION dp WITH parameters i prev_color groups  \n            IF i EQUALS m  \n                IF groups EQUALS target  \n                    RETURN zero  \n                ELSE  \n                    RETURN infinity  \n                END IF  \n            END IF  \n              \n            IF element at position i of houses NOT EQUALS zero  \n                SET new_groups TO groups PLUS one IF element at position i of houses NOT EQUALS prev_color ELSE zero  \n                RETURN result of dp WITH i PLUS one prev_color replaced by element at position i of houses and new_groups  \n            END IF  \n              \n            SET min_cost TO infinity  \n            FOR color FROM one TO n  \n                SET new_groups TO groups PLUS one IF color NOT EQUALS prev_color ELSE zero  \n                SET current_cost TO element at position i at position color MINUS one of cost PLUS result of dp WITH i PLUS one color and new_groups  \n                IF current_cost LESS THAN min_cost  \n                    SET min_cost TO current_cost  \n                END IF  \n            END FOR  \n            RETURN min_cost  \n        END FUNCTION  \n          \n        SET result TO result of dp WITH zero zero zero  \n        IF result NOT EQUALS infinity  \n            RETURN result  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "allocate-mailboxes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(houses k)  \n        SORT houses IN ASCENDING ORDER  \n        SET n TO the LENGTH OF houses  \n        SET cost TO a two dimensional list of size n by n with all elements SET TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i of cost THEN element at position j TO the element at position i PLUS one of cost THEN element at position j MINUS one PLUS the element at position j of houses MINUS the element at position i of houses  \n            END FOR  \n        END FOR  \n        SET dp TO a two dimensional list with n PLUS one rows and k PLUS one columns where each element IS SET TO infinity  \n        SET element at position zero of dp THEN element at position zero TO zero  \n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                FOR p FROM zero TO i MINUS one  \n                    SET element at position i of dp THEN element at position j TO the minimum value BETWEEN the current element at position i of dp THEN element at position j AND the sum of element at position p of dp THEN element at position j MINUS one PLUS element at position p of cost THEN element at position i MINUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp THEN element at position k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parallel-courses-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minNumberOfSemesters(n k relations)  \n        SET graph TO a new mapping with default empty list for each key  \n        SET in_degree TO a list of zeros with length equal to n PLUS one  \n        \n        FOR each pair prevCourse AND nextCourse IN relations  \n            APPEND nextCourse TO the list associated with prevCourse in graph  \n            INCREMENT the element at position nextCourse of in_degree BY one  \n        END FOR  \n        \n        SET queue TO an empty double-ended queue  \n        FOR course FROM one TO n  \n            IF the element at position course of in_degree EQUALS zero  \n                APPEND course TO queue  \n            END IF  \n        END FOR  \n        \n        SET semesters TO zero  \n        \n        WHILE queue holds any elements  \n            SET numberOfCoursesThisSemester TO the smaller of k AND the length of queue  \n            FOR index FROM one TO numberOfCoursesThisSemester  \n                REMOVE the element from the left end of queue AND ASSIGN to current_course  \n                FOR each next_course IN the list associated with current_course in graph  \n                    DECREMENT the element at position next_course of in_degree BY one  \n                    IF the element at position next_course of in_degree EQUALS zero  \n                        APPEND next_course TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT semesters BY one  \n        END WHILE  \n        \n        RETURN semesters  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-value-of-equation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxValueOfEquation(points, k)  \n        SET max_value TO negative infinity  \n        ASSIGN reference TO a new empty double ended queue named deque_  \n        \n        FOR each pair of values named xj and yj IN points  \n            WHILE deque_ is not empty AND the value of xj MINUS the second element at the front position of deque_ is GREATER THAN k  \n                REMOVE the front element FROM deque_  \n            END WHILE  \n            \n            IF deque_ is not empty  \n                SET max_value TO the greater value BETWEEN max_value AND the sum of yj PLUS xj PLUS the first element at the front position of deque_  \n            END IF  \n            \n            WHILE deque_ is not empty AND the difference of yj MINUS xj is GREATER THAN OR EQUAL TO the first element at the back position of deque_  \n                REMOVE the back element FROM deque_  \n            END WHILE  \n            \n            APPEND the pair consisting of the difference yj MINUS xj AND the value xj TO deque_  \n        END FOR  \n        \n        RETURN max_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION winnerSquareGame(n)  \n        SET dp TO a list of Boolean false values with length n PLUS one  \n        FOR i FROM one TO n  \n            SET j TO one  \n            WHILE j MULTIPLIED BY j LESS THAN OR EQUAL TO i  \n                IF dp at position i MINUS j MULTIPLIED BY j EQUALS false  \n                    SET dp at position i TO true  \n                    BREAK the loop  \n                END IF  \n                INCREMENT j BY one  \n            END WHILE  \n        END FOR  \n        RETURN dp at position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-position-for-a-service-centre", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getMinDistSum(positions)  \n        SET n TO the LENGTH OF positions  \n        SET x TO zero  \n        SET y TO zero  \n        FOR each position IN positions  \n            SET x1 TO the first element AT position  \n            SET y1 TO the second element AT position  \n            INCREMENT x BY x1  \n            INCREMENT y BY y1  \n        END FOR  \n        SET x TO x DIVIDED BY n  \n        SET y TO y DIVIDED BY n  \n        SET decay TO zero POINT nine nine nine  \n        SET eps TO zero POINT zero zero zero zero zero one  \n        SET alpha TO zero POINT five  \n        WHILE TRUE  \n            SET grad_x TO zero  \n            SET grad_y TO zero  \n            SET dist TO zero  \n            FOR each position IN positions  \n                SET x1 TO the first element AT position  \n                SET y1 TO the second element AT position  \n                SET a TO x MINUS x1  \n                SET b TO y MINUS y1  \n                SET c TO the square root of a MULTIPLIED BY a PLUS b MULTIPLIED BY b  \n                INCREMENT grad_x BY a DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT grad_y BY b DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT dist BY c  \n            END FOR  \n            SET dx TO grad_x MULTIPLIED BY alpha  \n            SET dy TO grad_y MULTIPLIED BY alpha  \n            DECREMENT x BY dx  \n            DECREMENT y BY dy  \n            MULTIPLY alpha BY decay  \n            IF the absolute value of dx IS LESS THAN OR EQUAL TO eps AND the absolute value of dy IS LESS THAN OR EQUAL TO eps  \n                RETURN dist  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-non-overlapping-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxNumOfSubstrings(s)  \n        SET first TO empty dictionary  \n        SET last TO empty dictionary  \n        FOR each index AND character IN enumeration of s  \n            IF character NOT IN first  \n                SET first AT character TO index  \n            END IF  \n            SET last AT character TO index  \n        END FOR  \n        \n        SET intervals TO empty list  \n        FOR each character IN keys of first  \n            SET start TO first AT character  \n            SET end TO last AT character  \n            SET i TO start  \n            WHILE i LESS THAN OR EQUAL TO end  \n                IF first AT element at position i of s LESS THAN start  \n                    BREAK the loop  \n                END IF  \n                SET end TO the GREATER THAN OF end AND last AT element at position i of s  \n                INCREMENT i BY one  \n            END WHILE  \n            IF loop ended WITHOUT break  \n                APPEND pair of start AND end TO intervals  \n            END IF  \n        END FOR  \n        \n        SORT intervals BY the second element of each pair in ascending order  \n        \n        SET result TO empty list  \n        SET prev_end TO negative one  \n        FOR each pair start AND end IN intervals  \n            IF start GREATER THAN prev_end  \n                APPEND the substring of s from position start TO position end to result  \n                SET prev_end TO end  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-a-value-of-a-mysterious-function-closest-to-target", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION closestToTarget(arr, target)  \n        SET seen TO an empty set  \n        SET min_diff TO a value representing positive infinity  \n        FOR each num IN arr  \n            SET new_seen TO an empty set  \n            FOR each x IN seen  \n                APPEND the bitwise AND of num AND x TO new_seen  \n            END FOR  \n            SET seen TO the union of new_seen AND a set containing num  \n            FOR each val IN seen  \n                SET current_difference TO the absolute value of val MINUS target  \n                IF current_difference LESS THAN min_diff  \n                    SET min_diff TO current_difference  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-increments-on-subarrays-to-form-a-target-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minNumberOperations(target)  \n        SET operations TO zero  \n        SET previous TO zero  \n        FOR each current IN target  \n            IF current GREATER THAN previous  \n                INCREMENT operations BY current MINUS previous  \n            END IF  \n            SET previous TO current  \n        END FOR  \n        RETURN operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-compression-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getLengthOfOptimalCompression(s, k)  \n        FUNCTION dp(i, k, prev_char, prev_count)  \n            IF k LESS THAN zero  \n                RETURN positive infinity  \n            END IF  \n            IF i EQUALS the LENGTH OF s  \n                RETURN zero  \n            END IF  \n            IF element at position i of s EQUALS prev_char  \n                IF prev_count EQUALS one OR prev_count EQUALS nine OR prev_count EQUALS ninety nine  \n                    SET increment TO one  \n                ELSE  \n                    SET increment TO zero  \n                END IF  \n                RETURN increment PLUS dp(i PLUS one, k, prev_char, prev_count PLUS one)  \n            ELSE  \n                SET keep TO one PLUS dp(i PLUS one, k, element at position i of s, one)  \n                SET delete TO dp(i PLUS one, k MINUS one, prev_char, prev_count)  \n                RETURN the smaller value BETWEEN keep AND delete  \n            END IF  \n        END FUNCTION  \n        RETURN dp(zero, k, empty string, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "get-the-maximum-score", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSum(nums1 nums2)  \n        SET i TO zero  \n        SET j TO zero  \n        SET sum1 TO zero  \n        SET sum2 TO zero  \n        SET MOD TO ten RAISED TO THE power OF nine PLUS one  \n        \n        WHILE i LESS THAN the LENGTH OF nums1 AND j LESS THAN the LENGTH OF nums2  \n            IF element at position i of nums1 LESS THAN element at position j of nums2  \n                INCREMENT sum1 BY element at position i of nums1  \n                INCREMENT i BY one  \n            ELSE IF element at position i of nums1 GREATER THAN element at position j of nums2  \n                INCREMENT sum2 BY element at position j of nums2  \n                INCREMENT j BY one  \n            ELSE  \n                SET maximum_value TO the GREATER OF sum1 AND sum2  \n                SET sum1 TO maximum_value PLUS element at position i of nums1  \n                SET sum2 TO maximum_value PLUS element at position i of nums1  \n                INCREMENT i BY one  \n                INCREMENT j BY one  \n            END IF  \n        END WHILE  \n        \n        WHILE i LESS THAN the LENGTH OF nums1  \n            INCREMENT sum1 BY element at position i of nums1  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        WHILE j LESS THAN the LENGTH OF nums2  \n            INCREMENT sum2 BY element at position j of nums2  \n            INCREMENT j BY one  \n        END WHILE  \n        \n        SET result TO the GREATER OF sum1 AND sum2  \n        SET result TO result MODULO MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-longest-awesome-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestAwesome(s)  \n        SET prefix_map TO mapping from zero TO negative one  \n        SET prefix_xor TO zero  \n        SET max_length TO zero  \n        FOR each position i AND character char IN s  \n            SET digit TO integer value of character char  \n            SET prefix_xor TO prefix_xor EXCLUSIVE OR bit value one LEFT SHIFTED BY digit  \n            IF prefix_xor EXISTS as a key IN prefix_map  \n                SET possible_length TO position i MINUS value of prefix_xor key IN prefix_map  \n                IF possible_length GREATER THAN max_length  \n                    SET max_length TO possible_length  \n                END IF  \n            END IF  \n            FOR each bit_index j FROM zero TO nine  \n                SET flipped TO prefix_xor EXCLUSIVE OR bit value one LEFT SHIFTED BY bit_index j  \n                IF flipped EXISTS as a key IN prefix_map  \n                    SET possible_length TO position i MINUS value of flipped key IN prefix_map  \n                    IF possible_length GREATER THAN max_length  \n                        SET max_length TO possible_length  \n                    END IF  \n                END IF  \n            END FOR  \n            IF prefix_xor DOES NOT EXIST as a key IN prefix_map  \n                SET value of prefix_xor key IN prefix_map TO position i  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-cut-a-stick", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO sorted list consisting of all elements of cuts PLUS zero PLUS n  \n        \n        FUNCTION dp(left, right)  \n            IF right MINUS left LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing positive infinity  \n            FOR i FROM left PLUS one TO right MINUS one  \n                SET cost TO element at position right of cuts MINUS element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-most-similar-path-in-a-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION mostSimilar(n names targetPath)  \n        SET graph TO a mapping from default empty list  \n        FOR each road WITH elements u AND v IN roads  \n            APPEND element v TO list at element u of graph  \n            APPEND element u TO list at element v of graph  \n        END FOR  \n        SET m TO the LENGTH OF targetPath  \n\n        FUNCTION dp(i j)  \n            IF i EQUALS zero THEN  \n                IF element j of names NOT EQUALS element i of targetPath THEN  \n                    RETURN one AND list containing element j  \n                ELSE  \n                    RETURN zero AND list containing element j  \n                END IF  \n            END IF  \n            SET min_cost TO positive infinite value  \n            SET min_path TO empty list  \n            FOR each element k IN list at element j of graph  \n                SET cost AND path TO result of dp(i MINUS one j)  \n                IF cost LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                    SET min_path TO path  \n                END IF  \n            END FOR  \n            SET current_cost TO min_cost PLUS one IF element j of names NOT EQUALS element i of targetPath OTHERWISE zero  \n            RETURN current_cost AND concatenation of min_path WITH list containing element j  \n        END FUNCTION  \n\n        SET min_cost TO positive infinite value  \n        SET min_path TO empty list  \n        FOR j FROM zero TO n MINUS one  \n            SET cost AND path TO result of dp(m MINUS one j)  \n            IF cost LESS THAN min_cost THEN  \n                SET min_cost TO cost  \n                SET min_path TO path  \n            END IF  \n        END FOR  \n        RETURN min_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-days-to-eat-n-oranges", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDays WITH PARAMETER n  \n        FUNCTION dp WITH PARAMETER remaining  \n            IF remaining LESS THAN OR EQUAL TO one  \n                RETURN remaining  \n            END IF  \n            RETURN one PLUS THE MINIMUM OF the REMAINDER OF remaining DIVIDED BY two PLUS THE RESULT OF dp WITH PARAMETER remaining DIVIDED BY two AND the REMAINDER OF remaining DIVIDED BY three PLUS THE RESULT OF dp WITH PARAMETER remaining DIVIDED BY three  \n        END FUNCTION  \n        RETURN dp WITH PARAMETER n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-v", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGameV(stoneValue)  \n        SET prefix_sum TO a list of zeros with the length of the LENGTH OF stoneValue PLUS one  \n        FOR index FROM zero TO the LENGTH OF stoneValue MINUS one  \n            SET element at position index PLUS one of prefix_sum TO element at position index of prefix_sum PLUS element at position index of stoneValue  \n        END FOR  \n        \n        FUNCTION get_range_sum(left, right)  \n            RETURN element at position right PLUS one of prefix_sum MINUS element at position left of prefix_sum  \n        END FUNCTION  \n        \n        FUNCTION dp(left, right)  \n            IF left EQUALS right  \n                RETURN zero  \n            END IF  \n            SET max_score TO zero  \n            FOR i FROM left TO right MINUS one  \n                SET left_sum TO get_range_sum left i  \n                SET right_sum TO get_range_sum i PLUS one right  \n                IF left_sum LESS THAN right_sum  \n                    IF max_score LESS THAN left_sum PLUS dp left i  \n                        SET max_score TO left_sum PLUS dp left i  \n                    END IF  \n                ELSE IF left_sum GREATER THAN right_sum  \n                    IF max_score LESS THAN right_sum PLUS dp i PLUS one right  \n                        SET max_score TO right_sum PLUS dp i PLUS one right  \n                    END IF  \n                ELSE  \n                    IF max_score LESS THAN left_sum PLUS dp left i  \n                        SET max_score TO left_sum PLUS dp left i  \n                    END IF  \n                    IF max_score LESS THAN right_sum PLUS dp i PLUS one right  \n                        SET max_score TO right_sum PLUS dp i PLUS one right  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN max_score  \n        END FUNCTION  \n        \n        RETURN dp zero LENGTH OF stoneValue MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-days-to-disconnect-island", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDays(grid)  \n        FUNCTION dfs(x, y, visited)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero of grid OR the TUPLE of x and y IS IN visited OR element at position x of grid AT position y EQUALS zero  \n                RETURN  \n            END IF  \n            ADD the TUPLE of x and y TO visited  \n            FOR each TUPLE of dx and dy IN the LIST containing TUPLE negative one AND zero AND TUPLE one AND zero AND TUPLE zero AND negative one AND TUPLE zero AND one  \n                CALL dfs WITH parameters x PLUS dx AND y PLUS dy AND visited  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION is_connected()  \n            ASSIGN an EMPTY SET TO visited  \n            ASSIGN the LIST of TUPLES i AND j FOR each i FROM zero TO the LENGTH OF grid MINUS one AND for each j FROM zero TO the LENGTH OF element at position zero of grid MINUS one WHERE element at position i of grid AT position j EQUALS one TO land_cells  \n            IF the LENGTH OF land_cells EQUALS zero  \n                RETURN True  \n            END IF  \n            CALL dfs WITH parameters the element at position zero of land_cells AT position zero AND the element at position zero of land_cells AT position one AND visited  \n            RETURN whether the LENGTH OF visited EQUALS the LENGTH OF land_cells  \n        END FUNCTION  \n\n        IF is_connected() EQUALS False  \n            RETURN zero  \n        END IF  \n\n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid AT position j EQUALS one  \n                    SET element at position i of grid AT position j TO zero  \n                    IF is_connected() EQUALS False  \n                        RETURN one  \n                    END IF  \n                    SET element at position i of grid AT position j TO one  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-reorder-array-to-get-same-bst", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numOfWays(nums)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        \n        FUNCTION count_ways(arr)  \n            IF the LENGTH OF arr LESS THAN OR EQUAL TO one THEN  \n                RETURN one  \n            END IF  \n            \n            SET root TO the element at position one of arr  \n            \n            SET left_subtree TO an empty list  \n            FOR each element x IN arr  \n                IF x LESS THAN root THEN  \n                    APPEND x TO left_subtree  \n                END IF  \n            END FOR  \n            \n            SET right_subtree TO an empty list  \n            FOR each element x IN arr  \n                IF x GREATER THAN root THEN  \n                    APPEND x TO right_subtree  \n                END IF  \n            END FOR  \n            \n            SET ways_left TO the result of count_ways applied to left_subtree  \n            SET ways_right TO the result of count_ways applied to right_subtree  \n            \n            SET total_ways TO the combination of the sum of the LENGTH OF left_subtree AND the LENGTH OF right_subtree TAKEN the LENGTH OF left_subtree  \n            \n            RETURN the product of ways_left MULTIPLIED BY ways_right MULTIPLIED BY total_ways MODULO MOD  \n        END FUNCTION  \n        \n        RETURN the product of the result of count_ways applied to nums MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-all-possible-routes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countRoutes(locations, start, finish, fuel)  \n        SET MOD TO ten RAISED TO THE power OF nine PLUS seven  \n        SET n TO the LENGTH OF locations  \n        \n        FUNCTION dp(city, remaining_fuel)  \n            IF remaining_fuel LESS THAN zero THEN  \n                RETURN zero  \n            END IF  \n            SET routes TO zero  \n            IF city EQUALS finish THEN  \n                SET routes TO one  \n            END IF  \n            FOR each next_city FROM zero TO n MINUS one  \n                IF next_city NOT EQUALS city THEN  \n                    SET fuel_cost TO the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element AT position city OF locations AND the element AT position next_city OF locations  \n                    IF remaining_fuel GREATER THAN OR EQUAL TO fuel_cost THEN  \n                        SET routes TO the REMAINDER AFTER DIVISION OF the SUM OF routes AND the CALL OF dp WITH next_city AND remaining_fuel MINUS fuel_cost BY MOD  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN routes  \n        END FUNCTION  \n        \n        RETURN the CALL OF dp WITH start AND fuel  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO list of consecutive numbers from zero TO n inclusive  \n        SET self.rank TO list of zeros of length n plus one  \n        SET self.count TO n  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET rootU TO self.find(u)  \n        SET rootV TO self.find(v)  \n        IF rootU NOT EQUALS rootV  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank  \n                SET element at position rootV of self.parent TO rootU  \n            ELSE IF element at position rootU of self.rank LESS THAN element at position rootV of self.rank  \n                SET element at position rootU of self.parent TO rootV  \n            ELSE  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.rank BY one  \n            END IF  \n            DECREMENT self.count BY one  \n            RETURN True  \n        END IF  \n        RETURN False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION maxNumEdgesToRemove(self, n, edges)  \n        ASSIGN uf_common TO new UnionFind instance with parameter n  \n        ASSIGN uf_alice TO new UnionFind instance with parameter n  \n        ASSIGN uf_bob TO new UnionFind instance with parameter n  \n\n        SET used_edges TO zero  \n\n        FOR each element consisting of t u v IN edges  \n            IF t EQUALS three  \n                IF uf_common.union(u, v)  \n                    CALL uf_alice.union with parameters u and v  \n                    CALL uf_bob.union with parameters u and v  \n                    INCREMENT used_edges BY one  \n                END IF  \n            END IF  \n        END FOR  \n\n        FOR each element consisting of t u v IN edges  \n            IF t EQUALS one AND uf_alice.union(u, v)  \n                INCREMENT used_edges BY one  \n            ELSE IF t EQUALS two AND uf_bob.union(u, v)  \n                INCREMENT used_edges BY one  \n            END IF  \n        END FOR  \n\n        IF uf_alice.count EQUALS one AND uf_bob.count EQUALS one  \n            RETURN the LENGTH OF edges MINUS used_edges  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-string-is-transformable-with-substring-sort-operations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isTransformable WITH PARAMETERS s AND t  \n        CREATE a mapping from digit to a list of positions called pos  \n        FOR each position i AND character c IN s  \n            ADD position i TO the list corresponding to the digit represented by character c in pos  \n        END FOR  \n        FOR each position i AND character c IN t  \n            SET digit TO the digit represented by character c  \n            IF the list corresponding to digit in pos HAS NO elements THEN  \n                RETURN false  \n            END IF  \n            FOR each smaller digit FROM zero TO digit MINUS one  \n                IF the list corresponding to smaller digit in pos IS NOT empty AND the first element in that list IS LESS THAN the first element in the list for digit THEN  \n                    RETURN false  \n                END IF  \n            END FOR  \n            REMOVE the first element from the list corresponding to digit in pos  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strange-printer-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isPrintable(targetGrid)  \n        SET color_bounds TO a new dictionary with default value as list of four elements where the first two are positive infinity and the last two are negative infinity  \n        FOR r FROM zero TO the length of targetGrid MINUS one  \n            FOR c FROM zero TO the length of the element at position zero of targetGrid MINUS one  \n                SET color TO the element at position r of targetGrid at position c  \n                SET the first element of color_bounds at key color TO the minimum value BETWEEN the first element of color_bounds at key color AND r  \n                SET the second element of color_bounds at key color TO the minimum value BETWEEN the second element of color_bounds at key color AND c  \n                SET the third element of color_bounds at key color TO the maximum value BETWEEN the third element of color_bounds at key color AND r  \n                SET the fourth element of color_bounds at key color TO the maximum value BETWEEN the fourth element of color_bounds at key color AND c  \n            END FOR  \n        END FOR  \n        \n        SET graph TO a new dictionary with default value as an empty list  \n        SET in_degree TO a new dictionary with default value as zero  \n        \n        FOR each color AND its bounds unpacked as minr minc maxr maxc IN color_bounds  \n            FOR r FROM minr TO maxr  \n                FOR c FROM minc TO maxc  \n                    IF the element at position r of targetGrid at position c NOT EQUALS color THEN  \n                        SET other_color TO the element at position r of targetGrid at position c  \n                        APPEND color TO the list in graph at key other_color  \n                        INCREMENT the value in in_degree at key color BY one  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        SET queue TO a new deque initialized with all colors in color_bounds for which the corresponding value in in_degree EQUALS zero  \n        SET visited_colors TO zero  \n        \n        WHILE the queue is not empty  \n            SET color TO the element removed from the left side of queue  \n            INCREMENT visited_colors BY one  \n            FOR each next_color IN the list in graph at key color  \n                DECREMENT the value in in_degree at key next_color BY one  \n                IF the value in in_degree at key next_color EQUALS zero THEN  \n                    APPEND next_color TO the right side of queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN whether visited_colors EQUALS the number of keys in color_bounds  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-connect-two-groups-of-points", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION connectTwoGroups(cost)  \n        SET size1 TO the LENGTH OF cost  \n        SET size2 TO the LENGTH OF element at position zero of cost  \n        SET dp TO a two dimensional list with size1 PLUS one rows and two TO THE power OF size2 columns FILLED WITH infinity VALUE  \n        SET element at position zero at position zero of dp TO zero  \n        \n        FOR i FROM zero TO size1 MINUS one  \n            FOR mask FROM zero TO two TO THE power OF size2 MINUS one  \n                FOR j FROM zero TO size2 MINUS one  \n                    SET element at position i PLUS one at position mask ORED WITH two TO THE power OF j of dp TO the MINIMUM VALUE BETWEEN element at position i PLUS one at position mask ORED WITH two TO THE power OF j of dp AND the SUM OF element at position i at position mask of dp PLUS element at position i at position j of cost  \n                END FOR  \n                FOR j FROM zero TO size2 MINUS one  \n                    IF the BITWISE AND OF mask AND two TO THE power OF j IS NOT EQUAL TO zero  \n                        SET element at position i PLUS one at position mask of dp TO the MINIMUM VALUE BETWEEN element at position i PLUS one at position mask of dp AND the SUM OF element at position i PLUS one at position mask XORED WITH two TO THE power OF j of dp PLUS element at position i at position j of cost  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position size1 at position two TO THE power OF size2 MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-achievable-transfer-requests", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumRequests(n, requests)  \n        SET max_requests TO zero  \n        SET num_requests TO the LENGTH OF requests  \n        FOR mask FROM zero TO two MULTIPLIED BY num_requests MINUS one  \n            SET balance TO a list of zero repeated n times  \n            SET count TO zero  \n            FOR i FROM zero TO num_requests MINUS one  \n                IF the element at position i of the binary representation of mask EQUALS one THEN  \n                    SET from_building TO the element at position zero of the element at position i of requests  \n                    SET to_building TO the element at position one of the element at position i of requests  \n                    DECREMENT the element at position from_building of balance BY one  \n                    INCREMENT the element at position to_building of balance BY one  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n            IF for each element b in balance the element b EQUALS zero THEN  \n                SET max_requests TO the GREATER OF max_requests AND count  \n            END IF  \n        END FOR  \n        RETURN max_requests  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-visible-points", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION visiblePoints(points LIST OF LIST OF INTEGER angle INTEGER location LIST OF INTEGER) RETURNS INTEGER  \n        SET angles TO empty list  \n        SET extra_points TO zero  \n\n        FOR each point IN points  \n            SET x TO element at position zero of point  \n            SET y TO element at position one of point  \n            IF x EQUALS element at position zero of location AND y EQUALS element at position one of location  \n                INCREMENT extra_points BY one  \n                CONTINUE to next iteration  \n            END IF  \n            SET angle_rad TO arctangent of the expression of y MINUS element at position one of location AND x MINUS element at position zero of location  \n            SET angle_deg TO angle_rad converted to degrees  \n            APPEND angle_deg TO angles  \n        END FOR  \n\n        SORT angles in ascending order  \n\n        SET angles TO angles concatenated with each element in angles plus three hundred sixty  \n\n        SET max_visible TO zero  \n        SET left TO zero  \n\n        FOR right FROM zero TO the length of angles MINUS one  \n            WHILE element at position right of angles MINUS element at position left of angles GREATER THAN angle  \n                INCREMENT left BY one  \n            END WHILE  \n            SET max_visible TO the greater value between max_visible AND right MINUS left PLUS one  \n        END FOR  \n\n        RETURN max_visible PLUS extra_points  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-one-bit-operations-to-make-integers-zero", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumOneBitOperations WITH PARAMETER n  \n        IF n EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        SET k TO zero  \n        WHILE two RAISED TO THE power OF k PLUS one THAT IS LESS THAN OR EQUAL TO n HOLDS  \n            INCREMENT k BY one  \n        END WHILE  \n        SET most_significant_bit TO two RAISED TO THE power OF k  \n        RETURN two RAISED TO THE power OF k PLUS one MINUS one MINUS minimumOneBitOperations OF n EXCLUSIVE OR most_significant_bit  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-subtrees-with-max-distance-between-cities", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSubgraphsForEachDiameter(n parameter, edges parameter)  \n        SET graph TO an empty mapping from integer TO list of integers  \n        FOR each integer i FROM one TO n parameter  \n            SET the element at key i of graph TO an empty list  \n        END FOR  \n        FOR each pair u parameter AND v parameter IN edges parameter  \n            APPEND v parameter TO the element at key u parameter of graph  \n            APPEND u parameter TO the element at key v parameter of graph  \n        END FOR  \n        \n        FUNCTION bfs(subtree parameter)  \n            IMPORT deque FROM collections  \n            SET start TO an arbitrary element chosen from subtree parameter  \n            SET queue TO a deque initialized with start  \n            SET visited TO a set initialized with start  \n            SET distance TO zero  \n            SET farthest_node TO start  \n            \n            WHILE queue is not empty  \n                REMOVE the element from the front of queue AND ASSIGN it TO node  \n                FOR each neighbor IN the element at key node of graph  \n                    IF neighbor is in subtree parameter AND neighbor is not in visited THEN  \n                        ADD neighbor TO visited  \n                        APPEND neighbor TO queue  \n                        SET farthest_node TO neighbor  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a deque initialized with farthest_node  \n            SET visited TO a set initialized with farthest_node  \n            SET max_distance TO zero  \n            \n            WHILE queue is not empty  \n                SET size TO the number of elements in queue  \n                FOR counter FROM one TO size  \n                    REMOVE the element from the front of queue AND ASSIGN it TO node  \n                    FOR each neighbor IN the element at key node of graph  \n                        IF neighbor is in subtree parameter AND neighbor is not in visited THEN  \n                            ADD neighbor TO visited  \n                            APPEND neighbor TO queue  \n                        END IF  \n                    END FOR  \n                END FOR  \n                IF queue is not empty THEN  \n                    INCREMENT max_distance BY one  \n                END IF  \n            END WHILE  \n            \n            RETURN max_distance  \n        END FUNCTION  \n        \n        SET result TO a list of zeros with length n parameter MINUS one  \n        \n        FOR size FROM two TO n parameter  \n            FOR each subset IN combinations of the sequence of integers from one TO n parameter taken size at a time  \n                SET visited TO an empty set  \n                SET stack TO a list initialized with the first element of subset  \n                WHILE stack is not empty  \n                    REMOVE the last element from stack AND ASSIGN it TO node  \n                    IF node is not in visited THEN  \n                        ADD node TO visited  \n                        FOR each neighbor IN the element at key node of graph  \n                            IF neighbor is in subset AND neighbor is not in visited THEN  \n                                APPEND neighbor TO stack  \n                            END IF  \n                        END FOR  \n                    END IF  \n                END WHILE  \n                \n                IF visited EQUALS the set constructed from subset THEN  \n                    SET diameter TO bfs called with the set constructed from subset  \n                    IF diameter GREATER THAN zero THEN  \n                        INCREMENT the element at position diameter MINUS one of result BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rank-transform-of-a-matrix", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO the result of calling self.find with element at position u of self.parent  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET root_u TO the result of calling self.find with u  \n        SET root_v TO the result of calling self.find with v  \n        IF root_u NOT EQUALS root_v THEN  \n            SET element at position root_u of self.parent TO root_v  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION matrixRankTransform(self, matrix)  \n        SET m TO length of matrix  \n        SET n TO length of element at position zero of matrix  \n        SET value_to_indices TO a new mapping with default of empty list  \n          \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                APPEND tuple consisting of r and c TO the list at key element at position r of matrix AT position c of value_to_indices  \n            END FOR  \n        END FOR  \n          \n        SET row_rank TO a list of zeros of length m  \n        SET col_rank TO a list of zeros of length n  \n        SET result TO a list of lists consisting of zeros with m elements each containing n elements  \n          \n        FOR value IN the sorted list of keys in value_to_indices  \n            ASSIGN uf TO a new UnionFind object initialized with m PLUS n  \n            SET rank TO a new mapping with default of integer zero  \n              \n            FOR each tuple consisting of r and c IN the list at key value of value_to_indices  \n                CALL uf.union with r AND c PLUS m  \n            END FOR  \n              \n            FOR each tuple consisting of r and c IN the list at key value of value_to_indices  \n                SET root TO the result of calling uf.find with r  \n                SET element at key root of rank TO the maximum between element at key root of rank AND the maximum between element at position r of row_rank AND element at position c of col_rank PLUS one  \n            END FOR  \n              \n            FOR each tuple consisting of r and c IN the list at key value of value_to_indices  \n                SET root TO the result of calling uf.find with r  \n                SET element at position r of result at position c TO element at key root of rank  \n                SET element at position r of row_rank TO element at key root of rank  \n                SET element at position c of col_rank TO element at key root of rank  \n            END FOR  \n        END FOR  \n          \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-form-a-target-string-given-a-dictionary", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numWays(words WITH TYPE List of string, target WITH TYPE string) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF element at position zero of words  \n        SET m TO the LENGTH OF target  \n        \n        SET freq TO list containing n elements each being a mapping from character to zero integer  \n        \n        FOR each word IN words  \n            FOR each position j AND character char IN word  \n                INCREMENT value at character char IN freq at position j BY one  \n            END FOR  \n        END FOR  \n        \n        SET dp TO two dimensional list with m PLUS one rows AND n PLUS one columns filled with zero integer  \n        \n        FOR each position j FROM zero TO n  \n            SET element at row zero AND column j of dp TO one  \n        END FOR  \n        \n        FOR each position i FROM one TO m  \n            FOR each position j FROM one TO n  \n                SET element at row i AND column j of dp TO element at row i AND column j MINUS one of dp  \n                IF value at character at position i MINUS one of target IN freq at position j MINUS one GREATER THAN zero  \n                    INCREMENT element at row i AND column j of dp BY element at row i MINUS one AND column j MINUS one of dp MULTIPLIED BY value at character at position i MINUS one of target IN freq at position j MINUS one  \n                    SET element at row i AND column j of dp TO element at row i AND column j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at row m AND column n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-instructions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPath(destination PARAMETERS destination AND k)  \n        SET row TO element at position zero of destination  \n        SET col TO element at position one of destination  \n        SET path TO empty list  \n        SET total_moves TO col PLUS row  \n        FOR i FROM zero TO total_moves MINUS one  \n            IF col GREATER THAN zero  \n                SET paths_with_H TO the number of combinations of row PLUS col MINUS one TAKEN col MINUS one  \n                IF k LESS THAN OR EQUAL TO paths_with_H  \n                    APPEND character H TO path  \n                    DECREMENT col BY one  \n                ELSE  \n                    APPEND character V TO path  \n                    DECREMENT row BY one  \n                    DECREMENT k BY paths_with_H  \n                END IF  \n            ELSE  \n                APPEND character V TO path  \n                DECREMENT row BY one  \n            END IF  \n        END FOR  \n        RETURN concatenation of all elements in path as a string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "create-sorted-array-through-instructions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET MAX TO the maximum element of instructions PLUS one  \n        SET bit TO a list of zeros with length MAX  \n\n        FUNCTION update(idx val)  \n            WHILE idx LESS THAN MAX holds  \n                INCREMENT element at position idx of bit BY val  \n                INCREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            SET total TO zero  \n            WHILE idx GREATER THAN zero holds  \n                INCREMENT total BY element at position idx of bit  \n                DECREMENT idx BY the value of idx AND the negative of idx  \n            END WHILE  \n            RETURN total  \n        END FUNCTION  \n\n        SET total_cost TO zero  \n        FOR each pair of i num IN the enumeration of instructions  \n            SET less_than TO the result of query with argument num MINUS one  \n            SET greater_than TO i MINUS the result of query with argument num  \n            IF less_than LESS THAN OR EQUAL TO greater_than holds  \n                SET cost TO less_than  \n            ELSE  \n                SET cost TO greater_than  \n            END IF  \n            SET total_cost TO the remainder of total_cost PLUS cost DIVIDED BY MOD  \n            CALL update with arguments num and one  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distribute-repeating-integers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canDistribute(nums PARAMETER, quantity PARAMETER)  \n        SET count TO the list of frequencies of each element in nums  \n        SORT quantity IN descending order  \n        \n        FUNCTION can_satisfy(index PARAMETER)  \n            IF index EQUALS the length of quantity THEN  \n                RETURN True  \n            END IF  \n            FOR i FROM zero TO the length of count MINUS one  \n                IF the element at position i of count GREATER THAN OR EQUAL TO the element at position index of quantity THEN  \n                    DECREMENT the element at position i of count BY the element at position index of quantity  \n                    IF can_satisfy(index PLUS one) RETURNS True THEN  \n                        RETURN True  \n                    END IF  \n                    INCREMENT the element at position i of count BY the element at position index of quantity  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_satisfy(zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-initial-energy-to-finish-tasks", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumEffort(tasks)  \n        SORT tasks IN ORDER WHERE the element representing the difference between the second element MINUS the first element of each task IS IN DESCENDING ORDER  \n        SET current_energy TO zero  \n        SET required_initial_energy TO zero  \n        FOR each element IN tasks  \n            ASSIGN actual TO the first element of element  \n            ASSIGN minimum TO the second element of element  \n            IF current_energy LESS THAN minimum THEN  \n                INCREMENT required_initial_energy BY minimum MINUS current_energy  \n                SET current_energy TO minimum  \n            END IF  \n            DECREMENT current_energy BY actual  \n        END FOR  \n        RETURN required_initial_energy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-removals-to-make-mountain-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumMountainRemovals(nums)  \n        SET n TO the LENGTH OF nums  \n        \n        SET lis TO a list of LENGTH n with each element set to one  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF element at position i of nums GREATER THAN element at position j of nums  \n                    SET lis at position i TO the GREATER VALUE BETWEEN lis at position i AND lis at position j PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET lds TO a list of LENGTH n with each element set to one  \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                IF element at position i of nums GREATER THAN element at position j of nums  \n                    SET lds at position i TO the GREATER VALUE BETWEEN lds at position i AND lds at position j PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET max_mountain_length TO zero  \n        FOR i FROM one TO n MINUS two  \n            IF lis at position i GREATER THAN one AND lds at position i GREATER THAN one  \n                SET max_mountain_length TO the GREATER VALUE BETWEEN max_mountain_length AND lis at position i PLUS lds at position i MINUS one  \n            END IF  \n        END FOR  \n        \n        RETURN n MINUS max_mountain_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-deviation-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeviation(nums)  \n        SET max_heap TO empty list  \n        SET min_value TO positive infinity  \n        \n        FOR each num IN nums  \n            IF element at position one of num MODULO two EQUALS one  \n                SET num TO num MULTIPLIED BY two  \n            END IF  \n            IF min_value GREATER THAN num  \n                SET min_value TO num  \n            END IF  \n            APPEND negative num TO max_heap maintaining heap property  \n        END FOR  \n        \n        SET min_deviation TO positive infinity  \n        \n        WHILE element at position one of element at position one of max_heap MODULO two EQUALS zero  \n            SET max_value TO negative of top element removed from max_heap maintaining heap property  \n            IF min_deviation GREATER THAN max_value MINUS min_value  \n                SET min_deviation TO max_value MINUS min_value  \n            END IF  \n            SET max_value TO max_value DIVIDED BY two  \n            IF min_value GREATER THAN max_value  \n                SET min_value TO max_value  \n            END IF  \n            APPEND negative max_value TO max_heap maintaining heap property  \n        END WHILE  \n        \n        IF min_deviation GREATER THAN negative of top element at max_heap MINUS min_value  \n            SET min_deviation TO negative of top element at max_heap MINUS min_value  \n        END IF  \n        \n        RETURN min_deviation  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-incompatibility", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        CREATE counter_object AS a COUNT of each element IN nums  \n        IF any count IN the VALUES OF counter_object is GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        CREATE empty dictionary subset_incompatibility  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask  \n            IF bit_count EQUALS subset_size THEN  \n                CREATE empty list elements  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BITWISE AND OF mask AND TWO RAISED TO THE POWER OF i is NOT EQUAL TO zero THEN  \n                        APPEND element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the NUMBER OF UNIQUE ELEMENTS IN elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM ELEMENT IN elements MINUS the MINIMUM ELEMENT IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT key mask  \n                END IF  \n            END IF  \n        END FOR  \n        CREATE list dp WITH LENGTH TWO RAISED TO THE POWER OF n FILLED WITH infinity  \n        SET dp AT position zero TO zero  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            IF the REMAINDER OF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask DIVIDED BY subset_size IS NOT EQUAL TO zero THEN  \n                CONTINUE TO the NEXT iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND OF mask AND subset_mask EQUALS subset_mask THEN  \n                    SET candidate_value TO dp AT position mask MINUS subset_mask PLUS subset_incompatibility AT subset_mask  \n                    IF candidate_value IS LESS THAN dp AT position mask THEN  \n                        SET dp AT position mask TO candidate_value  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET full_mask TO TWO RAISED TO THE POWER OF n MINUS one  \n        IF dp AT position full_mask IS NOT EQUAL TO infinity THEN  \n            RETURN dp AT position full_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delivering-boxes-from-storage-to-ports", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION boxDelivering(boxes PORTSCOUNT maxBoxes maxWeight)  \n        SET n TO the LENGTH OF boxes  \n        SET dp TO a list of length n PLUS one with all elements SET TO positive infinity  \n        SET element at position zero of dp TO zero  \n        \n        SET left TO zero  \n        SET current_weight TO zero  \n        SET extra_trips TO zero  \n        \n        FOR right FROM zero TO n MINUS one  \n            INCREMENT current_weight BY the element at position one of element at position right of boxes  \n            IF right GREATER THAN zero AND the element at position zero of element at position right of boxes NOT EQUALS the element at position zero of element at position right MINUS one of boxes  \n                INCREMENT extra_trips BY one  \n            END IF  \n            \n            WHILE left LESS THAN OR EQUAL TO right AND (right MINUS left PLUS one GREATER THAN maxBoxes OR current_weight GREATER THAN maxWeight)  \n                DECREMENT current_weight BY the element at position one of element at position left of boxes  \n                IF left GREATER THAN zero AND the element at position zero of element at position left of boxes NOT EQUALS the element at position zero of element at position left MINUS one of boxes  \n                    DECREMENT extra_trips BY one  \n                END IF  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            SET element at position right PLUS one of dp TO element at position left of dp PLUS two PLUS extra_trips  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-height-by-stacking-cuboids", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxHeight(cuboids)  \n        FOR each cuboid IN cuboids  \n            SORT the dimensions of cuboid in non-decreasing order  \n        END FOR  \n        SORT cuboids in lexicographical order based on their dimensions  \n        SET n TO the LENGTH OF cuboids  \n        CREATE a list named dp with n elements all initialized to zero  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i of dp TO the height dimension of cuboid at position i  \n            FOR j FROM zero TO i MINUS one  \n                IF the first dimension of cuboid at position j LESS THAN OR EQUAL TO the first dimension of cuboid at position i AND  \n                   the second dimension of cuboid at position j LESS THAN OR EQUAL TO the second dimension of cuboid at position i AND  \n                   the third dimension of cuboid at position j LESS THAN OR EQUAL TO the third dimension of cuboid at position i THEN  \n                    SET element at position i of dp TO the maximum of element at position i of dp AND element at position j of dp PLUS the height dimension of cuboid at position i  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the maximum element in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-adjacent-swaps-for-k-consecutive-ones", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMoves(nums, k)  \n        SET positions TO empty list  \n        FOR each index i IN range from zero TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums EQUALS one  \n                APPEND i TO positions  \n            END IF  \n        END FOR  \n        \n        FUNCTION calculate_cost(start, end)  \n            SET mid TO start PLUS end DIVIDED BY two using integer division  \n            SET median TO element at position mid of positions  \n            SET cost TO zero  \n            FOR each index i FROM start TO end MINUS one  \n                SET difference TO the ABSOLUTE VALUE OF element at position i of positions MINUS median PLUS mid MINUS i  \n                INCREMENT cost BY difference  \n            END FOR  \n            RETURN cost  \n        END FUNCTION  \n        \n        SET min_cost TO positive infinity  \n        FOR each index i FROM zero TO the LENGTH OF positions MINUS k  \n            SET current_cost TO calculate_cost with arguments i and i PLUS k  \n            IF current_cost LESS THAN min_cost  \n                SET min_cost TO current_cost  \n            END IF  \n        END FOR  \n        \n        RETURN min_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-xor-with-an-element-from-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximizeXor(nums PARAMETER, queries PARAMETER)  \n        CALL sort on nums to arrange numbers in ascending order  \n        \n        CALL sorted on enumeration of queries with sorting key as the second element of query sublist to arrange queries in ascending order by the maximum value parameter  \n        ASSIGN sorted_queries TO this sorted result  \n        \n        INITIALIZE result as a list with the length equal to the length of queries filled with negative one  \n        \n        INITIALIZE an empty dictionary named trie  \n        \n        SET num_index TO zero  \n        \n        FOR each query_index and a tuple of two elements xi and mi IN sorted_queries  \n            WHILE num_index is less than the length of nums AND the element at position num_index of nums is LESS THAN OR EQUAL TO mi  \n                SET num TO element at position num_index of nums  \n                ASSIGN reference TO trie in variable named node  \n                \n                FOR i FROM thirty-one DOWN TO zero  \n                    SET bit TO the integer value of num DIVIDED BY two RAISED TO power i THEN TAKE the remainder after division by two  \n                    IF bit NOT IN keys of node  \n                        SET element at key bit of node TO an empty dictionary  \n                    END IF  \n                    ASSIGN reference TO element at key bit of node  \n                END FOR  \n                \n                INCREMENT num_index BY one  \n            END WHILE  \n            \n            IF trie IS empty  \n                CONTINUE to next iteration of FOR loop  \n            END IF  \n            \n            ASSIGN reference TO trie in variable named node  \n            SET max_xor TO zero  \n            \n            FOR i FROM thirty-one DOWN TO zero  \n                SET bit TO the integer value of xi DIVIDED BY two RAISED TO power i THEN TAKE the remainder after division by two  \n                SET toggle_bit TO one MINUS bit  \n                \n                IF toggle_bit IN keys of node  \n                    SET max_xor TO max_xor PLUS two RAISED TO power i  \n                    ASSIGN reference TO element at key toggle_bit of node  \n                ELSE  \n                    ASSIGN reference TO element at key bit of node  \n                END IF  \n            END FOR  \n            \n            SET element at position query_index of result TO max_xor  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-operations-to-make-a-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minOperations(target, arr)  \n        SET index_map TO an empty collection mapping values to indices  \n        FOR each index FROM the first position TO the last position IN target  \n            SET value TO element at position index of target  \n            SET index_map at key value TO index  \n        END FOR  \n  \n        SET transformed_arr TO an empty list  \n        FOR each value IN arr  \n            IF value IS IN index_map  \n                APPEND index_map at key value TO transformed_arr  \n            END IF  \n        END FOR  \n  \n        SET lis TO an empty list  \n        FOR each num IN transformed_arr  \n            SET pos TO the position to insert num into lis keeping lis sorted in ascending order using binary search  \n            IF pos EQUALS the LENGTH OF lis  \n                APPEND num TO lis  \n            ELSE  \n                SET element at position pos of lis TO num  \n            END IF  \n        END FOR  \n  \n        SET lcs_length TO the LENGTH OF lis  \n        RETURN the LENGTH OF target MINUS lcs_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-special-evenly-spaced-elements-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solve(nums list OF integers queries list OF list OF integers) RETURNS list OF integers  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF nums  \n        SET max_y TO the HIGHEST y VALUE FROM each pair IN queries  \n        SET prefix_sums TO a list CONTAINING max_y PLUS one ELEMENTS each BEING a list OF n zeroes  \n        \n        FOR y FROM one TO max_y  \n            FOR i FROM n MINUS one DOWN TO zero  \n                IF i PLUS y LESS THAN n THEN  \n                    SET element at position i of element at position y of prefix_sums TO element at position i of nums PLUS element at position i PLUS y of element at position y of prefix_sums  \n                ELSE  \n                    SET element at position i of element at position y of prefix_sums TO element at position i of nums  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET answer TO an empty list  \n        FOR each pair x y IN queries  \n            APPEND element at position x of element at position y of prefix_sums MODULO MOD TO answer  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-reconstruct-a-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkWays(pairs)  \n        SET graph TO a new default dictionary of sets  \n        FOR each element x AND each element y IN pairs  \n            ADD element y TO the set corresponding to element x in graph  \n            ADD element x TO the set corresponding to element y in graph  \n        END FOR  \n          \n        SET max_degree TO the element in graph with the maximum size of the set mapped by that element in graph  \n        SET n TO the SIZE OF graph  \n          \n        IF the SIZE OF the set mapped by max_degree in graph NOT EQUALS n MINUS one  \n            RETURN zero  \n        END IF  \n          \n        FUNCTION can_be_parent(u v)  \n            FOR each element neighbor IN the set mapped by element v in graph  \n                IF element neighbor NOT IN the set mapped by element u in graph AND element neighbor NOT EQUALS element u  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n          \n        SET ways TO one  \n          \n        FOR each element u IN graph  \n            IF element u EQUALS max_degree  \n                CONTINUE to next iteration of the loop  \n            END IF  \n            SET parent TO null  \n            FOR each element v IN the set mapped by element u in graph  \n                IF element v IN graph AND the SIZE OF the set mapped by element v in graph GREATER THAN OR EQUAL TO the SIZE OF the set mapped by element u in graph AND can_be_parent with arguments element v AND element u RETURNS true  \n                    IF parent IS null OR the SIZE OF set mapped by element v in graph LESS THAN the SIZE OF set mapped by element parent in graph  \n                        SET parent TO element v  \n                    END IF  \n                END IF  \n            END FOR  \n            IF parent IS null  \n                RETURN zero  \n            END IF  \n            IF the SIZE OF set mapped by element parent in graph EQUALS the SIZE OF set mapped by element u in graph  \n                SET ways TO two  \n            END IF  \n        END FOR  \n          \n        RETURN ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the LIST of MINUS one zero ONE zero MINUS one  \n        SET g_mouse TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n        SET g_cat TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n\n        FOR each index i AND element row IN the ENUMERATION OF grid  \n            FOR each index j AND element c IN the ENUMERATION OF row  \n                IF c EQUALS the character representing a HASH  \n                    CONTINUE  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character representing uppercase C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character representing uppercase M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character representing uppercase F  \n                    SET food TO v  \n                END IF  \n                FOR each element a AND next element b IN consecutive pairs of dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the RESULT OF calling calc WITH g_mouse, g_cat, mouse_start, cat_start, food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            SET m TO element at position zero of state  \n            SET c TO element at position one of state  \n            SET t TO element at position two of state  \n            SET pt TO the EXCLUSIVE OR of t AND one  \n            SET pre TO an empty LIST  \n            IF pt EQUALS one  \n                FOR each pc IN element at position c of g_cat  \n                    IF element at position m AND position pc AND position one of ans EQUALS zero  \n                        APPEND the TUPLE of m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN element at position m of g_mouse  \n                    IF element at position pm AND position c AND position zero of ans EQUALS zero  \n                        APPEND the TUPLE of pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET element at position zero of element at position j of element at position i of degree TO the LENGTH OF element at position i of g_mouse  \n                SET element at position one of element at position j of element at position i of degree TO the LENGTH OF element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position hole AND position i AND position one of ans TO one  \n            SET element at position i AND position hole AND position zero of ans TO two  \n            SET element at position i AND position i AND position one of ans TO two  \n            SET element at position i AND position i AND position zero of ans TO two  \n            ADD the TUPLE of hole i one TO the end of q  \n            ADD the TUPLE of i hole zero TO the end of q  \n            ADD the TUPLE of i i zero TO the end of q  \n            ADD the TUPLE of i i one TO the end of q  \n        END FOR  \n        WHILE q is not empty  \n            REMOVE the element from the front of q AND ASSIGN to state  \n            SET t TO element at position zero AND position one AND position two of ans ACCORDING TO state  \n            FOR each prev_state IN get_prev_states WITH state  \n                SET pm TO element at position zero of prev_state  \n                SET pc TO element at position one of prev_state  \n                SET pt TO element at position two of prev_state  \n                IF pt EQUALS t MINUS one  \n                    SET element at position pm AND position pc AND position pt of ans TO t  \n                    ADD prev_state TO the end of q  \n                ELSE  \n                    DECREMENT element at position pm AND position pc AND position pt of degree BY one  \n                    IF element at position pm AND position pc AND position pt of degree EQUALS zero  \n                        SET element at position pm AND position pc AND position pt of ans TO t  \n                        ADD prev_state TO the end of q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN element at position mouse_start AND position cat_start AND position zero of ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "building-boxes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumBoxes(n)  \n        FUNCTION triangular_pyramid(k)  \n            SET product_of_k_and_next TO k MULTIPLIED BY the sum of k PLUS one  \n            SET product_of_three_consecutive TO product_of_k_and_next MULTIPLIED BY the sum of k PLUS two  \n            SET result TO product_of_three_consecutive DIVIDED BY six  \n            RETURN result  \n        END FUNCTION  \n\n        SET left TO zero  \n        SET right TO n  \n\n        WHILE left LESS THAN right  \n            SET mid TO the sum of left PLUS right PLUS one DIVIDED BY two  \n            IF triangular_pyramid(mid) LESS THAN OR EQUAL TO n  \n                SET left TO mid  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n\n        SET boxes_used TO triangular_pyramid(left)  \n        SET remaining TO n MINUS boxes_used  \n        SET floor_boxes TO the product of left MULTIPLIED BY the sum of left PLUS one DIVIDED BY two  \n\n        SET additional_boxes TO zero  \n        WHILE remaining GREATER THAN zero  \n            INCREMENT additional_boxes BY one  \n            DECREMENT remaining BY additional_boxes  \n        END WHILE  \n\n        RETURN the sum of floor_boxes PLUS additional_boxes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkPartitioning(s)  \n        FUNCTION is_palindrome(sub)  \n            RETURN the substring sub EQUALS the reverse of substring sub  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF s  \n        \n        SET is_pal TO a two dimensional collection of size n by n with all values set TO false  \n        \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM i TO n MINUS one  \n                IF the character at position i of s EQUALS the character at position j of s AND  \n                   the difference of j MINUS i LESS THAN OR EQUAL TO one OR the value at position i PLUS one and j MINUS one in is_pal EQUALS true  \n                THEN  \n                    SET the value at position i and j in is_pal TO true  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM one TO n MINUS two  \n            IF the value at position zero and i MINUS one in is_pal EQUALS true  \n            THEN  \n                FOR j FROM i TO n MINUS two  \n                    IF the value at position i and j in is_pal EQUALS true AND the value at position j PLUS one and n MINUS one in is_pal EQUALS true  \n                    THEN  \n                        RETURN true  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-events-that-can-be-attended-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxValue(events parameter LIST OF LIST OF INTEGER, k parameter INTEGER) RETURNS INTEGER  \n        CALL events sort BY the second element of each event  \n        SET n TO the LENGTH OF events  \n        SET dp TO a list composed of n PLUS one elements WHERE each element is a list composed of k PLUS one zeros  \n        \n        FOR i FROM one TO n  \n            SET start TO the first element of the event at position i MINUS one of events  \n            SET end TO the second element of the event at position i MINUS one of events  \n            SET value TO the third element of the event at position i MINUS one of events  \n            \n            SET j TO the result of finding the position using binary search in events WHERE the second element of the event EQUALS OR IS GREATER THAN start  \n            \n            FOR l FROM one TO k  \n                IF the value at position i MINUS one and position l in dp IS GREATER THAN OR EQUAL TO the value at position j and position l MINUS one in dp PLUS value THEN  \n                    SET the value at position i and position l in dp TO the value at position i MINUS one and position l in dp  \n                ELSE  \n                    SET the value at position i and position l in dp TO the value at position j and position l MINUS one in dp PLUS value  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN the value at position n and position k in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-subsequence-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minAbsDifference(nums goal)  \n        SET n TO the LENGTH OF nums  \n        SET mid TO n DIVIDED BY two  \n        \n        SET left_sums TO a LIST CONTAINING zero  \n        FOR each num IN the ELEMENTS FROM POSITION one TO POSITION mid OF nums  \n            SET new_sums TO an EMPTY LIST  \n            FOR each s IN left_sums  \n                APPEND s PLUS num TO new_sums  \n            END FOR  \n            EXTEND left_sums BY new_sums  \n        END FOR  \n        \n        SET right_sums TO a LIST CONTAINING zero  \n        FOR each num IN the ELEMENTS FROM POSITION mid PLUS one TO the END OF nums  \n            SET new_sums TO an EMPTY LIST  \n            FOR each s IN right_sums  \n                APPEND s PLUS num TO new_sums  \n            END FOR  \n            EXTEND right_sums BY new_sums  \n        END FOR  \n        \n        SORT right_sums IN ASCENDING ORDER  \n        \n        SET min_diff TO positive infinity  \n        \n        FOR each left_sum IN left_sums  \n            SET target TO goal MINUS left_sum  \n            SET pos TO the POSITION FOUND BY BINARY SEARCH FOR target IN right_sums RETURNING the LEFTMOST INSERTION POINT  \n            \n            IF pos IS LESS THAN the LENGTH OF right_sums  \n                SET min_diff TO THE MINIMUM OF min_diff AND THE ABSOLUTE VALUE OF left_sum PLUS the ELEMENT AT POSITION pos OF right_sums MINUS goal  \n            END IF  \n            IF pos IS GREATER THAN zero  \n                SET min_diff TO THE MINIMUM OF min_diff AND THE ABSOLUTE VALUE OF left_sum PLUS the ELEMENT AT POSITION pos MINUS one OF right_sums MINUS goal  \n            END IF  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-from-performing-multiplication-operations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(nums LIST OF INTEGER multipliers LIST OF INTEGER) RETURNS INTEGER  \n        SET m TO the LENGTH OF multipliers  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a LIST OF INTEGER OF SIZE m PLUS one FILLED WITH zero  \n        FOR i FROM m MINUS one TO zero DECREMENT BY one  \n            SET new_dp TO a LIST OF INTEGER OF SIZE m PLUS one FILLED WITH zero  \n            FOR left FROM zero TO i  \n                SET right TO n MINUS one MINUS i MINUS left MINUS MINUS left  \n                SET mul TO the element at position i of multipliers  \n                SET value_from_left TO mul MULTIPLIED BY the element at position left of nums PLUS the element at position left PLUS one of dp  \n                SET value_from_right TO mul MULTIPLIED BY the element at position right of nums PLUS the element at position left of dp  \n                IF value_from_left GREATER THAN value_from_right  \n                    SET the element at position left of new_dp TO value_from_left  \n                ELSE  \n                    SET the element at position left of new_dp TO value_from_right  \n                END IF  \n            END FOR  \n            SET dp TO new_dp  \n        END FOR  \n        RETURN the element at position zero of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-palindrome-length-from-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindrome(word1, word2)  \n        SET s TO the concatenation of word1 AND word2  \n        SET n TO the LENGTH OF s  \n        SET dp TO a two dimensional list of size n BY n FILLED WITH zeros  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i AND i OF dp TO one  \n        END FOR  \n        \n        SET max_len TO zero  \n        FOR length FROM two TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                IF element at position i OF s EQUALS element at position j OF s  \n                    SET element at position i AND j OF dp TO element at position i PLUS one AND j MINUS one OF dp PLUS two  \n                    IF i LESS THAN the LENGTH OF word1 AND j GREATER THAN OR EQUAL TO the LENGTH OF word1  \n                        SET max_len TO the GREATER OF max_len AND element at position i AND j OF dp  \n                    END IF  \n                ELSE  \n                    SET element at position i AND j OF dp TO the GREATER OF element at position i PLUS one AND j OF dp AND element at position i AND j MINUS one OF dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_len  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "car-fleet-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getCollisionTimes WITH PARAMETER cars  \n        SET n TO the LENGTH OF cars  \n        SET result TO a list of LENGTH n where each element is negative one point zero  \n        SET stack TO an empty list  \n        \n        FOR i FROM n MINUS one TO zero DECREMENTING BY one  \n            SET pos TO the element at position zero of the element at position i of cars  \n            SET speed TO the element at position one of the element at position i of cars  \n            \n            WHILE the LENGTH OF stack IS GREATER THAN zero  \n                SET next_index TO the element at the last position of stack  \n                SET next_pos TO the element at position zero of the element at position next_index of cars  \n                SET next_speed TO the element at position one of the element at position next_index of cars  \n                \n                IF speed IS LESS THAN OR EQUAL TO next_speed  \n                    REMOVE the last element FROM stack  \n                    CONTINUE to the next iteration of the WHILE loop  \n                END IF  \n                \n                SET collision_time TO the difference of next_pos MINUS pos DIVIDED BY the difference of speed MINUS next_speed  \n                \n                IF the element at position next_index of result IS GREATER THAN zero AND collision_time IS GREATER THAN OR EQUAL TO the element at position next_index of result  \n                    REMOVE the last element FROM stack  \n                    CONTINUE to the next iteration of the WHILE loop  \n                END IF  \n                \n                SET the element at position i of result TO collision_time  \n                BREAK from the WHILE loop  \n            END WHILE  \n            \n            APPEND i TO stack  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-pairs-of-nodes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(n, edges, queries)  \n        SET degree TO list containing zero repeated n PLUS one times  \n        FOR each pair u v IN edges  \n            INCREMENT element at position u of degree BY one  \n            INCREMENT element at position v of degree BY one  \n        END FOR  \n      \n        SET shared TO an empty map with default value zero  \n        FOR each pair u v IN edges  \n            IF u GREATER THAN v THEN  \n                SET temporary TO u  \n                SET u TO v  \n                SET v TO temporary  \n            END IF  \n            INCREMENT element at key consisting of pair u and v of shared BY one  \n        END FOR  \n      \n        SET sorted_degree TO the list degree arranged in ascending order  \n      \n        SET answers TO an empty list  \n        FOR each element q IN queries  \n            SET count TO zero  \n            SET left TO one  \n            SET right TO n  \n            WHILE left LESS THAN right DO  \n                IF element at position left of sorted_degree PLUS element at position right of sorted_degree GREATER THAN q THEN  \n                    INCREMENT count BY right MINUS left  \n                    DECREMENT right BY one  \n                ELSE  \n                    INCREMENT left BY one  \n                END IF  \n            END WHILE  \n          \n            FOR each pair u v AND count_uv IN elements of shared  \n                SET degree_uv TO element at position u of degree PLUS element at position v of degree  \n                IF degree_uv GREATER THAN q AND degree_uv MINUS count_uv LESS THAN OR EQUAL TO q THEN  \n                    DECREMENT count BY one  \n                END IF  \n            END FOR  \n          \n            APPEND count TO answers  \n        END FOR  \n      \n        RETURN answers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-of-a-good-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(nums k)  \n        SET left TO k  \n        SET right TO k  \n        SET current_min TO element at position k of nums  \n        SET max_score TO current_min  \n        WHILE left GREATER THAN zero OR right LESS THAN the LENGTH OF nums MINUS one  \n            IF left EQUALS zero  \n                INCREMENT right BY one  \n            ELSE IF right EQUALS the LENGTH OF nums MINUS one  \n                DECREMENT left BY one  \n            ELSE IF element at position left MINUS one of nums GREATER THAN OR EQUAL TO element at position right PLUS one of nums  \n                DECREMENT left BY one  \n            ELSE  \n                INCREMENT right BY one  \n            END IF  \n            SET current_min TO the minimum value AMONG current_min AND element at position left of nums AND element at position right of nums  \n            SET score TO current_min MULTIPLIED BY the LENGTH OF THE WINDOW FROM left TO right CALCULATED AS right MINUS left PLUS one  \n            SET max_score TO the maximum value AMONG max_score AND score  \n        END WHILE  \n        RETURN max_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-number-of-nice-divisors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxNiceDivisors(primeFactors)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        \n        IF primeFactors LESS THAN OR EQUAL TO three  \n            RETURN primeFactors  \n        END IF  \n        \n        SET num_threes TO integer division of primeFactors BY three  \n        SET remainder TO primeFactors MINUS num_threes MULTIPLIED BY three  \n        \n        IF remainder EQUALS zero  \n            RETURN the result of three raised to the power of num_threes taken modulo MOD  \n        ELSE IF remainder EQUALS one  \n            RETURN the result of three raised to the power of num_threes MINUS one taken modulo MOD MULTIPLIED BY four taken modulo MOD  \n        ELSE  \n            RETURN the result of three raised to the power of num_threes taken modulo MOD MULTIPLIED BY two taken modulo MOD  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-groups-getting-fresh-donuts", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxHappyGroups(batchSize, groups)  \n        IF batchSize EQUALS one  \n            RETURN the LENGTH OF groups  \n        END IF  \n\n        SET remainder_count TO list of zero repeated batchSize times  \n\n        FOR each group IN groups  \n            SET remainder_index TO the element at position group MINUS (the MULTIPLIED BY floor division of group by batchSize) MULTIPLIED BY batchSize  \n            INCREMENT element at position remainder_index of remainder_count BY one  \n        END FOR  \n\n        FUNCTION dp(remainder, variable number of remainder_count_elements)  \n            SET remainder_count TO the list of remainder_count_elements  \n            SET max_happy TO zero  \n\n            FOR index FROM zero TO batchSize MINUS one  \n                IF element at position index of remainder_count EQUALS zero  \n                    CONTINUE to next iteration  \n                END IF  \n\n                DECREMENT element at position index of remainder_count BY one  \n                SET new_remainder TO remainder MINUS index PLUS batchSize MULTIPLIED BY two (to ensure positive) MINUS ( (remainder MINUS index) DIVIDED BY batchSize MULTIPLIED BY batchSize )  \n\n                IF remainder EQUALS zero  \n                    SET happy_groups TO one PLUS dp(new_remainder, all elements of remainder_count)  \n                ELSE  \n                    SET happy_groups TO dp(new_remainder, all elements of remainder_count)  \n                END IF  \n\n                IF happy_groups GREATER THAN max_happy  \n                    SET max_happy TO happy_groups  \n                END IF  \n\n                INCREMENT element at position index of remainder_count BY one  \n            END FOR  \n\n            RETURN max_happy  \n        END FUNCTION  \n\n        RETURN dp(zero, all elements of remainder_count)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-different-subsequences-gcds", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET max_num TO the maximum value in nums  \n        SET num_set TO the set of elements in nums  \n        SET count TO zero  \n        FOR g FROM one TO max_num INCLUSIVE  \n            SET gcd_val TO zero  \n            FOR m FROM g TO max_num INCLUSIVE IN STEPS OF g  \n                IF element at position m of num_set IS PRESENT  \n                    SET gcd_val TO the greatest common divisor of gcd_val AND m  \n                    IF gcd_val EQUALS g  \n                        INCREMENT count BY one  \n                        BREAK out of inner loop  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-xor-sum-of-all-pairs-bitwise-and", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getXORSum(arr1 arr1 IS A LIST OF INTEGER arr2 arr2 IS A LIST OF INTEGER) RETURNS INTEGER  \n        SET xor_sum_arr1 TO zero  \n        SET xor_sum_arr2 TO zero  \n        FOR each num IN arr1  \n            SET xor_sum_arr1 TO the exclusive or of xor_sum_arr1 AND num  \n        END FOR  \n        FOR each num IN arr2  \n            SET xor_sum_arr2 TO the exclusive or of xor_sum_arr2 AND num  \n        END FOR  \n        RETURN the bitwise and of xor_sum_arr1 AND xor_sum_arr2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-building-height", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxBuilding(n, restrictions)  \n        APPEND a list containing the number one and zero TO restrictions  \n        SORT restrictions in ascending order according to the first element of each inner list  \n        \n        FOR i FROM one TO the length of restrictions MINUS one  \n            SET idx TO the element at position one of the element at position i of restrictions  \n            SET height TO the element at position two of the element at position i of restrictions  \n            SET prev_idx TO the element at position one of the element at position i MINUS one of restrictions  \n            SET prev_height TO the element at position two of the element at position i MINUS one of restrictions  \n            SET the element at position two of the element at position i of restrictions TO the minimum of height AND prev_height PLUS idx MINUS prev_idx  \n        END FOR  \n        \n        FOR i FROM the length of restrictions MINUS two DOWN TO zero  \n            SET idx TO the element at position one of the element at position i of restrictions  \n            SET height TO the element at position two of the element at position i of restrictions  \n            SET next_idx TO the element at position one of the element at position i PLUS one of restrictions  \n            SET next_height TO the element at position two of the element at position i PLUS one of restrictions  \n            SET the element at position two of the element at position i of restrictions TO the minimum of height AND next_height PLUS next_idx MINUS idx  \n        END FOR  \n        \n        SET max_height TO zero  \n        SET prev_idx TO the element at position one of the element at position zero of restrictions  \n        SET prev_height TO the element at position two of the element at position zero of restrictions  \n        \n        FOR i FROM one TO the length of restrictions MINUS one  \n            SET idx TO the element at position one of the element at position i of restrictions  \n            SET height TO the element at position two of the element at position i of restrictions  \n            SET possible_max TO idx MINUS prev_idx PLUS prev_height PLUS height DIVIDED BY two  \n            SET max_height TO the maximum of max_height AND possible_max  \n            SET prev_idx TO idx  \n            SET prev_height TO height  \n        END FOR  \n        \n        SET max_height TO the maximum of max_height AND prev_height PLUS n MINUS prev_idx  \n        \n        RETURN max_height  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-palindrome-using-same-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextPalindrome(num)  \n        SET n TO the LENGTH OF num  \n        SET half TO the SUBSTRING from position zero TO position n DIVIDED BY two MINUS one of num  \n        SET half_list TO the LIST of characters IN half  \n        SET k TO negative one  \n        SET l TO negative one  \n        \n        FOR i FROM the LENGTH OF half_list MINUS two DOWN TO zero  \n            IF the element at position i of half_list LESS THAN the element at position i PLUS one of half_list  \n                SET k TO i  \n                BREAK  \n            END IF  \n        END FOR  \n        \n        IF k EQUALS negative one  \n            RETURN an empty string  \n        END IF  \n        \n        FOR i FROM the LENGTH OF half_list MINUS one DOWN TO k PLUS one  \n            IF the element at position i of half_list GREATER THAN the element at position k of half_list  \n                SET l TO i  \n                BREAK  \n            END IF  \n        END FOR  \n        \n        SET temporary_value TO the element at position l of half_list  \n        SET the element at position l of half_list TO the element at position k of half_list  \n        SET the element at position k of half_list TO temporary_value  \n        \n        SET half_list TO the concatenation of the sublist of half_list from position zero TO k PLUS one AND the sublist of half_list from position k PLUS one TO the END sorted in ascending order  \n        \n        SET new_half TO the STRING JOINED from the elements of half_list in order  \n        \n        IF n MODULO two EQUALS zero  \n            RETURN the concatenation of new_half AND the REVERSE of new_half  \n        ELSE  \n            RETURN the concatenation of new_half AND the element at position n DIVIDED BY two of num AND the REVERSE of new_half  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-interval-to-include-each-query", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minInterval(intervals, queries)  \n        CALL intervals SORT BY the first element of interval in ascending order  \n        SET sorted_queries TO an empty list  \n        \n        FOR each element index and query_value IN queries WITH index  \n            APPEND pair of query_value AND index TO sorted_queries  \n        END FOR  \n        CALL sorted_queries SORT BY the first element of pair in ascending order  \n        \n        SET min_heap TO an empty list  \n        SET result TO a list of negative one with length EQUAL TO the LENGTH OF queries  \n        \n        SET interval_index TO zero  \n        \n        FOR each pair query and original_index IN sorted_queries  \n            WHILE interval_index LESS THAN the LENGTH OF intervals AND  \n                  element at position zero of element at position interval_index of intervals LESS THAN OR EQUAL TO query  \n                SET start TO element at position zero of element at position interval_index of intervals  \n                SET end TO element at position one of element at position interval_index of intervals  \n                SET interval_size TO end MINUS start PLUS one  \n                CALL push interval_size AND end ONTO min_heap  \n                INCREMENT interval_index BY one  \n            END WHILE  \n            \n            WHILE the LENGTH OF min_heap GREATER THAN zero AND  \n                  element at position one of element at position zero of min_heap LESS THAN query  \n                CALL pop FROM min_heap  \n            END WHILE  \n            \n            IF the LENGTH OF min_heap GREATER THAN zero  \n                SET element at position original_index OF result TO element at position zero of element at position zero of min_heap  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-color-value-in-a-directed-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestPathValue(colors parameters AS string, edges parameters AS list of list of integers) RETURNS integer  \n        SET number_of_nodes TO the LENGTH OF colors  \n        ASSIGN reference TO an empty mapping from integer keys to list values named graph  \n        SET list_in_degree TO a list of zeros of LENGTH number_of_nodes  \n        \n        FOR each pair origin_node comma destination_node IN edges  \n            APPEND destination_node TO list at key origin_node IN graph  \n            INCREMENT element at position destination_node OF list_in_degree BY one  \n        END FOR  \n        \n        SET queue TO a double-ended queue containing elements index i FOR each i FROM zero TO number_of_nodes MINUS one WHERE element at position i of list_in_degree EQUALS zero  \n        SET dp TO a list of lists each containing twenty-six zeros FOR each index FROM zero TO number_of_nodes MINUS one  \n        SET visited_nodes_count TO zero  \n        SET maximum_color_value TO zero  \n        \n        WHILE queue holds elements  \n            REMOVE and RETURN the leftmost element FROM queue AND ASSIGN IT TO current_node  \n            INCREMENT element at position corresponding to the alphabetical index of color at position current_node IN colors of dp at position current_node BY one  \n            SET maximum_color_value TO the GREATER THAN OF maximum_color_value AND element at position corresponding to the alphabetical index of color at position current_node IN colors of dp at position current_node  \n            INCREMENT visited_nodes_count BY one  \n            \n            FOR each neighbor_node IN list of neighbors of current_node in graph  \n                FOR color_index FROM zero TO twenty-five  \n                    SET element at position color_index of dp at position neighbor_node TO the GREATER THAN OF element at position color_index of dp at position neighbor_node AND element at position color_index of dp at position current_node  \n                END FOR  \n                DECREMENT element at position neighbor_node of list_in_degree BY one  \n                IF element at position neighbor_node of list_in_degree EQUALS zero  \n                    APPEND neighbor_node TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        IF visited_nodes_count EQUALS number_of_nodes  \n            RETURN maximum_color_value  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-floored-pairs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET max_num TO the maximum element in nums  \n        SET count TO a mapping from elements in nums to their frequencies  \n        SET prefix_sum TO a list of zeroes with length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num in count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the integer division of max_num BY num  \n                SET start TO num MULTIPLIED BY multiple  \n                IF num MULTIPLIED BY the sum of multiple PLUS one MINUS one LESS THAN OR EQUAL TO max_num  \n                    SET end TO num MULTIPLIED BY multiple PLUS one MINUS one  \n                ELSE  \n                    SET end TO max_num  \n                END IF  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num in count  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rearrangeSticks(n k)  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE two dimensional list dp with zeroes of dimensions n PLUS one BY k PLUS one  \n        SET element at position zero BY zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                SET element at position i BY j of dp TO the sum of element at position i MINUS one BY j MINUS one of dp PLUS the product of i MINUS one AND element at position i MINUS one BY j of dp MODULO MOD  \n            END FOR  \n        END FOR  \n        RETURN element at position n BY k of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-viii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGameVIII(stones)  \n        SET prefix_sum TO a list of zero repeated the LENGTH OF stones times  \n        SET element at position one of prefix_sum TO element at position one of stones  \n        FOR i FROM two TO the LENGTH OF stones  \n            SET element at position i of prefix_sum TO element at position i minus one of prefix_sum PLUS element at position i of stones  \n        END FOR  \n        SET dp TO element at the last position of prefix_sum  \n        FOR i FROM the LENGTH OF stones MINUS one MINUS one DOWN TO two  \n            IF dp GREATER THAN OR EQUAL TO element at position i of prefix_sum MINUS dp  \n                SET dp TO dp  \n            ELSE  \n                SET dp TO element at position i of prefix_sum MINUS dp  \n            END IF  \n        END FOR  \n        RETURN dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-xor-sum-of-two-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumXORSum(nums1 nums2)  \n        SET n TO the LENGTH OF nums1  \n        SET dp TO a list of size two RAISED TO the power of n with each element SET TO infinity  \n        SET element at position zero of dp TO zero  \n        \n        FOR mask FROM zero TO two RAISED TO the power of n MINUS one  \n            SET bit_count TO the number of one bits in the binary representation of mask  \n            \n            FOR j FROM zero TO n MINUS one  \n                IF the bitwise AND of mask AND two RAISED TO the power of j IS NOT EQUALS zero  \n                    SET dp at position mask TO the MINIMUM value BETWEEN dp at position mask AND the sum of dp at position the bitwise XOR of mask AND the bitwise NOT of two RAISED TO the power of j AND the bitwise XOR of element at position bit_count MINUS one of nums1 AND element at position j of nums2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position two RAISED TO the power of n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-skips-to-arrive-at-meeting-on-time", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSkips(dist speed hoursBefore)  \n        SET n TO the LENGTH OF dist  \n        CREATE a two dimensional list dp with n rows and n PLUS one columns where each element IS set TO infinity  \n        SET total_dist TO the SUM OF all elements IN dist  \n        \n        IF total_dist DIVIDED BY speed IS GREATER THAN hoursBefore  \n            RETURN negative one  \n        END IF  \n        \n        SET element at position zero of row zero IN dp TO element at position zero of dist  \n        FOR j FROM one TO n MINUS one  \n            SET element at position zero of row j IN dp TO element at position zero of dist  \n        END FOR  \n        \n        FOR i FROM one TO n MINUS one  \n            FOR j FROM zero TO i  \n                IF j IS LESS THAN i  \n                    SET element at position i of row j IN dp TO the CEILING OF the element at position i MINUS one of row j IN dp DIVIDED BY speed MULTIPLIED BY speed PLUS element at position i of dist  \n                END IF  \n                IF j IS GREATER THAN zero  \n                    SET element at position i of row j IN dp TO the MINIMUM VALUE BETWEEN element at position i of row j IN dp AND element at position i MINUS one of row j MINUS one IN dp PLUS element at position i of dist  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR j FROM zero TO n MINUS one  \n            IF element at position n MINUS one of row j IN dp IS LESS THAN OR EQUAL TO hoursBefore MULTIPLIED BY speed  \n                RETURN j  \n            END IF  \n        END FOR  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-space-wasted-from-packaging", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minWastedSpace(packages, boxes)  \n        SET MOD TO one billion PLUS seven  \n        SORT packages IN ascending order  \n        SET n TO the LENGTH OF packages  \n        \n        CREATE prefix_sum AS a LIST OF zeros WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix_sum TO element at position i of prefix_sum PLUS element at position i of packages  \n        END FOR  \n        \n        SET min_wasted_space TO positive infinity  \n        \n        FOR each box IN boxes  \n            SORT box IN ascending order  \n            IF element at position LENGTH OF box MINUS one of box IS LESS THAN element at position LENGTH OF packages MINUS one of packages  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            \n            SET total_wasted TO zero  \n            SET last_index TO zero  \n            \n            FOR each box_size IN box  \n                SET index TO last_index  \n                WHILE index IS LESS THAN n AND element at position index of packages IS LESS THAN OR EQUAL TO box_size  \n                    INCREMENT index BY one  \n                END WHILE  \n                \n                IF index IS GREATER THAN last_index  \n                    INCREMENT total_wasted BY (index MINUS last_index) MULTIPLIED BY box_size MINUS (element at position index of prefix_sum MINUS element at position last_index of prefix_sum)  \n                    SET last_index TO index  \n                END IF  \n            END FOR  \n            \n            IF last_index EQUALS n  \n                SET min_wasted_space TO THE MINIMUM OF min_wasted_space AND total_wasted  \n            END IF  \n        END FOR  \n        \n        IF min_wasted_space IS NOT positive infinity  \n            RETURN min_wasted_space MODULO MOD  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-ways-to-build-rooms-in-an-ant-colony", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION waysToBuildRooms(prevRoom)  \n        SET n TO the LENGTH OF prevRoom  \n        INITIALIZE graph AS a mapping from keys to EMPTY lists  \n        \n        FOR each room FROM one TO n MINUS one  \n            APPEND the value of room TO the element in graph at the position of element at position room of prevRoom  \n        END FOR  \n        \n        FUNCTION dp(node)  \n            IF the element in graph at position node EQUALS an EMPTY list THEN  \n                RETURN one AND one  \n            END IF  \n            \n            SET total_ways TO one  \n            SET total_size TO one  \n            INITIALIZE child_results AS an EMPTY list  \n            \n            FOR each child IN the element in graph at position node  \n                SET ways AND size TO the result of calling dp with child  \n                APPEND the pair of ways AND size TO child_results  \n                INCREMENT total_size BY size  \n            END FOR  \n            \n            SET current_size TO one  \n            FOR each ways AND size IN child_results  \n                SET total_ways TO total_ways MULTIPLIED BY the combination of current_size PLUS size MINUS one CHOOSE size MULTIPLIED BY ways  \n                SET total_ways TO total_ways MODULO ten RAISED TO the power of nine PLUS seven  \n                INCREMENT current_size BY size  \n            END FOR  \n            \n            RETURN total_ways AND total_size  \n        END FUNCTION  \n        \n        RETURN the first element of the result of calling dp with zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-common-subpath", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestCommonSubpath(n, paths)  \n        FUNCTION hash_subpaths(path, length)  \n            SET P TO one hundred thirteen  \n            SET MOD TO one billion plus seven  \n            SET hash_value TO zero  \n            SET power TO one  \n            FOR index FROM zero TO length MINUS one  \n                SET hash_value TO the result of hash_value MULTIPLIED BY P PLUS element at position index of path  \n                SET hash_value TO the remainder of hash_value DIVIDED BY MOD  \n                SET power TO the remainder of power MULTIPLIED BY P DIVIDED BY MOD  \n            END FOR  \n            SET hashes TO a new set containing hash_value  \n            FOR index FROM length TO the length of path MINUS one  \n                SET hash_value TO the result of hash_value MULTIPLIED BY P PLUS element at position index of path MINUS element at position index MINUS length of path MULTIPLIED BY power  \n                SET hash_value TO the remainder of hash_value DIVIDED BY MOD  \n                ADD hash_value TO hashes  \n            END FOR  \n            RETURN hashes  \n        END FUNCTION  \n        \n        FUNCTION check_common_subpath(length)  \n            IF length EQUALS zero THEN  \n                RETURN true  \n            END IF  \n            SET common_hashes TO the result of hash_subpaths with arguments element at position zero of paths and length  \n            FOR each path IN the slice of paths from position one TO the end  \n                SET current_hashes TO the result of hash_subpaths with arguments path and length  \n                SET common_hashes TO the intersection of common_hashes AND current_hashes  \n                IF common_hashes IS empty THEN  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true if common_hashes IS NOT empty OTHERWISE false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO the minimum of the lengths of each path in paths  \n        WHILE left LESS THAN right DO  \n            SET mid TO the integer division of the sum of left PLUS right PLUS one BY two  \n            IF the result of check_common_subpath with argument mid IS true THEN  \n                SET left TO mid  \n            ELSE  \n                SET right TO right MINUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "erect-the-fence-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION outerTrees(trees)  \n        FUNCTION dist_sq(p1, p2)  \n            SET difference in first element OF p1 MINUS first element OF p2 TO variable dx  \n            SET difference in second element OF p1 MINUS second element OF p2 TO variable dy  \n            SET result TO dx MULTIPLIED BY dx PLUS dy MULTIPLIED BY dy  \n            RETURN result  \n        END FUNCTION  \n\n        FUNCTION circumcenter(p1, p2, p3)  \n            ASSIGN first element OF p1 TO ax  \n            ASSIGN second element OF p1 TO ay  \n            ASSIGN first element OF p2 TO bx  \n            ASSIGN second element OF p2 TO by  \n            ASSIGN first element OF p3 TO cx  \n            ASSIGN second element OF p3 TO cy  \n            SET d TO two MULTIPLIED BY (ax MULTIPLIED BY (by MINUS cy) PLUS bx MULTIPLIED BY (cy MINUS ay) PLUS cx MULTIPLIED BY (ay MINUS by))  \n            SET ux TO (((ax MULTIPLIED BY ax PLUS ay MULTIPLIED BY ay) MULTIPLIED BY (by MINUS cy)) PLUS ((bx MULTIPLIED BY bx PLUS by MULTIPLIED BY by) MULTIPLIED BY (cy MINUS ay)) PLUS ((cx MULTIPLIED BY cx PLUS cy MULTIPLIED BY cy) MULTIPLIED BY (ay MINUS by))) DIVIDED BY d  \n            SET uy TO (((ax MULTIPLIED BY ax PLUS ay MULTIPLIED BY ay) MULTIPLIED BY (cx MINUS bx)) PLUS ((bx MULTIPLIED BY bx PLUS by MULTIPLIED BY by) MULTIPLIED BY (ax MINUS cx)) PLUS ((cx MULTIPLIED BY cx PLUS cy MULTIPLIED BY cy) MULTIPLIED BY (bx MINUS ax))) DIVIDED BY d  \n            SET center TO list containing ux and uy  \n            SET radius TO square root of (ux MINUS ax) MULTIPLIED BY (ux MINUS ax) PLUS (uy MINUS ay) MULTIPLIED BY (uy MINUS ay)  \n            RETURN center and radius  \n        END FUNCTION  \n\n        FUNCTION welzl(points, boundary, n)  \n            IF n EQUALS zero OR LENGTH OF boundary EQUALS three  \n                IF LENGTH OF boundary EQUALS zero  \n                    RETURN list containing zero and zero, zero  \n                ELSE IF LENGTH OF boundary EQUALS one  \n                    RETURN element at position zero of boundary, zero  \n                ELSE IF LENGTH OF boundary EQUALS two  \n                    SET center TO list containing (first element of element at position zero of boundary PLUS first element OF element at position one of boundary) DIVIDED BY two AND (second element of element at position zero of boundary PLUS second element OF element at position one of boundary) DIVIDED BY two  \n                    SET radius TO square root of dist_sq OF element at position zero of boundary and element at position one of boundary DIVIDED BY two  \n                    RETURN center and radius  \n                ELSE  \n                    RETURN result of calling circumcenter with elements unpacked from boundary  \n                END IF  \n            END IF  \n\n            SET p TO element at position n MINUS one of points  \n            SET center and radius TO result of calling welzl with points boundary and n MINUS one  \n            IF dist_sq(center, p) LESS THAN OR EQUAL TO radius MULTIPLIED BY radius  \n                RETURN center and radius  \n            END IF  \n            RETURN result of calling welzl with points, boundary with element p appended, and n MINUS one  \n        END FUNCTION  \n\n        CALL shuffle function ON trees  \n        SET center and radius TO result of calling welzl with trees, empty list, and length of trees  \n        RETURN list containing first element OF center, second element OF center, and radius  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "painting-a-grid-with-three-different-colors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION colorTheGrid(m PARAMETER n PARAMETER)  \n        SET MOD TO one billion PLUS seven  \n        \n        FUNCTION generate_valid_columns(prev_col PARAMETER)  \n            SET colors TO list containing one two three  \n            SET valid_cols TO empty list  \n            \n            FUNCTION backtrack(col PARAMETER row PARAMETER)  \n                IF row EQUALS m  \n                    APPEND a tuple of col TO valid_cols  \n                    RETURN  \n                END IF  \n                FOR each color IN colors  \n                    IF col IS empty OR element at position the last of col NOT EQUALS color  \n                        IF prev_col IS NOT null AND element at position row of prev_col EQUALS color  \n                            CONTINUE to next iteration of loop  \n                        END IF  \n                        APPEND color TO col  \n                        CALL backtrack WITH col AND row PLUS one  \n                        REMOVE last element FROM col  \n                    END IF  \n                END FOR  \n            END FUNCTION  \n            \n            CALL backtrack WITH empty list AND zero  \n            RETURN valid_cols  \n        END FUNCTION  \n        \n        SET all_valid_cols TO the result of calling generate_valid_columns WITH null  \n        SET num_valid_cols TO the length of all_valid_cols  \n        \n        SET compatible_cols TO a mapping FROM each index i FROM zero TO num_valid_cols MINUS one TO empty list  \n        FOR i FROM zero TO num_valid_cols MINUS one  \n            FOR j FROM zero TO num_valid_cols MINUS one  \n                SET are_compatible TO true  \n                FOR k FROM zero TO m MINUS one  \n                    IF element at position k of element at position i of all_valid_cols EQUALS element at position k of element at position j of all_valid_cols  \n                        SET are_compatible TO false  \n                        BREAK inner loop  \n                    END IF  \n                END FOR  \n                IF are_compatible  \n                    APPEND j TO element at position i of compatible_cols  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a list of length num_valid_cols WITH each element SET TO one  \n        \n        FOR each _ FROM one TO n MINUS one  \n            SET next_dp TO a list of length num_valid_cols WITH each element SET TO zero  \n            FOR i FROM zero TO num_valid_cols MINUS one  \n                FOR each j IN element at position i of compatible_cols  \n                    SET element at position j of next_dp TO element at position j of next_dp PLUS element at position i of dp MODULO MOD  \n                END FOR  \n            END FOR  \n            SET dp TO next_dp  \n        END FOR  \n        \n        SET total_ways TO zero  \n        FOR each value IN dp  \n            INCREMENT total_ways BY value  \n        END FOR  \n        SET total_ways TO total_ways MODULO MOD  \n        \n        RETURN total_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-genetic-difference-query", "passing_rate": 1.0, "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        SET children TO a new default dictionary with default value as TrieNode  \n        SET count TO zero  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION maxGeneticDifference(self, parents, queries)  \n        SET tree TO a new default dictionary with default value as an empty list  \n        FOR index FROM zero TO the length of parents MINUS one  \n            SET parent TO element at position index of parents  \n            IF parent NOT EQUALS negative one THEN  \n                APPEND index TO element at position parent of tree  \n            END IF  \n        END FOR  \n\n        SET node_queries TO a new default dictionary with default value as an empty list  \n        FOR each node_value_pair IN queries  \n            SET node TO element at position zero of node_value_pair  \n            SET val TO element at position one of node_value_pair  \n            APPEND val TO element at position node of node_queries  \n        END FOR  \n\n        SET root TO a new instance of TrieNode  \n        SET result TO a list of zeros with length equal to the length of queries  \n\n        FUNCTION dfs(node)  \n            CALL insert WITH trie_root AS root AND value AS node  \n\n            FOR each val IN element at position node of node_queries  \n                SET result at position element at position node and val in query_idx TO call max_xor WITH trie_root AS root AND value AS val  \n            END FOR  \n\n            FOR each child IN element at position node of tree  \n                CALL dfs WITH child  \n            END FOR  \n\n            CALL erase WITH trie_root AS root AND value AS node  \n        END FUNCTION  \n\n        FUNCTION insert(trie_root, value)  \n            SET current_node TO trie_root  \n            FOR i FROM seventeen DOWNTO zero  \n                SET bit TO value DIVIDED BY two RAISED TO the power i MODULO two  \n                SET current_node TO element at position bit of current_node.children  \n                INCREMENT current_node.count BY one  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION erase(trie_root, value)  \n            SET current_node TO trie_root  \n            FOR i FROM seventeen DOWNTO zero  \n                SET bit TO value DIVIDED BY two RAISED TO the power i MODULO two  \n                SET current_node TO element at position bit of current_node.children  \n                DECREMENT current_node.count BY one  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION max_xor(trie_root, value)  \n            SET current_node TO trie_root  \n            SET max_xor_val TO zero  \n            FOR i FROM seventeen DOWNTO zero  \n                SET bit TO value DIVIDED BY two RAISED TO the power i MODULO two  \n                SET toggled_bit TO one MINUS bit  \n                IF element at position toggled_bit of current_node.children EXISTS AND count of element at position toggled_bit of current_node.children GREATER THAN zero THEN  \n                    INCREMENT max_xor_val BY two RAISED TO the power i  \n                    SET current_node TO element at position toggled_bit of current_node.children  \n                ELSE  \n                    SET current_node TO element at position bit of current_node.children  \n                END IF  \n            END FOR  \n            RETURN max_xor_val  \n        END FUNCTION  \n\n        SET query_idx TO an empty dictionary  \n        FOR index FROM zero TO the length of queries MINUS one  \n            SET node TO element at position zero of element at position index of queries  \n            SET val TO element at position one of element at position index of queries  \n            SET element at position node and val of query_idx TO index  \n        END FOR  \n\n        FOR index FROM zero TO the length of parents MINUS one  \n            SET parent TO element at position index of parents  \n            IF parent EQUALS negative one THEN  \n                CALL dfs WITH index  \n                BREAK  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-duplicate-folders-in-system", "passing_rate": 1.0, "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        SET self.children TO a new default dictionary that creates TrieNode objects  \n        SET self.deleted TO False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION deleteDuplicateFolder(self, paths)  \n        SET ans TO an empty list  \n        SET root TO a new TrieNode object  \n        SET subtreeToNodes TO a new default dictionary with list as default value  \n\n        FOR each path IN the sorted order of paths  \n            SET node TO root  \n            FOR each s IN path  \n                SET node TO the child node of node.children corresponding to the element s  \n            END FOR  \n        END FOR  \n\n        FUNCTION buildSubtreeToRoots(node)  \n            SET subtree TO the concatenation of an opening parenthesis WITH  \n                the concatenation FOR each s IN the children of node OF  \n                    the element s concatenated WITH buildSubtreeToRoots called with the child node corresponding to s  \n                AND THEN a closing parenthesis  \n            IF subtree NOT EQUALS the string consisting of opening and closing parenthesis with nothing in between  \n                APPEND node TO the list in subtreeToNodes corresponding to the key subtree  \n            END IF  \n            RETURN subtree  \n        END FUNCTION  \n\n        CALL buildSubtreeToRoots with root as argument  \n\n        FOR each nodes IN the values of subtreeToNodes  \n            IF the length of nodes GREATER THAN one  \n                FOR each node IN nodes  \n                    SET node.deleted TO True  \n                END FOR  \n            END IF  \n        END FOR  \n\n        FUNCTION constructPath(node, path)  \n            FOR each pair of s and child IN the items of node.children  \n                IF child.deleted EQUALS False  \n                    CALL constructPath with child and the concatenation of path WITH the element s as a new list  \n                END IF  \n            END FOR  \n            IF the length of path GREATER THAN zero  \n                APPEND path TO ans  \n            END IF  \n        END FUNCTION  \n\n        CALL constructPath with root and an empty list as arguments  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-number-of-special-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSpecialSubsequences(nums)  \n        SET MOD TO the number one followed by nine zeros PLUS the number one  \n        SET dp TO a list containing zero and zero and zero  \n        FOR each num IN nums  \n            IF num EQUALS zero  \n                SET element at position zero of dp TO the result of two MULTIPLIED BY element at position zero of dp PLUS one MODULO MOD  \n            ELSE IF num EQUALS one  \n                SET element at position one of dp TO the result of two MULTIPLIED BY element at position one of dp PLUS element at position zero of dp MODULO MOD  \n            ELSE IF num EQUALS two  \n                SET element at position two of dp TO the result of two MULTIPLIED BY element at position two of dp PLUS element at position one of dp MODULO MOD  \n            END IF  \n        END FOR  \n        RETURN element at position two of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-the-length-of-two-palindromic-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(s)  \n        SET n TO the LENGTH OF s  \n        \n        SET max_len_end TO a list of the value one repeated n times  \n        SET max_len_start TO a list of the value one repeated n times  \n        \n        FUNCTION expand_around_center(left, right)  \n            WHILE left GREATER THAN OR EQUAL TO zero AND right LESS THAN n AND element at position left of s EQUALS element at position right of s  \n                SET length TO right MINUS left PLUS one  \n                SET max_len_end at position right TO the GREATER OF max_len_end at position right AND length  \n                SET max_len_start at position left TO the GREATER OF max_len_start at position left AND length  \n                DECREMENT left BY one  \n                INCREMENT right BY one  \n            END WHILE  \n        END FUNCTION  \n        \n        FOR i FROM zero TO n MINUS one  \n            CALL expand_around_center WITH i AND i  \n        END FOR  \n        \n        SET prefix_max TO a list of zeros of length n  \n        SET suffix_max TO a list of zeros of length n  \n        \n        SET prefix_max at position zero TO max_len_end at position zero  \n        FOR i FROM one TO n MINUS one  \n            SET prefix_max at position i TO the GREATER OF prefix_max at position i MINUS one AND max_len_end at position i  \n        END FOR  \n        \n        SET suffix_max at position n MINUS one TO max_len_start at position n MINUS one  \n        FOR i FROM n MINUS two TO zero STEP negative one  \n            SET suffix_max at position i TO the GREATER OF suffix_max at position i PLUS one AND max_len_start at position i  \n        END FOR  \n        \n        SET max_product TO zero  \n        FOR i FROM zero TO n MINUS two  \n            SET product TO prefix_max at position i MULTIPLIED BY suffix_max at position i PLUS one  \n            SET max_product TO the GREATER OF max_product AND product  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-longest-valid-obstacle-course-at-each-position", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestObstacleCourseAtEachPosition(obstacles)  \n        SET n TO the LENGTH OF obstacles  \n        SET ans TO an empty list  \n        SET increasing_subseq TO an empty list  \n        \n        FOR each obstacle IN obstacles  \n            SET idx TO the position of the smallest number in increasing_subseq which is GREATER THAN obstacle OR EQUAL TO obstacle based on rightmost insertion  \n            \n            IF idx EQUALS the LENGTH OF increasing_subseq  \n                APPEND obstacle TO increasing_subseq  \n            ELSE  \n                SET element at position idx of increasing_subseq TO obstacle  \n            END IF  \n            \n            APPEND idx PLUS one TO ans  \n        END FOR  \n        \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "last-day-where-you-can-still-cross", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO a list of integers from zero to n MINUS one  \n        SET self.rank TO a list of zeros with the length n  \n    END FUNCTION  \n      \n    FUNCTION find(self, x)  \n        IF element at position x of self.parent NOT EQUALS x  \n            SET element at position x of self.parent TO the result of self.find with argument element at position x of self.parent  \n        END IF  \n        RETURN element at position x of self.parent  \n    END FUNCTION  \n      \n    FUNCTION union(self, x, y)  \n        SET rootX TO the result of self.find with argument x  \n        SET rootY TO the result of self.find with argument y  \n        IF rootX NOT EQUALS rootY  \n            IF element at position rootX of self.rank GREATER THAN element at position rootY of self.rank  \n                SET element at position rootY of self.parent TO rootX  \n            ELSE IF element at position rootX of self.rank LESS THAN element at position rootY of self.rank  \n                SET element at position rootX of self.parent TO rootY  \n            ELSE  \n                SET element at position rootY of self.parent TO rootX  \n                INCREMENT element at position rootX of self.rank BY one  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION latestDayToCross(self, row, col, cells)  \n        SET grid TO a list composed of row elements each being a list composed of col elements all set to one  \n        SET uf TO a new UnionFind with the argument row MULTIPLIED BY col PLUS two  \n        SET TOP TO row MULTIPLIED BY col  \n        SET BOTTOM TO row MULTIPLIED BY col PLUS one  \n        SET directions TO a list containing four pairs of integers representing up one zero, down one zero, zero left one, zero right one  \n  \n        FOR day FROM the length of cells MINUS one DOWNTO zero STEP minus one  \n            SET r, c TO the element at position day of cells unpacked into two variables  \n            DECREMENT r BY one  \n            DECREMENT c BY one  \n            SET element at position r of grid at position c TO zero  \n  \n            FOR each pair dr, dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN row AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN col AND element at position nr of grid at position nc EQUALS zero  \n                    CALL uf.union WITH arguments r MULTIPLIED BY col PLUS c AND nr MULTIPLIED BY col PLUS nc  \n                END IF  \n            END FOR  \n  \n            IF r EQUALS zero  \n                CALL uf.union WITH arguments r MULTIPLIED BY col PLUS c AND TOP  \n            END IF  \n  \n            IF r EQUALS row MINUS one  \n                CALL uf.union WITH arguments r MULTIPLIED BY col PLUS c AND BOTTOM  \n            END IF  \n  \n            IF uf.find WITH argument TOP EQUALS uf.find WITH argument BOTTOM  \n                RETURN day  \n            END IF  \n        END FOR  \n  \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-unique-good-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfUniqueGoodSubsequences(binary)  \n        SET MOD TO ten TO THE POWER OF nine PLUS one  \n        SET end_with_0 TO zero  \n        SET end_with_1 TO zero  \n        SET has_zero TO the condition that the character zero is IN binary  \n        FOR each bit IN binary  \n            IF bit EQUALS the character one  \n                SET end_with_1 TO the remainder of the sum of end_with_0 PLUS end_with_1 PLUS one DIVIDED BY MOD  \n            ELSE  \n                SET end_with_0 TO the remainder of the sum of end_with_0 PLUS end_with_1 DIVIDED BY MOD  \n            END IF  \n        END FOR  \n        RETURN the remainder of the sum of end_with_0 PLUS end_with_1 PLUS has_zero DIVIDED BY MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gcd-sort-of-an-array", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n        SET self.rank TO list containing size copies of one  \n    END FUNCTION  \n\n    FUNCTION find(self, p)  \n        IF element at position p of self.parent NOT EQUALS p  \n            SET element at position p of self.parent TO self.find(element at position p of self.parent)  \n        END IF  \n        RETURN element at position p of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, p, q)  \n        SET rootP TO self.find(p)  \n        SET rootQ TO self.find(q)  \n        IF rootP EQUALS rootQ  \n            RETURN False  \n        END IF  \n        IF element at position rootP of self.rank GREATER THAN element at position rootQ of self.rank  \n            SET element at position rootQ of self.parent TO rootP  \n        ELSE IF element at position rootP of self.rank LESS THAN element at position rootQ of self.rank  \n            SET element at position rootP of self.parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of self.parent TO rootP  \n            INCREMENT element at position rootP of self.rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION gcdSort(self, nums)  \n        SET sorted_nums TO nums sorted in ascending order  \n        SET max_val TO the maximum value in nums  \n        SET uf TO a new UnionFind object initialized with max_val PLUS one  \n\n        FOR each num IN nums  \n            FOR each factor FROM two TO the integer part of the square root of num PLUS one  \n                IF num MODULO factor EQUALS zero  \n                    CALL uf.union(num, factor)  \n                    CALL uf.union(num, num DIVIDED BY factor)  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each i FROM zero TO the length of nums MINUS one  \n            IF uf.find(element at position i of nums) NOT EQUALS uf.find(element at position i of sorted_nums)  \n                RETURN False  \n            END IF  \n        END FOR  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subtree-removal-game-with-fibonacci-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findGameWinner(n)  \n        RETURN the remainder of n DIVIDED BY six NOT EQUALS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-operations-to-make-array-continuous", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minOperations(nums)  \n        SET n TO the LENGTH OF nums  \n        SET unique_nums TO the LIST OF ELEMENTS IN nums WITH DUPLICATES REMOVED AND SORTED IN ASCENDING ORDER  \n        SET min_operations TO n  \n        SET j TO zero  \n        FOR i FROM zero TO the LENGTH OF unique_nums MINUS one  \n            WHILE j IS LESS THAN the LENGTH OF unique_nums AND the ELEMENT AT POSITION j OF unique_nums IS LESS THAN the ELEMENT AT POSITION i OF unique_nums PLUS n  \n                INCREMENT j BY one  \n            END WHILE  \n            SET min_operations TO THE LESSER OF min_operations AND n MINUS THE DIFFERENCE BETWEEN j AND i  \n        END FOR  \n        RETURN min_operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-subsequence-repeated-k-times", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestSubsequenceRepeatedK(s PARAMETER k PARAMETER) RETURNS string  \n        IMPORT from collections the Counter  \n        \n        SET freq TO the frequency count of each character in s using Counter  \n        \n        SET valid_chars TO an empty list  \n        FOR each character AND its count IN freq  \n            IF count GREATER THAN OR EQUAL TO k  \n                APPEND character TO valid_chars  \n            END IF  \n        END FOR  \n        \n        SORT valid_chars in reverse lexicographical order  \n        \n        FUNCTION is_valid_subsequence(candidate PARAMETER) RETURNS boolean  \n            SET count TO zero  \n            SET index TO zero  \n            FOR each character IN s  \n                IF character EQUALS element at position index of candidate  \n                    INCREMENT index BY one  \n                    IF index EQUALS the LENGTH OF candidate  \n                        INCREMENT count BY one  \n                        SET index TO zero  \n                        IF count EQUALS k  \n                            RETURN True  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        SET max_length TO the LENGTH OF valid_chars DIVIDED BY k  \n        SET best_candidate TO empty string  \n        \n        FUNCTION backtrack(candidate PARAMETER)  \n            IF the LENGTH OF candidate GREATER THAN the LENGTH OF best_candidate  \n                SET best_candidate TO candidate  \n            END IF  \n            FOR each character IN valid_chars  \n                SET new_candidate TO candidate PLUS character  \n                IF is_valid_subsequence(new_candidate) IS True  \n                    CALL backtrack WITH new_candidate  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        CALL backtrack WITH empty string  \n        RETURN best_candidate  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-score-of-students-solving-math-expression", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION scoreOfStudents(s parameter named s AND answers parameter named answers)  \n        FUNCTION evaluate_expression(expression parameter named expression)  \n            SET tokens TO an empty list  \n            SET num TO zero  \n            FOR each character IN expression  \n                IF character is a digit THEN  \n                    SET num TO num MULTIPLIED BY ten PLUS numeric value of character  \n                ELSE  \n                    APPEND num TO tokens  \n                    APPEND character TO tokens  \n                    SET num TO zero  \n                END IF  \n            END FOR  \n            APPEND num TO tokens  \n            \n            SET i TO one  \n            WHILE i LESS THAN the LENGTH OF tokens DO  \n                IF element at position i of tokens EQUALS the multiplication symbol THEN  \n                    SET element at position i MINUS one of tokens TO the product of element at position i MINUS one of tokens MULTIPLIED BY element at position i PLUS one of tokens  \n                    REMOVE elements at positions i TO i PLUS two EXCLUSIVE FROM tokens  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n            \n            SET result TO element at position zero of tokens  \n            SET i TO one  \n            WHILE i LESS THAN the LENGTH OF tokens DO  \n                IF element at position i of tokens EQUALS the addition symbol THEN  \n                    SET result TO result PLUS element at position i PLUS one of tokens  \n                END IF  \n                INCREMENT i BY two  \n            END WHILE  \n            \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION get_possible_answers(expression parameter named expression)  \n            IF expression is composed entirely of digits THEN  \n                RETURN a set containing the numeric value of expression  \n            END IF  \n            \n            SET results TO an empty set  \n            FOR i FROM one TO the LENGTH OF expression MINUS one MINUS one STEP two DO  \n                SET left_results TO the return value of get_possible_answers with substring of expression from position zero TO position i MINUS one  \n                SET right_results TO the return value of get_possible_answers with substring of expression from position i PLUS one TO the end  \n                FOR each left IN left_results  \n                    FOR each right IN right_results  \n                        IF element at position i of expression EQUALS the addition symbol THEN  \n                            SET result TO left PLUS right  \n                        ELSE  \n                            SET result TO left MULTIPLIED BY right  \n                        END IF  \n                        IF result LESS THAN OR EQUAL TO one thousand THEN  \n                            ADD result TO results  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n        \n        SET correct_answer TO the return value of evaluate_expression with s as argument  \n        SET possible_answers TO the return value of get_possible_answers with s as argument  \n        \n        SET points TO zero  \n        FOR each answer IN answers  \n            IF answer EQUALS correct_answer THEN  \n                INCREMENT points BY five  \n            ELSE IF answer IS IN possible_answers THEN  \n                INCREMENT points BY two  \n            END IF  \n        END FOR  \n        \n        RETURN points  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter of list of integers k parameter of integer) RETURNS integer  \n        SET total_sum TO the sum of all elements of nums  \n        SET n TO the length of nums  \n        \n        CREATE left_diff as a dictionary with default integer zero  \n        CREATE right_diff as a dictionary with default integer zero  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value associated with diff in right_diff BY one  \n        END FOR  \n        \n        SET max_ways TO the value associated with zero in right_diff  \n        \n        SET current_sum TO zero  \n        FOR index i FROM zero TO n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            \n            SET diff_change TO k MINUS the element at position i of nums  \n            \n            SET new_ways TO the value associated with negative diff_change in left_diff PLUS the value associated with diff_change in right_diff  \n            \n            IF new_ways GREATER THAN max_ways  \n                SET max_ways TO new_ways  \n            END IF  \n            \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value associated with diff in right_diff BY one  \n            INCREMENT the value associated with diff in left_diff BY one  \n        END FOR  \n        \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-k-length-subsequence-with-occurrences-of-a-letter", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestSubsequence(s letter_string k integer letter letter_character repetition integer) RETURNS string  \n        SET letter_count TO the number of times the letter_character appears in the letter_string  \n        SET stack TO an empty list  \n        FOR each index i AND character char IN the letter_string from the first element to the last element  \n            WHILE the stack is not empty AND the character char is LESS THAN the element at the last position of the stack  \n            AND the LENGTH OF the letter_string MINUS i PLUS the LENGTH OF the stack MINUS one is GREATER THAN OR EQUAL TO k  \n                IF the element at the last position of the stack EQUALS letter_character  \n                    IF letter_count is GREATER THAN repetition  \n                        INCREMENT repetition BY one  \n                        REMOVE the element at the last position FROM the stack  \n                    ELSE  \n                        BREAK the WHILE loop  \n                    END IF  \n                ELSE  \n                    REMOVE the element at the last position FROM the stack  \n                END IF  \n            END WHILE  \n            IF the LENGTH OF the stack is LESS THAN k  \n                IF char EQUALS letter_character  \n                    APPEND char TO the stack  \n                    DECREMENT repetition BY one  \n                ELSE IF k MINUS the LENGTH OF the stack is GREATER THAN repetition  \n                    APPEND char TO the stack  \n                END IF  \n                IF char EQUALS letter_character  \n                    DECREMENT letter_count BY one  \n                END IF  \n            END IF  \n        END FOR  \n        WHILE the LENGTH OF the stack is LESS THAN k  \n            APPEND letter_character TO the stack  \n        END WHILE  \n        RETURN the concatenation of all elements in the stack as a single string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-array-into-two-arrays-to-minimize-sum-difference", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDifference(nums)  \n        SET n TO the LENGTH OF nums DIVIDED BY two  \n        SET total_sum TO the SUM OF nums  \n        SET target TO total_sum DIVIDED BY two  \n        SET min_diff TO positive infinity  \n        \n        SET left_half TO the first n elements of nums  \n        SET right_half TO the elements of nums from position n plus one TO the end  \n        \n        SET left_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        SET right_sums TO a list containing empty dictionaries repeated n PLUS one times  \n        \n        FOR i FROM zero TO n  \n            FOR each combination of i elements IN left_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN left_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN left_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN left_sums at position i BY one  \n            END FOR  \n            \n            FOR each combination of i elements IN right_half  \n                SET subset_sum TO the SUM OF the current combination  \n                IF subset_sum EXISTS AS A KEY IN right_sums at position i  \n                    DO NOTHING  \n                ELSE  \n                    SET the value at key subset_sum IN right_sums at position i TO zero  \n                END IF  \n                INCREMENT the value at key subset_sum IN right_sums at position i BY one  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO n  \n            SET left_values TO the keys of left_sums at position i SORTED in ascending order  \n            SET right_values TO the keys of right_sums at position n MINUS i SORTED in ascending order  \n            \n            SET j TO zero  \n            SET k TO the LENGTH OF right_values MINUS one  \n            \n            WHILE j LESS THAN the LENGTH OF left_values AND k GREATER THAN OR EQUAL TO zero  \n                SET current_sum TO the element at position j of left_values PLUS the element at position k of right_values  \n                SET diff_candidate TO total_sum MINUS two MULTIPLIED BY current_sum  \n                IF diff_candidate IS LESS THAN zero  \n                    SET diff_candidate TO the NEGATIVE of diff_candidate  \n                END IF  \n                IF diff_candidate LESS THAN min_diff  \n                    SET min_diff TO diff_candidate  \n                END IF  \n                \n                IF current_sum LESS THAN target  \n                    INCREMENT j BY one  \n                ELSE IF current_sum GREATER THAN target  \n                    DECREMENT k BY one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "second-minimum-time-to-reach-destination", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION secondMinimum(n  \n                            edges  \n                            time  \n                            change)  \n        SET graph TO list of empty lists for each integer from one TO n PLUS one  \n        FOR each pair u AND v IN edges  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n          \n        SET queue TO a double ended queue containing a tuple of one current vertex AND zero current time AND zero count  \n        SET minTimes TO list containing two elements each set to infinite value for each integer from one TO n PLUS one  \n        SET element at position one of minTimes at position zero TO zero  \n          \n        WHILE queue is not empty  \n            REMOVE the first element FROM queue AND ASSIGN TO current AND currentTime AND count  \n              \n            IF current EQUALS n AND count EQUALS one  \n                RETURN currentTime  \n            END IF  \n              \n            IF integer division of currentTime BY change MODULO two EQUALS zero  \n                SET nextTime TO currentTime PLUS time  \n            ELSE  \n                SET nextTime TO (integer division of currentTime BY change PLUS one) MULTIPLIED BY change PLUS time  \n            END IF  \n              \n            FOR each neighbor IN element at position current of graph  \n                IF element at position neighbor of minTimes at position zero GREATER THAN nextTime  \n                    SET element at position neighbor of minTimes at position one TO element at position neighbor of minTimes at position zero  \n                    SET element at position neighbor of minTimes at position zero TO nextTime  \n                    APPEND tuple containing neighbor AND nextTime AND zero TO queue  \n                ELSE IF element at position neighbor of minTimes at position zero LESS THAN nextTime AND nextTime LESS THAN element at position neighbor of minTimes at position one  \n                    SET element at position neighbor of minTimes at position one TO nextTime  \n                    APPEND tuple containing neighbor AND nextTime AND one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parallel-courses-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTime(n, relations, time)  \n        ASSIGN reference TO an empty mapping from element to list named graph  \n        FOR each pair prevCourse and nextCourse IN relations  \n            APPEND prevCourse TO the list associated with nextCourse in graph  \n        END FOR  \n\n        SET memo TO a list of length n PLUS one filled with negative one  \n\n        FUNCTION dfs(course)  \n            IF element at position course of memo NOT EQUALS negative one THEN  \n                RETURN element at position course of memo  \n            END IF  \n\n            SET max_prerequisite_time TO zero  \n            FOR each prevCourse IN element at position course of graph  \n                SET temp_time TO CALL dfs WITH prevCourse  \n                IF temp_time GREATER THAN max_prerequisite_time THEN  \n                    SET max_prerequisite_time TO temp_time  \n                END IF  \n            END FOR  \n\n            SET element at position course of memo TO max_prerequisite_time PLUS element at position course MINUS one of time  \n            RETURN element at position course of memo  \n        END FUNCTION  \n\n        SET total_minimum_time TO zero  \n        FOR course FROM one TO n  \n            SET current_time TO CALL dfs WITH course  \n            IF current_time GREATER THAN total_minimum_time THEN  \n                SET total_minimum_time TO current_time  \n            END IF  \n        END FOR  \n\n        RETURN total_minimum_time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-valid-move-combinations-on-chessboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countCombinations(pieces, positions)  \n        SET directions TO dictionary mapping rook TO list of pairs of one and zero negative one and zero zero and one zero and negative one   \n        ADD queen TO dictionary with list of pairs of one and zero negative one and zero zero and one zero and negative one one and one negative one and one one and negative one negative one and negative one  \n        ADD bishop TO dictionary with list of pairs of one and one negative one and one one and negative one negative one and negative one  \n        \n        SET positions TO new list by setting each row MINUS one and column MINUS one in positions  \n        \n        FUNCTION get_destinations(start, piece_type)  \n            SET r TO element at first position of start  \n            SET c TO element at second position of start  \n            SET dests TO list containing start  \n            FOR each pair dr and dc IN directions at key piece_type  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                WHILE nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN eight AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN eight  \n                    APPEND pair nr and nc TO dests  \n                    INCREMENT nr BY dr  \n                    INCREMENT nc BY dc  \n                END WHILE  \n            END FOR  \n            RETURN dests  \n        END FUNCTION  \n        \n        SET all_destinations TO empty list  \n        FOR each pos and piece IN pairs from positions and pieces  \n            APPEND get_destinations with pos and piece TO all_destinations  \n        END FOR  \n        \n        FUNCTION is_valid_combination(combination)  \n            SET pos TO copy of positions  \n            SET n TO length of pos  \n            WHILE true  \n                SET unique_positions_count TO zero  \n                CREATE empty set visited_positions  \n                FOR each position IN pos  \n                    IF position NOT IN visited_positions  \n                        ADD position TO visited_positions  \n                        INCREMENT unique_positions_count BY one  \n                    END IF  \n                END FOR  \n                IF unique_positions_count LESS THAN n  \n                    RETURN false  \n                END IF  \n                SET all_reached TO true  \n                FOR i FROM zero TO n MINUS one  \n                    IF element at position i of pos EQUALS element at position i of combination  \n                        CONTINUE to next iteration  \n                    END IF  \n                    SET all_reached TO false  \n                    SET r TO element at first position of element at position i of pos  \n                    SET c TO element at second position of element at position i of pos  \n                    IF element at first position of element at position i of combination GREATER THAN r  \n                        SET dr TO one  \n                    ELSE IF element at first position of element at position i of combination LESS THAN r  \n                        SET dr TO negative one  \n                    ELSE  \n                        SET dr TO zero  \n                    END IF  \n                    IF element at second position of element at position i of combination GREATER THAN c  \n                        SET dc TO one  \n                    ELSE IF element at second position of element at position i of combination LESS THAN c  \n                        SET dc TO negative one  \n                    ELSE  \n                        SET dc TO zero  \n                    END IF  \n                    SET element at position i of pos TO pair r PLUS dr and c PLUS dc  \n                END FOR  \n                IF all_reached  \n                    RETURN true  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n        \n        SET valid_count TO zero  \n        FOR each combination IN Cartesian product of elements in all_destinations  \n            IF is_valid_combination with combination  \n                INCREMENT valid_count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN valid_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-path-quality-of-a-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximalPathQuality(values, edges, maxTime)  \n        SET graph TO a new empty mapping from keys to empty lists  \n        FOR each element u v time IN edges  \n            APPEND pair of v and time TO the list corresponding to u in graph  \n            APPEND pair of u and time TO the list corresponding to v in graph  \n        END FOR  \n        \n        SET visited TO an empty set  \n        SET max_quality TO zero  \n        \n        FUNCTION dfs(node, current_time, current_quality)  \n            IF node EQUALS zero THEN  \n                IF current_quality GREATER THAN max_quality THEN  \n                    SET max_quality TO current_quality  \n                END IF  \n            END IF  \n            \n            FOR each pair neighbor time IN the list corresponding to node in graph  \n                IF time LESS THAN OR EQUAL TO current_time THEN  \n                    IF neighbor NOT IN visited THEN  \n                        ADD neighbor TO visited  \n                        CALL dfs WITH neighbor AND current_time MINUS time AND current_quality PLUS the element at position neighbor of values  \n                        REMOVE neighbor FROM visited  \n                    ELSE  \n                        CALL dfs WITH neighbor AND current_time MINUS time AND current_quality  \n                    END IF  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        ADD zero TO visited  \n        CALL dfs WITH zero AND maxTime AND the element at position zero of values  \n        \n        RETURN max_quality  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-tasks-you-can-assign", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxTaskAssign(tasks LIST OF integer, workers LIST OF integer, pills integer, strength integer) RETURNS integer  \n        CALL sort ON tasks  \n        CALL sort ON workers  \n        \n        FUNCTION canAssignTasks(k integer) RETURNS boolean  \n            SET available_workers TO sublist from position LENGTH OF workers MINUS k TO end OF workers  \n            SET pills_used TO zero  \n            \n            FOR i FROM k MINUS one DOWN TO zero  \n                SET task TO element at position i OF tasks  \n                SET worker_idx TO the position of the smallest element IN available_workers GREATER THAN OR EQUAL TO task  \n                \n                IF worker_idx IS LESS THAN LENGTH OF available_workers  \n                    REMOVE element at position worker_idx FROM available_workers  \n                ELSE IF pills_used IS LESS THAN pills  \n                    SET worker_idx TO the position of the smallest element IN available_workers GREATER THAN OR EQUAL TO task MINUS strength  \n                    \n                    IF worker_idx IS LESS THAN LENGTH OF available_workers  \n                        REMOVE element at position worker_idx FROM available_workers  \n                        INCREMENT pills_used BY one  \n                    ELSE  \n                        RETURN false  \n                    END IF  \n                ELSE  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO the minimum of LENGTH OF tasks AND LENGTH OF workers PLUS one  \n        \n        WHILE left IS LESS THAN right  \n            SET mid TO the integer division of left PLUS right BY two  \n            \n            IF canAssignTasks(mid) IS true  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN left MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-k-mirror-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kMirror WITH PARAMETERS k n  \n        FUNCTION is_palindrome WITH PARAMETER s  \n            RETURN s EQUALS reverse of s  \n        END FUNCTION  \n        \n        FUNCTION to_base_k WITH PARAMETERS num k  \n            IF num EQUALS zero THEN  \n                RETURN string representing zero  \n            END IF  \n            SET digits TO empty list  \n            WHILE num NOT EQUALS zero  \n                APPEND remainder of num DIVIDED BY k converted to integer TO digits  \n                SET num TO num DIVIDED BY k converted to integer by floor division  \n            END WHILE  \n            RETURN concatenation of strings converted from elements in reverse order of digits  \n        END FUNCTION  \n        \n        FUNCTION generate_palindromes WITH PARAMETER length  \n            IF length EQUALS one THEN  \n                FOR i FROM one TO nine  \n                    YIELD string representing i  \n                END FOR  \n            ELSE  \n                SET start TO ten RAISED TO the power of integer division of (length MINUS one) BY two  \n                SET end TO ten RAISED TO the power of integer division of (length PLUS one) BY two  \n                FOR half FROM start TO end MINUS one  \n                    SET half_str TO string representing half  \n                    IF length MODULO two EQUALS zero THEN  \n                        SET full TO concatenation of half_str AND reverse of half_str  \n                    ELSE  \n                        SET full TO concatenation of half_str AND substring of half_str from the position of the second last character to the first character in reverse order  \n                    END IF  \n                    YIELD full  \n                END FOR  \n            END IF  \n        END FUNCTION  \n        \n        SET k_mirror_numbers TO empty list  \n        SET length TO one  \n        WHILE LENGTH OF k_mirror_numbers LESS THAN n  \n            FOR each pal IN generate_palindromes WITH PARAMETER length  \n                SET num TO integer converted from pal  \n                IF is_palindrome WITH PARAMETER to_base_k WITH PARAMETERS num k RETURNS true THEN  \n                    APPEND num TO k_mirror_numbers  \n                    IF LENGTH OF k_mirror_numbers EQUALS n THEN  \n                        BREAK  \n                    END IF  \n                END IF  \n            END FOR  \n            INCREMENT length BY one  \n        END WHILE  \n        \n        RETURN sum of elements in k_mirror_numbers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-fertile-pyramids-in-a-land", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPyramids(grid)  \n        FUNCTION count_pyramids_from_top(grid)  \n            IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n                RETURN zero  \n            END IF  \n            SET m TO the LENGTH OF grid  \n            SET n TO the LENGTH OF element at position zero of grid  \n            SET dp TO a two dimensional list of zeros with m rows and n columns  \n            SET count TO zero  \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid at position j EQUALS one  \n                        IF i EQUALS zero OR j EQUALS zero OR j EQUALS n MINUS one  \n                            SET element at position i of dp at position j TO one  \n                        ELSE  \n                            SET element at position i of dp at position j TO the MINIMUM OF element at position i MINUS one of dp at position j MINUS one AND element at position i MINUS one of dp at position j AND element at position i MINUS one of dp at position j PLUS one PLUS one  \n                        END IF  \n                        IF element at position i of dp at position j GREATER THAN one  \n                            INCREMENT count BY element at position i of dp at position j MINUS one  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        FUNCTION count_pyramids_from_bottom(grid)  \n            IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n                RETURN zero  \n            END IF  \n            SET m TO the LENGTH OF grid  \n            SET n TO the LENGTH OF element at position zero of grid  \n            SET dp TO a two dimensional list of zeros with m rows and n columns  \n            SET count TO zero  \n            FOR i FROM m MINUS one DOWN TO zero  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid at position j EQUALS one  \n                        IF i EQUALS m MINUS one OR j EQUALS zero OR j EQUALS n MINUS one  \n                            SET element at position i of dp at position j TO one  \n                        ELSE  \n                            SET element at position i of dp at position j TO the MINIMUM OF element at position i PLUS one of dp at position j MINUS one AND element at position i PLUS one of dp at position j AND element at position i PLUS one of dp at position j PLUS one PLUS one  \n                        END IF  \n                        IF element at position i of dp at position j GREATER THAN one  \n                            INCREMENT count BY element at position i of dp at position j MINUS one  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN the RESULT OF count_pyramids_from_top APPLIED TO grid PLUS the RESULT OF count_pyramids_from_bottom APPLIED TO grid  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-all-people-with-secret", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findAllPeople(n, meetings, firstPerson)  \n        SET know_secret TO a set containing zero AND firstPerson  \n        SORT meetings BY the third element of each meeting representing the time  \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF meetings  \n            SET current_time TO the third element of the meeting at position i  \n            SET graph TO a default dictionary mapping each key to an empty list  \n            WHILE i LESS THAN the LENGTH OF meetings AND the third element of the meeting at position i EQUALS current_time  \n                SET x TO the first element of the meeting at position i  \n                SET y TO the second element of the meeting at position i  \n                APPEND y TO the list in graph at key x  \n                APPEND x TO the list in graph at key y  \n                INCREMENT i BY one  \n            END WHILE  \n            SET queue TO a double-ended queue initialized with each person in know_secret that is a key in graph  \n            SET visited TO an empty set  \n            WHILE the queue is not empty  \n                REMOVE the element from the front of queue AND ASSIGN it TO person  \n                IF person IS IN visited  \n                    CONTINUE to the next iteration of the WHILE loop  \n                END IF  \n                ADD person TO visited  \n                ADD person TO know_secret  \n                FOR each neighbor IN the list in graph at key person  \n                    IF neighbor IS NOT IN visited  \n                        APPEND neighbor TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n        END WHILE  \n        RETURN the list converted from know_secret  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-arrangement-of-pairs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validArrangement(pairs)  \n        SET graph TO a new mapping from element to list of elements with default empty list  \n        SET out_degree TO a new counting mapping from element to integer with default zero  \n        SET in_degree TO a new counting mapping from element to integer with default zero  \n        \n        FOR each element u and element v IN pairs  \n            APPEND element v TO the list at position u of graph  \n            INCREMENT the count at position u of out_degree BY one  \n            INCREMENT the count at position v of in_degree BY one  \n        END FOR  \n        \n        SET start_node TO none  \n        FOR each node IN graph  \n            IF the count at position node of out_degree EQUALS the count at position node of in_degree PLUS one  \n                SET start_node TO node  \n                BREAK the loop  \n            END IF  \n        END FOR  \n        \n        IF start_node IS none  \n            SET start_node TO the first element yielded by iterating over graph  \n        END IF  \n        \n        SET path TO an empty list  \n        SET stack TO a list containing start_node  \n        \n        WHILE the LENGTH OF stack IS greater than zero  \n            SET u TO the last element of stack  \n            IF the list at position u of graph IS NOT empty  \n                REMOVE the last element FROM the list at position u of graph AND SET it TO v  \n                APPEND element v TO stack  \n            ELSE  \n                REMOVE the last element FROM stack AND APPEND it TO path  \n            END IF  \n        END WHILE  \n        \n        REVERSE the order of elements in path  \n        \n        SET result TO an empty list  \n        FOR each index i FROM zero TO the LENGTH OF path MINUS one MINUS one  \n            APPEND a list containing the element at position i of path AND the element at position i PLUS one of path TO result  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits AS list of list of integers, startPos AS integer, k AS integer) RETURNS integer  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        \n        FOR right FROM zero TO the length of fruits MINUS one  \n            SET position TO the element at position zero of the element at position right of fruits  \n            SET amount TO the element at position one of the element at position right of fruits  \n            INCREMENT total_fruits BY amount  \n            \n            WHILE left LESS THAN OR EQUAL TO right AND NOT  \n                (startPos MINUS k LESS THAN OR EQUAL TO the element at position zero of the element at position left of fruits AND  \n                the element at position zero of the element at position left of fruits LESS THAN OR EQUAL TO startPos PLUS k AND  \n                startPos MINUS k LESS THAN OR EQUAL TO the element at position zero of the element at position right of fruits AND  \n                the element at position zero of the element at position right of fruits LESS THAN OR EQUAL TO startPos PLUS k AND  \n                the minimum value of the absolute value of the element at position zero of the element at position right of fruits MINUS startPos AND the absolute value of the element at position zero of the element at position left of fruits MINUS startPos PLUS the element at position zero of the element at position right of fruits MINUS the element at position zero of the element at position left of fruits) LESS THAN OR EQUAL TO k  \n            DO  \n                DECREMENT total_fruits BY the element at position one of the element at position left of fruits  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            IF max_fruits LESS THAN total_fruits  \n                SET max_fruits TO total_fruits  \n            END IF  \n        END FOR  \n        \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-operations-to-make-the-array-k-increasing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kIncreasing arr k  \n        FUNCTION longest_increasing_subsequence subarr  \n            SET lis TO empty list  \n            FOR each num IN subarr  \n                IF lis IS empty OR num IS GREATER THAN OR EQUAL TO element at position the last index of lis  \n                    APPEND num TO lis  \n                ELSE  \n                    SET pos TO the position where num can be inserted to the right in lis while preserving ascending order  \n                    SET element at position pos of lis TO num  \n                END IF  \n            END FOR  \n            RETURN the LENGTH OF lis  \n        END FUNCTION  \n        \n        SET total_operations TO zero  \n        SET n TO the LENGTH OF arr  \n        \n        FOR start FROM zero TO k MINUS one  \n            SET subarr TO empty list  \n            FOR i FROM start TO n MINUS one IN STEPS OF k  \n                APPEND element at position i of arr TO subarr  \n            END FOR  \n            \n            SET lis_length TO longest_increasing_subsequence called with subarr  \n            INCREMENT total_operations BY the LENGTH OF subarr MINUS lis_length  \n        END FOR  \n        \n        RETURN total_operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "recover-the-original-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION recoverArray(nums)  \n        SORT the elements of nums in ascending order  \n        SET n TO the LENGTH OF nums  \n        SET first TO the element at position zero of nums  \n        FOR i FROM one TO n MINUS one  \n            SET k TO the element at position i of nums MINUS first DIVIDED BY two  \n            IF k LESS THAN OR EQUAL TO zero OR first PLUS two MULTIPLIED BY k NOT EQUALS the element at position i of nums  \n                CONTINUE to the next iteration  \n            END IF  \n            SET count TO a mapping of each element of nums to its frequency  \n            SET arr TO an empty list  \n            FOR each element x IN nums  \n                IF the value at key x in count EQUALS zero  \n                    CONTINUE to the next iteration  \n                END IF  \n                IF the value at key the sum of x PLUS two MULTIPLIED BY k in count EQUALS zero  \n                    BREAK out of the loop  \n                END IF  \n                APPEND the sum of x PLUS k TO arr  \n                DECREMENT the value at key x in count BY one  \n                DECREMENT the value at key the sum of x PLUS two MULTIPLIED BY k in count BY one  \n            END FOR  \n            IF the LENGTH OF arr EQUALS n DIVIDED BY two  \n                RETURN arr  \n            END IF  \n        END FOR  \n        RETURN an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-operations-to-remove-adjacent-ones-in-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumOperations(grid)  \n        FUNCTION bfs()  \n            SET queue TO new empty double ended queue  \n            FOR u FROM zero TO n MINUS one  \n                IF element at position u of match EQUALS minus one  \n                    SET element at position u of dist TO zero  \n                    APPEND u TO queue  \n                ELSE  \n                    SET element at position u of dist TO infinity  \n                END IF  \n            END FOR  \n            SET element at position minus one of dist TO infinity  \n            WHILE queue IS NOT empty  \n                REMOVE first element FROM queue AND ASSIGN TO u  \n                IF element at position u of dist LESS THAN element at position minus one of dist  \n                    FOR each v IN element at position u of graph  \n                        IF element at position element at position v of match of dist EQUALS infinity  \n                            SET element at position element at position v of match of dist TO element at position u of dist PLUS one  \n                            APPEND element at position v of match TO queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END WHILE  \n            RETURN element at position minus one of dist LESS THAN infinity  \n        END FUNCTION  \n        \n        FUNCTION dfs(u)  \n            IF u NOT EQUALS minus one  \n                FOR each v IN element at position u of graph  \n                    IF element at position element at position v of match of dist EQUALS element at position u of dist PLUS one  \n                        IF dfs(element at position v of match)  \n                            SET element at position v of match TO u  \n                            SET element at position u of match TO v  \n                            RETURN True  \n                        END IF  \n                    END IF  \n                END FOR  \n                SET element at position u of dist TO infinity  \n                RETURN False  \n            END IF  \n            RETURN True  \n        END FUNCTION  \n        \n        SET rows TO length of grid  \n        SET cols TO length of element at position zero of grid  \n        SET n TO rows MULTIPLIED BY cols  \n        SET graph TO new list containing n PLUS one empty sets  \n        SET match TO new list containing n PLUS one elements each set TO minus one  \n        SET dist TO new list containing n PLUS one elements each set TO zero  \n        \n        FOR r FROM zero TO rows MINUS one  \n            FOR c FROM zero TO cols MINUS one  \n                IF element at position r of grid AND element at position c of that row EQUALS one  \n                    SET u TO r MULTIPLIED BY cols PLUS c  \n                    FOR each pair dr dc IN list containing pairs minus one zero one zero zero minus one zero one  \n                        SET nr TO r PLUS dr  \n                        SET nc TO c PLUS dc  \n                        IF nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN rows AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN cols AND element at position nr of grid AND element at position nc of that row EQUALS one  \n                            SET v TO nr MULTIPLIED BY cols PLUS nc  \n                            ADD v TO element at position u of graph  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET matching TO zero  \n        WHILE bfs()  \n            FOR u FROM zero TO n MINUS one  \n                IF element at position u of match EQUALS minus one AND dfs(u)  \n                    INCREMENT matching BY one  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN matching  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stamping-the-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION possibleToStamp(grid, stampHeight, stampWidth)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION prefix_sum(matrix)  \n            SET p TO a new matrix of zeros with the number of rows equal to m PLUS one and the number of columns equal to n PLUS one  \n            FOR r FROM one TO m  \n                FOR c FROM one TO n  \n                    SET element at position r and c of p TO the element at position r MINUS one and c MINUS one of matrix PLUS the element at position r MINUS one and c of p PLUS the element at position r and c MINUS one of p MINUS the element at position r MINUS one and c MINUS one of p  \n                END FOR  \n            END FOR  \n            RETURN p  \n        END FUNCTION  \n        \n        FUNCTION submatrix_sum(p, r1, c1, r2, c2)  \n            RETURN the element at position r2 PLUS one and c2 PLUS one of p MINUS the element at position r2 PLUS one and c1 of p MINUS the element at position r1 and c2 PLUS one of p PLUS the element at position r1 and c1 of p  \n        END FUNCTION  \n        \n        SET p_grid TO prefix_sum(grid)  \n        \n        SET p_stamps TO a new matrix of zeros with the number of rows equal to m PLUS one and the number of columns equal to n PLUS one  \n        \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                IF the element at position r and c of grid EQUALS zero THEN  \n                    IF r PLUS stampHeight LESS THAN OR EQUAL TO m AND c PLUS stampWidth LESS THAN OR EQUAL TO n THEN  \n                        IF submatrix_sum(p_grid, r, c, r PLUS stampHeight MINUS one, c PLUS stampWidth MINUS one) EQUALS zero THEN  \n                            INCREMENT element at position r and c of p_stamps BY one  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET p_stamps TO prefix_sum(p_stamps)  \n        \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                IF the element at position r and c of grid EQUALS zero THEN  \n                    IF submatrix_sum(p_stamps, the greater value of zero AND r MINUS stampHeight PLUS one, the greater value of zero AND c MINUS stampWidth PLUS one, r, c) EQUALS zero THEN  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "earliest-possible-day-of-full-bloom", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION earliestFullBloom(plantTime, growTime)  \n        SET tasks TO the collection of pairs composed of each element at position index of plantTime AND at position index of growTime FOR each index FROM zero TO the length of plantTime MINUS one  \n        SORT tasks in the order that the second element of each pair IS GREATER THAN for all comparisons  \n        \n        SET current_day TO zero  \n        SET earliest_bloom TO zero  \n        \n        FOR each pair IN tasks  \n            SET plant TO the first element of pair  \n            SET grow TO the second element of pair  \n            INCREMENT current_day BY plant  \n            SET bloom_day TO current_day PLUS grow  \n            IF bloom_day IS GREATER THAN earliest_bloom THEN  \n                SET earliest_bloom TO bloom_day  \n            END IF  \n        END FOR  \n        \n        RETURN earliest_bloom  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-running-time-of-n-computers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxRunTime(n, batteries)  \n        FUNCTION canRunFor(time)  \n            SET total TO zero  \n            FOR each battery IN batteries  \n                IF battery LESS THAN time  \n                    INCREMENT total BY battery  \n                ELSE  \n                    INCREMENT total BY time  \n                END IF  \n            END FOR  \n            IF total GREATER THAN OR EQUAL TO time MULTIPLIED BY n  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n\n        SET left TO zero  \n        SET right TO sum of all elements in batteries DIVIDED BY n  \n\n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right PLUS one DIVIDED BY two  \n            IF canRunFor(mid) IS true  \n                SET left TO mid  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n\n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "choose-numbers-from-two-arrays-in-range", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSubranges(nums1 nums2)  \n        SET n TO the LENGTH OF nums1  \n        SET count TO zero  \n        SET dp TO a new list WITH n elements EACH BEING a new mapping FROM integer TO integer INITIALLY empty  \n        \n        FOR i FROM zero TO n MINUS one  \n            INCREMENT the value associated WITH element at position i of nums1 IN the mapping at position i OF dp BY one  \n            INCREMENT the value associated WITH the NEGATIVE of element at position i of nums2 IN the mapping at position i OF dp BY one  \n            \n            IF i GREATER THAN zero THEN  \n                FOR each key value pair balance freq IN the mapping at position i MINUS one OF dp  \n                    SET the value associated WITH balance PLUS element at position i of nums1 IN the mapping at position i OF dp TO the current value associated WITH balance PLUS element at position i of nums1 IN the mapping at position i OF dp PLUS freq MODULO ten to the power of nine PLUS seven  \n                    SET the value associated WITH balance MINUS element at position i of nums2 IN the mapping at position i OF dp TO the current value associated WITH balance MINUS element at position i of nums2 IN the mapping at position i OF dp PLUS freq MODULO ten to the power of nine PLUS seven  \n                END FOR  \n            END IF  \n            \n            SET count TO count PLUS the value associated WITH zero IN the mapping at position i OF dp MODULO ten to the power of nine PLUS seven  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-good-people-based-on-statements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-substring-with-given-hash-value", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subStrHash(s string power integer modulo integer k integer hashValue integer) RETURNS string  \n        FUNCTION val(c character) RETURNS integer  \n            RETURN the unicode code of character c MINUS the unicode code of character a PLUS one  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF string s  \n        SET current_hash TO zero  \n        SET p_pow TO one  \n\n        FOR i FROM n MINUS k TO n MINUS one  \n            SET current_hash TO current_hash PLUS val(the element at position i of s) MULTIPLIED BY p_pow MODULO modulo  \n            IF i LESS THAN n MINUS one  \n                SET p_pow TO p_pow MULTIPLIED BY power MODULO modulo  \n            END IF  \n        END FOR  \n\n        SET start_index TO n MINUS k  \n        IF current_hash EQUALS hashValue  \n            RETURN the substring from position start_index TO the position one LESS THAN n of s  \n        END IF  \n\n        SET p_pow_k_minus_1 TO p_pow  \n\n        FOR i FROM n MINUS k MINUS one DOWN TO zero  \n            SET current_hash TO current_hash MINUS val(the element at position i PLUS k of s) MULTIPLIED BY p_pow_k_minus_1 MODULO modulo  \n            SET current_hash TO current_hash MULTIPLIED BY power PLUS val(the element at position i of s) MODULO modulo  \n\n            IF current_hash EQUALS hashValue  \n                SET start_index TO i  \n            END IF  \n        END FOR  \n\n        RETURN the substring from position start_index TO the position start_index PLUS k MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-remove-all-cars-containing-illegal-goods", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTime(s)  \n        SET n TO the LENGTH OF s  \n        SET left_costs TO a list of zeros with LENGTH n  \n        SET right_costs TO a list of zeros with LENGTH n  \n\n        IF the element at position zero of s EQUALS character one  \n            SET the element at position zero of left_costs TO one  \n        ELSE  \n            SET the element at position zero of left_costs TO zero  \n        END IF  \n\n        FOR i FROM one TO n MINUS one  \n            IF the element at position i of s EQUALS character zero  \n                SET the element at position i of left_costs TO the element at position i MINUS one of left_costs  \n            ELSE  \n                SET the element at position i of left_costs TO the MINIMUM OF i PLUS one AND the element at position i MINUS one of left_costs PLUS two  \n            END IF  \n        END FOR  \n\n        IF the element at position last of s EQUALS character one  \n            SET the element at position last of right_costs TO one  \n        ELSE  \n            SET the element at position last of right_costs TO zero  \n        END IF  \n\n        FOR i FROM n MINUS two DOWN TO zero  \n            IF the element at position i of s EQUALS character zero  \n                SET the element at position i of right_costs TO the element at position i PLUS one of right_costs  \n            ELSE  \n                SET the element at position i of right_costs TO the MINIMUM OF n MINUS i AND the element at position i PLUS one of right_costs PLUS two  \n            END IF  \n        END FOR  \n\n        SET min_time TO the MINIMUM OF the element at position last of left_costs AND the element at position zero of right_costs  \n\n        FOR i FROM zero TO n MINUS two  \n            SET min_time TO the MINIMUM OF min_time AND the element at position i of left_costs PLUS the element at position i PLUS one of right_costs  \n        END FOR  \n\n        RETURN min_time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-and-sum-of-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumANDSum(nums numSlots)  \n        FUNCTION dp(index slots)  \n            IF index EQUALS LENGTH OF nums  \n                RETURN zero  \n            END IF  \n              \n            SET max_and_sum TO zero  \n            SET slots_list TO list converted from slots  \n              \n            FOR i FROM zero TO numSlots MINUS one  \n                IF element at position i of slots_list LESS THAN two  \n                    INCREMENT element at position i of slots_list BY one  \n                    SET and_sum TO bitwise AND of element at position index of nums AND i PLUS one PLUS dp function called with index PLUS one AND tuple converted from slots_list  \n                    IF and_sum GREATER THAN max_and_sum  \n                        SET max_and_sum TO and_sum  \n                    END IF  \n                    DECREMENT element at position i of slots_list BY one  \n                END IF  \n            END FOR  \n              \n            RETURN max_and_sum  \n        END FUNCTION  \n          \n        SET initial_slots TO tuple consisting of zero repeated numSlots times  \n        RETURN dp function called with zero AND initial_slots  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-good-triplets-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS BIT  \n    FUNCTION __init__ (n)  \n        SET size TO n  \n        SET tree TO a list of zeros of length size PLUS one  \n    END FUNCTION  \n  \n    FUNCTION update (idx, delta)  \n        WHILE idx LESS THAN OR EQUAL TO size  \n            SET element at position idx of tree TO element at position idx of tree PLUS delta  \n            SET idx TO idx PLUS the bitwise AND of idx AND the negation of idx interpreted as integer  \n        END WHILE  \n    END FUNCTION  \n  \n    FUNCTION query (idx)  \n        SET result TO zero  \n        WHILE idx GREATER THAN zero  \n            SET result TO result PLUS element at position idx of tree  \n            SET idx TO idx MINUS the bitwise AND of idx AND the negation of idx interpreted as integer  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION goodTriplets (nums1, nums2)  \n        SET n TO the length of nums1  \n  \n        SET pos TO a list of zeros of length n  \n        SET i TO zero  \n        FOR each number named num IN nums1  \n            SET element at position num of pos TO i  \n            INCREMENT i BY one  \n        END FOR  \n  \n        SET compressed TO an empty list  \n        FOR each number named num IN nums2  \n            APPEND element at position num of pos TO compressed  \n        END FOR  \n  \n        ASSIGN reference TO a new instance of BIT initialized with n  \n        SET bit TO reference  \n  \n        SET smaller_count TO a list of zeros of length n  \n        SET larger_count TO a list of zeros of length n  \n  \n        SET i TO zero  \n        WHILE i LESS THAN n  \n            SET element at position i of smaller_count TO bit query called with element at position i of compressed  \n            CALL bit update with parameters element at position i of compressed PLUS one and one  \n            INCREMENT i BY one  \n        END WHILE  \n  \n        ASSIGN reference TO a new instance of BIT initialized with n  \n        SET bit TO reference  \n  \n        SET i TO n MINUS one  \n        WHILE i GREATER THAN OR EQUAL TO zero  \n            SET element at position i of larger_count TO bit query called with n MINUS bit query called with element at position i of compressed PLUS one  \n            CALL bit update with parameters element at position i of compressed PLUS one and one  \n            DECREMENT i BY one  \n        END WHILE  \n  \n        SET good_triplets TO zero  \n        SET i TO zero  \n        WHILE i LESS THAN n  \n            SET good_triplets TO good_triplets PLUS element at position i of smaller_count MULTIPLIED BY element at position i of larger_count  \n            INCREMENT i BY one  \n        END WHILE  \n  \n        RETURN good_triplets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-array-pairs-divisible-by-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET gcd_count TO a new counter collection  \n        \n        FOR each num IN nums  \n            INCREMENT the count in gcd_count for the gcd of num AND k BY one  \n        END FOR  \n        \n        SET total_pairs TO zero  \n        \n        SET gcd_values TO the list of keys of gcd_count  \n        SET n TO the length of gcd_values  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET gcd1 TO the element at position i of gcd_values  \n                SET gcd2 TO the element at position j of gcd_values  \n                \n                IF the remainder of gcd1 MULTIPLIED BY gcd2 DIVIDED BY k EQUALS zero THEN  \n                    IF i EQUALS j THEN  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd1 in gcd_count MINUS one DIVIDED BY two  \n                    ELSE  \n                        INCREMENT total_pairs BY the count of gcd1 in gcd_count MULTIPLIED BY the count of gcd2 in gcd_count  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-finish-the-race", "passing_rate": 1.0, "pseudocode": "CLASS Solution\n    FUNCTION minimumFinishTime(tires, changeTime, numLaps)\n        SET min_times TO a list of length FIFTEEN with all elements set to positive infinity\n        FOR each pair of first_variable AND ratio IN tires\n            SET total_time TO zero\n            FOR index FROM zero TO FOURTEEN\n                SET lap_time TO first_variable MULTIPLIED BY ratio RAISED TO the power of index\n                IF lap_time IS GREATER THAN changeTime PLUS first_variable\n                    BREAK the current loop\n                END IF\n                SET total_time TO total_time PLUS lap_time\n                IF total_time IS LESS THAN element at position index of min_times\n                    SET element at position index of min_times TO total_time\n                END IF\n            END FOR\n        END FOR\n\n        SET dp TO a list of length numLaps PLUS one with all elements set to positive infinity\n        SET element at position zero of dp TO zero\n\n        FOR i FROM one TO numLaps\n            FOR j FROM zero TO THE LESSER OF i MINUS one AND FOURTEEN\n                SET candidate_time TO element at position i MINUS j MINUS one of dp PLUS element at position j of min_times PLUS changeTime\n                IF candidate_time IS LESS THAN element at position i of dp\n                    SET element at position i of dp TO candidate_time\n                END IF\n            END FOR\n        END FOR\n\n        RETURN element at position numLaps of dp MINUS changeTime\n    END FUNCTION\nEND CLASS"}
{"task_id": "replace-non-coprime-numbers-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION replaceNonCoprimes(nums)  \n        SET stack TO an empty list  \n        FOR each num IN nums  \n            WHILE the LENGTH OF stack IS GREATER THAN zero  \n                SET g TO the greatest common divisor of the element at position the LENGTH OF stack MINUS one of stack AND num  \n                IF g EQUALS one  \n                    BREAK the WHILE loop  \n                END IF  \n                SET num TO the element at position the LENGTH OF stack MINUS one of stack MULTIPLIED BY num DIVIDED BY g  \n                REMOVE the element at position the LENGTH OF stack MINUS one FROM stack  \n            END WHILE  \n            APPEND num TO stack  \n        END FOR  \n        RETURN stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-weighted-subgraph-with-the-required-paths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumWeight(n edges src1 src2 dest)  \n        FUNCTION dijkstra(graph start)  \n            SET distances TO a list containing the value infinity repeated n times  \n            SET the element at position start of distances TO zero  \n            SET heap TO a list containing the pair zero and start  \n            \n            WHILE the LENGTH OF heap hold more than zero  \n                SET current_distance and current_node TO the result of removing the smallest element from heap  \n                \n                IF current_distance GREATER THAN the element at position current_node of distances  \n                    CONTINUE to the next iteration  \n                END IF  \n                \n                FOR each neighbor and weight IN the element at position current_node of graph  \n                    SET distance TO current_distance PLUS weight  \n                    \n                    IF distance LESS THAN the element at position neighbor of distances  \n                        SET the element at position neighbor of distances TO distance  \n                        ADD the pair distance and neighbor TO heap  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN distances  \n        END FUNCTION  \n        \n        SET graph TO a list containing n empty lists  \n        SET reverse_graph TO a list containing n empty lists  \n        \n        FOR each u v w IN edges  \n            APPEND the pair v and w TO the element at position u of graph  \n            APPEND the pair u and w TO the element at position v of reverse_graph  \n        END FOR  \n        \n        SET dist_from_src1 TO the result of calling dijkstra with graph and src1  \n        SET dist_from_src2 TO the result of calling dijkstra with graph and src2  \n        SET dist_to_dest TO the result of calling dijkstra with reverse_graph and dest  \n        \n        SET min_weight TO infinity  \n        \n        FOR each i FROM zero TO n MINUS one  \n            IF the element at position i of dist_from_src1 NOT EQUALS infinity AND the element at position i of dist_from_src2 NOT EQUALS infinity AND the element at position i of dist_to_dest NOT EQUALS infinity  \n                SET min_weight TO the minimum of min_weight and the sum of the element at position i of dist_from_src1 PLUS the element at position i of dist_from_src2 PLUS the element at position i of dist_to_dest  \n            END IF  \n        END FOR  \n        \n        IF min_weight EQUALS infinity  \n            RETURN negative one  \n        ELSE  \n            RETURN min_weight  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-white-tiles-after-covering-with-carpets", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumWhiteTiles(floor numCarpets carpetLen)  \n        SET n TO the LENGTH OF floor  \n        SET dp TO a two dimensional list of size n PLUS one BY numCarpets PLUS one FILLED WITH zeros  \n        FOR i FROM one TO n  \n            SET dp element at position i zero TO the VALUE OF dp element at position i MINUS one zero PLUS the EXPRESSION that element at position i MINUS one of floor EQUALS one  \n        END FOR  \n        FOR j FROM one TO numCarpets  \n            FOR i FROM one TO n  \n                SET dp element at position i j TO dp element at position i MINUS one j PLUS the EXPRESSION that element at position i MINUS one of floor EQUALS one  \n                SET dp element at position i j TO the MINIMUM OF the CURRENT dp element at position i j AND dp element at position MAXIMUM OF zero AND i MINUS carpetLen j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN dp element at position n numCarpets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-of-one-repeating-character", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestRepeating(s queryCharacters queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF the character element at position three of element at position i of intervals EQUALS the character element at position three of element at position i PLUS one of intervals  \n                    SET element at position i of intervals TO a tuple consisting of element at position one of element at position i of intervals COMMA element at position two of element at position i PLUS one of intervals COMMA character element at position three of element at position i of intervals  \n                    REMOVE element at position i PLUS one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n        \n        SET intervals TO an empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple consisting of start COMMA i MINUS one COMMA element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple consisting of start COMMA n MINUS one COMMA element at position start of s TO intervals  \n        \n        SET results TO an empty list  \n        SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n        \n        FOR each char idx IN the corresponding pairs of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start end c TO the tuple element at position i of intervals  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF idx GREATER THAN start  \n                INSERT a tuple consisting of start COMMA idx MINUS one COMMA c AT position i OF intervals  \n                SET element at position i PLUS one of intervals TO a tuple consisting of idx COMMA end COMMA c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT a tuple consisting of idx PLUS one COMMA end COMMA c AT position i PLUS one OF intervals  \n                SET element at position i of intervals TO a tuple consisting of start COMMA idx COMMA c  \n            END IF  \n            \n            SET element at position i of intervals TO a tuple consisting of the first element of element at position i of intervals COMMA the second element of element at position i of intervals COMMA char  \n            \n            CALL merge_intervals()  \n            \n            SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n            APPEND longest TO results  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-value-of-k-coins-from-piles", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxValueOfCoins(piles, k)  \n        SET n TO the LENGTH OF piles  \n        SET dp TO a LIST OF LISTS of zero WITH the SIZE of n PLUS one BY k PLUS one  \n\n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                SET current_pile TO element at position i MINUS one of piles  \n                SET current_value TO zero  \n                FOR l FROM zero TO the MINIMUM OF j AND the LENGTH OF current_pile  \n                    IF l GREATER THAN zero  \n                        INCREMENT current_value BY element at position l MINUS one of current_pile  \n                    END IF  \n                    IF dp at position i and j LESS THAN dp at position i MINUS one and j MINUS l PLUS current_value  \n                        SET dp at position i and j TO dp at position i MINUS one and j MINUS l PLUS current_value  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n\n        RETURN dp at position n and k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-scores-of-built-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumScores(s)  \n        SET n TO the LENGTH OF s  \n        SET lcp TO a list of zeros with LENGTH n  \n\n        SET l TO zero  \n        SET r TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF i LESS THAN OR EQUAL TO r  \n                SET lcp at position i TO the MINIMUM OF r MINUS i PLUS one AND lcp at position i MINUS l  \n            END IF  \n            \n            WHILE i PLUS lcp at position i LESS THAN n AND the element at position lcp at position i of s EQUALS the element at position i PLUS lcp at position i of s  \n                INCREMENT lcp at position i BY one  \n            END WHILE  \n            \n            IF i PLUS lcp at position i MINUS one GREATER THAN r  \n                SET l TO i  \n                SET r TO i PLUS lcp at position i MINUS one  \n            END IF  \n        END FOR  \n\n        SET total_score TO the SUM OF all elements in lcp PLUS n  \n        RETURN total_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-total-beauty-of-the-gardens", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET n TO the LENGTH OF flowers  \n        SET max_beauty TO zero  \n        SET prefix_sum TO A LIST OF ZEROS WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at POSITION i PLUS one OF prefix_sum TO element at POSITION i OF prefix_sum PLUS element at POSITION i OF flowers  \n        END FOR  \n        SET complete_gardens TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at POSITION i OF flowers GREATER THAN OR EQUAL TO target THEN  \n                INCREMENT complete_gardens BY one  \n            ELSE  \n                BREAK  \n            END IF  \n        END FOR  \n        SET remaining_flowers TO newFlowers  \n        SET max_incomplete_flowers TO zero  \n        FOR i FROM complete_gardens TO n  \n            IF i GREATER THAN zero THEN  \n                DECREMENT remaining_flowers BY target MINUS element at POSITION n MINUS i OF flowers  \n                IF remaining_flowers LESS THAN zero THEN  \n                    BREAK  \n                END IF  \n            END IF  \n            SET left TO zero  \n            SET right TO n MINUS i MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n                SET cost TO element at POSITION mid OF flowers MULTIPLIED BY mid PLUS one MINUS element at POSITION mid PLUS one OF prefix_sum  \n                IF cost GREATER THAN remaining_flowers THEN  \n                    DECREMENT right BY one PLUS mid MINUS right  \n                ELSE  \n                    INCREMENT left BY one PLUS mid MINUS left  \n                END IF  \n            END WHILE  \n            IF right GREATER THAN OR EQUAL TO zero THEN  \n                SET max_incomplete_flowers TO element at POSITION right OF flowers PLUS remaining_flowers MINUS element at POSITION right OF flowers MULTIPLIED BY right PLUS one PLUS NEGATION OF element at POSITION right PLUS one OF prefix_sum DIVIDED BY right PLUS one USING INTEGER DIVISION  \n            ELSE  \n                SET max_incomplete_flowers TO zero  \n            END IF  \n            SET total_beauty TO i MULTIPLIED BY full PLUS THE MINIMUM OF max_incomplete_flowers AND target MINUS one MULTIPLIED BY partial  \n            IF total_beauty GREATER THAN max_beauty THEN  \n                SET max_beauty TO total_beauty  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-of-a-node-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(scores, edges)  \n        CREATE graph AS a new default mapping from elements to empty lists  \n        FOR each element u AND element v IN edges  \n            APPEND a pair consisting of the element at position v of scores AND element v TO the list associated with element u in graph  \n            APPEND a pair consisting of the element at position u of scores AND element u TO the list associated with element v in graph  \n        END FOR  \n        FOR each element node IN graph  \n            SET the list associated with element node in graph TO the three highest scoring pairs from the list associated with element node in graph  \n        END FOR  \n        SET max_score TO negative one  \n        FOR each element u AND element v IN edges  \n            FOR each pair consisting of score1 AND x IN the list associated with element u in graph  \n                FOR each pair consisting of score2 AND y IN the list associated with element v in graph  \n                    IF the set containing x AND y AND u AND v HAS size EQUALS four  \n                        SET max_score TO the greater value between max_score AND the sum of score1 PLUS score2 PLUS the element at position u of scores PLUS the element at position v of scores  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN max_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-path-with-different-adjacent-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPath(parent, s)  \n        ASSIGN reference TO a new default dictionary with list as default value and name it tree  \n        FOR each index i and element p IN parent  \n            IF p NOT EQUALS negative one  \n                APPEND i TO the element at position p of tree  \n            END IF  \n        END FOR  \n  \n        SET self dot result TO one  \n  \n        FUNCTION dfs(node)  \n            SET max1 TO zero  \n            SET max2 TO zero  \n  \n            FOR each child IN the element at position node of tree  \n                SET child_length TO the result of calling dfs with child as argument  \n  \n                IF the element at position child of s NOT EQUALS the element at position node of s  \n                    IF child_length GREATER THAN max1  \n                        SET max2 TO max1  \n                        SET max1 TO child_length  \n                    ELSE IF child_length GREATER THAN max2  \n                        SET max2 TO child_length  \n                    END IF  \n                END IF  \n            END FOR  \n  \n            SET self dot result TO the greater value BETWEEN self dot result AND the sum of max1 PLUS max2 PLUS one  \n  \n            RETURN max1 PLUS one  \n        END FUNCTION  \n  \n        CALL dfs with zero as argument  \n  \n        RETURN self dot result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-cost-of-trip-with-k-highways", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumCost(n, highways, k)  \n        CREATE graph AS a default mapping FROM a key TO a list  \n        FOR each city1 city2 toll IN highways  \n            APPEND the pair of city2 and toll TO the list in graph at key city1  \n            APPEND the pair of city1 and toll TO the list in graph at key city2  \n        END FOR  \n  \n        FUNCTION dfs(city visited cost highways_used)  \n            DECLARE max_cost AS nonlocal variable  \n  \n            IF highways_used EQUALS k THEN  \n                SET max_cost TO the greater value BETWEEN max_cost AND cost  \n                RETURN  \n            END IF  \n  \n            FOR each neighbor toll IN the list at graph at key city  \n                IF neighbor NOT IN visited THEN  \n                    ADD neighbor TO visited  \n                    CALL dfs WITH neighbor visited cost PLUS toll highways_used PLUS one  \n                    REMOVE neighbor FROM visited  \n                END IF  \n            END FOR  \n        END FUNCTION  \n  \n        SET max_cost TO negative one  \n        FOR start_city FROM zero TO n MINUS one  \n            SET visited TO a set containing start_city  \n            CALL dfs WITH start_city visited zero zero  \n        END FOR  \n  \n        RETURN max_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-flowers-in-full-bloom", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fullBloomFlowers(flowers, people)  \n        SET start_times TO sorted list of the first element of each pair in flowers  \n        SET end_times TO sorted list of the second element of each pair in flowers  \n        SET result TO empty list  \n        FOR each person IN people  \n            SET started TO the count of elements in start_times that are less than or equal to person by binary searching the position to the right of person  \n            SET ended TO the count of elements in end_times that are less than person by binary searching the position to the left of person  \n            APPEND started MINUS ended TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-the-spreading-fire", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO the LIST of elements each being a PAIR consisting of one and zero MINUS one and zero zero and one zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two-dimensional list of size m by n each element set TO infinity  \n            SET queue TO an empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one  \n                        APPEND the TRIPLE consisting of i j and zero TO queue  \n                        SET element at position i and j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx and ny of grid EQUALS zero AND element at position nx and ny of fire_times EQUALS infinity  \n                        SET element at position nx and ny of fire_times TO t PLUS one  \n                        APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a double-ended queue containing a single TRIPLE consisting of zero zero and wait  \n            SET visited TO a set containing the PAIR zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the PAIR nx ny NOT IN visited AND element at position nx and ny of grid EQUALS zero  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one  \n                            IF element at position nx and ny of fire_times GREATER THAN OR EQUAL TO t PLUS one  \n                                RETURN true  \n                            ELSE  \n                                RETURN false  \n                            END IF  \n                        END IF  \n                        IF element at position nx and ny of fire_times GREATER THAN t PLUS one  \n                            ADD the PAIR nx ny TO visited  \n                            APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two rounded down to the nearest integer  \n            IF can_escape(mid)  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result NOT EQUALS m MULTIPLIED BY n  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "total-appeal-of-a-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION appealSum(s)  \n        SET last TO a list of length twenty six with each element set to minus one  \n        SET total_appeal TO zero  \n        SET current_appeal TO zero  \n        FOR each position i AND character char IN the enumeration of s  \n            SET index TO the numeric code of character char MINUS the numeric code of character a  \n            INCREMENT current_appeal BY position i MINUS element at position index of last  \n            INCREMENT total_appeal BY current_appeal  \n            SET element at position index of last TO position i  \n        END FOR  \n        RETURN total_appeal  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-there-is-a-valid-parentheses-string-path", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF the sum of m PLUS n MINUS one MODULO two NOT EQUALS zero  \n            RETURN false  \n        END IF  \n        \n        SET dp TO a three dimensional collection of size m PLUS one BY n PLUS one BY m PLUS n PLUS one FILLED WITH false  \n        \n        SET element at position zero of element at position one of dp TO true  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                FOR k FROM zero TO m PLUS n  \n                    IF element at position i of element at position j PLUS one of dp at position k OR element at position i PLUS one of element at position j of dp at position k  \n                        IF element at position i of element at position j of grid EQUALS the opening parenthesis AND k PLUS one LESS THAN m PLUS n PLUS one  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k PLUS one TO true  \n                        ELSE IF element at position i of element at position j of grid EQUALS the closing parenthesis AND k MINUS one GREATER THAN OR EQUAL TO zero  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k MINUS one TO true  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m of element at position n of dp at position zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "substring-with-largest-variance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestVariance(s)  \n        FUNCTION calculate_variance(substring, char_a, char_b)  \n            SET max_variance TO zero  \n            SET count_a TO zero  \n            SET count_b TO zero  \n            SET has_b TO false  \n            SET first_b TO false  \n            \n            FOR each char IN substring  \n                IF char EQUALS char_a  \n                    INCREMENT count_a BY one  \n                ELSE IF char EQUALS char_b  \n                    INCREMENT count_b BY one  \n                    SET has_b TO true  \n                END IF  \n                \n                IF count_b GREATER THAN zero  \n                    SET max_variance TO the greater value BETWEEN max_variance AND count_a MINUS count_b  \n                ELSE IF count_b EQUALS zero AND first_b EQUALS true  \n                    SET max_variance TO the greater value BETWEEN max_variance AND count_a MINUS one  \n                END IF  \n                \n                IF count_b GREATER THAN count_a  \n                    SET count_a TO zero  \n                    SET count_b TO zero  \n                    SET first_b TO has_b  \n                END IF  \n            END FOR  \n            \n            RETURN max_variance  \n        END FUNCTION  \n        \n        SET max_variance TO zero  \n        SET unique_chars TO the set of all different characters in s  \n        \n        FOR each ordered pair of distinct characters char_a AND char_b IN all permutations of unique_chars taking two at a time  \n            IF char_a EQUALS char_b  \n                CONTINUE to the next iteration  \n            END IF  \n            SET max_variance TO the greater value BETWEEN max_variance AND calculate_variance with arguments s char_a char_b  \n        END FOR  \n        \n        RETURN max_variance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-node-to-path-in-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION closestNode(n, edges, query)  \n        SET graph TO a new mapping from keys to empty lists  \n        FOR each element u and element v IN edges  \n            APPEND element v TO the list mapped by key u in graph  \n            APPEND element u TO the list mapped by key v in graph  \n        END FOR  \n        \n        FUNCTION find_path(start, end)  \n            SET queue TO a new double-ended queue containing one element which is a pair consisting of start and a list containing start  \n            SET visited TO a new set containing start  \n            \n            WHILE the size of queue is greater than zero  \n                SET node and path TO the first element removed from queue  \n                IF node EQUALS end THEN  \n                    RETURN path  \n                END IF  \n                FOR each neighbor IN the list mapped by key node in graph  \n                    IF neighbor NOT IN visited THEN  \n                        ADD neighbor TO visited  \n                        APPEND a pair consisting of neighbor and concatenation of path and a list containing neighbor TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n        END FUNCTION  \n        \n        FUNCTION closest_node_on_path(path, node)  \n            SET min_distance TO infinity  \n            SET closest_node TO no value  \n            FOR each element p IN path  \n                SET distance TO the length of find_path with first argument p and second argument node MINUS one  \n                IF distance LESS THAN min_distance THEN  \n                    SET min_distance TO distance  \n                    SET closest_node TO p  \n                END IF  \n            END FOR  \n            RETURN closest_node  \n        END FUNCTION  \n        \n        SET answer TO an empty list  \n        FOR each element start and element end and element node IN query  \n            SET path TO find_path with first argument start and second argument end  \n            APPEND closest_node_on_path with first argument path and second argument node TO answer  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-obstacle-removal-to-reach-corner", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumObstacles(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO a list containing the elements: pair of zero and one, pair of one and zero, pair of zero and negative one, pair of negative one and zero  \n        SET min_heap TO a list containing a triple of zero zero zero representing initial cost and coordinates  \n        SET visited TO a set containing the pair of zero and zero representing starting position  \n        \n        WHILE min_heap is not empty  \n            REMOVE from min_heap the element with the smallest first value and ASSIGN its three parts TO cost x y  \n            \n            IF pair of x and y EQUALS pair of m MINUS one and n MINUS one  \n                RETURN cost  \n            END IF  \n            \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND pair of nx ny NOT IN visited  \n                    ADD pair of nx ny TO visited  \n                    SET new_cost TO cost PLUS the element at position nx and then position ny of grid  \n                    INSERT new_cost nx ny INTO min_heap while maintaining heap property  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
