{"task_id": "longest-substring-without-repeating-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLongestSubstring(s)  \n        SET char_index_map TO an empty collection with keys as characters and values as positions  \n        SET max_length TO zero  \n        SET start TO zero  \n\n        FOR each position end and character char IN s  \n            IF char IS IN char_index_map AND the value at char in char_index_map IS GREATER THAN OR EQUAL TO start  \n                SET start TO the value at char in char_index_map PLUS one  \n            END IF  \n            SET the value at char in char_index_map TO end  \n            SET max_length TO the greater value BETWEEN max_length AND end MINUS start PLUS one  \n        END FOR  \n\n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "median-of-two-sorted-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMedianSortedArrays(nums1, nums2)  \n        IF the LENGTH OF nums1 IS GREATER THAN the LENGTH OF nums2  \n            SET temporary_reference TO nums1  \n            SET nums1 TO nums2  \n            SET nums2 TO temporary_reference  \n        END IF  \n        SET x TO the LENGTH OF nums1  \n        SET y TO the LENGTH OF nums2  \n        SET low TO zero  \n        SET high TO x  \n        WHILE low IS LESS THAN OR EQUAL TO high  \n            SET partitionX TO the INTEGER RESULT OF the SUM OF low PLUS high DIVIDED BY two  \n            SET partitionY TO the INTEGER RESULT OF the SUM OF x PLUS y PLUS one DIVIDED BY two MINUS partitionX  \n            IF partitionX EQUALS zero  \n                SET maxLeftX TO negative infinity  \n            ELSE  \n                SET maxLeftX TO the element at position partitionX MINUS one OF nums1  \n            END IF  \n            IF partitionX EQUALS x  \n                SET minRightX TO positive infinity  \n            ELSE  \n                SET minRightX TO the element at position partitionX OF nums1  \n            END IF  \n            IF partitionY EQUALS zero  \n                SET maxLeftY TO negative infinity  \n            ELSE  \n                SET maxLeftY TO the element at position partitionY MINUS one OF nums2  \n            END IF  \n            IF partitionY EQUALS y  \n                SET minRightY TO positive infinity  \n            ELSE  \n                SET minRightY TO the element at position partitionY OF nums2  \n            END IF  \n            IF maxLeftX IS LESS THAN OR EQUAL TO minRightY AND maxLeftY IS LESS THAN OR EQUAL TO minRightX  \n                IF the MODULO OF the SUM OF x PLUS y DIVIDED BY two EQUALS zero  \n                    RETURN the SUM OF the GREATER VALUE BETWEEN maxLeftX AND maxLeftY PLUS the SMALLER VALUE BETWEEN minRightX AND minRightY DIVIDED BY two  \n                ELSE  \n                    RETURN the GREATER VALUE BETWEEN maxLeftX AND maxLeftY  \n                END IF  \n            ELSE IF maxLeftX IS GREATER THAN minRightY  \n                SET high TO partitionX MINUS one  \n            ELSE  \n                SET low TO partitionX PLUS one  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-palindromic-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindrome WITH parameter s  \n        SET n TO the LENGTH OF s  \n        SET f TO a two dimensional list with n rows and n columns where each element is TRUE  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM the value of n MINUS two DOWN TO zero  \n            FOR j FROM the value of i PLUS one TO the value of n MINUS one  \n                SET the element at position i and j of f TO FALSE  \n                IF the element at position i of s EQUALS the element at position j of s  \n                    SET the element at position i and j of f TO the element at position i PLUS one and j MINUS one of f  \n                    IF the element at position i and j of f AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the substring of s from position k TO position k PLUS mx MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "zigzag-conversion", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION convert WITH PARAMETERS s numRows  \n        IF numRows EQUALS one  \n            RETURN s  \n        END IF  \n        SET rows TO list containing numRows empty strings  \n        SET current_row TO zero  \n        SET going_down TO false  \n        FOR each character IN s  \n            SET element at position current_row of rows TO element at position current_row of rows PLUS character  \n            IF current_row EQUALS zero OR current_row EQUALS numRows MINUS one  \n                SET going_down TO NOT going_down  \n            END IF  \n            IF going_down EQUALS true  \n                INCREMENT current_row BY one  \n            ELSE  \n                DECREMENT current_row BY one  \n            END IF  \n        END FOR  \n        RETURN concatenation of all elements in rows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-integer", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reverse(x)  \n        IF x LESS THAN zero  \n            SET sign TO negative one  \n        ELSE  \n            SET sign TO one  \n        END IF  \n        SET absolute value of x TO the absolute value of x  \n        SET string representation TO the string form of absolute value of x  \n        SET reversed string TO the characters of string representation in reverse order  \n        SET reversed number TO the integer form of reversed string  \n        SET result TO sign MULTIPLIED BY reversed number  \n        IF result LESS THAN negative one MULTIPLIED BY two RAISED TO THE power of thirty one OR result GREATER THAN two RAISED TO THE power of thirty one MINUS one  \n            RETURN zero  \n        END IF  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-to-integer-atoi", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two raised to the power of thirty one MINUS one  \n        SET INT_MIN TO negative two raised to the power of thirty one  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS a single space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS a plus character OR element at position index of s EQUALS a minus character)  \n            IF element at position index of s EQUALS a minus character  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the integer value of element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "regular-expression-matching", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO two dimensional list of False with number of rows equal to the length of s plus one and number of columns equal to the length of p plus one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p inclusive  \n            IF element at position j minus one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO element at position zero j minus two of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s inclusive  \n            FOR j FROM one TO the length of p inclusive  \n                IF element at position j minus one of p EQUALS element at position i minus one of s OR element at position j minus one of p EQUALS the character representing dot  \n                    SET element at position i j of dp TO element at position i minus one j minus one of dp  \n                ELSE IF element at position j minus one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO element at position i j minus two of dp  \n                    IF element at position j minus two of p EQUALS element at position i minus one of s OR element at position j minus two of p EQUALS the character representing dot  \n                        SET element at position i j of dp TO element at position i j of dp OR element at position i minus one j of dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "container-with-most-water", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxArea(height)  \n        SET left TO zero  \n        SET right TO the LENGTH OF height MINUS one  \n        SET max_area TO zero  \n        WHILE left LESS THAN right  \n            SET current_area TO the MINIMUM OF the element at position left of height AND the element at position right of height MULTIPLIED BY right MINUS left  \n            SET max_area TO the MAXIMUM OF max_area AND current_area  \n            IF the element at position left of height LESS THAN the element at position right of height  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-to-roman", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION intToRoman(num)  \n        SET val TO list of one thousand nine hundred ninety nine hundred fifty four hundred one hundred ninety fifty forty ten nine five four one  \n        SET syms TO list of the string M CM D CD C XC L XL X IX V IV I  \n        SET roman_numeral TO empty string  \n        SET i TO zero  \n        WHILE num GREATER THAN zero  \n            FOR each iteration FROM zero TO the integer quotient of num DIVIDED BY the element at position i of val MINUS one  \n                APPEND the element at position i of syms TO roman_numeral  \n                DECREMENT num BY the element at position i of val  \n            END FOR  \n            INCREMENT i BY one  \n        END WHILE  \n        RETURN roman_numeral  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "3sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION threeSum(nums)  \n        CALL the sort METHOD OF nums  \n        SET result TO an empty list  \n        SET n TO the LENGTH OF nums  \n        \n        FOR i FROM zero TO n MINUS two MINUS one  \n            IF i GREATER THAN zero AND element at position i of nums EQUALS element at position i MINUS one of nums  \n                CONTINUE to next iteration  \n            END IF  \n            \n            SET left TO i PLUS one  \n            SET right TO n MINUS one  \n            WHILE left LESS THAN right  \n                SET total TO element at position i of nums PLUS element at position left of nums PLUS element at position right of nums  \n                IF total EQUALS zero  \n                    APPEND list consisting of element at position i of nums AND element at position left of nums AND element at position right of nums TO result  \n                    WHILE left LESS THAN right AND element at position left of nums EQUALS element at position left PLUS one of nums  \n                        INCREMENT left BY one  \n                    END WHILE  \n                    WHILE left LESS THAN right AND element at position right of nums EQUALS element at position right MINUS one of nums  \n                        DECREMENT right BY one  \n                    END WHILE  \n                    INCREMENT left BY one  \n                    DECREMENT right BY one  \n                ELSE IF total LESS THAN zero  \n                    INCREMENT left BY one  \n                ELSE  \n                    DECREMENT right BY one  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "3sum-closest", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION threeSumClosest(nums target)  \n        SORT nums in ascending order  \n        SET closest_sum TO positive infinity  \n        FOR index i FROM zero TO the LENGTH OF nums MINUS two  \n            SET left TO i PLUS one  \n            SET right TO the LENGTH OF nums MINUS one  \n            WHILE left LESS THAN right  \n                SET current_sum TO element at position i of nums PLUS element at position left of nums PLUS element at position right of nums  \n                IF absolute value of current_sum MINUS target LESS THAN absolute value of closest_sum MINUS target  \n                    SET closest_sum TO current_sum  \n                END IF  \n                IF current_sum LESS THAN target  \n                    INCREMENT left BY one  \n                ELSE IF current_sum GREATER THAN target  \n                    DECREMENT right BY one  \n                ELSE  \n                    RETURN current_sum  \n                END IF  \n            END WHILE  \n        END FOR  \n        RETURN closest_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "4sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fourSum(nums target)  \n        SORT nums IN ASCENDING ORDER  \n        SET n TO the LENGTH OF nums  \n        SET quadruplets TO an EMPTY LIST  \n        \n        FOR i FROM zero TO n MINUS three MINUS one  \n            IF i GREATER THAN zero AND element at position i of nums EQUALS element at position i MINUS one of nums  \n                CONTINUE TO the NEXT ITERATION  \n            END IF  \n            \n            FOR j FROM i PLUS one TO n MINUS two MINUS one  \n                IF j GREATER THAN i PLUS one AND element at position j of nums EQUALS element at position j MINUS one of nums  \n                    CONTINUE TO the NEXT ITERATION  \n                END IF  \n                \n                SET left TO j PLUS one  \n                SET right TO n MINUS one  \n                \n                WHILE left LESS THAN right  \n                    SET total TO the element at position i of nums PLUS the element at position j of nums PLUS the element at position left of nums PLUS the element at position right of nums  \n                    \n                    IF total EQUALS target  \n                        APPEND a LIST containing the element at position i of nums and the element at position j of nums and the element at position left of nums and the element at position right of nums TO quadruplets  \n                        \n                        WHILE left LESS THAN right AND element at position left of nums EQUALS element at position left PLUS one of nums  \n                            INCREMENT left BY one  \n                        END WHILE  \n                        \n                        WHILE left LESS THAN right AND element at position right of nums EQUALS element at position right MINUS one of nums  \n                            DECREMENT right BY one  \n                        END WHILE  \n                        \n                        INCREMENT left BY one  \n                        DECREMENT right BY one  \n                    ELSE IF total LESS THAN target  \n                        INCREMENT left BY one  \n                    ELSE  \n                        DECREMENT right BY one  \n                    END IF  \n                END WHILE  \n            END FOR  \n        END FOR  \n        \n        RETURN quadruplets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "generate-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generateParenthesis(n)  \n        FUNCTION backtrack(s as string empty string left as integer zero right as integer zero)  \n            IF length of s EQUALS two MULTIPLIED BY n THEN  \n                APPEND s TO result  \n                RETURN  \n            END IF  \n            IF left LESS THAN n THEN  \n                CALL backtrack WITH s CONCATENATED WITH opening parenthesis left INCREMENTED BY one right  \n            END IF  \n            IF right LESS THAN left THEN  \n                CALL backtrack WITH s CONCATENATED WITH closing parenthesis left right INCREMENTED BY one  \n            END IF  \n        END FUNCTION  \n        SET result TO empty list  \n        CALL backtrack WITH default parameters  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-permutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextPermutation(nums)  \n        SET i TO the LENGTH OF nums MINUS two  \n        WHILE i GREATER THAN OR EQUAL TO zero AND element at position i of nums GREATER THAN OR EQUAL TO element at position i PLUS one of nums  \n            DECREMENT i BY one  \n        END WHILE  \n        \n        IF i GREATER THAN OR EQUAL TO zero  \n            SET j TO the LENGTH OF nums MINUS one  \n            WHILE element at position j of nums LESS THAN OR EQUAL TO element at position i of nums  \n                DECREMENT j BY one  \n            END WHILE  \n            \n            CALL swap_elements_at_positions WITH nums AND positions i AND j  \n        END IF  \n        \n        CALL reverse_subsequence_starting_at_position WITH nums AND position i PLUS one  \n    END FUNCTION  \n\n    FUNCTION swap_elements_at_positions(nums, position_one, position_two)  \n        SET temporary_value TO element at position position_one of nums  \n        SET element at position position_one of nums TO element at position position_two of nums  \n        SET element at position position_two of nums TO temporary_value  \n    END FUNCTION  \n\n    FUNCTION reverse_subsequence_starting_at_position(nums, start_position)  \n        SET end_position TO the LENGTH OF nums MINUS one  \n        WHILE start_position LESS THAN end_position  \n            CALL swap_elements_at_positions WITH nums AND positions start_position AND end_position  \n            INCREMENT start_position BY one  \n            DECREMENT end_position BY one  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-valid-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestValidParentheses(s)  \n        SET stack TO list containing the value negative one  \n        SET max_length TO zero  \n        FOR each index i AND character char IN s  \n            IF character char EQUALS the opening parenthesis symbol  \n                APPEND index i TO stack  \n            ELSE  \n                REMOVE the last element FROM stack  \n                IF stack IS empty  \n                    APPEND index i TO stack  \n                ELSE  \n                    SET difference TO index i MINUS the last element IN stack  \n                    SET max_length TO the larger value BETWEEN max_length AND difference  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-in-rotated-sorted-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION search(nums WITH TYPE List OF integers, target WITH TYPE integer) RETURNS integer  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS the DIFFERENCE OF right MINUS left DIVIDED BY two  \n            IF the element at position mid of nums EQUALS target  \n                RETURN mid  \n            END IF  \n            IF the element at position left of nums LESS THAN OR EQUAL TO the element at position mid of nums  \n                IF the element at position left of nums LESS THAN OR EQUAL TO target AND target LESS THAN the element at position mid of nums  \n                    SET right TO mid MINUS one  \n                ELSE  \n                    SET left TO mid PLUS one  \n                END IF  \n            ELSE  \n                IF the element at position mid of nums LESS THAN target AND target LESS THAN OR EQUAL TO the element at position right of nums  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION searchRange(nums target)  \n        FUNCTION find_left(nums target)  \n            SET left TO zero  \n            SET right TO the LENGTH OF nums MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two  \n                IF the element at position mid of nums LESS THAN target  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN left  \n        END FUNCTION  \n\n        FUNCTION find_right(nums target)  \n            SET left TO zero  \n            SET right TO the LENGTH OF nums MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two  \n                IF the element at position mid of nums LESS THAN OR EQUAL TO target  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN right  \n        END FUNCTION  \n\n        SET left_index TO the result of find_left with nums and target  \n        SET right_index TO the result of find_right with nums and target  \n\n        IF left_index LESS THAN OR EQUAL TO right_index AND zero LESS THAN OR EQUAL TO right_index AND right_index LESS THAN the LENGTH OF nums AND the element at position left_index of nums EQUALS target  \n            RETURN list containing left_index AND right_index  \n        ELSE  \n            RETURN list containing minus one AND minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sudoku-solver", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solveSudoku(board)  \n        FUNCTION is_valid(board, row, col, num)  \n            FOR i FROM zero TO eight  \n                IF element at position i of row at position row of board EQUALS num  \n                    RETURN False  \n                END IF  \n            END FOR  \n            FOR i FROM zero TO eight  \n                IF element at position col of row at position i of board EQUALS num  \n                    RETURN False  \n                END IF  \n            END FOR  \n            SET start_row TO three MULTIPLIED BY integer division of row BY three  \n            SET start_col TO three MULTIPLIED BY integer division of col BY three  \n            FOR i FROM zero TO two  \n                FOR j FROM zero TO two  \n                    IF element at position start_col PLUS j of row at position start_row PLUS i of board EQUALS num  \n                        RETURN False  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        FUNCTION solve(board)  \n            FOR row FROM zero TO eight  \n                FOR col FROM zero TO eight  \n                    IF element at position col of row at position row of board EQUALS the single character dot  \n                        FOR num IN the string representations of numbers from one TO nine  \n                            IF is_valid(board, row, col, num)  \n                                SET element at position col of row at position row of board TO num  \n                                IF solve(board) HOLDS True  \n                                    RETURN True  \n                                END IF  \n                                SET element at position col of row at position row of board TO the single character dot  \n                            END IF  \n                        END FOR  \n                        RETURN False  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        CALL solve(board)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-and-say", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countAndSay WITH PARAMETER n  \n        IF n EQUALS one  \n            RETURN the character one expressed as string  \n        END IF  \n        SET current_sequence TO the character one expressed as string  \n        FOR each integer underscore FROM one TO n MINUS one  \n            SET next_sequence TO the empty string  \n            SET count TO one  \n            SET previous_char TO the element at position zero of current_sequence  \n            FOR each integer i FROM one TO the length of current_sequence MINUS one  \n                IF the element at position i of current_sequence EQUALS previous_char  \n                    INCREMENT count BY one  \n                ELSE  \n                    APPEND the string representation of count TO next_sequence  \n                    APPEND previous_char TO next_sequence  \n                    SET previous_char TO the element at position i of current_sequence  \n                    SET count TO one  \n                END IF  \n            END FOR  \n            APPEND the string representation of count TO next_sequence  \n            APPEND previous_char TO next_sequence  \n            SET current_sequence TO next_sequence  \n        END FOR  \n        RETURN current_sequence  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum2(candidates, target)  \n        FUNCTION backtrack(start, target, path)  \n            IF target EQUALS zero  \n                APPEND path TO result  \n                RETURN  \n            END IF  \n            IF target LESS THAN zero  \n                RETURN  \n            END IF  \n            FOR i FROM start TO the LENGTH OF candidates MINUS one  \n                IF i GREATER THAN start AND the element at position i of candidates EQUALS the element at position i MINUS one of candidates  \n                    CONTINUE  \n                END IF  \n                CALL backtrack WITH the value i PLUS one FOR start AND target MINUS the element at position i of candidates FOR target AND path APPENDED BY the element at position i of candidates FOR path  \n            END FOR  \n        END FUNCTION  \n        CALL sort ON candidates  \n        SET result TO an empty list  \n        CALL backtrack WITH zero FOR start AND target FOR target AND an empty list FOR path  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "first-missing-positive", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION firstMissingPositive(nums)  \n        SET n TO the LENGTH OF nums  \n        FOR index i FROM zero TO n MINUS one  \n            WHILE the element at position i of nums IS GREATER THAN OR EQUAL TO one AND the element at position i of nums IS LESS THAN OR EQUAL TO n AND the element at position equal TO the element at position i of nums MINUS one of nums IS NOT EQUALS TO the element at position i of nums  \n                SET correct_index TO the element at position i of nums MINUS one  \n                SET temporary_value TO the element at position correct_index of nums  \n                SET the element at position correct_index of nums TO the element at position i of nums  \n                SET the element at position i of nums TO temporary_value  \n            END WHILE  \n        END FOR  \n        FOR index i FROM zero TO n MINUS one  \n            IF the element at position i of nums IS NOT EQUALS TO i PLUS one  \n                RETURN i PLUS one  \n            END IF  \n        END FOR  \n        RETURN n PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "trapping-rain-water", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION trap(height)  \n        IF height EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET n TO the LENGTH OF height  \n        SET left_max TO a list of zeros with LENGTH n  \n        SET right_max TO a list of zeros with LENGTH n  \n        SET element at position one of left_max TO element at position one of height  \n        FOR i FROM two TO n  \n            SET element at position i of left_max TO the GREATER VALUE OF element at position i MINUS one of left_max AND element at position i of height  \n        END FOR  \n        SET element at position n of right_max TO element at position n of height  \n        FOR i FROM n MINUS one MINUS one DOWN TO one DECREMENT BY one  \n            SET element at position i of right_max TO the GREATER VALUE OF element at position i PLUS one of right_max AND element at position i of height  \n        END FOR  \n        SET trapped_water TO zero  \n        FOR i FROM one TO n  \n            INCREMENT trapped_water BY the SMALLER VALUE OF element at position i of left_max AND element at position i of right_max MINUS element at position i of height  \n        END FOR  \n        RETURN trapped_water  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "multiply-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION multiply(num1  \n    num2)  \n        IF num1 EQUALS the string zero OR num2 EQUALS the string zero  \n            RETURN the string zero  \n        END IF  \n        SET result TO a list of zero repeated the LENGTH OF num1 PLUS the LENGTH OF num2 times  \n        SET num1 TO the characters of num1 in reverse order  \n        SET num2 TO the characters of num2 in reverse order  \n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the numeric code of the element at position i of num1 MINUS the numeric code of the character zero MULTIPLIED BY the numeric code of the element at position j of num2 MINUS the numeric code of the character zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum_ TO mul PLUS the element at position p1 of result  \n                SET the element at position p1 of result TO the remainder of sum_ DIVIDED BY ten  \n                INCREMENT the element at position p2 of result BY the quotient of sum_ DIVIDED BY ten  \n            END FOR  \n        END FOR  \n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading occurrences of the character zero removed  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wildcard-matching", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s parameter s TO string, p parameter p TO string) RETURNS boolean  \n        SET dp TO list of lists of boolean with the number of elements equal to the length of s PLUS one, each element is a list of boolean with the number of elements equal to the length of p PLUS one, all elements initialized to False  \n        \n        SET element at position zero of element at position zero of dp TO True  \n        \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character represented by asterisk  \n                SET element at position zero of element at position j of dp TO element at position zero of element at position j MINUS one of dp  \n            END IF  \n        END FOR  \n        \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character represented by asterisk  \n                    SET element at position i of element at position j of dp TO element at position i MINUS one of element at position j of dp OR element at position i of element at position j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character represented by question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i of element at position j of dp TO element at position i MINUS one of element at position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position the length of s of element at position the length of p of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION jump(nums)  \n        IF the LENGTH OF nums LESS THAN OR EQUAL TO one THEN  \n            RETURN zero  \n        END IF  \n        SET jumps TO zero  \n        SET current_end TO zero  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one MINUS one  \n            SET farthest TO the GREATER THAN OR EQUAL TO VALUE BETWEEN farthest AND the SUM OF i PLUS the element at position i of nums  \n            IF i EQUALS current_end THEN  \n                INCREMENT jumps BY one  \n                SET current_end TO farthest  \n                IF current_end GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one THEN  \n                    BREAK  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN jumps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION permute(nums)  \n        FUNCTION backtrack(path, remaining)  \n            IF the LENGTH OF remaining EQUALS zero  \n                APPEND path TO permutations  \n                RETURN  \n            END IF  \n            FOR i FROM zero TO the LENGTH OF remaining MINUS one  \n                SET new_path TO the concatenation of path PLUS the element at position i of remaining  \n                SET new_remaining TO the concatenation of the SUBLIST of remaining FROM position zero TO position i MINUS one PLUS the SUBLIST of remaining FROM position i PLUS one TO the LAST position  \n                CALL backtrack WITH new_path AND new_remaining  \n            END FOR  \n        END FUNCTION  \n        SET permutations TO an empty list  \n        CALL backtrack WITH an empty list AND nums  \n        RETURN permutations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutations-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION permuteUnique(nums)  \n        FUNCTION backtrack(path, used, res)  \n            IF the LENGTH OF path EQUALS the LENGTH OF nums  \n                APPEND a COPY OF path TO res  \n                RETURN  \n            END IF  \n            FOR index i FROM zero TO the LENGTH OF nums MINUS one  \n                IF element at position i of used IS true OR (i GREATER THAN zero AND element at position i of nums EQUALS element at position i MINUS one of nums AND element at position i MINUS one of used IS false)  \n                    CONTINUE TO next iteration  \n                END IF  \n                SET element at position i of used TO true  \n                APPEND element at position i of nums TO path  \n                CALL backtrack WITH arguments path used res  \n                REMOVE the last element FROM path  \n                SET element at position i of used TO false  \n            END FOR  \n        END FUNCTION  \n        CALL the SORT method ON nums  \n        SET res TO an empty list  \n        SET used TO a list of false values WITH the LENGTH OF nums  \n        CALL backtrack WITH arguments an empty list used res  \n        RETURN res  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-image", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rotate(matrix)  \n        SET n TO the LENGTH OF matrix  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET temporary_value TO the element at position j of element at position i of matrix  \n                SET the element at position j of element at position i of matrix TO the element at position i of element at position j of matrix  \n                SET the element at position i of element at position j of matrix TO temporary_value  \n            END FOR  \n        END FOR  \n        FOR i FROM zero TO n MINUS one  \n            CALL reverse_row WITH the element at position i of matrix AS parameter  \n        END FOR  \n    END FUNCTION  \n  \n    FUNCTION reverse_row(row)  \n        SET left_index TO zero  \n        SET right_index TO the LENGTH OF row MINUS one  \n        WHILE left_index LESS THAN right_index  \n            SET temporary_value TO the element at position right_index of row  \n            SET the element at position right_index of row TO the element at position left_index of row  \n            SET the element at position left_index of row TO temporary_value  \n            INCREMENT left_index BY one  \n            DECREMENT right_index BY one  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "group-anagrams", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION groupAnagrams(strs)  \n        SET anagrams TO an empty dictionary that returns an empty list for missing keys  \n        FOR each string s IN strs  \n            SET sorted_str TO the result of concatenating the characters of s arranged in ascending alphabetical order  \n            APPEND s TO the list stored in anagrams with the key sorted_str  \n        END FOR  \n        RETURN the list of all values contained in anagrams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "powx-n", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION myPow(x FLOAT, n INTEGER) RETURNS FLOAT  \n        FUNCTION qpow(a FLOAT, n INTEGER) RETURNS FLOAT  \n            SET ans TO one  \n            WHILE n GREATER THAN zero  \n                IF the remainder of n DIVIDED BY two EQUALS one  \n                    SET ans TO ans MULTIPLIED BY a  \n                END IF  \n                SET a TO a MULTIPLIED BY a  \n                SET n TO n DIVIDED BY two discarding remainder  \n            END WHILE  \n            RETURN ans  \n        END FUNCTION  \n  \n        IF n GREATER THAN OR EQUAL TO zero  \n            RETURN qpow with arguments x and n  \n        ELSE  \n            RETURN one DIVIDED BY qpow with arguments x and the negative of n  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "n-queens", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solveNQueens WITH PARAMETER n  \n        FUNCTION is_not_under_attack WITH PARAMETERS row col  \n            RETURN the negation of the expression that the element at position col of the list cols PLUS the element at position that is the difference of row MINUS col of the list hills PLUS the element at position that is the sum of row PLUS col of the list dales IS NOT EQUALS zero  \n        END FUNCTION  \n        \n        FUNCTION place_queen WITH PARAMETERS row col  \n            ADD the tuple consisting of row and col TO the set queens  \n            SET the element at position col of the list cols TO one  \n            SET the element at position that is the difference of row MINUS col of the list hills TO one  \n            SET the element at position that is the sum of row PLUS col of the list dales TO one  \n        END FUNCTION  \n        \n        FUNCTION remove_queen WITH PARAMETERS row col  \n            REMOVE the tuple consisting of row and col FROM the set queens  \n            SET the element at position col of the list cols TO zero  \n            SET the element at position that is the difference of row MINUS col of the list hills TO zero  \n            SET the element at position that is the sum of row PLUS col of the list dales TO zero  \n        END FUNCTION  \n        \n        FUNCTION add_solution  \n            SET solution TO an empty list  \n            FOR each tuple of an unused variable and col IN the collection of elements of the set queens sorted by their first component  \n                SET row_string TO the concatenation of the string consisting of a single dot repeated col times PLUS the string consisting of the letter Q PLUS the string consisting of a single dot repeated the difference of n MINUS col MINUS one times  \n                APPEND row_string TO the list solution  \n            END FOR  \n            APPEND the list solution TO the list output  \n        END FUNCTION  \n        \n        FUNCTION backtrack WITH OPTIONAL PARAMETER row DEFAULTING TO zero  \n            FOR col FROM zero TO the difference of n MINUS one  \n                IF is_not_under_attack WITH ARGUMENTS row col RETURNS true  \n                    CALL place_queen WITH ARGUMENTS row col  \n                    IF the sum of row PLUS one EQUALS n  \n                        CALL add_solution  \n                    ELSE  \n                        CALL backtrack WITH ARGUMENT the sum of row PLUS one  \n                    END IF  \n                    CALL remove_queen WITH ARGUMENTS row col  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET cols TO a list of length n with all elements zero  \n        SET hills TO a list of length that is the difference of two times n MINUS one with all elements zero  \n        SET dales TO a list of length that is the difference of two times n MINUS one with all elements zero  \n        SET queens TO an empty set  \n        SET output TO an empty list  \n        CALL backtrack WITH NO ARGUMENTS  \n        RETURN output  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "n-queens-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION totalNQueens with parameter n  \n        FUNCTION is_not_under_attack with parameters row and col  \n            RETURN NOT the sum of element at position col of cols PLUS element at position difference of row MINUS col of hills PLUS element at position sum of row PLUS col of dales EQUALS zero  \n        END FUNCTION  \n        \n        FUNCTION place_queen with parameters row and col  \n            SET element at position col of cols TO one  \n            SET element at position difference of row MINUS col of hills TO one  \n            SET element at position sum of row PLUS col of dales TO one  \n        END FUNCTION  \n        \n        FUNCTION remove_queen with parameters row and col  \n            SET element at position col of cols TO zero  \n            SET element at position difference of row MINUS col of hills TO zero  \n            SET element at position sum of row PLUS col of dales TO zero  \n        END FUNCTION  \n        \n        FUNCTION backtrack with parameters row and count  \n            FOR col FROM zero TO n MINUS one  \n                IF is_not_under_attack with arguments row and col EQUALS true  \n                    CALL place_queen with arguments row and col  \n                    IF sum of row PLUS one EQUALS n  \n                        INCREMENT count BY one  \n                    ELSE  \n                        SET count TO CALL backtrack with arguments sum of row PLUS one and count  \n                    END IF  \n                    CALL remove_queen with arguments row and col  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        SET cols TO a list of zero repeated n times  \n        SET hills TO a list of zero repeated the quantity of two MULTIPLIED BY n MINUS one times  \n        SET dales TO a list of zero repeated the quantity of two MULTIPLIED BY n MINUS one times  \n        \n        RETURN the result of CALL backtrack with no arguments  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSubArray(nums)  \n        SET max_sum TO element at position one of nums  \n        SET current_sum TO element at position one of nums  \n        FOR each num IN elements from position two TO the end of nums  \n            IF num GREATER THAN current_sum PLUS num  \n                SET current_sum TO num  \n            ELSE  \n                SET current_sum TO current_sum PLUS num  \n            END IF  \n            IF max_sum LESS THAN current_sum  \n                SET max_sum TO current_sum  \n            END IF  \n        END FOR  \n        RETURN max_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "spiral-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION spiralOrder(matrix)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty THEN  \n            RETURN empty list  \n        END IF  \n        SET result TO empty list  \n        SET top TO zero  \n        SET bottom TO the length of matrix MINUS one  \n        SET left TO zero  \n        SET right TO the length of element at position zero of matrix MINUS one  \n        WHILE top LESS THAN OR EQUAL TO bottom AND left LESS THAN OR EQUAL TO right  \n            FOR i FROM left TO right  \n                APPEND element at position top of matrix AT position i TO result  \n            END FOR  \n            INCREMENT top BY one  \n            FOR i FROM top TO bottom  \n                APPEND element at position i of matrix AT position right TO result  \n            END FOR  \n            DECREMENT right BY one  \n            IF top LESS THAN OR EQUAL TO bottom THEN  \n                FOR i FROM right TO left DECREMENTING BY one  \n                    APPEND element at position bottom of matrix AT position i TO result  \n                END FOR  \n                DECREMENT bottom BY one  \n            END IF  \n            IF left LESS THAN OR EQUAL TO right THEN  \n                FOR i FROM bottom TO top DECREMENTING BY one  \n                    APPEND element at position i of matrix AT position left TO result  \n                END FOR  \n                INCREMENT left BY one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN False  \n            END IF  \n            SET sum_of_current_index_and_element TO i PLUS element at position i of nums  \n            IF sum_of_current_index_and_element GREATER THAN farthest  \n                SET farthest TO sum_of_current_index_and_element  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN True  \n        ELSE  \n            RETURN False  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "merge-intervals", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION merge(intervals)  \n        SORT intervals IN ORDER OF element at position zero of each element  \n        SET merged TO empty list  \n        FOR each interval IN intervals  \n            IF merged IS empty OR element at position one of element at position the last index of merged LESS THAN element at position zero of interval  \n                APPEND interval TO merged  \n            ELSE  \n                SET element at position one of element at position the last index of merged TO the GREATER THAN OR EQUAL TO value BETWEEN element at position one of element at position the last index of merged AND element at position one of interval  \n            END IF  \n        END FOR  \n        RETURN merged  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "insert-interval", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION insert(intervals, newInterval)  \n        IF intervals EQUALS an empty list  \n            RETURN a list containing newInterval  \n        END IF  \n        \n        SET merged TO an empty list  \n        SET i TO zero  \n        SET n TO the LENGTH OF intervals  \n        \n        WHILE i LESS THAN n AND element at position one of the element at position i of intervals LESS THAN element at position zero of newInterval  \n            APPEND element at position i of intervals TO merged  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        WHILE i LESS THAN n AND element at position zero of the element at position i of intervals LESS THAN OR EQUAL TO element at position one of newInterval  \n            SET element at position zero of newInterval TO the minimum value BETWEEN element at position zero of newInterval AND element at position zero of the element at position i of intervals  \n            SET element at position one of newInterval TO the maximum value BETWEEN element at position one of newInterval AND element at position one of the element at position i of intervals  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        APPEND newInterval TO merged  \n        \n        WHILE i LESS THAN n  \n            APPEND element at position i of intervals TO merged  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        RETURN merged  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "spiral-matrix-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generateMatrix(n)  \n        SET matrix TO an empty list  \n        FOR each number FROM zero TO n MINUS one  \n            SET row TO an empty list  \n            FOR each number FROM zero TO n MINUS one  \n                APPEND zero TO row  \n            END FOR  \n            APPEND row TO matrix  \n        END FOR  \n        \n        SET top TO zero  \n        SET bottom TO n MINUS one  \n        SET left TO zero  \n        SET right TO n MINUS one  \n        \n        SET num TO one  \n        \n        WHILE top LESS THAN OR EQUAL TO bottom AND left LESS THAN OR EQUAL TO right  \n            FOR i FROM left TO right  \n                SET element at position i of element at position top of matrix TO num  \n                INCREMENT num BY one  \n            END FOR  \n            INCREMENT top BY one  \n            \n            FOR i FROM top TO bottom  \n                SET element at position right of element at position i of matrix TO num  \n                INCREMENT num BY one  \n            END FOR  \n            DECREMENT right BY one  \n            \n            IF top LESS THAN OR EQUAL TO bottom  \n                FOR i FROM right DOWN TO left  \n                    SET element at position i of element at position bottom of matrix TO num  \n                    INCREMENT num BY one  \n                END FOR  \n                DECREMENT bottom BY one  \n            END IF  \n            \n            IF left LESS THAN OR EQUAL TO right  \n                FOR i FROM bottom DOWN TO top  \n                    SET element at position left of element at position i of matrix TO num  \n                    INCREMENT num BY one  \n                END FOR  \n                INCREMENT left BY one  \n            END IF  \n        END WHILE  \n        \n        RETURN matrix  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION uniquePaths(m, n)  \n        SET dp TO a two dimensional list where each row has n elements of one and there are m such rows  \n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                SET element at position i of dp AT position j TO element at position i MINUS one of dp AT position j PLUS element at position i of dp AT position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN element at position m MINUS one of dp AT position n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION uniquePathsWithObstacles(obstacleGrid)  \n        IF obstacleGrid EQUALS empty OR element at position zero at position zero of obstacleGrid EQUALS one  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF obstacleGrid  \n        SET n TO the LENGTH OF element at position zero of obstacleGrid  \n        SET dp TO a new two dimensional list with m rows each containing n zeros  \n        SET element at position zero at position zero of dp TO one  \n        FOR j FROM one TO n MINUS one  \n            IF element at position zero at position j of obstacleGrid EQUALS zero  \n                SET element at position zero at position j of dp TO element at position zero at position j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO m MINUS one  \n            IF element at position i at position zero of obstacleGrid EQUALS zero  \n                SET element at position i at position zero of dp TO element at position i MINUS one at position zero of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                IF element at position i at position j of obstacleGrid EQUALS zero  \n                    SET element at position i at position j of dp TO element at position i MINUS one at position j of dp PLUS element at position i at position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position m MINUS one at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-path-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minPathSum(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        CREATE a two dimensional list named dp with m rows each containing n zeros  \n        \n        SET element at position zero zero of dp TO element at position zero zero of grid  \n        \n        FOR j FROM one TO n MINUS one  \n            SET element at position zero j of dp TO element at position zero j MINUS one of dp PLUS element at position zero j of grid  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            SET element at position i zero of dp TO element at position i MINUS one zero of dp PLUS element at position i zero of grid  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                SET element at position i j of dp TO the MINIMUM OF element at position i MINUS one j of dp AND element at position i j MINUS one of dp PLUS element at position i j of grid  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m MINUS one n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        SET number pattern TO a string matching an optional plus or minus sign followed by either one or more digits optionally followed by a decimal point and zero or more digits or a decimal point followed by one or more digits and optionally followed by an exponent part consisting of the letter e followed by an optional plus or minus sign and one or more digits  \n        RETURN the result of matching the entire string s to the number pattern is not equal to nothing  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "text-justification", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fullJustify(words maxWidth)  \n        FUNCTION justify_line(line num_of_letters is_last_line)  \n            IF the LENGTH OF line EQUALS one OR is_last_line EQUALS true  \n                RETURN the concatenation of all elements in line separated by single space PLUS the repetition of single space for maxWidth MINUS num_of_letters MINUS the LENGTH OF line PLUS one TIMES  \n            ELSE  \n                SET total_spaces TO maxWidth MINUS num_of_letters  \n                SET num_of_gaps TO the LENGTH OF line MINUS one  \n                SET spaces_between_words TO total_spaces DIVIDED BY num_of_gaps  \n                SET extra_spaces TO total_spaces MODULO num_of_gaps  \n                FOR index FROM zero TO num_of_gaps MINUS one  \n                    IF index LESS THAN extra_spaces  \n                        SET element at position index of line TO element at position index of line PLUS the repetition of single space for spaces_between_words PLUS one TIMES  \n                    ELSE  \n                        SET element at position index of line TO element at position index of line PLUS the repetition of single space for spaces_between_words TIMES  \n                    END IF  \n                END FOR  \n                RETURN the concatenation of all elements in line without any separator  \n            END IF  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        SET line TO empty list  \n        SET num_of_letters TO zero  \n        \n        FOR each word IN words  \n            IF num_of_letters PLUS the LENGTH OF word PLUS the LENGTH OF line GREATER THAN maxWidth  \n                APPEND justify_line(line num_of_letters false) TO result  \n                SET line TO empty list  \n                SET num_of_letters TO zero  \n            END IF  \n            APPEND word TO line  \n            INCREMENT num_of_letters BY the LENGTH OF word  \n        END FOR  \n        \n        APPEND justify_line(line num_of_letters true) TO result  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "simplify-path", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION simplifyPath(path)  \n        SET components TO splitting path by the character slash  \n        SET stack TO an empty list  \n        FOR each component IN components  \n            IF component EQUALS an empty string OR component EQUALS a single period  \n                CONTINUE to the next iteration  \n            ELSE IF component EQUALS two periods  \n                IF stack is not empty  \n                    REMOVE the last element FROM stack  \n                END IF  \n            ELSE  \n                ADD component TO the end of stack  \n            END IF  \n        END FOR  \n        SET simplified_path TO concatenation of the character slash AND concatenation of all elements in stack separated by the character slash  \n        RETURN simplified_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "edit-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(word1 word1 AND word2 word2)  \n        SET m TO the LENGTH OF word1  \n        SET n TO the LENGTH OF word2  \n        SET dp TO a list consisting of m PLUS one elements each being a list consisting of n PLUS one zeros  \n        FOR i FROM zero TO m  \n            SET element at position zero of element at position i of dp TO i  \n        END FOR  \n        FOR j FROM zero TO n  \n            SET element at position j of element at position zero of dp TO j  \n        END FOR  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF element at position i MINUS one of word1 EQUALS element at position j MINUS one of word2 THEN  \n                    SET element at position j of element at position i of dp TO element at position j MINUS one of element at position i MINUS one of dp  \n                ELSE  \n                    SET delete_cost TO element at position j of element at position i MINUS one of dp  \n                    SET insert_cost TO element at position j MINUS one of element at position i of dp  \n                    SET replace_cost TO element at position j MINUS one of element at position i MINUS one of dp  \n                    SET minimum_cost TO the minimum value among delete_cost insert_cost AND replace_cost  \n                    SET element at position j of element at position i of dp TO one PLUS minimum_cost  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of element at position m of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "set-matrix-zeroes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION setZeroes(matrix)  \n        IF matrix EQUALS nothing OR the LENGTH OF matrix EQUALS zero OR the LENGTH OF element at position zero of matrix EQUALS zero  \n            RETURN  \n        END IF  \n\n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n\n        SET first_row_has_zero TO false  \n        FOR j FROM zero TO n MINUS one  \n            IF element at position zero of matrix AT position j EQUALS zero  \n                SET first_row_has_zero TO true  \n                BREAK  \n            END IF  \n        END FOR  \n\n        SET first_col_has_zero TO false  \n        FOR i FROM zero TO m MINUS one  \n            IF element at position i of matrix AT position zero EQUALS zero  \n                SET first_col_has_zero TO true  \n                BREAK  \n            END IF  \n        END FOR  \n\n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                IF element at position i of matrix AT position j EQUALS zero  \n                    SET element at position i of matrix AT position zero TO zero  \n                    SET element at position zero of matrix AT position j TO zero  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                IF element at position i of matrix AT position zero EQUALS zero OR element at position zero of matrix AT position j EQUALS zero  \n                    SET element at position i of matrix AT position j TO zero  \n                END IF  \n            END FOR  \n        END FOR  \n\n        IF first_row_has_zero EQUALS true  \n            FOR j FROM zero TO n MINUS one  \n                SET element at position zero of matrix AT position j TO zero  \n            END FOR  \n        END IF  \n\n        IF first_col_has_zero EQUALS true  \n            FOR i FROM zero TO m MINUS one  \n                SET element at position i of matrix AT position zero TO zero  \n            END FOR  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-colors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sortColors(nums)  \n        SET low TO zero  \n        SET mid TO zero  \n        SET high TO the LENGTH OF nums MINUS one  \n        WHILE mid LESS THAN OR EQUAL TO high  \n            IF element at position mid of nums EQUALS zero  \n                SET temporary_value TO element at position mid of nums  \n                SET element at position mid of nums TO element at position low of nums  \n                SET element at position low of nums TO temporary_value  \n                INCREMENT low BY one  \n                INCREMENT mid BY one  \n            ELSE IF element at position mid of nums EQUALS one  \n                INCREMENT mid BY one  \n            ELSE IF element at position mid of nums EQUALS two  \n                SET temporary_value TO element at position mid of nums  \n                SET element at position mid of nums TO element at position high of nums  \n                SET element at position high of nums TO temporary_value  \n                DECREMENT high BY one  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-window-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minWindow(s, t)  \n        FROM collections IMPORT Counter  \n        SET t_count TO Counter of t  \n        SET required TO the LENGTH OF t_count  \n        SET left TO zero  \n        SET right TO zero  \n        SET formed TO zero  \n        SET window_counts TO Counter object with no elements  \n        SET min_length TO positive infinity  \n        SET min_start TO zero  \n        WHILE right LESS THAN the LENGTH OF s  \n            INCREMENT the count of element at position right of s IN window_counts BY one  \n            IF element at position right of s IS IN t_count AND count of element at position right of s IN window_counts EQUALS count of element at position right of s IN t_count  \n                INCREMENT formed BY one  \n            END IF  \n            WHILE left LESS THAN OR EQUAL TO right AND formed EQUALS required  \n                SET char TO element at position left of s  \n                IF right MINUS left PLUS one LESS THAN min_length  \n                    SET min_length TO right MINUS left PLUS one  \n                    SET min_start TO left  \n                END IF  \n                DECREMENT the count of char IN window_counts BY one  \n                IF char IS IN t_count AND count of char IN window_counts LESS THAN count of char IN t_count  \n                    DECREMENT formed BY one  \n                END IF  \n                INCREMENT left BY one  \n            END WHILE  \n            INCREMENT right BY one  \n        END WHILE  \n        IF min_length EQUALS positive infinity  \n            RETURN empty string  \n        ELSE  \n            RETURN substring from position min_start TO position min_start PLUS min_length MINUS one of s  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combinations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combine(n k)  \n        FUNCTION backtrack(start path)  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH i PLUS one AND path  \n                REMOVE the last element FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL backtrack WITH one AND an empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subsets", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subsets(nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN a list containing an empty list  \n        END IF  \n        SET subsets_without_first TO the result of calling subsets with the sublist of nums from position two TO the end  \n        SET subsets_with_first TO an empty list  \n        FOR each subset IN subsets_without_first  \n            SET new_subset TO a list formed by prepending the element at position one of nums TO subset  \n            APPEND new_subset TO subsets_with_first  \n        END FOR  \n        RETURN the concatenation of subsets_without_first AND subsets_with_first  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-search", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION exist(board word)  \n        IF board EQUALS empty  \n            RETURN False  \n        END IF  \n\n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF element at position zero of board  \n        SET visited TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            SET row TO an empty list  \n            FOR j FROM zero TO n MINUS one  \n                APPEND False TO row  \n            END FOR  \n            APPEND row TO visited  \n        END FOR  \n\n        FUNCTION dfs(x y index)  \n            IF index EQUALS the LENGTH OF word  \n                RETURN True  \n            END IF  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x of visited AND element at position y OF element at position x OF visited EQUALS True OR element at position x OF board AND element at position y OF element at position x OF board NOT EQUALS element at position index OF word  \n                RETURN False  \n            END IF  \n\n            SET element at position x OF visited AND element at position y OF element at position x OF visited TO True  \n            FOR each pair dx dy IN the list of pairs consisting of negative one and zero PLUS one and zero PLUS zero and negative one PLUS zero and one  \n                IF dfs(x PLUS dx y PLUS dy index PLUS one)  \n                    RETURN True  \n                END IF  \n            END FOR  \n            SET element at position x OF visited AND element at position y OF element at position x OF visited TO False  \n            RETURN False  \n        END FUNCTION  \n\n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF dfs(i j zero)  \n                    RETURN True  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicates-from-sorted-array-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF nums EQUALS empty list THEN  \n            RETURN zero  \n        END IF  \n        SET write_index TO zero  \n        FOR i FROM zero TO the smaller value BETWEEN two AND the length of nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        FOR i FROM two TO the length of nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-in-rotated-sorted-array-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION search(nums, target)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN false  \n        END IF  \n        \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS the result of right MINUS left DIVIDED BY two  \n            \n            IF element at position mid of nums EQUALS target  \n                RETURN true  \n            END IF  \n            \n            IF element at position left of nums EQUALS element at position mid of nums AND element at position mid of nums EQUALS element at position right of nums  \n                INCREMENT left BY one  \n                DECREMENT right BY one  \n            ELSE IF element at position left of nums LESS THAN OR EQUAL TO element at position mid of nums  \n                IF element at position left of nums LESS THAN OR EQUAL TO target AND target LESS THAN element at position mid of nums  \n                    SET right TO mid MINUS one  \n                ELSE  \n                    SET left TO mid PLUS one  \n                END IF  \n            ELSE  \n                IF element at position mid of nums LESS THAN target AND target LESS THAN OR EQUAL TO element at position right of nums  \n                    SET left TO mid PLUS one  \n                ELSE  \n                    SET right TO mid MINUS one  \n                END IF  \n            END IF  \n        END WHILE  \n        \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-rectangle-in-histogram", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestRectangleArea(heights)  \n        SET stack TO a list containing only negative one  \n        SET max_area TO zero  \n        APPEND zero TO the end of heights  \n        \n        FOR each position i AND height h IN heights with their indices  \n            WHILE the element at the last position of stack DOES NOT EQUAL negative one AND height h IS LESS THAN the element at the position at the last element of stack in heights  \n                SET height TO the element at the position obtained by removing the last element from stack in heights  \n                SET width TO position i MINUS the element at the last position of stack MINUS one  \n                SET max_area TO the greater of max_area AND height MULTIPLIED BY width  \n            END WHILE  \n            APPEND position i TO stack  \n        END FOR  \n        \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximal-rectangle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximalRectangle(matrix)  \n        IF matrix EQUALS empty OR the element at position zero of matrix EQUALS empty  \n            RETURN zero  \n        END IF  \n      \n        SET rows TO the LENGTH OF matrix  \n        SET cols TO the LENGTH OF element at position zero of matrix  \n        SET heights TO a list of zero repeated cols times  \n        SET max_area TO zero  \n      \n        FOR i FROM zero TO rows MINUS one  \n            FOR j FROM zero TO cols MINUS one  \n                IF the element at position i of matrix at position j EQUALS one as a string  \n                    INCREMENT the element at position j of heights BY one  \n                ELSE  \n                    SET the element at position j of heights TO zero  \n                END IF  \n            END FOR  \n          \n            SET max_area TO the greater value BETWEEN max_area AND the result of FUNCTION largestRectangleArea WITH parameter heights  \n        END FOR  \n      \n        RETURN max_area  \n    END FUNCTION  \n      \n    FUNCTION largestRectangleArea(heights)  \n        SET stack TO an empty list  \n        SET max_area TO zero  \n        SET index TO zero  \n      \n        WHILE index LESS THAN the LENGTH OF heights  \n            IF stack IS empty OR the element at position index of heights GREATER THAN OR EQUAL TO the element at position at the last element of stack of heights  \n                APPEND index TO stack  \n                INCREMENT index BY one  \n            ELSE  \n                SET top_of_stack TO the last element REMOVED FROM stack  \n                IF stack IS empty  \n                    SET area TO the element at position top_of_stack of heights MULTIPLIED BY index  \n                ELSE  \n                    SET area TO the element at position top_of_stack of heights MULTIPLIED BY (index MINUS the last element of stack MINUS one)  \n                END IF  \n                SET max_area TO the greater value BETWEEN max_area AND area  \n            END IF  \n        END WHILE  \n      \n        WHILE stack IS NOT empty  \n            SET top_of_stack TO the last element REMOVED FROM stack  \n            IF stack IS empty  \n                SET area TO the element at position top_of_stack of heights MULTIPLIED BY index  \n            ELSE  \n                SET area TO the element at position top_of_stack of heights MULTIPLIED BY (index MINUS the last element of stack MINUS one)  \n            END IF  \n            SET max_area TO the greater value BETWEEN max_area AND area  \n        END WHILE  \n      \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "scramble-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isScramble(s1 s1 STRING s2 s2 STRING) RETURNS BOOLEAN  \n        IF s1 EQUALS s2 THEN  \n            RETURN True  \n        END IF  \n  \n        IF sorted characters of s1 NOT EQUALS sorted characters of s2 THEN  \n            RETURN False  \n        END IF  \n  \n        SET n TO the LENGTH OF s1  \n  \n        FOR i FROM one TO n MINUS one  \n            IF isScramble(substring from position one TO position i of s1, substring from position one TO position i of s2) EQUALS True AND isScramble(substring from position i PLUS one TO the end of s1, substring from position i PLUS one TO the end of s2) EQUALS True THEN  \n                RETURN True  \n            END IF  \n  \n            IF isScramble(substring from position one TO position i of s1, substring from position n MINUS i PLUS one TO the end of s2) EQUALS True AND isScramble(substring from position i PLUS one TO the end of s1, substring from position one TO position n MINUS i of s2) EQUALS True THEN  \n                RETURN True  \n            END IF  \n        END FOR  \n  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gray-code", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN list containing zero  \n        END IF  \n        SET prev_gray TO CALL grayCode WITH argument n MINUS one ON self  \n        SET mask TO one MULTIPLIED BY two RAISED TO THE POWER OF n MINUS one  \n        SET current_gray TO prev_gray APPENDED WITH list built by FOR each num IN reversed prev_gray CREATE mask OR num  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subsets-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subsetsWithDup(nums)  \n        SORT nums IN ascending order  \n        SET result TO an empty list  \n        SET subset TO an empty list  \n        \n        FUNCTION dfs(i)  \n            IF i GREATER THAN OR EQUAL TO the LENGTH OF nums  \n                APPEND a copy of subset TO result  \n                RETURN  \n            END IF  \n            \n            APPEND element at position i of nums TO subset  \n            CALL dfs WITH argument i PLUS one  \n            \n            REMOVE the last element FROM subset  \n            WHILE i PLUS one LESS THAN the LENGTH OF nums AND element at position i of nums EQUALS element at position i PLUS one of nums  \n                INCREMENT i BY one  \n            END WHILE  \n            CALL dfs WITH argument i PLUS one  \n        END FUNCTION  \n        \n        CALL dfs WITH argument zero  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decode-ways", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDecodings(s)  \n        IF s EQUALS empty string OR element at position one of s EQUALS character zero  \n            RETURN zero  \n        END IF  \n\n        SET dp TO list of zeros with length EQUALS the LENGTH OF s PLUS one  \n        SET element at position one of dp TO one  \n        SET element at position two of dp TO one  \n\n        FOR i FROM three TO the LENGTH OF s PLUS one  \n            IF element at position i MINUS one of s NOT EQUALS character zero  \n                SET element at position i of dp TO element at position i of dp PLUS element at position i MINUS one of dp  \n            END IF  \n\n            SET two_digit_string TO substring from position i MINUS two TO position i of s  \n            SET two_digit TO the integer value of two_digit_string  \n            IF two_digit GREATER THAN OR EQUAL TO ten AND two_digit LESS THAN OR EQUAL TO twenty six  \n                SET element at position i of dp TO element at position i of dp PLUS element at position i MINUS two of dp  \n            END IF  \n        END FOR  \n\n        RETURN element at position the LENGTH OF dp of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-ip-addresses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION restoreIpAddresses(s)  \n        FUNCTION is_valid(segment)  \n            IF the LENGTH OF segment EQUALS one OR the FIRST element of segment NOT EQUALS zero AND the INTEGER VALUE OF segment LESS THAN OR EQUAL TO two hundred fifty five  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n        \n        FUNCTION backtrack(start, path)  \n            IF the LENGTH OF path EQUALS four  \n                IF start EQUALS the LENGTH OF s  \n                    APPEND the JOINING of elements in path USING the word dot TO result  \n                END IF  \n                RETURN  \n            END IF  \n            FOR length FROM one TO three  \n                IF start PLUS length LESS THAN OR EQUAL TO the LENGTH OF s  \n                    SET segment TO the substring from position start TO position start PLUS length MINUS one of s  \n                    IF is_valid(segment) EQUALS true  \n                        CALL backtrack WITH start PLUS length AND path PLUS a list containing segment  \n                    END IF  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET result TO an empty list  \n        CALL backtrack WITH zero AND an empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-binary-search-trees", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numTrees WITH PARAMETER n  \n        SET dp TO a list of zeros of length n PLUS one  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            FOR j FROM one TO i  \n                SET element at position i of dp TO element at position i of dp PLUS element at position j MINUS one of dp MULTIPLIED BY element at position i MINUS j of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "interleaving-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isInterleave(s1 s1 AS string s2 s2 AS string s3 s3 AS string) RETURNS boolean  \n        IF the LENGTH OF s1 PLUS the LENGTH OF s2 NOT EQUALS the LENGTH OF s3  \n            RETURN false  \n        END IF  \n        SET dp TO a list OF boolean values all set TO false with the LENGTH OF s2 PLUS one  \n        SET the element at position zero of dp TO true  \n        FOR i FROM zero TO the LENGTH OF s1  \n            FOR j FROM zero TO the LENGTH OF s2  \n                IF i GREATER THAN zero  \n                    SET the element at position j of dp TO the element at position j of dp AND the character at position i MINUS one IN s1 EQUALS the character at position i PLUS j MINUS one IN s3  \n                END IF  \n                IF j GREATER THAN zero  \n                    SET the element at position j of dp TO the element at position j of dp OR the element at position j MINUS one of dp AND the character at position j MINUS one IN s2 EQUALS the character at position i PLUS j MINUS one IN s3  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the element at position the LENGTH OF s2 of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flatten-binary-tree-to-linked-list", "passing_rate": 1.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val SET TO zero left SET TO none right SET TO none  \n        SET the value property TO val  \n        SET the left child property TO left  \n        SET the right child property TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF the values collection does not contain any elements  \n        RETURN none  \n    END IF  \n    ASSIGN reference TO a new TreeNode object initialized with the first element of values  \n    SET counter i TO one  \n    CREATE an empty double-ended queue named queue  \n    APPEND the root reference TO the queue  \n    WHILE the queue contains any elements  \n        REMOVE and ASSIGN the first element of queue TO node  \n        IF the counter i is less than the length of values AND the element at position i of values is not none  \n            SET the left child property of node TO a new TreeNode initialized with the element at position i of values  \n            APPEND the left child property of node TO the queue  \n        END IF  \n        INCREMENT i BY one  \n        IF the counter i is less than the length of values AND the element at position i of values is not none  \n            SET the right child property of node TO a new TreeNode initialized with the element at position i of values  \n            APPEND the right child property of node TO the queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN the root reference  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p and q  \n    IF p does not exist AND q does not exist  \n        RETURN true  \n    ELSE IF p does not exist OR q does not exist  \n        RETURN false  \n    ELSE IF the value property of p NOT EQUALS the value property of q  \n        RETURN false  \n    ELSE  \n        RETURN the logical AND of the result of is_same_tree with parameters the left child property of p and the left child property of q AND the result of is_same_tree with parameters the right child property of p and the right child property of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION flatten with parameter root  \n        IF root does not exist  \n            RETURN  \n        END IF  \n        CREATE a list named stack containing the root element  \n        WHILE the stack contains any elements  \n            REMOVE and ASSIGN the last element of stack TO node  \n            IF the right child property of node exists  \n                APPEND the right child property of node TO stack  \n            END IF  \n            IF the left child property of node exists  \n                APPEND the left child property of node TO stack  \n            END IF  \n            SET the left child property of node TO none  \n            IF the stack contains any elements  \n                SET the right child property of node TO the last element of stack  \n            ELSE  \n                SET the right child property of node TO none  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDistinct(s, t)  \n        SET m TO the LENGTH OF s  \n        SET n TO the LENGTH OF t  \n        CREATE dp AS a two dimensional list with m PLUS one rows AND n PLUS one columns FILLED WITH zero  \n        FOR i FROM zero TO m  \n            SET element at position zero of element at position i of dp TO one  \n        END FOR  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF element at position i MINUS one of s EQUALS element at position j MINUS one of t THEN  \n                    SET element at position j of element at position i of dp TO element at position j MINUS one of element at position i MINUS one of dp PLUS element at position j of element at position i MINUS one of dp  \n                ELSE  \n                    SET element at position j of element at position i of dp TO element at position j of element at position i MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of element at position m of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "triangle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTotal(triangle)  \n        FOR row FROM the LENGTH OF triangle MINUS two DOWN TO zero  \n            FOR col FROM zero TO the LENGTH OF element at position row of triangle MINUS one  \n                SET element at position col of element at position row of triangle TO element at position col of element at position row of triangle PLUS the MINIMUM VALUE BETWEEN element at position col of element at position row PLUS one of triangle AND element at position col PLUS one of element at position row PLUS one of triangle  \n            END FOR  \n        END FOR  \n        RETURN element at position zero of element at position zero of triangle  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices)  \n        SET max_profit TO zero  \n        FOR i FROM two TO the LENGTH OF prices  \n            IF element at position i of prices GREATER THAN element at position i MINUS one of prices  \n                INCREMENT max_profit BY element at position i of prices MINUS element at position i MINUS one of prices  \n            END IF  \n        END FOR  \n        RETURN max_profit  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit with parameter prices  \n        IF the LENGTH OF prices EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        SET minimum price one TO positive infinity  \n        SET minimum price two TO positive infinity  \n        SET maximum profit one TO zero  \n        SET maximum profit two TO zero  \n        FOR each price IN prices  \n            IF price LESS THAN minimum price one THEN  \n                SET minimum price one TO price  \n            END IF  \n            IF price MINUS minimum price one GREATER THAN maximum profit one THEN  \n                SET maximum profit one TO price MINUS minimum price one  \n            END IF  \n            IF price MINUS maximum profit one LESS THAN minimum price two THEN  \n                SET minimum price two TO price MINUS maximum profit one  \n            END IF  \n            IF price MINUS minimum price two GREATER THAN maximum profit two THEN  \n                SET maximum profit two TO price MINUS minimum price two  \n            END IF  \n        END FOR  \n        RETURN maximum profit two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-ladder", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION ladderLength(beginWord endWord wordList)  \n        IF endWord NOT IN the collection wordList  \n            RETURN zero  \n        END IF  \n        \n        SET word_dict TO an empty default dictionary of lists  \n        SET word_length TO the LENGTH OF the sequence beginWord  \n        \n        FOR each word IN the collection wordList  \n            FOR index FROM zero TO word_length MINUS one  \n                SET intermediate_key TO the concatenation of substring from position zero TO position index MINUS one of word PLUS a placeholder PLUS substring from position index PLUS one TO the end of word  \n                APPEND word TO the list associated with intermediate_key in word_dict  \n            END FOR  \n        END FOR  \n        \n        SET queue TO a new empty double ended queue with the initial element being a pair consisting of beginWord and one  \n        SET visited TO a new set containing beginWord  \n        \n        WHILE the queue is not empty  \n            REMOVE the first element from queue and unpack it into current_word and current_length  \n            \n            FOR index FROM zero TO word_length MINUS one  \n                SET intermediate_word TO the concatenation of substring from position zero TO position index MINUS one of current_word PLUS a placeholder PLUS substring from position index PLUS one TO the end of current_word  \n                FOR each word IN the list associated with intermediate_word in word_dict  \n                    IF word EQUALS endWord  \n                        RETURN current_length PLUS one  \n                    END IF  \n                    IF word NOT IN visited  \n                        ADD word TO visited  \n                        ADD the pair consisting of word and current_length PLUS one TO the end of queue  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n        \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-consecutive-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestConsecutive(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        SET num_set TO the SET OF nums  \n        SET longest_streak TO zero  \n        FOR each num IN num_set  \n            IF the ELEMENT AT POSITION the VALUE OF num MINUS one OF num_set DOES NOT EXIST THEN  \n                SET current_num TO num  \n                SET current_streak TO one  \n                WHILE the ELEMENT AT POSITION the VALUE OF current_num PLUS one OF num_set EXISTS DO  \n                    INCREMENT current_num BY one  \n                    INCREMENT current_streak BY one  \n                END WHILE  \n                SET longest_streak TO the GREATER OF longest_streak AND current_streak  \n            END IF  \n        END FOR  \n        RETURN longest_streak  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "surrounded-regions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solve(board)  \n        IF board EQUALS empty OR element at position zero of board EQUALS empty THEN  \n            RETURN  \n        END IF  \n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF element at position zero of board  \n        \n        FUNCTION dfs(x, y)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x of element at position y of board NOT EQUALS the character O THEN  \n                RETURN  \n            END IF  \n            SET element at position x of element at position y of board TO the character S  \n            CALL dfs WITH x PLUS one AND y  \n            CALL dfs WITH x MINUS one AND y  \n            CALL dfs WITH x AND y PLUS one  \n            CALL dfs WITH x AND y MINUS one  \n        END FUNCTION  \n        \n        FOR i FROM zero TO m MINUS one  \n            CALL dfs WITH i AND zero  \n            CALL dfs WITH i AND n MINUS one  \n        END FOR  \n        \n        FOR j FROM zero TO n MINUS one  \n            CALL dfs WITH zero AND j  \n            CALL dfs WITH m MINUS one AND j  \n        END FOR  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of element at position j of board EQUALS the character O THEN  \n                    SET element at position i of element at position j of board TO the character X  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of element at position j of board EQUALS the character S THEN  \n                    SET element at position i of element at position j of board TO the character O  \n                END IF  \n            END FOR  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION partition(s)  \n        FUNCTION is_palindrome(sub)  \n            RETURN sub EQUALS the reverse of sub  \n        END FUNCTION  \n        \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the length of s THEN  \n                APPEND path TO result  \n                RETURN  \n            END IF  \n            FOR end FROM start PLUS one TO the length of s PLUS one  \n                IF is_palindrome(the substring from position start TO position end MINUS one of s) THEN  \n                    CALL backtrack WITH end AND the concatenation of path AND the substring from position start TO position end MINUS one of s  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        CALL backtrack WITH zero AND empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n\n        SET is_palindrome TO a two-dimensional list with n elements each containing n elements set to FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i of element at position i of is_palindrome TO TRUE  \n        END FOR  \n\n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start of element at position end of is_palindrome TO whether element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start of element at position end of is_palindrome TO whether element at position start of s EQUALS element at position end of s AND element at position start PLUS one of element at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n\n        SET min_cuts TO a list of length n with all elements set to zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero of element at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO infinity  \n                FOR j FROM one TO i  \n                    IF element at position j of element at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n\n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "candy", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION candy WITH PARAMETER ratings  \n        SET n TO the LENGTH OF ratings  \n        SET candies TO a list of one repeated n times  \n        FOR i FROM two TO n  \n            IF element at position i of ratings IS GREATER THAN element at position i MINUS one of ratings  \n                SET element at position i of candies TO element at position i MINUS one of candies PLUS one  \n            END IF  \n        END FOR  \n        FOR i FROM n MINUS one MINUS one DOWN TO one MINUS one BY MINUS one  \n            IF element at position i of ratings IS GREATER THAN element at position i PLUS one of ratings  \n                SET element at position i of candies TO the GREATER OF element at position i of candies AND element at position i PLUS one of candies PLUS one  \n            END IF  \n        END FOR  \n        SET total_candies TO zero  \n        FOR each candy IN candies  \n            INCREMENT total_candies BY candy  \n        END FOR  \n        RETURN total_candies  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-break", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordBreak(s string, wordDict list of string) RETURNS boolean  \n        SET wordSet TO CONVERT wordDict TO a set of strings  \n        SET dp TO a list of boolean values where each value is False WITH the LENGTH OF s PLUS one  \n        SET element at position zero of dp TO True  \n        FOR i FROM one TO the LENGTH OF s  \n            FOR j FROM zero TO i MINUS one  \n                IF element at position j of dp EQUALS True AND the substring of s from position j PLUS one TO position i IS IN wordSet  \n                    SET element at position i of dp TO True  \n                    BREAK the inner loop  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the LENGTH OF s of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-break-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordBreak(s PARAMETER s TO STRING, wordDict PARAMETER wordDict TO LIST OF STRING) RETURNS LIST OF STRING  \n        SET wordSet TO the SET CONTAINING ALL ELEMENTS OF wordDict  \n        SET memo TO the EMPTY DICTIONARY  \n        \n        FUNCTION backtrack(start PARAMETER start TO INTEGER) RETURNS LIST OF STRING  \n            IF start EXISTS AS A KEY IN memo THEN  \n                RETURN the VALUE ASSOCIATED WITH start IN memo  \n            END IF  \n            IF start EQUALS the LENGTH OF s THEN  \n                RETURN the LIST CONTAINING THE EMPTY STRING  \n            END IF  \n            \n            SET res TO the EMPTY LIST  \n            FOR each end FROM start PLUS one TO the LENGTH OF s INCLUSIVE  \n                SET word TO the SUBSTRING FROM POSITION start TO POSITION end MINUS ONE OF s  \n                IF word EXISTS AS AN ELEMENT IN wordSet THEN  \n                    FOR each sentence IN backtrack(end)  \n                        IF sentence IS THE EMPTY STRING THEN  \n                            APPEND word TO res  \n                        ELSE  \n                            APPEND word PLUS ONE SPACE PLUS sentence TO res  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            \n            SET memo AT KEY start TO res  \n            RETURN res  \n        END FUNCTION  \n        \n        RETURN backtrack WITH ARGUMENT zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "evaluate-reverse-polish-notation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION evalRPN(tokens)  \n        SET stack TO empty list  \n        FOR each token IN tokens  \n            IF token EQUALS plus SIGN OR token EQUALS minus SIGN OR token EQUALS multiplication SIGN OR token EQUALS division SIGN  \n                SET b TO element at last position of stack  \n                REMOVE element at last position FROM stack  \n                SET a TO element at last position of stack  \n                REMOVE element at last position FROM stack  \n                IF token EQUALS plus SIGN  \n                    APPEND the sum of a PLUS b TO stack  \n                ELSE IF token EQUALS minus SIGN  \n                    APPEND the difference of a MINUS b TO stack  \n                ELSE IF token EQUALS multiplication SIGN  \n                    APPEND the product of a MULTIPLIED BY b TO stack  \n                ELSE IF token EQUALS division SIGN  \n                    APPEND the integer part of a DIVIDED BY b TO stack  \n                END IF  \n            ELSE  \n                APPEND the integer value of token TO stack  \n            END IF  \n        END FOR  \n        RETURN element at first position of stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-words-in-a-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords WITH PARAMETER s  \n        SET words TO the result of splitting s BY spaces handling multiple spaces implicitly  \n        REVERSE the order of words  \n        SET reversed_string TO the concatenation of words JOINED BY a single space  \n        RETURN reversed_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN zero  \n        END IF  \n        SET max_product TO element at position one of nums  \n        SET min_product TO element at position one of nums  \n        SET result TO element at position one of nums  \n        FOR each num IN the elements of nums from position two TO the end  \n            IF num LESS THAN zero  \n                SET temporary_variable TO max_product  \n                SET max_product TO min_product  \n                SET min_product TO temporary_variable  \n            END IF  \n            IF num GREATER THAN max_product MULTIPLIED BY num  \n                SET max_product TO num  \n            ELSE  \n                SET max_product TO max_product MULTIPLIED BY num  \n            END IF  \n            IF num LESS THAN min_product MULTIPLIED BY num  \n                SET min_product TO num  \n            ELSE  \n                SET min_product TO min_product MULTIPLIED BY num  \n            END IF  \n            IF result LESS THAN max_product  \n                SET result TO max_product  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-minimum-in-rotated-sorted-array-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMin(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        WHILE left LESS THAN right  \n            SET mid TO the INTEGER RESULT OF left PLUS right DIVIDED BY two  \n            IF the element at position mid of nums GREATER THAN the element at position right of nums  \n                SET left TO mid PLUS one  \n            ELSE IF the element at position mid of nums LESS THAN the element at position right of nums  \n                SET right TO mid  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN the element at position left of nums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-with-at-most-two-distinct-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLongestSubstringTwoDistinct(s)  \n        ASSIGN reference TO a new mapping that returns zero for any key  \n        SET left TO zero  \n        SET max_length TO zero  \n        \n        FOR each position right FROM zero TO the length of s MINUS one  \n            INCREMENT the count of the element at position right of s in the mapping BY one  \n            \n            WHILE the number of keys in the mapping GREATER THAN two  \n                DECREMENT the count of the element at position left of s in the mapping BY one  \n                IF the count of the element at position left of s in the mapping EQUALS zero  \n                    REMOVE the element at position left of s FROM the mapping  \n                END IF  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            SET max_length TO the maximum BETWEEN max_length AND right MINUS left PLUS one  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "one-edit-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isOneEditDistance(s, t)  \n        IF the LENGTH OF s GREATER THAN the LENGTH OF t  \n            RETURN the RESULT OF calling isOneEditDistance WITH t AND s  \n        END IF  \n        \n        SET diff TO the LENGTH OF t MINUS the LENGTH OF s  \n        \n        IF diff GREATER THAN one  \n            RETURN False  \n        END IF  \n        \n        IF diff EQUALS zero  \n            SET count TO zero  \n            FOR each pair of characters c1 AND c2 FROM s AND t IN ORDER  \n                IF c1 NOT EQUALS c2  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n            RETURN whether count EQUALS one  \n        ELSE  \n            FOR index FROM zero TO the LENGTH OF s MINUS one  \n                IF the element at position index of s NOT EQUALS the element at position index of t  \n                    RETURN whether the substring from position index TO the END of s EQUALS the substring from position index PLUS one TO the END of t  \n                END IF  \n            END FOR  \n            RETURN True  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-peak-element", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPeakElement(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right DIVIDED BY two  \n            IF element at position mid of nums GREATER THAN element at position mid PLUS one of nums  \n                SET right TO mid  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "compare-version-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION compareVersion(version1 version1 STRING, version2 version2 STRING) RETURNS INTEGER  \n        SET v1_revisions TO the list of substrings of version1 separated by the character representing a dot  \n        SET v2_revisions TO the list of substrings of version2 separated by the character representing a dot  \n        SET max_length TO the greater of the length of v1_revisions AND the length of v2_revisions  \n        FOR index i FROM zero TO max_length MINUS one  \n            IF index i LESS THAN the length of v1_revisions  \n                SET v1 TO the integer value of the element at position i of v1_revisions  \n            ELSE  \n                SET v1 TO zero  \n            END IF  \n            IF index i LESS THAN the length of v2_revisions  \n                SET v2 TO the integer value of the element at position i of v2_revisions  \n            ELSE  \n                SET v2 TO zero  \n            END IF  \n            IF v1 LESS THAN v2  \n                RETURN negative one  \n            ELSE IF v1 GREATER THAN v2  \n                RETURN positive one  \n            END IF  \n        END FOR  \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "fraction-to-recurring-decimal", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator integer, denominator integer) RETURNS string  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string consisting of a single minus character  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n        \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n        \n        SET quotient TO the result of integer division of numerator BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n        \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign AND integer_part  \n        END IF  \n        \n        SET seen_remainders TO an empty dictionary mapping remainders TO positions  \n        SET fractional_part TO an empty list  \n        \n        WHILE remainder NOT EQUALS zero  \n            IF remainder IS in the keys of seen_remainders  \n                SET start TO the value associated to remainder in seen_remainders  \n                SET non_repeating TO the concatenation of the elements from position zero UP TO position start EXCLUSIVE of fractional_part  \n                SET repeating TO the concatenation of the elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, a single dot character, non_repeating, a left parenthesis character, repeating, AND a right parenthesis character  \n            END IF  \n            \n            ASSIGN the current length of fractional_part AS the value at remainder key in seen_remainders  \n            \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the result of integer division of remainder BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n        \n        RETURN the concatenation of sign, integer_part, a single dot character, AND the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "factorial-trailing-zeroes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION trailingZeroes(n)  \n        SET count TO zero  \n        WHILE n GREATER THAN zero  \n            SET n TO n DIVIDED BY five  \n            INCREMENT count BY n  \n        END WHILE  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dungeon-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION calculateMinimumHP(dungeon)  \n        SET m TO the LENGTH OF dungeon  \n        SET n TO the LENGTH OF element at position zero of dungeon  \n        CREATE dp AS a two dimensional list with dimensions m PLUS one by n PLUS one  \n        INITIALIZE all elements of dp TO positive infinity  \n        SET element at position m of dp and position n MINUS one TO one  \n        SET element at position m MINUS one of dp and position n TO one  \n        FOR i FROM m MINUS one DOWN TO zero  \n            FOR j FROM n MINUS one DOWN TO zero  \n                SET min_health TO the MINIMUM OF element at position i PLUS one of dp and position j  \n                AND element at position i of dp and position j PLUS one  \n                MINUS element at position i of dungeon and position j  \n                IF min_health LESS THAN one  \n                    SET element at position i of dp and position j TO one  \n                ELSE  \n                    SET element at position i of dp and position j TO min_health  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position zero of dp and position zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestNumber(nums)  \n        SET nums_str TO an empty list  \n        FOR each number IN nums  \n            APPEND the string representation of number TO nums_str  \n        END FOR  \n\n        FUNCTION compare(x, y)  \n            IF the string x concatenated with the string y GREATER THAN the string y concatenated with the string x THEN  \n                RETURN negative one  \n            ELSE IF the string x concatenated with the string y LESS THAN the string y concatenated with the string x THEN  \n                RETURN one  \n            ELSE  \n                RETURN zero  \n            END IF  \n        END FUNCTION  \n\n        SORT nums_str with the sorting order determined by the compare function  \n\n        IF the element at position zero of nums_str EQUALS the string zero THEN  \n            RETURN the string zero  \n        END IF  \n\n        SET result TO an empty string  \n        FOR each element IN nums_str  \n            CONCATENATE element TO result  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-words-in-a-string-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        CALL reverse the elements of s in place  \n        SET start TO zero  \n        FOR end FROM zero TO the LENGTH OF s MINUS one  \n            IF the element at position end of s EQUALS a space character  \n                CALL reverse the elements from position start TO position end MINUS one of s in place  \n                SET start TO end PLUS one  \n            END IF  \n        END FOR  \n        CALL reverse the elements from position start TO the last position of s in place  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "repeated-dna-sequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRepeatedDnaSequences(s)  \n        SET sequence_count TO an empty dictionary with default value zero  \n        FOR index FROM zero TO the LENGTH OF s MINUS ten PLUS one  \n            SET sequence TO the substring from position index TO position index PLUS ten MINUS one of s  \n            INCREMENT the value of sequence_count at sequence BY one  \n        END FOR  \n        SET repeated_sequences TO an empty list  \n        FOR each sequence_key IN the keys of sequence_count  \n            IF the value of sequence_count at sequence_key GREATER THAN one  \n                APPEND sequence_key TO repeated_sequences  \n            END IF  \n        END FOR  \n        RETURN repeated_sequences  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(k, prices)  \n        IF the LENGTH OF prices EQUALS zero OR k EQUALS zero  \n            RETURN zero  \n        END IF  \n\n        SET n TO the LENGTH OF prices  \n\n        IF k GREATER THAN OR EQUAL TO n DIVIDED BY two  \n            SET profit TO zero  \n            FOR i FROM one TO n MINUS one  \n                IF the element at position i of prices GREATER THAN the element at position i MINUS one of prices  \n                    INCREMENT profit BY the element at position i of prices MINUS the element at position i MINUS one of prices  \n                END IF  \n            END FOR  \n            RETURN profit  \n        END IF  \n\n        CREATE list hold WITH k PLUS one ELEMENTS EACH EQUAL TO NEGATIVE infinity  \n        CREATE list release WITH k PLUS one ELEMENTS EACH EQUAL TO zero  \n\n        FOR each price IN prices  \n            FOR i FROM one TO k  \n                SET hold at position i TO the GREATER VALUE BETWEEN hold at position i AND release at position i MINUS one MINUS price  \n                SET release at position i TO the GREATER VALUE BETWEEN release at position i AND hold at position i PLUS price  \n            END FOR  \n        END FOR  \n\n        RETURN release at position k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rotate(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET k TO k MODULO n  \n        \n        FUNCTION reverse(start end)  \n            WHILE start LESS THAN end  \n                SET temporary TO element at position start of nums  \n                SET element at position start of nums TO element at position end of nums  \n                SET element at position end of nums TO temporary  \n                INCREMENT start BY one  \n                DECREMENT end BY one  \n            END WHILE  \n        END FUNCTION  \n        \n        CALL reverse WITH zero AND n MINUS one  \n        CALL reverse WITH zero AND k MINUS one  \n        CALL reverse WITH k AND n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "house-robber", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rob(nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN zero  \n        END IF  \n        IF the LENGTH OF nums EQUALS one  \n            RETURN the element at position zero of nums  \n        END IF  \n        SET dp TO a list of zero repeated the LENGTH OF nums times  \n        SET element at position zero of dp TO the element at position zero of nums  \n        SET element at position one of dp TO the GREATER OF the element at position zero of nums AND the element at position one of nums  \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            SET element at position i of dp TO the GREATER OF the element at position i MINUS one of dp AND the element at position i MINUS two of dp PLUS the element at position i of nums  \n        END FOR  \n        RETURN the element at the last position of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bitwise-and-of-numbers-range", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rangeBitwiseAnd(left INTEGER PARAMETER right INTEGER PARAMETER) RETURNS INTEGER  \n        SET shift TO zero  \n        WHILE left LESS THAN right  \n            SET left TO the result of left DIVIDED BY two discarding remainder  \n            SET right TO the result of right DIVIDED BY two discarding remainder  \n            INCREMENT shift BY one  \n        END WHILE  \n        SET result TO left MULTIPLIED BY two RAISED TO THE POWER OF shift  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-primes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO a list of Boolean true values with the LENGTH OF n  \n        SET element at position zero of is_prime TO Boolean false  \n        SET element at position one of is_prime TO Boolean false  \n        FOR start FROM two TO the INTEGER part of the SQUARE ROOT of n PLUS one  \n            IF element at position start of is_prime EQUALS Boolean true  \n                FOR multiple FROM start MULTIPLIED BY start TO n MINUS one IN STEPS OF start  \n                    SET element at position multiple of is_prime TO Boolean false  \n                END FOR  \n            END IF  \n        END FOR  \n        RETURN the SUM of all Boolean true values in is_prime  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canFinish(numCourses numCourses PARAMETERS, prerequisites prerequisites PARAMETERS)  \n        ASSIGN reference TO a new empty mapping from item to list named graph  \n        SET indegree TO a list of zeros of length numCourses  \n        \n        FOR each pair of course and prereq IN prerequisites  \n            APPEND course TO the list at key prereq in graph  \n            INCREMENT the element at position course of indegree BY one  \n        END FOR  \n        \n        SET queue TO a new double-ended queue containing each course in the range from zero TO numCourses MINUS one with the condition that the element at position course of indegree EQUALS zero  \n        \n        WHILE queue is not empty  \n            REMOVE and ASSIGN the element from the front of queue TO current_course  \n            DECREMENT numCourses BY one  \n            \n            FOR each next_course IN the list at key current_course in graph  \n                DECREMENT the element at position next_course of indegree BY one  \n                IF the element at position next_course of indegree EQUALS zero  \n                    APPEND next_course TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the condition that numCourses EQUALS zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-size-subarray-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSubArrayLen(target parameter, nums parameter)  \n        SET left TO zero  \n        SET current_sum TO zero  \n        SET min_length TO infinite value  \n        FOR right FROM zero TO the LENGTH OF nums MINUS one  \n            INCREMENT current_sum BY the element at position right of nums  \n            WHILE current_sum GREATER THAN OR EQUAL TO target  \n                SET min_length TO the lesser OF min_length AND right MINUS left PLUS one  \n                DECREMENT current_sum BY the element at position left of nums  \n                INCREMENT left BY one  \n            END WHILE  \n        END FOR  \n        IF min_length NOT EQUALS infinite value  \n            RETURN min_length  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findOrder(numCourses, prerequisites)  \n        SET adj_list TO an empty mapping from each course from zero TO numCourses MINUS one TO an empty list  \n        SET in_degrees TO a list of zeros with length numCourses  \n        \n        FOR each pair dest AND src IN prerequisites  \n            APPEND dest TO the list at key src IN adj_list  \n            INCREMENT the element at position dest IN in_degrees BY one  \n        END FOR  \n        \n        SET queue TO a new double ended queue with each course from zero TO numCourses MINUS one WHERE the element at position course IN in_degrees EQUALS zero  \n        SET topological_order TO an empty list  \n        \n        WHILE queue is not empty  \n            SET current TO the element removed from the left end of queue  \n            APPEND current TO topological_order  \n            \n            FOR each neighbor IN the list at key current IN adj_list  \n                DECREMENT the element at position neighbor IN in_degrees BY one  \n                IF the element at position neighbor IN in_degrees EQUALS zero  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        IF the length of topological_order EQUALS numCourses  \n            RETURN topological_order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-search-ii", "passing_rate": 1.0, "pseudocode": "CLASS Trie  \n    FUNCTION __init__(self)  \n        SET self.children TO a list containing twenty-six None elements  \n        SET self.ref TO negative one  \n    END FUNCTION  \n\n    FUNCTION insert(self, w, ref)  \n        SET node TO self  \n        FOR each character c IN w  \n            SET idx TO the Unicode code point of character c MINUS the Unicode code point of character a  \n            IF element at position idx of node.children EQUALS None THEN  \n                SET element at position idx of node.children TO a new Trie object  \n            END IF  \n            SET node TO element at position idx of node.children  \n        END FOR  \n        SET node.ref TO ref  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findWords(self, board, words)  \n        FUNCTION dfs(node, i, j)  \n            SET idx TO the Unicode code point of element at position j of element at position i of board MINUS the Unicode code point of character a  \n            IF element at position idx of node.children EQUALS None THEN  \n                RETURN  \n            END IF  \n            SET node TO element at position idx of node.children  \n            IF node.ref GREATER THAN OR EQUAL TO zero THEN  \n                APPEND element at position node.ref of words TO ans  \n                SET node.ref TO negative one  \n            END IF  \n            SET c TO element at position j of element at position i of board  \n            SET element at position j of element at position i of board TO the character hash  \n            FOR a, b IN pairs of adjacent elements when iterating over the sequence negative one zero one zero negative one  \n                SET x TO i PLUS a  \n                SET y TO j PLUS b  \n                IF x GREATER THAN OR EQUAL TO zero AND x LESS THAN m AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n AND element at position y of element at position x of board NOT EQUALS character hash THEN  \n                    CALL dfs WITH arguments node, x, y  \n                END IF  \n            END FOR  \n            SET element at position j of element at position i of board TO c  \n        END FUNCTION  \n\n        SET tree TO a new Trie object  \n        FOR each index i AND element w IN words  \n            CALL insert method of tree WITH arguments w, i  \n        END FOR  \n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF element at position zero of board  \n        SET ans TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                CALL dfs WITH arguments tree, i, j  \n            END FOR  \n        END FOR  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "house-robber-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rob(nums)  \n        FUNCTION rob_linear(houses)  \n            IF the COLLECTION houses EQUALS the EMPTY COLLECTION  \n                RETURN zero  \n            END IF  \n            IF the LENGTH OF the COLLECTION houses EQUALS one  \n                RETURN the ELEMENT at POSITION one OF the COLLECTION houses  \n            END IF  \n            SET dp TO a COLLECTION OF zeroes WITH the LENGTH OF the COLLECTION houses  \n            SET the ELEMENT at POSITION one OF dp TO the ELEMENT at POSITION one OF the COLLECTION houses  \n            SET the ELEMENT at POSITION two OF dp TO the GREATER value BETWEEN the ELEMENT at POSITION one OF the COLLECTION houses AND the ELEMENT at POSITION two OF the COLLECTION houses  \n            FOR i FROM three TO the LENGTH OF the COLLECTION houses  \n                SET the ELEMENT at POSITION i OF dp TO the GREATER value BETWEEN the ELEMENT at POSITION i MINUS one OF dp AND the SUM of the ELEMENT at POSITION i MINUS two OF dp AND the ELEMENT at POSITION i OF the COLLECTION houses  \n            END FOR  \n            RETURN the ELEMENT at the LAST POSITION OF dp  \n        END FUNCTION  \n        IF the COLLECTION nums EQUALS the EMPTY COLLECTION  \n            RETURN zero  \n        END IF  \n        IF the LENGTH OF the COLLECTION nums EQUALS one  \n            RETURN the ELEMENT at POSITION one OF the COLLECTION nums  \n        END IF  \n        RETURN the GREATER value BETWEEN the RESULT OF rob_linear WITH the COLLECTION nums EXCLUDING the LAST ELEMENT AND the RESULT OF rob_linear WITH the COLLECTION nums EXCLUDING the FIRST ELEMENT  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-palindrome", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPalindrome(s)  \n        IF s EQUALS empty string  \n            RETURN s  \n        END IF  \n\n        FUNCTION is_palindrome(check_str)  \n            IF check_str EQUALS the string formed by the characters of check_str in reverse order  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n\n        FOR i FROM the LENGTH OF s TO zero DECREMENT BY one  \n            IF is_palindrome(the substring from position start zero TO position i MINUS one of s) IS true  \n                SET to_add TO the string formed by the characters of the substring from position i TO the end of s in reverse order  \n                RETURN the concatenation of to_add AND s  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-largest-element-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findKthLargest(nums k)  \n        SET min_heap TO an empty list  \n        FOR each number IN nums  \n            PUSH the number INTO the min_heap using heap insertion  \n            IF the LENGTH OF min_heap GREATER THAN k  \n                REMOVE the smallest element FROM min_heap using heap removal  \n            END IF  \n        END FOR  \n        RETURN the element at position one of min_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum3(k, n)  \n        FUNCTION backtrack(start, path, target, k)  \n            IF target EQUALS zero AND k EQUALS zero  \n                APPEND copy of path TO result  \n                RETURN  \n            END IF  \n            IF target LESS THAN zero OR k LESS THAN zero  \n                RETURN  \n            END IF  \n            FOR i FROM start TO nine  \n                APPEND i TO path  \n                CALL backtrack WITH i PLUS one AND path AND target MINUS i AND k MINUS one  \n                REMOVE last element FROM path  \n            END FOR  \n        END FUNCTION  \n\n        SET result TO empty list  \n        CALL backtrack WITH one AND empty list AND n AND k  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximal-square", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximalSquare(matrix)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET dp TO a collection of zeroes with m plus one rows each containing n plus one zeroes  \n        SET max_side TO zero  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF element at position i minus one of matrix AND element at position j minus one of that element EQUALS the character one  \n                    SET dp at position i and j TO the minimum value among dp at position i minus one and j AND dp at position i and j minus one AND dp at position i minus one and j minus one PLUS one  \n                    SET max_side TO the maximum value between max_side AND dp at position i and j  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_side MULTIPLIED BY max_side  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION computeArea(ax1 ay1 ax2 ay2 bx1 by1 bx2 by2)  \n        SET area1 TO the difference of ax2 MINUS ax1 MULTIPLIED BY the difference of ay2 MINUS ay1  \n        SET area2 TO the difference of bx2 MINUS bx1 MULTIPLIED BY the difference of by2 MINUS by1  \n        SET overlap_width TO the greater of zero AND the difference of the lesser of ax2 AND bx2 MINUS the greater of ax1 AND bx1  \n        SET overlap_height TO the greater of zero AND the difference of the lesser of ay2 AND by2 MINUS the greater of ay1 AND by1  \n        SET overlap_area TO overlap_width MULTIPLIED BY overlap_height  \n        SET total_area TO area1 PLUS area2 MINUS overlap_area  \n        RETURN total_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "majority-element-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each m IN nums  \n            IF m EQUALS m1  \n                INCREMENT n1 BY one  \n            ELSE IF m EQUALS m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements FROM the list containing m1 AND m2 WHERE the count of element IN nums GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-digit-one", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countDigitOne(n)  \n        IF n LESS THAN OR EQUAL TO zero THEN  \n            RETURN zero  \n        END IF  \n        SET count TO zero  \n        SET factor TO one  \n        WHILE factor LESS THAN OR EQUAL TO n DO  \n            SET lower_nums TO n MINUS the INTEGER DIVISION of n BY factor MULTIPLIED BY factor  \n            SET cur_num TO the INTEGER DIVISION of n BY factor MODULO ten  \n            SET higher_nums TO the INTEGER DIVISION of n BY factor MULTIPLIED BY ten  \n            IF cur_num EQUALS zero THEN  \n                INCREMENT count BY higher_nums MULTIPLIED BY factor  \n            ELSE IF cur_num EQUALS one THEN  \n                INCREMENT count BY higher_nums MULTIPLIED BY factor PLUS lower_nums PLUS one  \n            ELSE  \n                INCREMENT count BY higher_nums PLUS one MULTIPLIED BY factor  \n            END IF  \n            SET factor TO factor MULTIPLIED BY ten  \n        END WHILE  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "product-of-array-except-self", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION productExceptSelf(nums)  \n        SET n TO the LENGTH OF nums  \n        SET answer TO a new list of length n with every element SET TO one  \n        SET left_product TO one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i of answer TO left_product  \n            SET left_product TO left_product MULTIPLIED BY element at position i of nums  \n        END FOR  \n        SET right_product TO one  \n        FOR i FROM n MINUS one TO zero STEPPING DOWN BY one  \n            SET element at position i of answer TO element at position i of answer MULTIPLIED BY right_product  \n            SET right_product TO right_product MULTIPLIED BY element at position i of nums  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-window-maximum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSlidingWindow(nums k)  \n        IF nums EQUALS empty OR k EQUALS zero  \n            RETURN empty list  \n        END IF  \n\n        SET deq TO empty double ended queue  \n        SET result TO empty list  \n\n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF deq IS NOT empty AND the element at position zero of deq LESS THAN i MINUS k PLUS one  \n                REMOVE the element at position zero from deq  \n            END IF  \n\n            WHILE deq IS NOT empty AND the element at position element at position the last position of deq of nums LESS THAN element at position i of nums  \n                REMOVE the last element from deq  \n            END WHILE  \n\n            APPEND i TO deq  \n\n            IF i GREATER THAN OR EQUAL TO k MINUS one  \n                APPEND the element at position element at position zero of deq of nums TO result  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "different-ways-to-add-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION diffWaysToCompute(expression)  \n        FUNCTION compute(left, right, operator)  \n            SET results TO empty list  \n            FOR each l IN left  \n                FOR each r IN right  \n                    IF operator EQUALS the plus symbol  \n                        APPEND the sum of l PLUS r TO results  \n                    ELSE IF operator EQUALS the minus symbol  \n                        APPEND the difference of l MINUS r TO results  \n                    ELSE IF operator EQUALS the multiplication symbol  \n                        APPEND the product of l MULTIPLIED BY r TO results  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n  \n        FUNCTION helper(sub_expr)  \n            IF sub_expr CONSISTS OF digits ONLY  \n                RETURN list containing the integer value of sub_expr  \n            END IF  \n  \n            SET results TO empty list  \n            FOR index FROM zero TO the length of sub_expr MINUS one  \n                IF the element at position index of sub_expr EQUALS the plus symbol OR EQUALS the minus symbol OR EQUALS the multiplication symbol  \n                    SET left_results TO the result of calling helper on the substring from position zero TO position index MINUS one of sub_expr  \n                    SET right_results TO the result of calling helper on the substring from position index PLUS one TO the end of sub_expr  \n                    EXTEND results BY the result of calling compute with left_results AND right_results AND the element at position index of sub_expr  \n                END IF  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n  \n        RETURN the result of calling helper with expression  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-word-distance-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestWordDistance(wordsDict, word1, word2)  \n        SET min_distance TO infinity  \n        SET prev_word1 TO negative one  \n        SET prev_word2 TO negative one  \n        SET same_word TO word1 EQUALS word2  \n        \n        FOR each index i FROM zero TO the LENGTH OF wordsDict MINUS one  \n            SET word TO element at position i of wordsDict  \n            \n            IF word EQUALS word1  \n                IF same_word  \n                    SET prev_word2 TO prev_word1  \n                END IF  \n                SET prev_word1 TO i  \n            END IF  \n            \n            IF word EQUALS word2  \n                IF NOT same_word  \n                    SET prev_word2 TO i  \n                END IF  \n            END IF  \n            \n            IF prev_word1 NOT EQUALS negative one AND prev_word2 NOT EQUALS negative one  \n                IF min_distance GREATER THAN absolute value of prev_word1 MINUS prev_word2  \n                    SET min_distance TO absolute value of prev_word1 MINUS prev_word2  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN min_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findStrobogrammatic(n)  \n        FUNCTION dfs(u)  \n            IF u EQUALS zero  \n                RETURN list containing empty string  \n            END IF  \n            IF u EQUALS one  \n                RETURN list containing string zero string one string eight  \n            END IF  \n            SET ans TO empty list  \n            FOR each element v IN result of CALLING dfs with argument u MINUS two  \n                FOR each pair of characters l and r IN list containing string one one string eight eight string six nine string nine six  \n                    APPEND concatenation of character l with string v with character r TO list ans  \n                END FOR  \n                IF u NOT EQUALS n  \n                    APPEND concatenation of string zero with string v with string zero TO list ans  \n                END IF  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        RETURN result of CALLING dfs with argument n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low, high)  \n        FUNCTION generate_strobogrammatic(n, final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            IF n EQUALS one  \n                RETURN a list containing the strings zero one and eight  \n            END IF  \n            SET middles TO the result of generate_strobogrammatic of n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero concatenated with middle concatenated with zero TO result  \n                END IF  \n                APPEND the string one concatenated with middle concatenated with one TO result  \n                APPEND the string six concatenated with middle concatenated with nine TO result  \n                APPEND the string eight concatenated with middle concatenated with eight TO result  \n                APPEND the string nine concatenated with middle concatenated with six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        FUNCTION count_strobogrammatic(low, high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN generate_strobogrammatic of length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN count_strobogrammatic of low and high  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "group-shifted-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION groupStrings(strings)  \n        FUNCTION get_canonical_form(s)  \n            IF the string s EQUALS empty string  \n                RETURN empty string  \n            END IF  \n            SET canonical_form TO an empty list  \n            FOR each character c IN the string s  \n                SET difference TO the ordinal value of the character c MINUS the ordinal value of the element at position one of the string s MODULO twenty six  \n                APPEND the string representation of the difference TO canonical_form  \n            END FOR  \n            RETURN the concatenation of the elements in canonical_form SEPARATED BY a comma  \n        END FUNCTION  \n        \n        SET groups TO a new dictionary with default value as an empty list  \n        \n        FOR each string s IN the list strings  \n            SET canonical_form TO the result of calling get_canonical_form with the string s  \n            APPEND the string s TO the value in groups for the key canonical_form  \n        END FOR  \n        \n        RETURN the list of all values contained in groups  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "factor-combinations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getFactors(n)  \n        FUNCTION backtrack(start, target)  \n            FOR i FROM start TO the integer square root of target PLUS one  \n                IF target MODULO i EQUALS zero  \n                    APPEND the concatenation of path WITH i AND target DIVIDED BY i TO result  \n                    APPEND i TO path  \n                    CALL backtrack WITH i AND target DIVIDED BY i  \n                    REMOVE the last element FROM path  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        SET result TO an empty list  \n        SET path TO an empty list  \n        CALL backtrack WITH two AND n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "verify-preorder-sequence-in-binary-search-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION verifyPreorder(preorder)  \n        SET stack TO empty list  \n        SET lower_bound TO negative infinity  \n        FOR each value IN preorder  \n            IF value LESS THAN lower_bound  \n                RETURN False  \n            END IF  \n            WHILE stack is not empty AND value GREATER THAN element at last position of stack  \n                SET lower_bound TO element at last position of stack  \n                REMOVE element at last position FROM stack  \n            END WHILE  \n            APPEND value TO stack  \n        END FOR  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-house", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(costs)  \n        IF the LENGTH OF costs EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        SET prev_red TO element at position zero of element at position zero of costs  \n        SET prev_blue TO element at position one of element at position zero of costs  \n        SET prev_green TO element at position two of element at position zero of costs  \n        FOR i FROM one TO the LENGTH OF costs MINUS one  \n            SET current_red TO element at position zero of element at position i of costs PLUS the MINIMUM OF prev_blue AND prev_green  \n            SET current_blue TO element at position one of element at position i of costs PLUS the MINIMUM OF prev_red AND prev_green  \n            SET current_green TO element at position two of element at position i of costs PLUS the MINIMUM OF prev_red AND prev_blue  \n            SET prev_red TO current_red  \n            SET prev_blue TO current_blue  \n            SET prev_green TO current_green  \n        END FOR  \n        RETURN the MINIMUM OF prev_red AND prev_blue AND prev_green  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "3sum-smaller", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION threeSumSmaller(nums target)  \n        CALL sort ON nums  \n        SET count TO zero  \n        SET n TO the LENGTH OF nums  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET left TO i PLUS one  \n            SET right TO n MINUS one  \n            WHILE left LESS THAN right  \n                SET current_sum TO element at position i of nums PLUS element at position left of nums PLUS element at position right of nums  \n                IF current_sum LESS THAN target  \n                    INCREMENT count BY right MINUS left  \n                    INCREMENT left BY one  \n                ELSE  \n                    DECREMENT right BY one  \n                END IF  \n            END WHILE  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "single-number-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION singleNumber(nums)  \n        SET xor_all TO zero  \n        FOR each num IN nums  \n            SET xor_all TO xor_all XOR num  \n        END FOR  \n        SET diff_bit TO the result of bitwise AND between xor_all AND the two complement of xor_all  \n        SET num1 TO zero  \n        SET num2 TO zero  \n        FOR each num IN nums  \n            IF the result of bitwise AND between num AND diff_bit NOT EQUALS zero  \n                SET num1 TO num1 XOR num  \n            ELSE  \n                SET num2 TO num2 XOR num  \n            END IF  \n        END FOR  \n        RETURN list containing num1 AND num2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "graph-valid-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validTree(n, edges)  \n        IF the LENGTH OF edges NOT EQUALS n MINUS one  \n            RETURN False  \n        END IF  \n        \n        SET adj_list TO an empty mapping FROM integer TO empty list for each integer FROM zero TO n MINUS one  \n        \n        FOR each pair a AND b IN edges  \n            APPEND b TO the list at key a IN adj_list  \n            APPEND a TO the list at key b IN adj_list  \n        END FOR  \n        \n        SET visited TO an empty set  \n        \n        FUNCTION dfs(node)  \n            IF node IS IN visited  \n                RETURN  \n            END IF  \n            ADD node TO visited  \n            FOR each neighbor IN the list at key node IN adj_list  \n                CALL dfs WITH neighbor  \n            END FOR  \n        END FUNCTION  \n        \n        CALL dfs WITH zero  \n        \n        IF the LENGTH OF visited EQUALS n  \n            RETURN True  \n        ELSE  \n            RETURN False  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ugly-number-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nthUglyNumber(n)  \n        SET ugly_numbers TO list containing one  \n        SET i2 TO zero  \n        SET i3 TO zero  \n        SET i5 TO zero  \n        WHILE the LENGTH OF ugly_numbers LESS THAN n  \n            SET next_multiple_of_2 TO element at position i2 of ugly_numbers MULTIPLIED BY two  \n            SET next_multiple_of_3 TO element at position i3 of ugly_numbers MULTIPLIED BY three  \n            SET next_multiple_of_5 TO element at position i5 of ugly_numbers MULTIPLIED BY five  \n            SET next_ugly_number TO the SMALLEST OF next_multiple_of_2 AND next_multiple_of_3 AND next_multiple_of_5  \n            APPEND next_ugly_number TO ugly_numbers  \n            IF next_ugly_number EQUALS next_multiple_of_2  \n                INCREMENT i2 BY one  \n            END IF  \n            IF next_ugly_number EQUALS next_multiple_of_3  \n                INCREMENT i3 BY one  \n            END IF  \n            IF next_ugly_number EQUALS next_multiple_of_5  \n                INCREMENT i5 BY one  \n            END IF  \n        END WHILE  \n        RETURN element at position n MINUS one of ugly_numbers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-house-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCostII(costs)  \n        IF the LENGTH OF costs EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF costs  \n        SET k TO the LENGTH OF element at position zero of costs  \n        \n        IF k EQUALS one THEN  \n            IF n EQUALS one THEN  \n                RETURN element at position zero at position zero of costs  \n            ELSE  \n                RETURN positive infinity  \n            END IF  \n        END IF  \n        \n        FOR i FROM one TO n MINUS one  \n            SET min_cost TO positive infinity  \n            SET min_cost_index TO negative one  \n            SET second_min_cost TO positive infinity  \n            \n            FOR j FROM zero TO k MINUS one  \n                IF element at position i MINUS one at position j of costs LESS THAN min_cost THEN  \n                    SET second_min_cost TO min_cost  \n                    SET min_cost TO element at position i MINUS one at position j of costs  \n                    SET min_cost_index TO j  \n                ELSE IF element at position i MINUS one at position j of costs LESS THAN second_min_cost THEN  \n                    SET second_min_cost TO element at position i MINUS one at position j of costs  \n                END IF  \n            END FOR  \n            \n            FOR j FROM zero TO k MINUS one  \n                IF j EQUALS min_cost_index THEN  \n                    SET element at position i at position j of costs TO element at position i at position j of costs PLUS second_min_cost  \n                ELSE  \n                    SET element at position i at position j of costs TO element at position i at position j of costs PLUS min_cost  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET answer TO positive infinity  \n        FOR element IN element at position n MINUS one of costs  \n            IF element LESS THAN answer THEN  \n                SET answer TO element  \n            END IF  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-permutation-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generatePalindromes(s)  \n        FUNCTION dfs(t)  \n            IF the LENGTH OF t EQUALS the LENGTH OF s  \n                APPEND t TO ans  \n                RETURN  \n            END IF  \n            FOR each character c AND count v IN cnt  \n                IF v GREATER THAN one  \n                    DECREMENT cnt at character c BY two  \n                    CALL dfs WITH concatenation of character c PLUS t PLUS character c  \n                    INCREMENT cnt at character c BY two  \n                END IF  \n            END FOR  \n        END FUNCTION  \n      \n        ASSIGN cnt TO the counting collection of characters in s  \n        SET mid TO the empty string  \n        FOR each character c AND count v IN cnt  \n            IF v MODULO two EQUALS one  \n                IF mid IS NOT the empty string  \n                    RETURN the empty list  \n                END IF  \n                SET mid TO character c  \n                DECREMENT cnt at character c BY one  \n            END IF  \n        END FOR  \n        SET ans TO the empty list  \n        CALL dfs WITH mid  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "h-index", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SORT citations IN ORDER OF DESCENDING VALUE  \n        FOR each position i AND each citation IN citations  \n            IF citation LESS THAN i PLUS one  \n                RETURN i  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "h-index-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET n TO the LENGTH OF citations  \n        SET left TO zero  \n        SET right TO n MINUS one  \n        SET h_index TO zero  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS left MINUS right DIVIDED BY two  \n            IF element at position mid of citations GREATER THAN OR EQUAL TO n MINUS mid  \n                SET h_index TO n MINUS mid  \n                SET right TO mid MINUS one  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        \n        RETURN h_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-fence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numWays(n parameter n INTEGER k parameter k INTEGER) RETURNS INTEGER  \n        IF n EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN k  \n        END IF  \n        IF n EQUALS two THEN  \n            RETURN k MULTIPLIED BY k  \n        END IF  \n        \n        SET same TO k  \n        SET diff TO k MULTIPLIED BY k MINUS one  \n        SET total TO same PLUS diff  \n        \n        FOR i FROM three TO n  \n            SET new_same TO diff  \n            SET new_diff TO total MULTIPLIED BY k MINUS one  \n            SET same TO new_same  \n            SET diff TO new_diff  \n            SET total TO same PLUS diff  \n        END FOR  \n        \n        RETURN total  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list where each element is infinite repeated for the number of times equal to n incremented by one  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i multiplied by i is less than or equal to n  \n            APPEND i multiplied by i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n inclusive  \n            FOR each square IN squares  \n                IF i is less than square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the minimum value between dp at position i and dp at position i minus square incremented by one  \n            END FOR  \n        END FOR  \n        RETURN dp at position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wiggle-sort", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wiggleSort(nums)  \n        SET less TO true  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one MINUS one  \n            IF less  \n                IF element at position i of nums GREATER THAN element at position i PLUS one of nums  \n                    SWAP element at position i of nums WITH element at position i PLUS one of nums  \n                END IF  \n            ELSE  \n                IF element at position i of nums LESS THAN element at position i PLUS one of nums  \n                    SWAP element at position i of nums WITH element at position i PLUS one of nums  \n                END IF  \n            END IF  \n            SET less TO NOT less  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "expression-add-operators", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION addOperators(num, target) RETURNS List of strings  \n        FUNCTION dfs(index, path, value, prev)  \n            IF index EQUALS LENGTH OF num  \n                IF value EQUALS target  \n                    APPEND path TO result  \n                END IF  \n                RETURN  \n            END IF  \n            \n            FOR i FROM index PLUS one TO LENGTH OF num  \n                SET operand TO substring from position index TO position i OF num  \n                IF LENGTH OF operand GREATER THAN one AND element at position zero OF operand EQUALS character zero  \n                    CONTINUE  \n                END IF  \n                \n                IF index EQUALS zero  \n                    CALL dfs WITH arguments i, operand, integer value of operand, integer value of operand  \n                ELSE  \n                    CALL dfs WITH arguments i, path PLUS the word PLUS PLUS operand, value PLUS integer value of operand, integer value of operand  \n                    CALL dfs WITH arguments i, path PLUS the word MINUS PLUS operand, value MINUS integer value of operand, NEGATIVE integer value of operand  \n                    CALL dfs WITH arguments i, path PLUS the word MULTIPLIED BY PLUS operand, value MINUS prev PLUS prev MULTIPLIED BY integer value of operand, prev MULTIPLIED BY integer value of operand  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        CALL dfs WITH arguments zero, empty string, zero, zero  \n        RETURN result  \nEND CLASS"}
{"task_id": "walls-and-gates", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wallsAndGates WITH PARAMETER rooms  \n        IF rooms EQUALS nothing OR the LENGTH OF rooms EQUALS zero OR the LENGTH OF element at position zero of rooms EQUALS zero  \n            RETURN nothing  \n        END IF  \n        SET rows TO the LENGTH OF rooms  \n        SET cols TO the LENGTH OF element at position zero of rooms  \n        ASSIGN reference TO a new double ended queue named queue  \n        FOR variable r FROM zero TO rows MINUS one  \n            FOR variable c FROM zero TO cols MINUS one  \n                IF element at position r of rooms AND element at position c EQUALS zero  \n                    APPEND tuple consisting of r AND c TO queue  \n                END IF  \n            END FOR  \n        END FOR  \n        SET directions TO list consisting of tuple zero AND one AND tuple one AND zero AND tuple zero AND minus one AND tuple minus one AND zero  \n        WHILE the LENGTH OF queue IS GREATER THAN zero  \n            REMOVE element from the left side of queue AND SET TO variables r AND c  \n            FOR each tuple dr AND dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF zero LESS THAN OR EQUAL TO nr AND nr LESS THAN rows AND zero LESS THAN OR EQUAL TO nc AND nc LESS THAN cols AND element at position nr of rooms AND element at position nc EQUALS two billion one hundred forty seven million four hundred eighty three thousand six hundred forty seven  \n                    SET element at position nr of rooms AND element at position nc TO element at position r of rooms AND element at position c PLUS one  \n                    APPEND tuple consisting of nr AND nc TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-duplicate-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDuplicate(nums)  \n        FUNCTION f(x)  \n            SET count TO zero  \n            FOR each v IN nums  \n                IF v LESS THAN OR EQUAL TO x EQUALS true  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n            IF count GREATER THAN x EQUALS true  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n      \n        SET left_boundary TO zero  \n        SET right_boundary TO the LENGTH OF nums MINUS one  \n        WHILE left_boundary LESS THAN right_boundary  \n            SET middle_point TO left_boundary PLUS right_boundary MINUS left_boundary DIVIDED BY two  \n            IF f(middle_point) EQUALS true  \n                SET right_boundary TO middle_point  \n            ELSE  \n                SET left_boundary TO middle_point PLUS one  \n            END IF  \n        END WHILE  \n        RETURN left_boundary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "game-of-life", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION gameOfLife(board)  \n        IF board EQUALS nothing OR the LENGTH OF board EQUALS zero OR the LENGTH OF element at position zero of board EQUALS zero  \n            RETURN  \n        END IF  \n        \n        SET m TO the LENGTH OF board  \n        SET n TO the LENGTH OF element at position zero of board  \n        \n        SET directions TO a list containing the pairs of values representing the eight neighbors each pair consisting of minus one AND minus one, minus one AND zero, minus one AND one, zero AND minus one, zero AND one, one AND minus one, one AND zero, AND one AND one  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET live_neighbors TO zero  \n                FOR each pair dx dy IN directions  \n                    SET ni TO i PLUS dx  \n                    SET nj TO j PLUS dy  \n                    IF ni IS GREATER THAN OR EQUAL TO zero AND ni IS LESS THAN m AND nj IS GREATER THAN OR EQUAL TO zero AND nj IS LESS THAN n AND (element at position ni of board AT position nj EQUALS one OR element at position ni of board AT position nj EQUALS three)  \n                        INCREMENT live_neighbors BY one  \n                    END IF  \n                END FOR  \n                \n                IF element at position i of board AT position j EQUALS one  \n                    IF live_neighbors IS LESS THAN two OR live_neighbors IS GREATER THAN three  \n                        SET element at position i of board AT position j TO three  \n                    END IF  \n                ELSE  \n                    IF live_neighbors EQUALS three  \n                        SET element at position i of board AT position j TO two  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of board AT position j EQUALS two  \n                    SET element at position i of board AT position j TO one  \n                ELSE IF element at position i of board AT position j EQUALS three  \n                    SET element at position i of board AT position j TO zero  \n                END IF  \n            END FOR  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-pattern-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordPatternMatch(pattern string, s string) RETURNS boolean  \n        FUNCTION backtrack(pattern_index integer, string_index integer, mapping dictionary, used set) RETURNS boolean  \n            IF pattern_index EQUALS the LENGTH OF pattern AND string_index EQUALS the LENGTH OF s  \n                RETURN True  \n            END IF  \n            IF pattern_index EQUALS the LENGTH OF pattern OR string_index EQUALS the LENGTH OF s  \n                RETURN False  \n            END IF  \n            SET current_char TO element at position pattern_index of pattern  \n            IF current_char IS IN mapping  \n                SET word TO the VALUE ASSOCIATED WITH current_char IN mapping  \n                IF substring from position string_index TO position string_index PLUS the LENGTH OF word of s NOT EQUALS word  \n                    RETURN False  \n                END IF  \n                IF backtrack(pattern_index PLUS one, string_index PLUS the LENGTH OF word, mapping, used) RETURNS True  \n                    RETURN True  \n                END IF  \n            ELSE  \n                FOR end FROM string_index PLUS one TO the LENGTH OF s  \n                    SET word TO substring from position string_index TO position end of s  \n                    IF word IS IN used  \n                        CONTINUE TO next iteration  \n                    END IF  \n                    ASSIGN word TO current_char IN mapping  \n                    ADD word TO used  \n                    IF backtrack(pattern_index PLUS one, end, mapping, used) RETURNS True  \n                        RETURN True  \n                    END IF  \n                    REMOVE current_char FROM mapping  \n                    REMOVE word FROM used  \n                END FOR  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n        RETURN backtrack(zero, zero, empty dictionary, empty set)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flip-game-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF the element state IS IN the dictionary memo THEN  \n                RETURN the element at key state of the dictionary memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the substring from position index TO position index PLUS one of state EQUALS two plus signs THEN  \n                    SET new_state TO the concatenation of the substring from position zero TO position index of state PLUS two minus signs PLUS the substring from position index PLUS two TO the end of state  \n                    \n                    IF NOT the value returned by calling can_win_helper WITH new_state THEN  \n                        SET the element at key state of the dictionary memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the element at key state of the dictionary memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the value returned by calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-meeting-point", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minTotalDistance(grid)  \n        SET rows TO empty list  \n        SET cols TO empty list  \n        FOR index i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR index j FROM zero TO the LENGTH OF element at position i of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    APPEND i TO rows  \n                    APPEND j TO cols  \n                END IF  \n            END FOR  \n        END FOR  \n        SORT rows IN ascending order  \n        SORT cols IN ascending order  \n        SET median_row TO element at position the LENGTH OF rows DIVIDED BY two of rows  \n        SET median_col TO element at position the LENGTH OF cols DIVIDED BY two of cols  \n        SET min_distance TO zero  \n        FOR each row IN rows  \n            INCREMENT min_distance BY the absolute value of row MINUS median_row  \n        END FOR  \n        FOR each col IN cols  \n            INCREMENT min_distance BY the absolute value of col MINUS median_col  \n        END FOR  \n        RETURN min_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulls-and-cows", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getHint(secret, guess)  \n        SET bulls TO zero  \n        SET cows TO zero  \n        SET secret_count TO new empty dictionary with default zero values  \n        SET guess_count TO new empty dictionary with default zero values  \n        FOR each pair of characters s and g IN corresponding elements of secret and guess  \n            IF s EQUALS g THEN  \n                INCREMENT bulls BY one  \n            ELSE  \n                INCREMENT the value in secret_count corresponding to s BY one  \n                INCREMENT the value in guess_count corresponding to g BY one  \n            END IF  \n        END FOR  \n        FOR each digit key IN secret_count  \n            INCREMENT cows BY the smaller quantity of the value corresponding to digit key in secret_count AND the value corresponding to digit key in guess_count  \n        END FOR  \n        RETURN the concatenation of the textual value of bulls, the uppercase letter A, the textual value of cows, and the uppercase letter B  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-increasing-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLIS(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        SET dp TO an empty list  \n        FOR each num IN nums  \n            SET idx TO the POSITION where num CAN BE INSERTED in dp TO MAINTAIN SORT ORDER BY USING BINARY SEARCH  \n            IF idx EQUALS the LENGTH OF dp THEN  \n                APPEND num TO dp  \n            ELSE  \n                SET the element at position idx of dp TO num  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-rectangle-enclosing-black-pixels", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minArea(image  x  y)  \n        IF image EQUALS nothing OR the LENGTH OF image EQUALS zero OR the LENGTH OF element at position zero of image EQUALS zero  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF image  \n        SET n TO the LENGTH OF element at position zero of image  \n        \n        FUNCTION hasBlackPixelInRow(row)  \n            FOR each pixel IN element at position row of image  \n                IF pixel EQUALS one as character  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        FUNCTION hasBlackPixelInColumn(col)  \n            FOR each row FROM zero TO m MINUS one  \n                IF element at position col of element at position row of image EQUALS one as character  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        FUNCTION findTop()  \n            SET low TO zero  \n            SET high TO x  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high DIVIDED BY two with integer division  \n                IF hasBlackPixelInRow(mid) EQUALS True  \n                    SET high TO mid  \n                ELSE  \n                    SET low TO mid PLUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        FUNCTION findBottom()  \n            SET low TO x  \n            SET high TO m MINUS one  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high PLUS one DIVIDED BY two with integer division  \n                IF hasBlackPixelInRow(mid) EQUALS True  \n                    SET low TO mid  \n                ELSE  \n                    SET high TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        FUNCTION findLeft()  \n            SET low TO zero  \n            SET high TO y  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high DIVIDED BY two with integer division  \n                IF hasBlackPixelInColumn(mid) EQUALS True  \n                    SET high TO mid  \n                ELSE  \n                    SET low TO mid PLUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        FUNCTION findRight()  \n            SET low TO y  \n            SET high TO n MINUS one  \n            WHILE low LESS THAN high  \n                SET mid TO low PLUS high PLUS one DIVIDED BY two with integer division  \n                IF hasBlackPixelInColumn(mid) EQUALS True  \n                    SET low TO mid  \n                ELSE  \n                    SET high TO mid MINUS one  \n                END IF  \n            END WHILE  \n            RETURN low  \n        END FUNCTION  \n        \n        SET top TO findTop()  \n        SET bottom TO findBottom()  \n        SET left TO findLeft()  \n        SET right TO findRight()  \n        \n        RETURN (bottom MINUS top PLUS one) MULTIPLIED BY (right MINUS left PLUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-islands-ii", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self)  \n        SET self.parent TO empty mapping  \n        SET self.count TO zero  \n    END FUNCTION  \n  \n    FUNCTION make_set(self, x)  \n        IF x NOT IN self.parent THEN  \n            SET the element at position x of self.parent TO x  \n            INCREMENT self.count BY one  \n        END IF  \n    END FUNCTION  \n  \n    FUNCTION find(self, x)  \n        IF the element at position x of self.parent NOT EQUALS x THEN  \n            SET the element at position x of self.parent TO the result of calling self.find with the argument being the element at position x of self.parent  \n        END IF  \n        RETURN the element at position x of self.parent  \n    END FUNCTION  \n  \n    FUNCTION union(self, x, y)  \n        SET rootX TO the result of calling self.find with argument x  \n        SET rootY TO the result of calling self.find with argument y  \n        IF rootX NOT EQUALS rootY THEN  \n            SET the element at position rootX of self.parent TO rootY  \n            DECREMENT self.count BY one  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION numIslands2(self, m, n, positions)  \n        FUNCTION is_valid(x, y)  \n            RETURN the expression that zero IS LESS THAN OR EQUAL TO x AND x IS LESS THAN m AND zero IS LESS THAN OR EQUAL TO y AND y IS LESS THAN n  \n        END FUNCTION  \n  \n        SET directions TO the list of four elements where the first element is the tuple of one and zero the second element is the tuple of minus one and zero the third element is the tuple of zero and one the fourth element is the tuple of zero and minus one  \n        ASSIGN reference uf TO a new instance of UnionFind  \n        SET grid TO a two-dimensional list consisting of m elements each being a list of n elements all set to zero  \n        SET result TO empty list  \n  \n        FOR pair r c IN the list positions  \n            IF the element at position r of grid at position c IS EQUALS one THEN  \n                APPEND the element uf.count TO the list result  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n  \n            SET the element at position r of grid at position c TO one  \n            CALL the method make_set of uf with argument the tuple of r and c  \n  \n            FOR each pair dr dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF calling is_valid with arguments nr and nc RETURNS true AND the element at position nr of grid at position nc IS EQUALS one THEN  \n                    CALL the method union of uf WITH arguments the tuple of r and c AND the tuple of nr and nc  \n                END IF  \n            END FOR  \n  \n            APPEND the element uf.count TO the list result  \n        END FOR  \n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "additive-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isAdditiveNumber(num)  \n        FUNCTION is_valid_sequence(start, first, second)  \n            IF start EQUALS the LENGTH OF num  \n                RETURN True  \n            END IF  \n            \n            SET expected TO the STRING REPRESENTATION OF first PLUS second  \n            SET length TO the LENGTH OF expected  \n            \n            IF start PLUS length GREATER THAN the LENGTH OF num OR substring from position start TO position start PLUS length MINUS one of num NOT EQUALS expected  \n                RETURN False  \n            END IF  \n            \n            RETURN the RESULT OF is_valid_sequence WITH PARAMETERS start PLUS length SECOND second THIRD the INTEGER VALUE OF expected  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF num  \n        FOR i FROM one TO the INTEGER DIVISION OF n BY two PLUS one  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET first TO substring from position zero TO position i MINUS one of num  \n                SET second TO substring from position i TO position j MINUS one of num  \n                \n                IF the LENGTH OF first GREATER THAN one AND the element at position zero of first EQUALS the CHARACTER zero OR the LENGTH OF second GREATER THAN one AND the element at position zero of second EQUALS the CHARACTER zero  \n                    CONTINUE TO next iteration  \n                END IF  \n                \n                IF the RESULT OF is_valid_sequence WITH PARAMETERS j FIRST the INTEGER VALUE OF first SECOND the INTEGER VALUE OF second EQUALS True  \n                    RETURN True  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-with-cooldown", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices)  \n        IF prices EQUALS empty collection THEN  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF prices  \n        IF n EQUALS one THEN  \n            RETURN zero  \n        END IF  \n        \n        SET hold TO negative infinity  \n        SET sold TO zero  \n        SET rest TO zero  \n        \n        FOR each price IN prices  \n            SET new_hold TO the GREATER VALUE BETWEEN hold AND rest MINUS price  \n            SET new_sold TO hold PLUS price  \n            SET new_rest TO the GREATER VALUE BETWEEN rest AND sold  \n            \n            SET hold TO new_hold  \n            SET sold TO new_sold  \n            SET rest TO new_rest  \n        END FOR  \n        \n        RETURN the GREATER VALUE BETWEEN sold AND rest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sparse-matrix-multiplication", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION multiply(mat1 parameter, mat2 parameter)  \n        SET number_of_rows_of_mat1 TO the LENGTH OF mat1  \n        SET number_of_columns_of_mat1 TO the LENGTH OF the element at position one of mat1  \n        SET number_of_rows_of_mat2 TO the LENGTH OF mat2  \n        SET number_of_columns_of_mat2 TO the LENGTH OF the element at position one of mat2  \n        INITIALIZE result_matrix AS an empty list  \n        FOR each row_index FROM one TO number_of_rows_of_mat1  \n            INITIALIZE row_list AS an empty list  \n            FOR each column_index FROM one TO number_of_columns_of_mat2  \n                APPEND zero TO row_list  \n            END FOR  \n            APPEND row_list TO result_matrix  \n        END FOR  \n        FOR each row_index FROM one TO number_of_rows_of_mat1  \n            FOR each column_index FROM one TO number_of_columns_of_mat2  \n                FOR each inner_index FROM one TO number_of_rows_of_mat2  \n                    SET current_value TO the element at position row_index of result_matrix at position column_index  \n                    SET multiplicand_left TO the element at position row_index of mat1 at position inner_index  \n                    SET multiplicand_right TO the element at position inner_index of mat2 at position column_index  \n                    SET new_value TO current_value PLUS multiplicand_left MULTIPLIED BY multiplicand_right  \n                    SET the element at position row_index of result_matrix at position column_index TO new_value  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN result_matrix  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "burst-balloons", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxCoins(nums)  \n        SET nums TO a new list with one followed by all elements of nums followed by one  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a two dimensional list of zeros with size n by n  \n        FOR each length FROM two TO n MINUS one  \n            FOR each i FROM zero TO n MINUS length MINUS one  \n                SET j TO i PLUS length  \n                FOR each k FROM i PLUS one TO j MINUS one  \n                    SET coins TO the element at position i of nums MULTIPLIED BY the element at position k of nums MULTIPLIED BY the element at position j of nums PLUS the element at position i then k of dp PLUS the element at position k then j of dp  \n                    IF the element at position i then j of dp LESS THAN coins  \n                        SET the element at position i then j of dp TO coins  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the element at position zero then n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-ugly-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nthSuperUglyNumber(n, primes)  \n        SET ugly_numbers TO list containing one  \n        SET heap TO empty list  \n        FOR index FROM zero TO the LENGTH OF primes MINUS one  \n            APPEND tuple of element at position index of primes AND index TO heap  \n        END FOR  \n        APPLY heapify operation TO heap  \n        SET indices TO list of zeros with the LENGTH OF primes  \n        WHILE the LENGTH OF ugly_numbers LESS THAN n holds  \n            EXTRACT the tuple with the smallest first element FROM heap AND STORE first element IN next_ugly AND second element IN prime_index  \n            IF next_ugly NOT EQUALS element at the last position of ugly_numbers THEN  \n                APPEND next_ugly TO ugly_numbers  \n            END IF  \n            INCREMENT element at position prime_index of indices BY one  \n            SET next_multiple TO element at position prime_index of primes MULTIPLIED BY element at position element at position prime_index of indices of ugly_numbers  \n            PUSH tuple of next_multiple AND prime_index INTO heap  \n        END WHILE  \n        RETURN element at the last position of ugly_numbers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-of-smaller-numbers-after-self", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSmaller(nums)  \n        SET sorted_nums TO the sorted list of unique elements in nums  \n        SET rank TO an empty dictionary  \n        SET idx TO one  \n        FOR each val IN sorted_nums  \n            ASSIGN val AS KEY WITH VALUE idx IN rank  \n            INCREMENT idx BY one  \n        END FOR  \n        \n        SET bit TO a list of zeros with length equal to the LENGTH OF sorted_nums PLUS one  \n        \n        FUNCTION get_sum(idx)  \n            SET res TO zero  \n            WHILE idx GREATER THAN zero  \n                INCREMENT res BY element at position idx of bit  \n                DECREMENT idx BY the bitwise AND of idx AND its negation as a positive integer  \n            END WHILE  \n            RETURN res  \n        END FUNCTION  \n        \n        FUNCTION update(idx, delta)  \n            WHILE idx LESS THAN the LENGTH OF bit  \n                INCREMENT element at position idx of bit BY delta  \n                INCREMENT idx BY the bitwise AND of idx AND its negation as a positive integer  \n            END WHILE  \n        END FUNCTION  \n        \n        SET counts TO an empty list  \n        FOR each num IN nums traversed from last to first  \n            SET r TO value in rank for key num  \n            APPEND get_sum(r MINUS one) TO counts  \n            CALL update with parameters r AND one  \n        END FOR  \n        \n        RETURN counts traversed from last to first  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicate-letters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeDuplicateLetters(s)  \n        SET last_occurrence TO an empty dictionary  \n        FOR each index idx FROM zero TO the LENGTH OF s MINUS one  \n            SET character char TO element at position idx of s  \n            SET the value at key char of last_occurrence TO idx  \n        END FOR  \n        \n        SET stack TO an empty list  \n        SET in_stack TO an empty set  \n        \n        FOR each index idx FROM zero TO the LENGTH OF s MINUS one  \n            SET character char TO element at position idx of s  \n            \n            IF char IS IN in_stack  \n                CONTINUE TO the next iteration of the loop  \n            END IF  \n            \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND char IS LESS THAN element at the last position of stack AND idx IS LESS THAN the value at key element at the last position of stack of last_occurrence  \n                SET removed_char TO the last element removed FROM stack  \n                REMOVE removed_char FROM in_stack  \n            END WHILE  \n            \n            APPEND char TO stack  \n            ADD char TO in_stack  \n        END FOR  \n        \n        SET result TO the concatenation of all elements in stack in order  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-distance-from-all-buildings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestDistance(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN negative one  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        SET total_distance TO a list consisting of m elements each being a list consisting of n zeroes  \n        SET reach_count TO a list consisting of m elements each being a list consisting of n zeroes  \n        SET building_count TO zero  \n        \n        SET directions TO a list consisting of four elements each being a pair representing one of the following directions: one step down with zero steps sideways, one step up with zero steps sideways, zero steps down with one step rightwards, zero steps down with one step leftwards  \n        \n        FUNCTION bfs(start_x, start_y)  \n            SET queue TO a deque initialized with a pair of start_x and start_y  \n            SET visited TO a list consisting of m elements each being a list consisting of n elements each set to false  \n            SET distance TO zero  \n            SET reachable TO zero  \n            \n            WHILE the LENGTH OF queue is greater than zero  \n                SET size TO the LENGTH OF queue  \n                INCREMENT distance BY one  \n                \n                FOR each iteration number from zero TO size MINUS one  \n                    REMOVE the element from the left of queue and ASSIGN its first component TO x and second component TO y  \n                    \n                    FOR each pair dx, dy IN directions  \n                        SET nx TO x PLUS dx  \n                        SET ny TO y PLUS dy  \n                        \n                        IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n AND element at position nx of visited at position ny EQUALS false AND element at position nx of grid at position ny EQUALS zero  \n                            SET element at position nx of visited at position ny TO true  \n                            APPEND the pair of nx and ny TO queue  \n                            INCREMENT element at position nx of total_distance at position ny BY distance  \n                            INCREMENT element at position nx of reach_count at position ny BY one  \n                            INCREMENT reachable BY one  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END WHILE  \n            \n            RETURN reachable  \n        END FUNCTION  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    INCREMENT building_count BY one  \n                    IF bfs(i, j) IS LESS THAN building_count MINUS one  \n                        RETURN negative one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_distance TO a very large number representing infinity  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid at position j EQUALS zero AND element at position i of reach_count at position j EQUALS building_count  \n                    SET min_distance TO the smaller value BETWEEN min_distance AND element at position i of total_distance at position j  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF min_distance IS EQUAL TO a very large number representing infinity  \n            RETURN negative one  \n        ELSE  \n            RETURN min_distance  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-word-lengths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters in word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the set at position i of word_sets has NO COMMON ELEMENTS WITH the set at position j of word_sets  \n                    SET product TO the LENGTH OF the element at position i of words MULTIPLIED BY the LENGTH OF the element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulb-switcher", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        RETURN the integer part of the square root of n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "generalized-abbreviation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION generateAbbreviations(word)  \n        FUNCTION backtrack(index, path, count)  \n            IF index EQUALS the LENGTH OF word  \n                IF count GREATER THAN zero  \n                    APPEND the STRING REPRESENTATION OF count TO path  \n                END IF  \n                APPEND the CONCATENATION OF all elements IN path TO result  \n            ELSE  \n                IF count GREATER THAN zero  \n                    CALL backtrack WITH the value of index PLUS one the list formed by the elements of path followed by the string representation of count followed by the element at position index of word and zero AS arguments  \n                ELSE  \n                    CALL backtrack WITH the value of index PLUS one the list formed by the elements of path followed by the element at position index of word and zero AS arguments  \n                END IF  \n                CALL backtrack WITH the value of index PLUS one path and the value of count PLUS one AS arguments  \n            END IF  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL backtrack WITH zero an empty list and zero AS arguments  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "create-maximum-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxNumber(nums1 nums2 k)  \n        FUNCTION maxSingleArray(nums k)  \n            SET drop TO the LENGTH OF nums MINUS k  \n            SET stack TO an empty list  \n            FOR each num IN nums  \n                WHILE drop IS GREATER THAN zero AND stack IS NOT empty AND element at the last position of stack IS LESS THAN num  \n                    REMOVE element at the last position FROM stack  \n                    DECREMENT drop BY one  \n                END WHILE  \n                APPEND num TO stack  \n            END FOR  \n            RETURN the SUBLIST of stack from position zero TO position k minus one  \n        END FUNCTION  \n        \n        FUNCTION merge(arr1 arr2)  \n            SET merged_list TO an empty list  \n            WHILE the LENGTH OF arr1 PLUS the LENGTH OF arr2 IS GREATER THAN zero  \n                IF arr1 IS GREATER THAN arr2  \n                    APPEND element at position zero of arr1 TO merged_list  \n                    REMOVE element at position zero FROM arr1  \n                ELSE  \n                    APPEND element at position zero of arr2 TO merged_list  \n                    REMOVE element at position zero FROM arr2  \n                END IF  \n            END WHILE  \n            RETURN merged_list  \n        END FUNCTION  \n        \n        SET max_number TO an empty list  \n        FOR i FROM zero TO k  \n            IF i IS LESS THAN OR EQUAL TO the LENGTH OF nums1 AND k MINUS i IS LESS THAN OR EQUAL TO the LENGTH OF nums2  \n                SET candidate TO merge(maxSingleArray(nums1 i) maxSingleArray(nums2 k MINUS i))  \n                IF max_number IS LESS THAN candidate  \n                    SET max_number TO candidate  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN max_number  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins AS list of integers, amount AS integer) RETURNS integer  \n        SET dp TO a list with the length of amount PLUS one where each element is amount PLUS one  \n        SET element at position zero of dp TO zero  \n        \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET element at position a of dp TO the smaller value BETWEEN element at position a of dp AND element at position a MINUS coin of dp PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF element at position amount of dp IS NOT EQUALS TO amount PLUS one  \n            RETURN element at position amount of dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-connected-components-in-an-undirected-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countComponents WITH PARAMETERS n edges  \n        SET graph TO an empty mapping from each integer FROM zero TO n MINUS one TO an empty list  \n        FOR each pair consisting of a and b IN edges  \n            APPEND b TO the list mapped by a in graph  \n            APPEND a TO the list mapped by b in graph  \n        END FOR  \n        SET visited TO an empty set  \n        FUNCTION dfs WITH PARAMETER node  \n            IF node IS IN visited  \n                RETURN  \n            END IF  \n            ADD node TO visited  \n            FOR each neighbor IN the list mapped by node in graph  \n                CALL dfs WITH neighbor  \n            END FOR  \n        END FUNCTION  \n        SET components TO zero  \n        FOR node FROM zero TO n MINUS one  \n            IF node IS NOT IN visited  \n                CALL dfs WITH node  \n                INCREMENT components BY one  \n            END IF  \n        END FOR  \n        RETURN components  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wiggle-sort-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wiggleSort(nums)  \n        CALL sort nums in ascending order  \n        SET sorted_nums TO a new list containing each element of nums in order  \n        SET n TO the number of elements in nums  \n        SET left TO the integer division of (n MINUS one) BY two  \n        SET right TO n MINUS one  \n        FOR index FROM zero TO n MINUS one  \n            IF the remainder of index DIVIDED BY two EQUALS zero  \n                SET element at position index of nums TO element at position left of sorted_nums  \n                DECREMENT left BY one  \n            ELSE  \n                SET element at position index of nums TO element at position right of sorted_nums  \n                DECREMENT right BY one  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-size-subarray-sum-equals-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSubArrayLen(nums, k)  \n        SET cumulative_sum_index TO a dictionary mapping zero TO negative one  \n        SET cumulative_sum TO zero  \n        SET max_length TO zero  \n        FOR each index i AND element num IN nums with enumeration  \n            SET cumulative_sum TO cumulative_sum PLUS num  \n            IF cumulative_sum MINUS k IS a key in cumulative_sum_index  \n                SET max_length TO the greater value BETWEEN max_length AND i MINUS the value at key cumulative_sum MINUS k in cumulative_sum_index  \n            END IF  \n            IF cumulative_sum IS NOT a key in cumulative_sum_index  \n                SET the value at key cumulative_sum in cumulative_sum_index TO i  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-of-range-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countRangeSum(nums lower upper)  \n        SET prefix_sums TO a list containing zero  \n        SET current_sum TO zero  \n        SET count TO zero  \n        \n        FOR each num IN nums  \n            SET current_sum TO current_sum PLUS num  \n            \n            SET left TO current_sum MINUS upper  \n            SET right TO current_sum MINUS lower  \n            \n            SET number_of_elements_to_right TO the number of elements in prefix_sums strictly less than or equal to right  \n            SET number_of_elements_to_left TO the number of elements in prefix_sums strictly less than left  \n            INCREMENT count BY number_of_elements_to_right MINUS number_of_elements_to_left  \n            \n            INSERT current_sum into prefix_sums maintaining sorted order  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-increasing-path-in-a-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestIncreasingPath(matrix)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET directions TO list containing the pairs one and zero MINUS one and zero zero and one zero and MINUS one  \n        SET dp TO new two dimensional list of LENGTH m BY LENGTH n with all elements SET TO negative one  \n        \n        FUNCTION dfs(x y)  \n            IF element at position x of dp at position y NOT EQUALS negative one  \n                RETURN element at position x of dp at position y  \n            END IF  \n            \n            SET max_length TO one  \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of matrix at position ny GREATER THAN element at position x of matrix at position y  \n                    SET candidate_length TO one PLUS dfs(nx ny)  \n                    IF candidate_length GREATER THAN max_length  \n                        SET max_length TO candidate_length  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET element at position x of dp at position y TO max_length  \n            RETURN max_length  \n        END FUNCTION  \n        \n        SET longest_path TO zero  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET current_length TO dfs(i j)  \n                IF current_length GREATER THAN longest_path  \n                    SET longest_path TO current_length  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN longest_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "patching-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minPatches(nums n)  \n        SET missing TO one  \n        SET patches TO zero  \n        SET i TO zero  \n        \n        WHILE missing LESS THAN OR EQUAL TO n  \n            IF i LESS THAN the LENGTH OF nums AND element at position i of nums LESS THAN OR EQUAL TO missing  \n                SET missing TO missing PLUS element at position i of nums  \n                INCREMENT i BY one  \n            ELSE  \n                SET missing TO missing PLUS missing  \n                INCREMENT patches BY one  \n            END IF  \n        END WHILE  \n        \n        RETURN patches  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "verify-preorder-serialization-of-a-binary-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isValidSerialization(preorder)  \n        SET nodes TO list obtained by splitting preorder string by comma delimiter  \n        SET slots TO one  \n        FOR each node IN nodes  \n            IF slots EQUALS zero  \n                RETURN False  \n            END IF  \n            DECREMENT slots BY one  \n            IF node NOT EQUALS the single hash symbol  \n                INCREMENT slots BY two  \n            END IF  \n        END FOR  \n        RETURN slots EQUALS zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-itinerary", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findItinerary(tickets)  \n        SET graph TO a new mapping with default value as empty list  \n        FOR each pair of departure location and arrival location IN the tickets sorted in descending lexical order  \n            APPEND the arrival location TO the list associated with the departure location in graph  \n        END FOR  \n        \n        SET itinerary TO an empty list  \n        \n        FUNCTION visit(airport)  \n            WHILE the list associated with airport in graph is not empty  \n                CALL visit with the last element removed from the list associated with airport in graph  \n            END WHILE  \n            APPEND airport TO itinerary  \n        END FUNCTION  \n        \n        CALL visit with the string that is the abbreviation for John F Kennedy airport  \n        RETURN the reverse order of itinerary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "increasing-triplet-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION increasingTriplet(nums)  \n        SET first TO positive infinity  \n        SET second TO positive infinity  \n        \n        FOR each num IN nums  \n            IF num LESS THAN OR EQUAL TO first  \n                SET first TO num  \n            ELSE IF num LESS THAN OR EQUAL TO second  \n                SET second TO num  \n            ELSE  \n                RETURN true  \n            END IF  \n        END FOR  \n        \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "self-crossing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isSelfCrossing(distance)  \n        SET n TO the LENGTH OF distance  \n        IF n LESS THAN four  \n            RETURN False  \n        END IF  \n        FOR i FROM three TO n MINUS one  \n            IF element at position i of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance AND element at position i MINUS one of distance LESS THAN OR EQUAL TO element at position i MINUS three of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO four AND element at position i MINUS one of distance EQUALS element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n            IF i GREATER THAN OR EQUAL TO five AND element at position i MINUS two of distance GREATER THAN OR EQUAL TO element at position i MINUS four of distance AND element at position i MINUS three of distance GREATER THAN OR EQUAL TO element at position i MINUS one of distance AND element at position i MINUS one of distance PLUS element at position i MINUS five of distance GREATER THAN OR EQUAL TO element at position i MINUS three of distance AND element at position i PLUS element at position i MINUS four of distance GREATER THAN OR EQUAL TO element at position i MINUS two of distance  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-with-at-most-k-distinct-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lengthOfLongestSubstringKDistinct(s, k)  \n        IF k EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET char_map TO empty collection that maps characters to positions  \n        SET left TO zero  \n        SET max_length TO zero  \n        \n        FOR right FROM zero TO the LENGTH OF s MINUS one  \n            ASSIGN reference of rightmost character in s at position right TO right IN char_map  \n            \n            IF the SIZE OF char_map GREATER THAN k THEN  \n                SET leftmost_char TO the character in char_map WITH the minimum mapped position  \n                SET left TO the position mapped to leftmost_char IN char_map PLUS one  \n                REMOVE leftmost_char FROM char_map  \n            END IF  \n            \n            SET max_length TO the greater value BETWEEN max_length AND right MINUS left PLUS one  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-break", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dp TO list of zeros with length of n PLUS one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            SET max_product TO zero  \n            FOR j FROM one TO i MINUS one  \n                SET product_one TO j MULTIPLIED BY element at position i MINUS j of dp  \n                SET product_two TO j MULTIPLIED BY i MINUS j  \n                SET max_product TO maximum value among max_product product_one and product_two  \n            END FOR  \n            SET element at position i of dp TO max_product  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "top-k-frequent-elements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION topKFrequent(nums k) RETURNS list of integers  \n        SET frequency_map TO a mapping from integer to integer with default zero  \n        FOR each num IN nums  \n            INCREMENT value at key num in frequency_map BY one  \n        END FOR  \n\n        SET max_frequency TO the greatest value among all values in frequency_map  \n        SET buckets TO a list of empty lists with the length of max_frequency PLUS one  \n\n        FOR each num freq IN all key value pairs in frequency_map  \n            APPEND num TO the element at position freq of buckets  \n        END FOR  \n\n        SET result TO an empty list  \n        FOR freq FROM max_frequency DOWN TO one  \n            IF the length of the element at position freq of buckets IS GREATER THAN zero  \n                APPEND all elements of the element at position freq of buckets TO result  \n                IF the length of result IS GREATER THAN OR EQUAL TO k  \n                    RETURN the first k elements of result  \n                END IF  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "android-unlock-patterns", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfPatterns(m n)  \n        SET jumps TO a collection mapping pairs of start dot and end dot TO an intermediate dot that must be visited when jumping over  \n            PAIR start dot one AND end dot three maps TO dot two  \n            PAIR start dot one AND end dot seven maps TO dot four  \n            PAIR start dot one AND end dot nine maps TO dot five  \n            PAIR start dot two AND end dot eight maps TO dot five  \n            PAIR start dot three AND end dot one maps TO dot two  \n            PAIR start dot three AND end dot seven maps TO dot five  \n            PAIR start dot three AND end dot nine maps TO dot six  \n            PAIR start dot four AND end dot six maps TO dot five  \n            PAIR start dot five AND end dot five maps TO dot five  \n            PAIR start dot six AND end dot four maps TO dot five  \n            PAIR start dot seven AND end dot one maps TO dot four  \n            PAIR start dot seven AND end dot three maps TO dot five  \n            PAIR start dot seven AND end dot nine maps TO dot eight  \n            PAIR start dot eight AND end dot two maps TO dot five  \n            PAIR start dot nine AND end dot one maps TO dot five  \n            PAIR start dot nine AND end dot three maps TO dot six  \n            PAIR start dot nine AND end dot seven maps TO dot eight  \n        \n        FUNCTION countPatternsFromDot(current visited length)  \n            IF length EQUALS n THEN  \n                RETURN one  \n            END IF  \n            SET count TO one IF length GREATER THAN OR EQUAL TO m OTHERWISE zero  \n            FOR each next_dot FROM one TO nine DO  \n                IF element at position next_dot of visited IS false THEN  \n                    SET jump TO the value mapped by PAIR current AND next_dot in jumps  \n                    IF jump IS NOT PRESENT OR element at position jump of visited IS true THEN  \n                        SET element at position next_dot of visited TO true  \n                        INCREMENT count BY countPatternsFromDot(next_dot visited length PLUS one)  \n                        SET element at position next_dot of visited TO false  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        SET visited TO a collection of ten elements all set to false  \n        SET result TO zero  \n        FOR i FROM one TO nine DO  \n            SET element at position i of visited TO true  \n            INCREMENT result BY countPatternsFromDot(i visited one)  \n            SET element at position i of visited TO false  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "russian-doll-envelopes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxEnvelopes(envelopes)  \n        SORT envelopes BY the element at position zero of element IN envelopes IN ASCENDING ORDER AND BY the NEGATION OF the element at position one of element IN envelopes IN DESCENDING ORDER  \n        SET dp TO an empty list  \n        FOR each pair OF underscore and h IN envelopes  \n            SET idx TO the result of FINDING the LEFTMOST POSITION TO INSERT h INTO dp via BINARY SEARCH  \n            IF idx EQUALS the LENGTH OF dp  \n                APPEND h TO dp  \n            ELSE  \n                SET the element at position idx of dp TO h  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "line-reflection", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isReflected(points)  \n        SET unique_points TO the set of tuples formed by converting each element of points into a tuple  \n        SET min_x TO the minimum value of the first element of each tuple in unique_points  \n        SET max_x TO the maximum value of the first element of each tuple in unique_points  \n        SET line_of_reflection TO min_x PLUS max_x DIVIDED BY two  \n        FOR each tuple of x and y IN unique_points  \n            SET reflected_x TO two MULTIPLIED BY line_of_reflection MINUS x  \n            IF the tuple of reflected_x and y IS NOT an element of unique_points  \n                RETURN False  \n            END IF  \n        END FOR  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-numbers-with-unique-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero  \n            RETURN one  \n        END IF  \n        IF n EQUALS one  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            DECREMENT available_digits BY one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rearrange-string-k-distance-apart", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rearrangeString(s string k integer) RETURNS string  \n        IF k LESS THAN OR EQUAL TO one  \n            RETURN s  \n        END IF  \n\n        SET freq TO the frequency mapping of each character in s  \n\n        SET max_heap TO an empty list  \n        FOR each character and count IN freq  \n            APPEND a pair of negative count PLUS character TO max_heap  \n        END FOR  \n        CONVERT max_heap INTO a heap structure  \n\n        SET wait_queue TO an empty list  \n\n        SET result TO an empty list  \n\n        WHILE max_heap is not empty  \n            EXTRACT the top element from max_heap into count and character  \n            APPEND character TO result  \n\n            APPEND a pair of count PLUS one PLUS character TO wait_queue  \n\n            IF the length of wait_queue EQUALS k  \n                REMOVE the first element from wait_queue into count and character  \n                IF count LESS THAN zero  \n                    ADD the pair of count PLUS character TO max_heap as a heap element  \n                END IF  \n            END IF  \n        END WHILE  \n\n        IF the length of result NOT EQUALS the length of s  \n            RETURN an empty string  \n        END IF  \n\n        RETURN the concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-transformed-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sortTransformedArray(nums WITH TYPE List of integer, a WITH TYPE integer, b WITH TYPE integer, c WITH TYPE integer) RETURNS List of integer  \n        FUNCTION quadratic(x)  \n            RETURN a MULTIPLIED BY x MULTIPLIED BY x PLUS b MULTIPLIED BY x PLUS c  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF nums  \n        SET result TO a new list of integer zeros with LENGTH n  \n        SET left TO zero  \n        SET right TO n MINUS one  \n        \n        IF a GREATER THAN OR EQUAL TO zero  \n            SET index TO n MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                IF quadratic of element at position left of nums GREATER THAN quadratic of element at position right of nums  \n                    SET element at position index of result TO quadratic of element at position left of nums  \n                    INCREMENT left BY one  \n                ELSE  \n                    SET element at position index of result TO quadratic of element at position right of nums  \n                    DECREMENT right BY one  \n                END IF  \n                DECREMENT index BY one  \n            END WHILE  \n        ELSE  \n            SET index TO zero  \n            WHILE left LESS THAN OR EQUAL TO right  \n                IF quadratic of element at position left of nums LESS THAN quadratic of element at position right of nums  \n                    SET element at position index of result TO quadratic of element at position left of nums  \n                    INCREMENT left BY one  \n                ELSE  \n                    SET element at position index of result TO quadratic of element at position right of nums  \n                    DECREMENT right BY one  \n                END IF  \n                INCREMENT index BY one  \n            END WHILE  \n        END IF  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bomb-enemy", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxKilledEnemies(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO LENGTH OF grid  \n        SET n TO LENGTH OF element at position zero of grid  \n        SET max_kills TO zero  \n        \n        SET row_kills TO zero  \n        SET col_kills TO list of zeros of length n  \n        \n        FOR variable i FROM zero TO m MINUS one  \n            FOR variable j FROM zero TO n MINUS one  \n                \n                IF j EQUALS zero OR element at position j MINUS one of element at position i of grid EQUALS wall  \n                    SET row_kills TO zero  \n                    FOR variable k FROM j TO n MINUS one  \n                        IF element at position k of element at position i of grid EQUALS enemy  \n                            INCREMENT row_kills BY one  \n                        ELSE IF element at position k of element at position i of grid EQUALS wall  \n                            BREAK  \n                        END IF  \n                    END FOR  \n                END IF  \n                \n                IF i EQUALS zero OR element at position i MINUS one of element at position j of grid EQUALS wall  \n                    SET element at position j of col_kills TO zero  \n                    FOR variable k FROM i TO m MINUS one  \n                        IF element at position k of element at position j of grid EQUALS enemy  \n                            INCREMENT element at position j of col_kills BY one  \n                        ELSE IF element at position k of element at position j of grid EQUALS wall  \n                            BREAK  \n                        END IF  \n                    END FOR  \n                END IF  \n                \n                IF element at position j of element at position i of grid EQUALS empty cell  \n                    SET max_kills TO maximum of max_kills AND row_kills PLUS element at position j of col_kills  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_kills  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-two-integers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getSum(a b)  \n        SET maximum TO the largest thirty two bits integer  \n        SET mask TO a number representing thirty two bits all set to one  \n        \n        WHILE b NOT EQUALS zero holds  \n            SET carry TO the result of the bitwise AND between a and b MULTIPLIED BY two  \n            SET a TO the result of the bitwise XOR between a and b ANDed with mask  \n            SET b TO the result of the bitwise AND between carry and mask  \n        END WHILE  \n        \n        IF a LESS THAN OR EQUAL TO maximum holds  \n            RETURN a  \n        ELSE  \n            RETURN the bitwise NOT of the bitwise XOR between a and mask  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-k-pairs-with-smallest-sums", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kSmallestPairs(nums1 nums1 AS List OF INTEGER nums2 nums2 AS List OF INTEGER k k AS INTEGER) RETURNS List OF List OF INTEGER  \n        IF nums1 EQUALS empty OR nums2 EQUALS empty OR k LESS THAN OR EQUAL TO zero THEN  \n            RETURN empty list  \n        END IF  \n        SET min_heap TO empty list  \n        FOR i FROM zero TO the MINIMUM OF k AND the LENGTH OF nums1 MINUS one  \n            PUSH onto min_heap the tuple of the element at position i of nums1 PLUS the element at position zero of nums2 the index i and zero  \n        END FOR  \n        SET result TO empty list  \n        WHILE the LENGTH OF min_heap GREATER THAN zero AND the LENGTH OF result LESS THAN k  \n            SET tuple TO the result of popping the smallest element from min_heap  \n            SET i TO the second element of tuple  \n            SET j TO the third element of tuple  \n            APPEND the list containing the element at position i of nums1 and the element at position j of nums2 TO result  \n            IF j PLUS one LESS THAN the LENGTH OF nums2 THEN  \n                PUSH onto min_heap the tuple of the element at position i of nums1 PLUS the element at position j PLUS one of nums2 the index i and j PLUS one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "guess-number-higher-or-lower-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getMoneyAmount(n)  \n        FUNCTION dp(left, right)  \n            IF left GREATER THAN OR EQUAL TO right THEN  \n                RETURN zero  \n            END IF  \n            SET minimum cost TO infinity  \n            FOR pivot FROM left TO right  \n                SET left cost TO dp of left AND pivot MINUS one  \n                SET right cost TO dp of pivot PLUS one AND right  \n                SET cost TO pivot PLUS maximum of left cost AND right cost  \n                SET minimum cost TO minimum of minimum cost AND cost  \n            END FOR  \n            RETURN minimum cost  \n        END FUNCTION  \n        RETURN dp of one AND n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wiggle-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wiggleMaxLength(nums)  \n        IF the LENGTH OF nums LESS THAN two  \n            RETURN the LENGTH OF nums  \n        END IF  \n        \n        SET up TO one  \n        SET down TO one  \n        \n        FOR index i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums GREATER THAN the element at position i MINUS one of nums  \n                SET up TO down PLUS one  \n            ELSE IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                SET down TO up PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN the GREATER OF up AND down  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum4(nums target)  \n        SET dp TO a list of zeros with the length equal to target PLUS one  \n        SET the element at position zero of dp TO one  \n        FOR each amount FROM one TO target  \n            FOR each num IN nums  \n                IF amount GREATER THAN OR EQUAL TO num  \n                    SET the element at position amount of dp TO the element at position amount of dp PLUS the element at position amount MINUS num of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the element at position target of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-element-in-a-sorted-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(matrix parameter LIST OF LIST OF INTEGER k parameter INTEGER) RETURNS INTEGER  \n        FUNCTION countLessEqual(mid parameter INTEGER) RETURNS INTEGER  \n            SET count TO zero  \n            SET row TO LENGTH OF matrix MINUS one  \n            SET col TO zero  \n            WHILE row GREATER THAN OR EQUAL TO zero AND col LESS THAN LENGTH OF matrix  \n                IF element at position row of matrix AT position col LESS THAN OR EQUAL TO mid  \n                    INCREMENT count BY row PLUS one  \n                    INCREMENT col BY one  \n                ELSE  \n                    DECREMENT row BY one  \n                END IF  \n            END WHILE  \n            RETURN count  \n        END FUNCTION  \n\n        SET n TO LENGTH OF matrix  \n        SET low TO element at position zero of matrix AT position zero  \n        SET high TO element at position n MINUS one of matrix AT position n MINUS one  \n\n        WHILE low LESS THAN high  \n            SET mid TO low PLUS high DIVIDED BY two  \n            IF countLessEqual(mid) LESS THAN k  \n                SET low TO mid PLUS one  \n            ELSE  \n                SET high TO mid  \n            END IF  \n        END WHILE  \n\n        RETURN low  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lexicographical-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lexicalOrder WITH PARAMETER n  \n        SET result TO empty list  \n        \n        FUNCTION dfs WITH PARAMETER current  \n            IF current GREATER THAN n THEN  \n                RETURN  \n            END IF  \n            APPEND current TO result  \n            FOR i FROM zero TO nine  \n                SET next_num TO current MULTIPLIED BY ten PLUS i  \n                IF next_num GREATER THAN n THEN  \n                    RETURN  \n                END IF  \n                CALL dfs WITH PARAMETER next_num  \n            END FOR  \n        END FUNCTION  \n        \n        FOR i FROM one TO nine  \n            CALL dfs WITH PARAMETER i  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "elimination-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lastRemaining(n)  \n        SET remaining TO n  \n        SET step TO one  \n        SET left_to_right TO true  \n        SET head TO one  \n        \n        WHILE remaining GREATER THAN one  \n            IF left_to_right EQUALS true OR remaining MODULO two EQUALS one  \n                INCREMENT head BY step  \n            END IF  \n            SET step TO step MULTIPLIED BY two  \n            SET remaining TO remaining DIVIDED BY two  \n            SET left_to_right TO NOT left_to_right  \n        END WHILE  \n        \n        RETURN head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-rectangle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO an empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            INCREMENT area BY the result of the subtraction of x1 FROM x2 MULTIPLIED BY the result of the subtraction of y1 FROM y2  \n            \n            FOR each point p IN the list containing tuple of x1 y1 tuple of x1 y2 tuple of x2 y1 and tuple of x2 y2  \n                IF point p IS IN points THEN  \n                    REMOVE point p FROM points  \n                ELSE  \n                    ADD point p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF area NOT EQUALS the result of the subtraction of X1 FROM X2 MULTIPLIED BY the result of the subtraction of Y1 FROM Y2 THEN  \n            RETURN false  \n        END IF  \n        \n        IF points NOT EQUALS the set containing tuples of X1 Y1 X1 Y2 X2 Y1 and X2 Y2 THEN  \n            RETURN false  \n        END IF  \n        \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "utf-8-validation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validUtf8(data)  \n        FUNCTION get_byte_count(byte)  \n            IF the result of shifting byte to the right by seven positions EQUALS zero  \n                RETURN one  \n            ELSE IF the result of shifting byte to the right by five positions EQUALS the binary value one one zero  \n                RETURN two  \n            ELSE IF the result of shifting byte to the right by four positions EQUALS the binary value one one one zero  \n                RETURN three  \n            ELSE IF the result of shifting byte to the right by three positions EQUALS the binary value one one one one zero  \n                RETURN four  \n            ELSE  \n                RETURN negative one  \n            END IF  \n        END FUNCTION  \n          \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF data  \n            SET byte_count TO the result of get_byte_count applied to the element at position i of data  \n            IF byte_count EQUALS negative one  \n                RETURN False  \n            END IF  \n            IF i PLUS byte_count GREATER THAN the LENGTH OF data  \n                RETURN False  \n            END IF  \n            FOR j FROM i PLUS one TO i PLUS byte_count MINUS one  \n                IF the result of shifting the element at position j of data to the right by six positions NOT EQUALS the binary value one zero  \n                    RETURN False  \n                END IF  \n            END FOR  \n            INCREMENT i BY byte_count  \n        END WHILE  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decode-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION decodeString(s)  \n        SET stack TO empty list  \n        SET a TO empty sequence  \n        SET d TO empty sequence  \n        \n        FOR each char IN s  \n            IF character char is a digit  \n                SET d TO concatenation of d and char  \n            ELSE IF character char is an alphabetic letter  \n                SET a TO concatenation of a and char  \n            ELSE IF character char equals the opening bracket character  \n                APPEND the tuple of a and the conversion of d to integer TO stack  \n                SET a TO empty sequence  \n                SET d TO empty sequence  \n            ELSE IF character char equals the closing bracket character  \n                ASSIGN p and n TO the tuple obtained by removing and returning the last element of stack  \n                SET a TO concatenation of p and the sequence a repeated n times  \n            END IF  \n        END FOR  \n        \n        RETURN a  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-with-at-least-k-repeating-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestSubstring(s k)  \n        IF the LENGTH OF s LESS THAN k  \n            RETURN zero  \n        END IF  \n        ASSIGN reference TO a collection that COUNTS each element IN s  \n        FOR each character IN the counted collection  \n            IF the FREQUENCY of character LESS THAN k  \n                RETURN the MAXIMUM value AMONG the RESULTS of CALLING longestSubstring with each substring RESULTING from SPLITTING s BY character AND k  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-function", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxRotateFunction(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET total_sum TO the SUM OF all elements IN nums  \n        SET current_sum TO the SUM OF each element index MULTIPLIED BY the element value FOR each index and element IN nums  \n        SET max_value TO current_sum  \n        FOR k FROM one TO n MINUS one  \n            SET current_sum TO current_sum PLUS total_sum MINUS n MULTIPLIED BY the element at position n MINUS k of nums  \n            SET max_value TO the GREATER OF max_value AND current_sum  \n        END FOR  \n        RETURN max_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-replacement", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION integerReplacement(n)  \n        SET count TO zero  \n        WHILE n NOT EQUALS one  \n            IF n MODULO two EQUALS zero  \n                SET n TO n DIVIDED BY two  \n            ELSE  \n                IF n EQUALS three  \n                    SET n TO n MINUS one  \n                ELSE IF (n PLUS one) MODULO four EQUALS zero  \n                    SET n TO n PLUS one  \n                ELSE  \n                    SET n TO n MINUS one  \n                END IF  \n            END IF  \n            INCREMENT count BY one  \n        END WHILE  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "nth-digit", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findNthDigit(n)  \n        SET length TO one  \n        SET count TO nine  \n        SET start TO one  \n        WHILE n GREATER THAN length MULTIPLIED BY count  \n            SET n TO n MINUS length MULTIPLIED BY count  \n            INCREMENT length BY one  \n            SET count TO count MULTIPLIED BY ten  \n            SET start TO start MULTIPLIED BY ten  \n        END WHILE  \n        SET start TO start PLUS the INTEGER RESULT OF the DIVISION of n MINUS one BY length  \n        SET digit_index TO the REMAINDER of the DIVISION of n MINUS one BY length  \n        SET number_string TO the STRING REPRESENTATION of start  \n        SET digit_character TO the ELEMENT at position digit_index OF number_string  \n        SET digit_value TO the INTEGER VALUE of digit_character  \n        RETURN digit_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-k-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeKdigits(num k)  \n        SET stack TO an empty list  \n        FOR each digit IN the sequence of characters in num  \n            WHILE k GREATER THAN zero AND stack IS NOT empty AND element at the last position of stack GREATER THAN digit  \n                REMOVE the element at the last position FROM stack  \n                DECREMENT k BY one  \n            END WHILE  \n            APPEND digit TO stack  \n        END FOR  \n        IF k EQUALS zero  \n            SET final_stack TO stack  \n        ELSE  \n            SET final_stack TO the sequence of elements in stack from the first position TO the length of stack MINUS k  \n        END IF  \n        SET joined_result TO the concatenation of all elements in final_stack  \n        SET result TO the substring of joined_result starting from the first position WHERE the character IS NOT EQUAL TO the character zero TO the end of joined_result  \n        IF result IS NOT empty  \n            RETURN result  \n        ELSE  \n            RETURN the character zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-jump", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS an empty list OR the LENGTH OF stones LESS THAN two THEN  \n            RETURN False  \n        END IF  \n        \n        SET stone_set TO a new empty set  \n        FOR each stone IN stones  \n            ADD stone TO stone_set  \n        END FOR  \n        \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the last element of stones THEN  \n                RETURN True  \n            END IF  \n            \n            IF the tuple of position and jump IS IN memo THEN  \n                RETURN the value from memo with key tuple of position and jump  \n            END IF  \n            \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the sum of position PLUS next_jump IS IN stone_set THEN  \n                    IF can_jump_to(the sum of position PLUS next_jump, next_jump) THEN  \n                        SET the value in memo with key tuple of position and jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value in memo with key tuple of position and jump TO False  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_jump_to(the first element of stones, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "queue-reconstruction-by-height", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reconstructQueue(people)  \n        SORT people BY the NEGATION OF element at position zero of person AND THEN BY element at position one of person IN ASCENDING ORDER  \n        SET queue TO an empty list  \n        FOR each person IN people  \n            INSERT person INTO queue AT the position indicated BY element at position one of person  \n        END FOR  \n        RETURN queue  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "trapping-rain-water-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION trapRainWater(heightMap)  \n        IF heightMap EQUALS empty OR element at position zero of heightMap EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF heightMap  \n        SET n TO the LENGTH OF element at position zero of heightMap  \n        SET visited TO a two dimensional list of Boolean FALSE values with m rows and n columns  \n        SET min_heap TO an empty list  \n        \n        FOR i FROM zero TO m MINUS one  \n            PUSH to min_heap a tuple consisting of element at position i of heightMap at position zero , i , zero  \n            PUSH to min_heap a tuple consisting of element at position i of heightMap at position n MINUS one , i , n MINUS one  \n            SET element at position i of visited at position zero TO TRUE  \n            SET element at position i of visited at position n MINUS one TO TRUE  \n        END FOR  \n        \n        FOR j FROM zero TO n MINUS one  \n            PUSH to min_heap a tuple consisting of element at position zero of heightMap at position j , zero , j  \n            PUSH to min_heap a tuple consisting of element at position m MINUS one of heightMap at position j , m MINUS one , j  \n            SET element at position zero of visited at position j TO TRUE  \n            SET element at position m MINUS one of visited at position j TO TRUE  \n        END FOR  \n        \n        SET directions TO a list of four tuples as follows  \n            first tuple is minus one and zero  \n            second tuple is one and zero  \n            third tuple is zero and minus one  \n            fourth tuple is zero and one  \n        \n        SET water_trapped TO zero  \n        \n        WHILE min_heap is not empty  \n            POP from min_heap to get three values height x y  \n            \n            FOR each tuple dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of visited at position ny EQUALS FALSE  \n                    SET element at position nx of visited at position ny TO TRUE  \n                    INCREMENT water_trapped BY the result of MAXIMUM BETWEEN zero AND height MINUS element at position nx of heightMap at position ny  \n                    PUSH to min_heap a tuple consisting of the MAXIMUM BETWEEN height AND element at position nx of heightMap at position ny , nx , ny  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN water_trapped  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-largest-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitArray(nums k)  \n        FUNCTION canSplit(max_sum)  \n            SET current_sum TO zero  \n            SET subarrays TO one  \n            FOR each num IN nums  \n                IF current_sum PLUS num GREATER THAN max_sum  \n                    INCREMENT subarrays BY one  \n                    SET current_sum TO num  \n                ELSE  \n                    INCREMENT current_sum BY num  \n                END IF  \n            END FOR  \n            RETURN subarrays LESS THAN OR EQUAL TO k  \n        END FUNCTION  \n\n        SET left TO the maximum element in nums  \n        SET right TO the sum of all elements in nums  \n        WHILE left LESS THAN right  \n            SET mid TO the integer division of left PLUS right by two  \n            IF canSplit(mid)  \n                SET right TO mid  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-unique-word-abbreviation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minAbbreviation(target STRING, dictionary LIST OF STRING) RETURNS STRING  \n        \n        FUNCTION is_valid_abbr(s STRING, abbr STRING) RETURNS BOOLEAN  \n            SET i TO zero  \n            SET j TO zero  \n            WHILE i LESS THAN the LENGTH OF s AND j LESS THAN the LENGTH OF abbr  \n                IF the element at position j of abbr IS A DIGIT  \n                    IF the element at position j of abbr EQUALS zero  \n                        RETURN false  \n                    END IF  \n                    SET shift TO zero  \n                    WHILE j LESS THAN the LENGTH OF abbr AND the element at position j of abbr IS A DIGIT  \n                        SET shift TO shift MULTIPLIED BY ten PLUS the numeric value of the element at position j of abbr  \n                        INCREMENT j BY one  \n                    END WHILE  \n                    INCREMENT i BY shift  \n                ELSE  \n                    IF the element at position i of s NOT EQUALS the element at position j of abbr  \n                        RETURN false  \n                    END IF  \n                    INCREMENT i BY one  \n                    INCREMENT j BY one  \n                END IF  \n            END WHILE  \n            RETURN i EQUALS the LENGTH OF s AND j EQUALS the LENGTH OF abbr  \n        END FUNCTION  \n        \n        FUNCTION generate_abbrs(word STRING, length INTEGER, abbr STRING EQUALS empty string, index INTEGER EQUALS zero, skip_count INTEGER EQUALS zero)  \n            IF index EQUALS length  \n                IF skip_count GREATER THAN zero  \n                    SET abbr TO abbr PLUS the string representation of skip_count  \n                END IF  \n                APPEND abbr TO abbrs  \n                RETURN  \n            END IF  \n            \n            CALL generate_abbrs WITH word, length, abbr, index PLUS one, skip_count PLUS one  \n            \n            IF skip_count GREATER THAN zero  \n                SET abbr TO abbr PLUS the string representation of skip_count  \n            END IF  \n            CALL generate_abbrs WITH word, length, abbr PLUS the element at position index of word, index PLUS one, zero  \n        END FUNCTION  \n        \n        FUNCTION find_unique_abbr() RETURNS STRING OR NONE  \n            FOR length FROM one TO the LENGTH OF target  \n                SET abbrs TO an empty list  \n                CALL generate_abbrs WITH target, the LENGTH OF target  \n                SET min_abbr TO none  \n                SET min_length TO positive infinity  \n                FOR each abbr IN abbrs  \n                    IF FOR ALL each word IN filtered_dict it IS NOT the case THAT is_valid_abbr returns true for word AND abbr  \n                        IF the LENGTH OF abbr LESS THAN min_length  \n                            SET min_length TO the LENGTH OF abbr  \n                            SET min_abbr TO abbr  \n                        END IF  \n                    END IF  \n                END FOR  \n                IF min_abbr IS NOT none  \n                    RETURN min_abbr  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET filtered_dict TO an empty list  \n        FOR each word IN dictionary  \n            IF the LENGTH OF word EQUALS the LENGTH OF target  \n                APPEND word TO filtered_dict  \n            END IF  \n        END FOR  \n        \n        SET abbrs TO an empty list  \n        RETURN the result of calling find_unique_abbr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "arithmetic-slices", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        IF the LENGTH OF nums LESS THAN three THEN  \n            RETURN zero  \n        END IF  \n        \n        SET total_slices TO zero  \n        SET current_length TO two  \n        \n        FOR i FROM three TO the LENGTH OF nums  \n            IF the element at position i of nums MINUS the element at position i MINUS one of nums EQUALS the element at position i MINUS one of nums MINUS the element at position i MINUS two of nums THEN  \n                INCREMENT current_length BY one  \n                INCREMENT total_slices BY current_length MINUS two  \n            ELSE  \n                SET current_length TO two  \n            END IF  \n        END FOR  \n        \n        RETURN total_slices  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-equal-subset-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canPartition(nums)  \n        SET total_sum TO the sum of elements in nums  \n        IF the remainder of total_sum DIVIDED BY two NOT EQUALS zero  \n            RETURN false  \n        END IF  \n        SET target TO total_sum DIVIDED BY two  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a list of false VALUES with the LENGTH OF target PLUS one  \n        SET the element at position zero of dp TO true  \n        FOR each element num IN nums  \n            FOR index i FROM target DOWN TO num  \n                SET the element at position i of dp TO the logical OR of the element at position i of dp AND the element at position i MINUS num of dp  \n            END FOR  \n        END FOR  \n        RETURN the element at position target of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sentence-screen-fitting", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence SENTENCE LIST OF STRINGS rows INTEGER cols INTEGER) RETURNS INTEGER  \n        SET s TO the concatenation of all elements of sentence with a single space inserted between each followed by a single trailing space  \n        SET total_length TO the length of s  \n        SET position TO zero  \n        FOR each iteration IN the range from one TO rows inclusive  \n            INCREMENT position BY cols  \n            IF the element at position modulo total_length of s EQUALS a single space  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position is greater than zero AND the element at position minus one modulo total_length of s NOT EQUALS a single space  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        RETURN the integer division of position BY total_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "battleships-in-a-board", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countBattleships WITH PARAMETER board  \n        SET count TO zero  \n        FOR i FROM zero TO the LENGTH OF board MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position i of board MINUS one  \n                IF element at position i of board at position j EQUALS character X THEN  \n                    IF (i EQUALS zero OR element at position i MINUS one of board at position j EQUALS character full stop) AND (j EQUALS zero OR element at position i of board at position j MINUS one EQUALS character full stop) THEN  \n                        INCREMENT count BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strong-password-checker", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION strongPasswordChecker(password)  \n        SET n TO the LENGTH OF password  \n        \n        SET has_lower TO false  \n        SET has_upper TO false  \n        SET has_digit TO false  \n        FOR each character IN password  \n            IF character is a lowercase letter THEN  \n                SET has_lower TO true  \n            END IF  \n            IF character is an uppercase letter THEN  \n                SET has_upper TO true  \n            END IF  \n            IF character is a digit THEN  \n                SET has_digit TO true  \n            END IF  \n        END FOR  \n        \n        SET missing_types TO three MINUS the SUM of has_lower PLUS has_upper PLUS has_digit  \n        \n        SET replace TO zero  \n        SET one TO zero  \n        SET two TO zero  \n        SET i TO two  \n        WHILE i LESS THAN n  \n            IF the character at position i of password EQUALS the character at position i MINUS one of password AND the character at position i of password EQUALS the character at position i MINUS two of password THEN  \n                SET length TO two  \n                WHILE i LESS THAN n AND the character at position i of password EQUALS the character at position i MINUS one of password  \n                    INCREMENT length BY one  \n                    INCREMENT i BY one  \n                END WHILE  \n                INCREMENT replace BY length DIVIDED BY three  \n                IF length MODULO three EQUALS zero THEN  \n                    INCREMENT one BY one  \n                ELSE IF length MODULO three EQUALS one THEN  \n                    INCREMENT two BY one  \n                END IF  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        \n        IF n LESS THAN six THEN  \n            RETURN the GREATER OF missing_types AND six MINUS n  \n        ELSE IF n LESS THAN OR EQUAL TO twenty THEN  \n            RETURN the GREATER OF missing_types AND replace  \n        ELSE  \n            SET delete TO n MINUS twenty  \n            \n            SET replace TO replace MINUS the SMALLER OF delete AND one  \n            SET replace TO replace MINUS the INTEGER DIVISION BY two OF the SMALLER OF the GREATER OF delete MINUS one AND zero AND two MULTIPLIED BY two  \n            SET replace TO replace MINUS the INTEGER DIVISION BY three OF the GREATER OF delete MINUS one MINUS two MULTIPLIED BY two AND zero  \n            \n            RETURN delete PLUS the GREATER OF missing_types AND replace  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-xor-of-two-numbers-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaximumXOR(nums)  \n        SET max_xor TO zero  \n        FOR i FROM thirty one TO zero DECREMENT BY one  \n            SET max_xor TO max_xor MULTIPLIED BY two  \n            SET current_candidate TO max_xor PLUS one  \n            SET prefixes TO empty set  \n            FOR each num IN nums  \n                SET prefix TO the value of num DIVIDED BY two RAISED TO THE POWER OF i TAKE the INTEGER PART  \n                ADD prefix TO prefixes  \n            END FOR  \n            FOR each prefix IN prefixes  \n                SET required_value TO current_candidate EQUALS prefix XOR some unknown value  \n                IF the value obtained by XOR of current_candidate and prefix IS IN prefixes  \n                    SET max_xor TO current_candidate  \n                    BREAK out of the loop  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN max_xor  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO mapping of character frequencies in s  \n        SET digits TO list of zero FOR each position FROM zero TO nine  \n        SET digit at position zero TO the frequency of character z in count  \n        SET digit at position two TO the frequency of character w in count  \n        SET digit at position four TO the frequency of character u in count  \n        SET digit at position six TO the frequency of character x in count  \n        SET digit at position eight TO the frequency of character g in count  \n        SET digit at position three TO the frequency of character h in count MINUS digit at position eight  \n        SET digit at position five TO the frequency of character f in count MINUS digit at position four  \n        SET digit at position seven TO the frequency of character s in count MINUS digit at position six  \n        SET digit at position nine TO the frequency of character i in count MINUS digit at position five MINUS digit at position six MINUS digit at position eight  \n        SET digit at position one TO the frequency of character o in count MINUS digit at position zero MINUS digit at position two MINUS digit at position four  \n        SET result TO empty list  \n        FOR index FROM zero TO nine  \n            FOR count_index FROM one TO digit at position index  \n                APPEND index converted to string TO result  \n            END FOR  \n        END FOR  \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-repeating-character-replacement", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION characterReplacement(s parameter, k parameter)  \n        SET max_length TO zero  \n        SET max_count TO zero  \n        SET left TO zero  \n        CREATE count AS a mapping from character to integer with default zero  \n        \n        FOR right FROM zero TO the LENGTH OF s MINUS one  \n            INCREMENT the value at key element at position right of s in count BY one  \n            IF the value at key element at position right of s in count GREATER THAN max_count  \n                SET max_count TO the value at key element at position right of s in count  \n            END IF  \n            \n            IF the LENGTH OF the window defined by right MINUS left PLUS one MINUS max_count GREATER THAN k  \n                DECREMENT the value at key element at position left of s in count BY one  \n                INCREMENT left BY one  \n            END IF  \n            \n            IF the LENGTH OF the window defined by right MINUS left PLUS one GREATER THAN max_length  \n                SET max_length TO the LENGTH OF the window defined by right MINUS left PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION wordSquares(words)  \n        SET prefix_to_words TO empty mapping from text TO list of text  \n        FOR each word IN words  \n            FOR index FROM zero TO length of word MINUS one  \n                SET prefix TO substring from position zero TO position index MINUS one of word  \n                APPEND word TO list at prefix_to_words at prefix  \n            END FOR  \n        END FOR  \n        \n        SET results TO empty list  \n        \n        FUNCTION backtrack(square)  \n            IF length of square EQUALS length of element at position zero of words THEN  \n                APPEND square TO results  \n                RETURN  \n            END IF  \n            \n            SET prefix TO empty text  \n            FOR each word_element IN square  \n                SET prefix TO prefix PLUS element at position length of square of word_element  \n            END FOR  \n            \n            FOR each candidate IN list at prefix_to_words at prefix  \n                CALL backtrack with argument square PLUS list containing candidate  \n            END FOR  \n        END FUNCTION  \n        \n        FOR each word IN words  \n            CALL backtrack with argument list containing word  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-genetic-mutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMutation(start, end, bank)  \n        SET s TO a set created from the elements of bank  \n        SET q TO a double ended queue initialized with a pair containing start and zero  \n        SET mp TO a mapping where the key A maps to the sequence T C G the key T maps to the sequence A C G the key C maps to the sequence A T G and the key G maps to the sequence A T C  \n        WHILE the queue q is not empty  \n            REMOVE the first element from the queue q and assign the first part to t and the second part to step  \n            IF the string t EQUALS the string end  \n                RETURN step  \n            END IF  \n            FOR each index i and character v at the position i in the string t  \n                FOR each character j in the sequence mapped from v in mp  \n                    SET next TO the concatenation of the substring from position zero TO the position before i of t PLUS the character j PLUS the substring from the position after i TO the last position of t  \n                    IF the string next IS AN ELEMENT OF the set s  \n                        APPEND the pair containing next and step PLUS one TO the queue q  \n                        REMOVE the string next FROM the set s  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-overlapping-intervals", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION eraseOverlapIntervals(intervals)  \n        IF the LENGTH OF intervals EQUALS zero  \n            RETURN zero  \n        END IF  \n        SORT intervals BY the element at position two of each interval  \n        SET end TO the element at position two of the first interval in intervals  \n        SET count TO zero  \n        FOR i FROM two TO the LENGTH OF intervals  \n            IF the element at position one of the interval at position i GREATER THAN OR EQUAL TO end  \n                SET end TO the element at position two of the interval at position i  \n            ELSE  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-right-interval", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRightInterval(intervals)  \n        SET start_times TO list of pairs of element at position zero of interval and index for each index and interval in enumeration of intervals  \n        SORT start_times by first element of each pair in ascending order  \n        SET result TO empty list  \n        FOR each interval IN intervals  \n            SET end_time TO element at position one of interval  \n            SET idx TO the position returned by binary search for the place where a pair starting with end_time can be inserted in start_times to maintain sorted order  \n            IF idx LESS THAN the LENGTH OF start_times THEN  \n                APPEND element at position one of element at position idx of start_times TO result  \n            ELSE  \n                APPEND the integer negative one TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-all-anagrams-in-a-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findAnagrams(s parameter s AS string, p parameter p AS string) RETURNS list of integers  \n        SET length of s TO len_s  \n        SET length of p TO len_p  \n        IF len_p GREATER THAN len_s THEN  \n            RETURN an empty list  \n        END IF  \n        SET p_count TO the frequency counter of each character IN string p  \n        SET s_count TO the frequency counter of each character IN the substring from position zero TO position len_p MINUS one of string s  \n        SET anagrams TO an empty list  \n        IF the frequency counter s_count EQUALS the frequency counter p_count THEN  \n            APPEND zero TO anagrams  \n        END IF  \n        FOR i FROM len_p TO len_s MINUS one  \n            INCREMENT by one the count of the character at position i of string s IN s_count  \n            DECREMENT by one the count of the character at position i MINUS len_p of string s IN s_count  \n            IF the count of the character at position i MINUS len_p of string s IN s_count EQUALS zero THEN  \n                REMOVE the character at position i MINUS len_p of string s FROM s_count  \n            END IF  \n            IF the frequency counter s_count EQUALS the frequency counter p_count THEN  \n                APPEND the value of i MINUS len_p PLUS one TO anagrams  \n            END IF  \n        END FOR  \n        RETURN anagrams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-smallest-in-lexicographical-order", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findKthNumber(n n INTEGER, k k INTEGER) RETURNS INTEGER  \n        FUNCTION count_steps(prefix prefix INTEGER, n n INTEGER) RETURNS INTEGER  \n            SET next_prefix TO prefix PLUS one  \n            SET steps TO zero  \n            WHILE prefix LESS THAN OR EQUAL TO n  \n                SET steps TO steps PLUS the MINIMUM OF the value of n MINUS prefix PLUS one AND next_prefix MINUS prefix  \n                SET prefix TO prefix MULTIPLIED BY ten  \n                SET next_prefix TO next_prefix MULTIPLIED BY ten  \n            END WHILE  \n            RETURN steps  \n        END FUNCTION  \n  \n        SET current TO one  \n        SET k TO k MINUS one  \n        WHILE k GREATER THAN zero  \n            SET steps TO count_steps WITH arguments current AND n  \n            IF steps LESS THAN OR EQUAL TO k  \n                SET current TO current PLUS one  \n                SET k TO k MINUS steps  \n            ELSE  \n                SET current TO current MULTIPLIED BY ten  \n                SET k TO k MINUS one  \n            END IF  \n        END WHILE  \n        RETURN current  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-all-duplicates-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDuplicates(nums)  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            WHILE the element at position i of nums NOT EQUALS the element at position the element at position i of nums MINUS one of nums  \n                SET temporary_variable TO the element at position i of nums  \n                SET the element at position i of nums TO the element at position temporary_variable MINUS one of nums  \n                SET the element at position temporary_variable MINUS one of nums TO temporary_variable  \n            END WHILE  \n        END FOR  \n        SET result_list TO an empty list  \n        FOR each index i AND element v IN nums with index i  \n            IF element v NOT EQUALS i PLUS one  \n                APPEND element v TO result_list  \n            END IF  \n        END FOR  \n        RETURN result_list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-compression", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION compress(chars)  \n        IF the LENGTH OF chars EQUALS zero  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        SET read_index TO zero  \n        \n        WHILE read_index LESS THAN the LENGTH OF chars  \n            SET char TO the element at position read_index of chars  \n            SET count TO zero  \n            \n            WHILE read_index LESS THAN the LENGTH OF chars AND the element at position read_index of chars EQUALS char  \n                INCREMENT read_index BY one  \n                INCREMENT count BY one  \n            END WHILE  \n            \n            SET the element at position write_index of chars TO char  \n            INCREMENT write_index BY one  \n            \n            IF count GREATER THAN one  \n                FOR each digit IN the string representation of count  \n                    SET the element at position write_index of chars TO digit  \n                    INCREMENT write_index BY one  \n                END FOR  \n            END IF  \n        END WHILE  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sequence-reconstruction", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sequenceReconstruction(nums parameter, sequences parameter)  \n        SET n TO the LENGTH OF nums parameter  \n        ASSIGN reference TO an empty mapping from element to list named graph  \n        SET indegree TO a list of zeros of the LENGTH EQUAL TO n PLUS one  \n        \n        FOR each sequence IN sequences parameter  \n            FOR integer i FROM zero TO the LENGTH OF sequence MINUS one MINUS one  \n                SET u TO element at position i of sequence  \n                SET v TO element at position i PLUS one of sequence  \n                APPEND v TO the list associated with u in graph  \n                SET indegree element at position v TO element at position v of indegree MINUS one  \n            END FOR  \n        END FOR  \n        \n        ASSIGN reference TO an empty deque named queue  \n        FOR integer i FROM one TO n  \n            IF element at position i of indegree EQUALS zero THEN  \n                APPEND i TO queue  \n            END IF  \n        END FOR  \n        \n        IF the LENGTH OF queue NOT EQUALS one THEN  \n            RETURN False  \n        END IF  \n        \n        SET index TO zero  \n        WHILE queue is not empty  \n            IF the LENGTH OF queue NOT EQUALS one THEN  \n                RETURN False  \n            END IF  \n            \n            SET node TO the FIRST element REMOVED FROM queue  \n            IF node NOT EQUALS element at position index of nums parameter THEN  \n                RETURN False  \n            END IF  \n            INCREMENT index BY one  \n            \n            FOR each neighbor IN the list associated with node in graph  \n                DECREMENT element at position neighbor of indegree BY one  \n                IF element at position neighbor of indegree EQUALS zero THEN  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN index EQUALS n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "arithmetic-slices-ii-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArithmeticSlices(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n LESS THAN three  \n            RETURN zero  \n        END IF  \n        SET dp TO a list of dictionaries INITIALIZED with zero for each index FROM zero TO n MINUS one  \n        SET total_count TO zero  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                SET difference_to_d TO the element at position i of nums MINUS the element at position j of nums  \n                IF the difference_to_d EXISTS as a key in the dictionary at position j of dp  \n                    INCREMENT the value at key difference_to_d in the dictionary at position i of dp BY the sum of the value at key difference_to_d in the dictionary at position j of dp PLUS one  \n                    INCREMENT total_count BY the value at key difference_to_d in the dictionary at position j of dp  \n                ELSE  \n                    INCREMENT the value at key difference_to_d in the dictionary at position i of dp BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-boomerangs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfBoomerangs(points)  \n        SET ans TO zero  \n        FOR each p1 IN points  \n            SET cnt TO an empty mapping of counts  \n            FOR each p2 IN points  \n                SET dx TO element at position zero of p1 MINUS element at position zero of p2  \n                SET dy TO element at position one of p1 MINUS element at position one of p2  \n                SET d TO dx MULTIPLIED BY dx PLUS dy MULTIPLIED BY dy  \n                INCREMENT ans BY the value at key d in cnt if present otherwise zero  \n                INCREMENT the value at key d in cnt BY one  \n            END FOR  \n        END FOR  \n        RETURN ans MULTIPLIED BY two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-characters-by-frequency", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION frequencySort(s)  \n        CALL function Counter with s TO frequency  \n        CALL function sorted with keys of frequency using ordering by frequency of element at position current character in frequency from greatest to least TO sorted_characters  \n        SET result TO empty string  \n        FOR each character IN sorted_characters  \n            APPEND character REPEATED frequency of character times TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-arrows-to-burst-balloons", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinArrowShots(points)  \n        CALL points SORT IN ORDER OF the second element of each element in points  \n        SET arrows TO zero  \n        SET last_arrow_position TO negative infinity  \n        FOR each balloon IN points  \n            IF the first element of balloon IS GREATER THAN last_arrow_position  \n                INCREMENT arrows BY one  \n                SET last_arrow_position TO the second element of balloon  \n            END IF  \n        END FOR  \n        RETURN arrows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-equal-array-elements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMoves(nums)  \n        SET min_num TO the minimum element IN nums  \n        SET total_moves TO zero  \n        FOR each num IN nums  \n            INCREMENT total_moves BY num MINUS min_num  \n        END FOR  \n        RETURN total_moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "4sum-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fourSumCount(nums1, nums2, nums3, nums4)  \n        CREATE an empty dictionary named sum_ab  \n        FOR each element a IN nums1  \n            FOR each element b IN nums2  \n                SET current_sum TO a PLUS b  \n                IF current_sum EXISTS AS a key IN sum_ab  \n                    INCREMENT the value at key current_sum IN sum_ab BY one  \n                ELSE  \n                    SET the value at key current_sum IN sum_ab TO one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET count TO zero  \n        FOR each element c IN nums3  \n            FOR each element d IN nums4  \n                SET target TO the NEGATIVE of c PLUS d  \n                IF target EXISTS AS a key IN sum_ab  \n                    INCREMENT count BY the value at key target IN sum_ab  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "132-pattern", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION find132pattern(nums)  \n        SET second TO negative infinity  \n        SET stack TO empty list  \n        FOR each num IN the elements of nums from last to first  \n            IF num LESS THAN second  \n                RETURN true  \n            END IF  \n            WHILE the LENGTH OF stack GREATER THAN zero AND element at position last of stack LESS THAN num  \n                SET second TO the element removed from the end of stack  \n            END WHILE  \n            APPEND num TO stack  \n        END FOR  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "poor-pigs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION poorPigs WITH parameters buckets minutesToDie minutesToTest  \n        SET states TO the INTEGER DIVISION of minutesToTest BY minutesToDie PLUS one  \n        SET logarithm_of_buckets TO the LOGARITHM of buckets  \n        SET logarithm_of_states TO the LOGARITHM of states  \n        SET pigs TO the SMALLEST INTEGER GREATER THAN OR EQUAL TO the DIVISION of logarithm_of_buckets BY logarithm_of_states  \n        RETURN pigs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-equal-array-elements-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMoves2(nums)  \n        SORT nums IN ascending order  \n        SET median TO element at position the LENGTH OF nums DIVIDED BY two of nums  \n        SET moves TO zero  \n        FOR each num IN nums  \n            INCREMENT moves BY the ABSOLUTE VALUE OF num MINUS median  \n        END FOR  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "can-i-win", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canIWin(maxChoosableInteger, desiredTotal)  \n        IF the product of maxChoosableInteger AND the sum of maxChoosableInteger PLUS one DIVIDED BY two LESS THAN desiredTotal  \n            RETURN false  \n        END IF  \n        IF desiredTotal LESS THAN OR EQUAL TO zero  \n            RETURN true  \n        END IF  \n        SET memo TO an empty dictionary  \n        FUNCTION can_win(current_total, used_numbers)  \n            IF the pair of current_total AND used_numbers IS IN memo  \n                RETURN the value mapped by the pair of current_total AND used_numbers from memo  \n            END IF  \n            FOR number FROM one TO maxChoosableInteger  \n                IF the bitwise AND of used_numbers AND the number one shifted LEFT BY number IS EQUALS zero  \n                    IF the sum of current_total PLUS number GREATER THAN OR EQUAL TO desiredTotal OR NOT can_win(the sum of current_total PLUS number, the bitwise OR of used_numbers AND the number one shifted LEFT BY number)  \n                        SET memo at key of the pair of current_total AND used_numbers TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            SET memo at key of the pair of current_total AND used_numbers TO false  \n            RETURN false  \n        END FUNCTION  \n        RETURN can_win(zero, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "optimal-account-balancing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minTransfers(transactions)  \n        SET balance TO an empty dictionary  \n        FOR each transaction_element IN transactions  \n            SET frm TO element at position one of transaction_element  \n            SET to TO element at position two of transaction_element  \n            SET amount TO element at position three of transaction_element  \n            IF frm is a key in balance  \n                SET balance[frm] TO balance at key frm MINUS amount  \n            ELSE  \n                SET balance[frm] TO zero MINUS amount  \n            END IF  \n            IF to is a key in balance  \n                SET balance[to] TO balance at key to PLUS amount  \n            ELSE  \n                SET balance[to] TO amount  \n            END IF  \n        END FOR  \n        SET balances TO an empty list  \n        FOR each net IN the values of balance  \n            IF net NOT EQUALS zero  \n                APPEND net TO balances  \n            END IF  \n        END FOR  \n        IF the LENGTH OF balances EQUALS zero  \n            RETURN zero  \n        END IF  \n\n        FUNCTION settle(start, cnt)  \n            WHILE start LESS THAN the LENGTH OF balances AND element at position start of balances EQUALS zero  \n                INCREMENT start BY one  \n            END WHILE  \n            IF start EQUALS the LENGTH OF balances  \n                RETURN cnt  \n            END IF  \n            SET min_cnt TO infinity  \n            FOR i FROM start PLUS one TO the LENGTH OF balances MINUS one  \n                IF element at position start of balances MULTIPLIED BY element at position i of balances LESS THAN zero  \n                    SET element at position i of balances TO element at position i of balances PLUS element at position start of balances  \n                    SET min_cnt TO the minimum OF min_cnt AND the result of settle with start PLUS one AND cnt PLUS one  \n                    SET element at position i of balances TO element at position i of balances MINUS element at position start of balances  \n                END IF  \n            END FOR  \n            RETURN min_cnt  \n        END FUNCTION  \n\n        RETURN settle WITH zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-substrings-in-wraparound-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findSubstringInWraproundString(s)  \n        SET max_length TO an empty dictionary mapping each character from a to z TO zero  \n        SET current_length TO zero  \n        FOR index FROM zero TO the LENGTH OF s MINUS one  \n            IF index GREATER THAN zero AND the character code of element at position index of s MINUS the character code of element at position index MINUS one of s EQUALS one OR element at position index of s EQUALS character a AND element at position index MINUS one of s EQUALS character z  \n                INCREMENT current_length BY one  \n            ELSE  \n                SET current_length TO one  \n            END IF  \n            SET existing_value TO the value in max_length for the character at position index of s  \n            SET max_length for the character at position index of s TO the GREATER OF existing_value AND current_length  \n        END FOR  \n        SET total_unique_substrings TO zero  \n        FOR each value IN the values of max_length  \n            INCREMENT total_unique_substrings BY value  \n        END FOR  \n        RETURN total_unique_substrings  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "validate-ip-address", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validIPAddress(queryIP)  \n        FUNCTION is_valid_ipv4_block(block)  \n            IF block CONSISTS OF only digits  \n                SET num TO the integer conversion of block  \n                IF num IS LESS THAN OR EQUAL TO two hundred fifty five AND the string conversion of num EQUALS block  \n                    RETURN true  \n                ELSE  \n                    RETURN false  \n                END IF  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n  \n        FUNCTION is_valid_ipv6_block(block)  \n            IF the length of block IS GREATER THAN OR EQUAL TO one AND the length of block IS LESS THAN OR EQUAL TO four  \n                TRY  \n                    CONVERT block FROM base sixteen TO integer  \n                    RETURN true  \n                CATCH conversion failure  \n                    RETURN false  \n                END TRY  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n  \n        SET parts_ipv4 TO the result of splitting queryIP BY the period character  \n        SET parts_ipv6 TO the result of splitting queryIP BY the colon character  \n  \n        IF the length of parts_ipv4 EQUALS four AND for every element part IN parts_ipv4 the function is_valid_ipv4_block returns true FOR part  \n            RETURN the string \"IPv4\"  \n        ELSE IF the length of parts_ipv6 EQUALS eight AND for every element part IN parts_ipv6 the function is_valid_ipv6_block returns true FOR part  \n            RETURN the string \"IPv6\"  \n        ELSE  \n            RETURN the string \"Neither\"  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "convex-polygon", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isConvex(points)  \n        FUNCTION cross_product(o, a, b)  \n            SET first_difference_horizontal TO element at position zero of a MINUS element at position zero of o  \n            SET first_difference_vertical TO element at position one of a MINUS element at position one of o  \n            SET second_difference_horizontal TO element at position zero of b MINUS element at position zero of o  \n            SET second_difference_vertical TO element at position one of b MINUS element at position one of o  \n            SET cross_product_value TO first_difference_horizontal MULTIPLIED BY second_difference_vertical MINUS first_difference_vertical MULTIPLIED BY second_difference_horizontal  \n            RETURN cross_product_value  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF points  \n        \n        IF n LESS THAN OR EQUAL TO three  \n            RETURN True  \n        END IF  \n        \n        SET orientation TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET o TO element at position i of points  \n            SET a TO element at position (i PLUS one) MODULO n of points  \n            SET b TO element at position (i PLUS two) MODULO n of points  \n            SET cross TO cross_product(o, a, b)  \n            \n            IF cross NOT EQUALS zero  \n                IF orientation EQUALS zero  \n                    IF cross GREATER THAN zero  \n                        SET orientation TO one  \n                    ELSE  \n                        SET orientation TO minus one  \n                    END IF  \n                ELSE IF (orientation EQUALS one AND cross LESS THAN zero) OR (orientation EQUALS minus one AND cross GREATER THAN zero)  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "concatenated-words", "passing_rate": 1.0, "pseudocode": "CLASS Trie  \n    FUNCTION __init__(self)  \n        SET self.children TO a list of length twenty six with all elements equal to none  \n        SET self.is_end TO false  \n    END FUNCTION  \n\n    FUNCTION insert(self, w)  \n        SET node TO self  \n        FOR each character c IN w  \n            SET idx TO the unicode code point number of character c MINUS the unicode code point number of the lowercase letter a  \n            IF the element at position idx of node.children EQUALS none THEN  \n                SET the element at position idx of node.children TO a new Trie object  \n            END IF  \n            SET node TO the element at position idx of node.children  \n        END FOR  \n        SET node.is_end TO true  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findAllConcatenatedWordsInADict(self, words)  \n        FUNCTION dfs(w, start)  \n            IF start EQUALS the length of w THEN  \n                RETURN true  \n            END IF  \n            SET node TO trie  \n            FOR i FROM start TO the length of w MINUS one  \n                SET idx TO the unicode code point number of the element at position i of w MINUS the unicode code point number of the lowercase letter a  \n                IF the element at position idx of node.children EQUALS none THEN  \n                    RETURN false  \n                END IF  \n                SET node TO the element at position idx of node.children  \n                IF node.is_end EQUALS true AND dfs(w, i PLUS one) EQUALS true THEN  \n                    RETURN true  \n                END IF  \n            END FOR  \n            RETURN false  \n        END FUNCTION  \n\n        SET trie TO a new Trie object  \n        SET ans TO an empty list  \n        SORT words by the length of each element in ascending order  \n        FOR each w IN words  \n            IF w IS NOT empty string THEN  \n                IF dfs(w, zero) EQUALS true THEN  \n                    APPEND w TO ans  \n                ELSE  \n                    CALL trie.insert with argument w  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "matchsticks-to-square", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION makesquare(matchsticks)  \n        SET total_length TO the SUM OF all elements IN matchsticks  \n        IF the remainder of total_length DIVIDED BY four NOT EQUALS zero  \n            RETURN False  \n        END IF  \n        SET side_length TO total_length DIVIDED BY four  \n        SORT matchsticks IN descending order  \n        FUNCTION can_form_sides(sides index)  \n            IF index EQUALS the LENGTH OF matchsticks  \n                FOR each side IN sides  \n                    IF side NOT EQUALS side_length  \n                        RETURN False  \n                    END IF  \n                END FOR  \n                RETURN True  \n            END IF  \n            FOR i FROM zero TO three  \n                IF the element at position i of sides PLUS the element at position index of matchsticks LESS THAN OR EQUAL TO side_length  \n                    SET the element at position i of sides TO the element at position i of sides PLUS the element at position index of matchsticks  \n                    IF can_form_sides(sides index PLUS one) RETURNS True  \n                        RETURN True  \n                    END IF  \n                    SET the element at position i of sides TO the element at position i of sides MINUS the element at position index of matchsticks  \n                END IF  \n                IF the element at position i of sides EQUALS zero  \n                    BREAK the FOR loop  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        RETURN can_form_sides(a list of four zeros zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ones-and-zeroes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        SET dp TO a two-dimensional collection with m plus one rows and n plus one columns filled with zero values  \n        FOR each s IN strs  \n            SET count_0 TO the number of times zero character appears in s  \n            SET count_1 TO the number of times one character appears in s  \n            FOR i FROM m DOWN TO count_0  \n                FOR j FROM n DOWN TO count_1  \n                    SET value_with_current TO the element at position i minus count_0 of dp at position j minus count_1 PLUS one  \n                    SET element at position i of dp at position j TO the greater value between the element at position i of dp at position j and value_with_current  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the element at position m of dp at position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "heaters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRadius(houses LIST OF INTEGER heaters LIST OF INTEGER)  \n        SORT houses IN ASCENDING ORDER  \n        SORT heaters IN ASCENDING ORDER  \n        SET min_radius TO zero  \n        SET j TO zero  \n        FOR each house IN houses  \n            WHILE j LESS THAN the LENGTH OF heaters MINUS one AND the ABSOLUTE VALUE OF the element at position j of heaters MINUS house GREATER THAN OR EQUAL TO the ABSOLUTE VALUE OF the element at position j PLUS one of heaters MINUS house  \n                INCREMENT j BY one  \n            END WHILE  \n            SET min_radius TO the GREATER VALUE BETWEEN min_radius AND the ABSOLUTE VALUE OF the element at position j of heaters MINUS house  \n        END FOR  \n        RETURN min_radius  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "total-hamming-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION totalHammingDistance(nums)  \n        SET total_distance TO zero  \n        FOR i FROM zero TO thirty one  \n            SET count_ones TO zero  \n            FOR each num IN nums  \n                INCREMENT count_ones BY the value of element at position i of num shifted right by zero bits with bitwise AND one EQUALS one  \n            END FOR  \n            SET count_zeros TO the LENGTH OF nums MINUS count_ones  \n            INCREMENT total_distance BY count_ones MULTIPLIED BY count_zeros  \n        END FOR  \n        RETURN total_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-window-median", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION medianSlidingWindow(nums k)  \n        SET lo TO empty list  \n        SET hi TO empty list  \n\n        FUNCTION balance_heaps()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi PLUS one THEN  \n                CALL heappush WITH hi AND the NEGATION OF CALL heappop WITH lo  \n            ELSE IF the LENGTH OF hi IS GREATER THAN the LENGTH OF lo THEN  \n                CALL heappush WITH lo AND the NEGATION OF CALL heappop WITH hi  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION add_num(num)  \n            IF lo IS empty OR num IS LESS THAN OR EQUAL TO the NEGATION OF the element at position zero of lo THEN  \n                CALL heappush WITH lo AND the NEGATION OF num  \n            ELSE  \n                CALL heappush WITH hi AND num  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION remove_num(num)  \n            IF num IS LESS THAN OR EQUAL TO the NEGATION OF the element at position zero of lo THEN  \n                REMOVE the NEGATION OF num FROM lo  \n                IF lo IS NOT empty THEN  \n                    CALL heapify WITH lo  \n                END IF  \n            ELSE  \n                REMOVE num FROM hi  \n                IF hi IS NOT empty THEN  \n                    CALL heapify WITH hi  \n                END IF  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION get_median()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi THEN  \n                RETURN the NEGATION OF the element at position zero of lo  \n            ELSE  \n                RETURN the SUM of the NEGATION OF the element at position zero of lo PLUS the element at position zero of hi DIVIDED BY two  \n            END IF  \n        END FUNCTION  \n\n        FOR i FROM zero TO k MINUS one DO  \n            CALL add_num WITH the element at position i of nums  \n        END FOR  \n\n        SET medians TO a new list containing CALL get_median()  \n\n        FOR i FROM k TO the LENGTH OF nums MINUS one DO  \n            CALL add_num WITH the element at position i of nums  \n            CALL remove_num WITH the element at position i MINUS k of nums  \n            APPEND CALL get_median() TO medians  \n        END FOR  \n\n        RETURN medians  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-permutation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPermutation(s)  \n        SET result TO empty list  \n        FOR index FROM zero TO the LENGTH OF s PLUS one  \n            APPEND index PLUS one TO result  \n        END FOR  \n        SET start TO zero  \n        FOR end FROM zero TO the LENGTH OF s  \n            IF end EQUALS the LENGTH OF s OR the element at position end of s EQUALS the character I  \n                SET segment TO the elements of result FROM position start TO position end PLUS one  \n                SET reversed_segment TO the elements of segment IN REVERSE ORDER  \n                REPLACE the elements of result FROM position start TO position end PLUS one WITH reversed_segment  \n                SET start TO end PLUS one  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "zuma-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinStep(board, hand)  \n        FUNCTION clean(board)  \n            SET stack TO empty list  \n            FOR each ball IN board  \n                IF stack is not empty AND the first element of the last pair in stack NOT EQUALS ball AND the second element of the last pair in stack GREATER THAN OR EQUAL TO three  \n                    REMOVE the last element FROM stack  \n                END IF  \n                IF stack is empty OR the first element of the last pair in stack NOT EQUALS ball  \n                    APPEND the pair of ball AND one TO stack  \n                ELSE  \n                    INCREMENT the second element of the last pair in stack BY one  \n                END IF  \n            END FOR  \n            IF stack is not empty AND the second element of the last pair in stack GREATER THAN OR EQUAL TO three  \n                REMOVE the last element FROM stack  \n            END IF  \n            SET result TO empty string  \n            FOR each pair of ball AND count IN stack  \n                APPEND ball REPEATED count TIMES TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n\n        FUNCTION dfs(board, hand_counter)  \n            IF board is empty  \n                RETURN zero  \n            END IF  \n            SET min_steps TO infinity  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF board  \n                SET j TO i PLUS one  \n                WHILE j LESS THAN the LENGTH OF board AND the element at position i of board EQUALS the element at position j of board  \n                    INCREMENT j BY one  \n                END WHILE  \n                SET increment TO three MINUS j MINUS i  \n                IF the count of the element at position i of board IN hand_counter GREATER THAN OR EQUAL TO increment  \n                    SET new_hand_counter TO a copy of hand_counter  \n                    DECREMENT the count of the element at position i of board IN new_hand_counter BY increment  \n                    SET new_board TO the result of clean with the concatenation of the substring from position zero TO position i of board WITH the substring from position j TO the end of board  \n                    SET steps TO dfs called with new_board AND new_hand_counter  \n                    IF steps GREATER THAN OR EQUAL TO zero  \n                        SET min_steps TO the smaller value BETWEEN min_steps AND steps PLUS increment  \n                    END IF  \n                END IF  \n                SET i TO j  \n            END WHILE  \n            IF min_steps EQUALS infinity  \n                RETURN negative one  \n            ELSE  \n                RETURN min_steps  \n            END IF  \n        END FUNCTION  \n\n        SET hand_counter TO a Counter of hand  \n        RETURN dfs called with board AND hand_counter  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-maze", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hasPath maze start destination  \n        SET directions TO list of pairs representing moving right moving down moving left moving up  \n        SET m TO the LENGTH OF maze  \n        SET n TO the LENGTH OF element at position zero of maze  \n        SET visited TO empty set  \n        \n        FUNCTION dfs x y  \n            IF the pair of x and y IS IN visited THEN  \n                RETURN False  \n            END IF  \n            IF list consisting of x and y EQUALS destination THEN  \n                RETURN True  \n            END IF  \n            ADD the pair of x and y TO visited  \n            \n            FOR each pair dx dy IN directions  \n                SET nx TO x  \n                SET ny TO y  \n                WHILE nx PLUS dx IS GREATER THAN OR EQUAL TO zero AND nx PLUS dx IS LESS THAN m AND ny PLUS dy IS GREATER THAN OR EQUAL TO zero AND ny PLUS dy IS LESS THAN n AND element at position nx PLUS dx of maze element at position ny PLUS dy EQUALS zero DO  \n                    INCREMENT nx BY dx  \n                    INCREMENT ny BY dy  \n                END WHILE  \n                IF dfs nx ny RETURNS True THEN  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN dfs element at position zero of start element at position one of start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(u, last, t)  \n            IF u EQUALS the LENGTH OF nums  \n                IF the LENGTH OF t GREATER THAN one  \n                    APPEND a copy of t TO ans  \n                END IF  \n                RETURN  \n            END IF  \n            IF element at position u of nums GREATER THAN OR EQUAL TO last  \n                APPEND element at position u of nums TO t  \n                CALL dfs with arguments u PLUS one, element at position u of nums, t  \n                REMOVE last element FROM t  \n            END IF  \n            IF element at position u of nums NOT EQUALS last  \n                CALL dfs with arguments u PLUS one, last, t  \n            END IF  \n        END FUNCTION  \n        SET ans TO an empty list  \n        CALL dfs with arguments zero, negative one thousand, an empty list  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-pairs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reversePairs(nums)  \n        FUNCTION merge_and_count(nums, start, end)  \n            IF start GREATER THAN OR EQUAL TO end THEN  \n                RETURN zero  \n            END IF  \n            \n            SET mid TO the integer division of the sum of start AND end BY two  \n            SET count TO the result of merge_and_count WITH nums AND start AND mid PLUS the result of merge_and_count WITH nums AND mid PLUS one AND end  \n            \n            SET j TO mid PLUS one  \n            FOR i FROM start TO mid  \n                WHILE j LESS THAN OR EQUAL TO end AND element at position i of nums GREATER THAN two MULTIPLIED BY element at position j of nums  \n                    INCREMENT j BY one  \n                END WHILE  \n                INCREMENT count BY j MINUS (mid PLUS one)  \n            END FOR  \n            \n            SET merged TO an empty list  \n            SET left TO start  \n            SET right TO mid PLUS one  \n            WHILE left LESS THAN OR EQUAL TO mid AND right LESS THAN OR EQUAL TO end  \n                IF element at position left of nums LESS THAN OR EQUAL TO element at position right of nums THEN  \n                    APPEND element at position left of nums TO merged  \n                    INCREMENT left BY one  \n                ELSE  \n                    APPEND element at position right of nums TO merged  \n                    INCREMENT right BY one  \n                END IF  \n            END WHILE  \n            \n            FOR each element FROM position left TO position mid of nums  \n                APPEND element TO merged  \n            END FOR  \n            FOR each element FROM position right TO position end of nums  \n                APPEND element TO merged  \n            END FOR  \n            \n            FOR index FROM start TO end  \n                SET element at position index of nums TO element at position index MINUS start of merged  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN merge_and_count WITH nums AND zero AND the LENGTH OF nums MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "target-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findTargetSumWays(nums, target)  \n        FUNCTION dfs(index, current_sum, memo)  \n            IF index EQUALS the LENGTH OF nums  \n                IF current_sum EQUALS target  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF the PAIR of index AND current_sum IS IN memo  \n                RETURN the VALUE in memo ASSOCIATED WITH the PAIR of index AND current_sum  \n            END IF  \n            SET positive TO the RESULT OF dfs CALLED WITH index INCREMENTED BY one AND current_sum INCREMENTED BY the ELEMENT at position index OF nums AND memo  \n            SET negative TO the RESULT OF dfs CALLED WITH index INCREMENTED BY one AND current_sum DECREMENTED BY the ELEMENT at position index OF nums AND memo  \n            SET the VALUE in memo ASSOCIATED WITH the PAIR of index AND current_sum TO positive PLUS negative  \n            RETURN the VALUE in memo ASSOCIATED WITH the PAIR of index AND current_sum  \n        END FUNCTION  \n        RETURN the RESULT OF dfs CALLED WITH zero AND zero AND an EMPTY DICTIONARY  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "diagonal-traverse", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDiagonalOrder(mat)  \n        IF mat EQUALS nothing OR element at position zero of mat EQUALS nothing  \n            RETURN an empty list  \n        END IF  \n        \n        SET m TO the length of mat  \n        SET n TO the length of element at position zero of mat  \n        SET result TO an empty list  \n        SET r TO zero  \n        SET c TO zero  \n        SET direction TO one  \n        \n        FOR each iteration FROM zero TO m MULTIPLIED BY n MINUS one  \n            APPEND element at position r of mat and position c TO result  \n            IF direction EQUALS one  \n                SET new_r TO r MINUS one  \n                SET new_c TO c PLUS one  \n            ELSE  \n                SET new_r TO r PLUS one  \n                SET new_c TO c MINUS one  \n            END IF  \n            \n            IF new_r LESS THAN zero OR new_r EQUALS m OR new_c LESS THAN zero OR new_c EQUALS n  \n                IF direction EQUALS one  \n                    IF new_c EQUALS n  \n                        SET new_r TO r PLUS one  \n                        SET new_c TO c  \n                    ELSE  \n                        SET new_r TO zero  \n                        SET new_c TO c PLUS one  \n                    END IF  \n                ELSE  \n                    IF new_r EQUALS m  \n                        SET new_r TO r  \n                        SET new_c TO c PLUS one  \n                    ELSE  \n                        SET new_r TO r PLUS one  \n                        SET new_c TO zero  \n                    END IF  \n                END IF  \n                SET direction TO direction MULTIPLIED BY negative one  \n            END IF  \n            \n            SET r TO new_r  \n            SET c TO new_c  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-maze-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findShortestWay(maze, ball, hole)  \n        SET directions TO list of tuples representing move down zero move right one and move down one move right zero and move down zero move left one and move up one move right zero  \n        SET m TO the LENGTH OF maze  \n        SET n TO the LENGTH OF the element at position zero of maze  \n        ASSIGN reference TO tuple conversion of ball INTO start  \n        ASSIGN reference TO tuple conversion of hole INTO hole  \n        SET priority queue TO a list containing a tuple of zero distance an empty string path and start position  \n        SET visited set TO an empty set  \n        \n        WHILE the priority queue is not empty  \n            REMOVE the element with the smallest distance from the priority queue and ASSIGN its values INTO dist path an tuple of x y  \n            \n            IF the tuple of x y EQUALS hole  \n                RETURN path  \n            END IF  \n            \n            IF the tuple of x y IS IN visited set  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            ADD the tuple of x y TO visited set  \n            \n            FOR each tuple of dx dy direction IN directions  \n                SET new_x TO x  \n                SET new_y TO y  \n                SET count TO zero  \n                \n                WHILE new_x PLUS dx IS GREATER THAN OR EQUAL TO zero AND new_x PLUS dx IS LESS THAN m AND new_y PLUS dy IS GREATER THAN OR EQUAL TO zero AND new_y PLUS dy IS LESS THAN n AND the element at position new_x PLUS dx of the element at position new_y PLUS dy of maze EQUALS zero  \n                    SET new_x TO new_x PLUS dx  \n                    SET new_y TO new_y PLUS dy  \n                    INCREMENT count BY one  \n                    IF the tuple of new_x new_y EQUALS hole  \n                        BREAK from the WHILE loop  \n                    END IF  \n                END WHILE  \n                \n                IF the tuple of new_x new_y IS NOT IN visited set  \n                    ADD a tuple of dist PLUS count path concatenated with direction and the tuple of new_x new_y TO the priority queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the string impossible  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ipo", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaximizedCapital(k INT w INT profits LIST OF INT capital LIST OF INT) RETURNS INT  \n        SET projects TO list of pairs each containing element at position index of capital AND element at position index of profits FOR index FROM zero TO the LENGTH OF capital MINUS one  \n        SORT projects BY the first element of each pair in ascending order  \n        \n        SET max_heap TO empty list  \n        \n        SET i TO zero  \n        SET n TO the LENGTH OF projects  \n        \n        FOR loop_variable FROM one TO k  \n            \n            WHILE i LESS THAN n AND the first element of element at position i of projects LESS THAN OR EQUAL TO w  \n                SET negative_profit TO negative of the second element of element at position i of projects  \n                ADD negative_profit TO max_heap USING heap insertion  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF the LENGTH OF max_heap EQUALS zero  \n                BREAK the loop  \n            END IF  \n            \n            SET most_profitable_project TO the result of removing the smallest element from max_heap using heap removal  \n            INCREMENT w BY negative of most_profitable_project  \n        END FOR  \n        \n        RETURN w  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-greater-element-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextGreaterElements(nums)  \n        SET n TO the LENGTH OF nums  \n        SET result TO a list of LENGTH n with each element SET TO negative one  \n        SET stack TO an empty list  \n        FOR i FROM zero TO two MULTIPLIED BY n MINUS one  \n            SET index TO the remainder of i DIVIDED BY n  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND the element at position the last element in stack of nums IS LESS THAN the element at position index of nums  \n                SET popped_index TO the last element removed FROM stack  \n                SET the element at position popped_index of result TO the element at position index of nums  \n            END WHILE  \n            IF i IS LESS THAN n  \n                APPEND index TO stack  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-maze-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestDistance(maze, start, destination)  \n        SET m TO the LENGTH OF maze  \n        SET n TO the LENGTH OF the element at position zero of maze  \n        SET directions TO the LIST OF pairs each consisting of an integer one and integer zero, integer minus one and integer zero, integer zero and integer one, integer zero and integer minus one  \n        SET start TO the TUPLE formed from start  \n        SET destination TO the TUPLE formed from destination  \n        SET visited TO an EMPTY set  \n        SET pq TO a LIST containing a SINGLE element which is a PAIR consisting of integer zero and start  \n        \n        WHILE pq is NOT empty  \n            SET dist TO the first element of the result of removing the smallest element from pq heap  \n            SET x TO the first element of the second element of the same removed pair  \n            SET y TO the second element of the second element of the same removed pair  \n            \n            IF x EQUALS the first element of destination AND y EQUALS the second element of destination  \n                RETURN dist  \n            END IF  \n            \n            IF the PAIR consisting of x and y IS IN visited  \n                CONTINUE to the next iteration of the while loop  \n            END IF  \n            \n            ADD the PAIR consisting of x and y TO visited  \n            \n            FOR each pair dx and dy IN directions  \n                SET new_x TO x  \n                SET new_y TO y  \n                SET count TO zero  \n                \n                WHILE new_x PLUS dx IS GREATER THAN OR EQUAL TO zero AND new_x PLUS dx IS LESS THAN m AND new_y PLUS dy IS GREATER THAN OR EQUAL TO zero AND new_y PLUS dy IS LESS THAN n AND the element at position new_x PLUS dx of maze AND position new_y PLUS dy IS EQUALS zero  \n                    SET new_x TO new_x PLUS dx  \n                    SET new_y TO new_y PLUS dy  \n                    INCREMENT count BY one  \n                END WHILE  \n                \n                IF the PAIR consisting of new_x and new_y IS NOT IN visited  \n                    ADD to pq heap the PAIR consisting of dist PLUS count and the PAIR consisting of new_x and new_y  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN integer minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "freedom-trail", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRotateSteps(ring, key)  \n        ASSIGN reference TO a new dictionary that assigns an empty list for each new key in char_positions  \n        FOR each index i AND character char IN ring  \n            APPEND i TO the list at key char in char_positions  \n        END FOR  \n        SET n TO the LENGTH OF ring  \n        \n        FUNCTION dp(i, prev_pos)  \n            IF i EQUALS the LENGTH OF key THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_steps TO infinity  \n            FOR each position pos IN the list at key at position i in key in char_positions  \n                SET clockwise TO the remainder of the subtraction of prev_pos FROM pos DIVIDED BY n  \n                SET anticlockwise TO the remainder of the subtraction of pos FROM prev_pos DIVIDED BY n  \n                SET steps TO the minimum of clockwise AND anticlockwise PLUS one PLUS the result of dp with parameters i PLUS one AND pos  \n                SET min_steps TO the minimum of min_steps AND steps  \n            END FOR  \n            \n            RETURN min_steps  \n        END FUNCTION  \n        \n        RETURN dp with parameters zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-palindromic-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindromeSubseq(s)  \n        SET n TO the LENGTH OF s  \n        SET dp TO a two dimensional array of size n by n FILLED WITH zeroes  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of dp TO one  \n        END FOR  \n        FOR length FROM two TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i PLUS one at position j MINUS one of dp PLUS two TO element at position i at position j of dp  \n                ELSE  \n                    SET element at position i at position j of dp TO the GREATER value BETWEEN element at position i PLUS one at position j of dp AND element at position i at position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position zero at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-washing-machines", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinMoves(machines)  \n        SET total_dresses TO zero  \n        FOR each machine IN machines  \n            INCREMENT total_dresses BY machine  \n        END FOR  \n        SET n TO the LENGTH OF machines  \n        \n        IF the remainder of total_dresses DIVIDED BY n NOT EQUALS zero  \n            RETURN negative one  \n        END IF  \n        \n        SET target TO total_dresses DIVIDED BY n  \n        SET left_sum TO zero  \n        SET max_moves TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET left_excess TO left_sum MINUS target MULTIPLIED BY i  \n            SET right_excess TO total_dresses MINUS left_sum MINUS element at position i of machines MINUS target MULTIPLIED BY n MINUS i MINUS one  \n            \n            SET current_moves TO the maximum value among the absolute value of left_excess AND the absolute value of right_excess AND element at position i of machines MINUS target  \n            SET max_moves TO the maximum value between max_moves AND current_moves  \n            \n            INCREMENT left_sum BY element at position i of machines  \n        END FOR  \n        \n        RETURN max_moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION change(amount parameter, coins parameter)  \n        SET dp TO a list of zeros with length of amount parameter PLUS one  \n        SET element at position zero of dp TO one  \n        FOR each coin IN coins parameter  \n            FOR variable x FROM coin TO amount parameter  \n                INCREMENT element at position x of dp BY element at position x MINUS coin of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position amount parameter of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-uncommon-subsequence-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLUSlength(strs)  \n        FUNCTION is_subsequence(s, t)  \n            SET iterator_of_t TO iterator of t  \n            RETURN whether for every character_in_s the character_in_s is found in iterator_of_t in order  \n        END FUNCTION  \n        \n        SORT strs by the negative length of each element PLUS lexicographical order of each element  \n        \n        FOR each index_i AND word IN enumeration of strs  \n            SET unique TO true  \n            FOR each index_j AND other_word IN enumeration of strs  \n                IF index_i NOT EQUALS index_j AND is_subsequence(word, other_word) THEN  \n                    SET unique TO false  \n                    BREAK inner loop  \n                END IF  \n            END FOR  \n            IF unique THEN  \n                RETURN the length of word  \n            END IF  \n        END FOR  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "continuous-subarray-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkSubarraySum(nums, k)  \n        SET remainder_map TO a dictionary mapping zero TO negative one  \n        SET current_sum TO zero  \n        FOR each index i WITH element num IN nums  \n            SET current_sum TO current_sum PLUS num  \n            IF k NOT EQUALS zero  \n                SET current_sum TO the remainder of current_sum DIVIDED BY k  \n            END IF  \n            IF current_sum IS A KEY IN remainder_map  \n                IF the difference BETWEEN i AND the value associated WITH current_sum IN remainder_map IS GREATER THAN one  \n                    RETURN True  \n                END IF  \n            ELSE  \n                ASSIGN the value i TO the key current_sum IN remainder_map  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary-through-deleting", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLongestWord(s, dictionary)  \n        FUNCTION is_subsequence(word, s)  \n            SET iterator_to_s TO an iterator OVER s  \n            FOR each character IN word  \n                IF character DOES NOT APPEAR IN iterator_to_s AFTER its current position  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        SORT dictionary BY descending LENGTH OF each element AND ascending LEXICOGRAPHICAL ORDER OF each element  \n        \n        FOR each word IN dictionary  \n            IF is_subsequence(word, s) EQUALS true  \n                RETURN word  \n            END IF  \n        END FOR  \n        \n        RETURN an empty string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "contiguous-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxLength(nums)  \n        SET prefix_sum_index TO a dictionary with element zero mapped to element minus one  \n        SET max_length TO zero  \n        SET count TO zero  \n        FOR each index i AND element num IN the enumeration of nums  \n            IF num EQUALS one  \n                INCREMENT count BY one  \n            ELSE  \n                DECREMENT count BY one  \n            END IF  \n            IF count IS A KEY IN prefix_sum_index  \n                SET max_length TO the GREATER OF max_length AND the result of i MINUS the element at key count IN prefix_sum_index  \n            ELSE  \n                SET the element at key count IN prefix_sum_index TO i  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "beautiful-arrangement", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countArrangement(n)  \n        FUNCTION backtrack(used, index)  \n            IF index EQUALS n PLUS one  \n                RETURN one  \n            END IF  \n            SET count TO zero  \n            FOR i FROM one TO n  \n                IF element at position i of used EQUALS False AND (i MODULO index EQUALS zero OR index MODULO i EQUALS zero)  \n                    SET element at position i of used TO True  \n                    INCREMENT count BY backtrack(used, index PLUS one)  \n                    SET element at position i of used TO False  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        SET used TO list of False repeated n PLUS one times  \n        RETURN backtrack(used, one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minesweeper", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION updateBoard(board  click)  \n        FUNCTION count_adjacent_mines(r  c)  \n            SET count TO zero  \n            FOR i FROM r MINUS one TO r PLUS one  \n                FOR j FROM c MINUS one TO c PLUS one  \n                    IF i GREATER THAN OR EQUAL TO zero AND i LESS THAN the LENGTH OF board AND j GREATER THAN OR EQUAL TO zero AND j LESS THAN the LENGTH OF element at position zero of board AND element at position i of board AT position j EQUALS the character MINE  \n                        INCREMENT count BY one  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        FUNCTION dfs(r  c)  \n            IF NOT (r GREATER THAN OR EQUAL TO zero AND r LESS THAN the LENGTH OF board AND c GREATER THAN OR EQUAL TO zero AND c LESS THAN the LENGTH OF element at position zero of board)  \n                RETURN  \n            END IF  \n            IF element at position r of board AT position c NOT EQUALS the character EMPTY  \n                RETURN  \n            END IF  \n            \n            SET mine_count TO count_adjacent_mines(r  c)  \n            IF mine_count GREATER THAN zero  \n                SET element at position r of board AT position c TO the STRING REPRESENTATION OF mine_count  \n            ELSE  \n                SET element at position r of board AT position c TO the character BLANK  \n                FOR i FROM r MINUS one TO r PLUS one  \n                    FOR j FROM c MINUS one TO c PLUS one  \n                        CALL dfs(i  j)  \n                    END FOR  \n                END FOR  \n            END IF  \n        END FUNCTION  \n        \n        DESTRUCTURE click INTO row  col  \n        IF element at position row of board AT position col EQUALS the character MINE  \n            SET element at position row of board AT position col TO the character EXPLODED  \n            RETURN board  \n        END IF  \n        \n        CALL dfs(row  col)  \n        RETURN board  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lonely-pixel-i", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLonelyPixel(picture)  \n        IF picture EQUALS empty OR element at position zero of picture EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF picture  \n        SET n TO the LENGTH OF element at position zero of picture  \n        SET row_count TO a list of zeroes with the LENGTH m  \n        SET col_count TO a list of zeroes with the LENGTH n  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of picture AND element at position j IN THAT EQUALS the character B  \n                    INCREMENT element at position i of row_count BY one  \n                    INCREMENT element at position j of col_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET lonely_pixel_count TO zero  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of picture AND element at position j IN THAT EQUALS the character B AND element at position i of row_count EQUALS one AND element at position j of col_count EQUALS one  \n                    INCREMENT lonely_pixel_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN lonely_pixel_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-diff-pairs-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPairs(nums k)  \n        IF k LESS THAN zero  \n            RETURN zero  \n        END IF  \n        SET num_counts TO empty dictionary  \n        FOR each num IN nums  \n            SET current_count TO value at key num in num_counts OR zero if key does not exist  \n            SET value at key num in num_counts TO current_count PLUS one  \n        END FOR  \n        SET unique_pairs TO zero  \n        FOR each num IN keys of num_counts  \n            IF k EQUALS zero  \n                IF value at key num in num_counts GREATER THAN one  \n                    INCREMENT unique_pairs BY one  \n                END IF  \n            ELSE  \n                IF key equal to num PLUS k EXISTS in num_counts  \n                    INCREMENT unique_pairs BY one  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN unique_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lonely-pixel-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findBlackPixel(picture, target)  \n        IF picture EQUALS empty OR element at position zero of picture EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF picture  \n        SET n TO the LENGTH OF element at position zero of picture  \n        SET row_count TO a list of zeros with LENGTH m  \n        SET col_count TO a list of zeros with LENGTH n  \n        SET row_patterns TO a default dictionary of integers  \n        FOR r FROM zero TO m MINUS one  \n            SET pattern TO the concatenation of elements of element at position r of picture as strings joined in sequence  \n            INCREMENT the count of pattern in row_patterns BY one  \n            FOR c FROM zero TO n MINUS one  \n                IF the element at position c of element at position r of picture EQUALS black pixel  \n                    INCREMENT element at position r of row_count BY one  \n                    INCREMENT element at position c of col_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET lonely_pixels TO zero  \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                IF the element at position c of element at position r of picture EQUALS black pixel  \n                    SET pattern TO the concatenation of elements of element at position r of picture as strings joined in sequence  \n                    IF element at position r of row_count EQUALS target AND element at position c of col_count EQUALS target AND the count of pattern in row_patterns EQUALS target  \n                        INCREMENT lonely_pixels BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN lonely_pixels  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "complex-number-multiplication", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION complexNumberMultiply(num1 num2)  \n        FUNCTION parse_complex(num)  \n            SET parts TO the result of splitting num by the plus sign  \n            SET real TO the integer conversion of the element at position zero of parts  \n            SET imaginary_string TO the element at position one of parts  \n            SET imaginary TO the integer conversion of the substring from position zero TO the position before the last character of imaginary_string  \n            RETURN real AND imaginary  \n        END FUNCTION  \n        \n        SET real1 AND imag1 TO the result of calling parse_complex with num1  \n        SET real2 AND imag2 TO the result of calling parse_complex with num2  \n        \n        SET real_part TO real1 MULTIPLIED BY real2 MINUS imag1 MULTIPLIED BY imag2  \n        SET imaginary_part TO real1 MULTIPLIED BY imag2 PLUS imag1 MULTIPLIED BY real2  \n        \n        RETURN the string formed by concatenating the string representation of real_part PLUS the plus sign PLUS the string representation of imaginary_part PLUS the character i  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-difference", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET split_result TO list of elements obtained by splitting time at character colon  \n            SET hours TO element at position zero of split_result converted to integer  \n            SET minutes TO element at position one of split_result converted to integer  \n            RETURN hours MULTIPLIED BY sixty PLUS minutes  \n        END FUNCTION  \n        \n        SET minutes_list TO list of elements obtained by applying to_minutes to each element in timePoints  \n        SORT minutes_list IN ascending order  \n        \n        SET min_diff TO infinity  \n        FOR i FROM one TO LENGTH OF minutes_list MINUS one  \n            SET current_difference TO element at position i of minutes_list MINUS element at position i MINUS one of minutes_list  \n            IF current_difference LESS THAN min_diff  \n                SET min_diff TO current_difference  \n            END IF  \n        END FOR  \n        \n        SET circular_difference TO one thousand four hundred forty MINUS element at last position of minutes_list PLUS element at position zero of minutes_list  \n        IF circular_difference LESS THAN min_diff  \n            SET min_diff TO circular_difference  \n        END IF  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "single-element-in-a-sorted-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION singleNonDuplicate(nums)  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS the result of right MINUS left DIVIDED BY two  \n            \n            IF mid MODULO two EQUALS one  \n                DECREMENT mid BY one  \n            END IF  \n            \n            IF element at position mid of nums EQUALS element at position mid PLUS one of nums  \n                SET left TO mid PLUS two  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN element at position left of nums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "01-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION updateMatrix(mat)  \n        IF mat EQUALS empty OR element at position zero of mat EQUALS empty  \n            RETURN mat  \n        END IF  \n        SET rows TO the LENGTH OF mat  \n        SET cols TO the LENGTH OF element at position zero of mat  \n        SET dist TO a new two dimensional list of size rows by cols filled with positive infinity  \n        SET queue TO an empty double ended queue  \n        FOR each r FROM zero TO rows MINUS one  \n            FOR each c FROM zero TO cols MINUS one  \n                IF element at position r of mat AT position c EQUALS zero  \n                    SET element at position r of dist AT position c TO zero  \n                    APPEND the tuple of r and c TO queue  \n                END IF  \n            END FOR  \n        END FOR  \n        SET directions TO the list of tuples consisting of minus one and zero PLUS one and zero PLUS zero and minus one PLUS zero and one  \n        WHILE queue is not empty  \n            REMOVE the element from the left side of queue and ASSIGN the first value of the tuple TO r and the second value of the tuple TO c  \n            FOR each tuple of dr and dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF nr IS GREATER THAN OR EQUAL TO zero AND nr IS LESS THAN rows AND nc IS GREATER THAN OR EQUAL TO zero AND nc IS LESS THAN cols AND element at position nr of dist AT position nc IS GREATER THAN element at position r of dist AT position c PLUS one  \n                    SET element at position nr of dist AT position nc TO element at position r of dist AT position c PLUS one  \n                    APPEND the tuple of nr and nc TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN dist  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "output-contest-matches", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch WITH PARAMETER n  \n        SET teams TO list of strings representing numbers from one TO n inclusive  \n        WHILE n GREATER THAN one holds  \n            FOR each i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO open parenthesis concatenated WITH element at position i of teams concatenated WITH comma concatenated WITH element at position n MINUS one MINUS i of teams concatenated WITH close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN element at position zero of teams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-boxes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeBoxes(boxes)  \n        FUNCTION dp(l, r, k, memo)  \n            IF l GREATER THAN r THEN  \n                RETURN zero  \n            END IF  \n            IF tuple composed of l r and k EXISTS IN memo THEN  \n                RETURN value ASSOCIATED WITH tuple composed of l r and k IN memo  \n            END IF  \n            \n            WHILE r GREATER THAN l AND element at position r of boxes EQUALS element at position r MINUS one of boxes DO  \n                DECREMENT r BY one  \n                INCREMENT k BY one  \n            END WHILE  \n            \n            SET res TO value RETURNED BY dp WITH arguments l r MINUS one zero memo PLUS quantity k PLUS one MULTIPLIED BY quantity k PLUS one  \n            \n            FOR i FROM l TO r MINUS one DO  \n                IF element at position i of boxes EQUALS element at position r of boxes THEN  \n                    SET candidate TO value RETURNED BY dp WITH arguments l i k PLUS one memo PLUS value RETURNED BY dp WITH arguments i PLUS one r MINUS one zero memo  \n                    IF candidate GREATER THAN res THEN  \n                        SET res TO candidate  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            ASSIGN res TO key tuple composed of l r and k IN memo  \n            RETURN res  \n        END FUNCTION  \n        \n        RETURN value RETURNED BY dp WITH arguments zero LENGTH OF boxes MINUS one zero empty dictionary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-provinces", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findCircleNum(isConnected)  \n        FUNCTION dfs(city)  \n            FOR neighbor FROM zero TO n MINUS one  \n                IF element at position city of isConnected AT position neighbor EQUALS one AND element at position neighbor of visited EQUALS False  \n                    SET element at position neighbor of visited TO True  \n                    CALL dfs WITH neighbor  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF isConnected  \n        SET visited TO a list of False values repeated n times  \n        SET province_count TO zero  \n\n        FOR city FROM zero TO n MINUS one  \n            IF element at position city of visited EQUALS False  \n                CALL dfs WITH city  \n                INCREMENT province_count BY one  \n            END IF  \n        END FOR  \n\n        RETURN province_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-with-equal-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitArray(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n LESS THAN seven  \n            RETURN False  \n        END IF  \n        SET prefix_sum TO a list of n elements each initialized to zero  \n        SET element at position zero of prefix_sum TO element at position zero of nums  \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of prefix_sum TO element at position i MINUS one of prefix_sum PLUS element at position i of nums  \n        END FOR  \n        FOR j FROM three TO n MINUS three MINUS one  \n            SET seen TO an empty set  \n            FOR i FROM one TO j MINUS one MINUS one  \n                IF element at position i MINUS one of prefix_sum EQUALS element at position j MINUS one of prefix_sum MINUS element at position i of prefix_sum  \n                    ADD element at position i MINUS one of prefix_sum TO seen  \n                END IF  \n            END FOR  \n            FOR k FROM j PLUS two TO n MINUS one MINUS one  \n                IF element at position n MINUS one of prefix_sum MINUS element at position k of prefix_sum EQUALS element at position k MINUS one of prefix_sum MINUS element at position j of prefix_sum AND element at position k MINUS one of prefix_sum MINUS element at position j of prefix_sum IS IN seen  \n                    RETURN True  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "student-attendance-record-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkRecord WITH parameter n  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE dp AS a three dimensional list of size n PLUS one BY two BY three filled with zeros  \n        SET element at position zero zero zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO one  \n                FOR k FROM zero TO two  \n                    SET element at position i j zero of dp TO element at position i j zero of dp PLUS element at position i MINUS one j k of dp MODULO MOD  \n                    IF j EQUALS zero  \n                        SET element at position i one zero of dp TO element at position i one zero of dp PLUS element at position i MINUS one zero k of dp MODULO MOD  \n                    END IF  \n                    IF k LESS THAN two  \n                        SET element at position i j k PLUS one of dp TO element at position i j k PLUS one of dp PLUS element at position i MINUS one j k of dp MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        SET result TO zero  \n        FOR j FROM zero TO one  \n            FOR k FROM zero TO two  \n                SET result TO result PLUS element at position n j k of dp MODULO MOD  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "optimal-division", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION optimalDivision(nums)  \n        IF the LENGTH OF nums EQUALS one  \n            RETURN the string representation of the element at position one of nums  \n        END IF  \n        \n        IF the LENGTH OF nums EQUALS two  \n            RETURN the string representation of the element at position one of nums  \n            CONCATENATED WITH the division word  \n            CONCATENATED WITH the string representation of the element at position two of nums  \n        END IF  \n        \n        RETURN the string representation of the element at position one of nums  \n        CONCATENATED WITH the division word  \n        CONCATENATED WITH an opening parenthesis word  \n        CONCATENATED WITH the string join of the division word between the string representations of elements from position two TO the length of nums of nums  \n        CONCATENATED WITH a closing parenthesis word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "brick-wall", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION leastBricks(wall)  \n        SET gap_counts TO a new dictionary with default value zero for any key  \n        FOR each row IN wall  \n            SET total TO zero  \n            FOR each brick IN the elements of row excluding the last element  \n                SET total TO total PLUS the current brick  \n                INCREMENT the value in gap_counts corresponding to key total BY one  \n            END FOR  \n        END FOR  \n        SET max_gaps TO the maximum value among all values in gap_counts or zero if gap_counts is empty  \n        RETURN the length of wall MINUS max_gaps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-concatenated-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitLoopedString(strs)  \n        FOR index FROM zero TO the LENGTH OF strs MINUS one  \n            SET reversed_str TO the reverse of the element at position index of strs  \n            IF reversed_str GREATER THAN the element at position index of strs  \n                SET the element at position index of strs TO reversed_str  \n            END IF  \n        END FOR  \n  \n        SET doubled_strs TO the concatenation of strs WITH strs  \n  \n        SET max_string TO an empty string  \n  \n        FOR index FROM zero TO the LENGTH OF strs MINUS one  \n            FOR each is_reversed IN the collection consisting of False AND True  \n                IF is_reversed EQUALS True  \n                    SET current TO the reverse of the element at position index of strs  \n                ELSE  \n                    SET current TO the element at position index of strs  \n                END IF  \n  \n                SET remaining TO the concatenation of the elements from position index PLUS one TO position index PLUS the LENGTH OF strs MINUS one of doubled_strs  \n  \n                FOR cut_position FROM zero TO the LENGTH OF current  \n                    SET candidate TO the concatenation of the substring from cut_position TO the end of current WITH remaining WITH the substring from the start TO cut_position of current  \n  \n                    IF candidate GREATER THAN max_string  \n                        SET max_string TO candidate  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n  \n        RETURN max_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-greater-element-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextGreaterElement(n)  \n        SET digits TO list of characters representing the decimal digits of n  \n        SET length TO the number of elements in digits  \n        SET i TO length MINUS two  \n        WHILE i IS GREATER THAN OR EQUAL TO zero AND element at position i of digits IS GREATER THAN OR EQUAL TO element at position i PLUS one of digits  \n            DECREMENT i BY one  \n        END WHILE  \n        IF i EQUALS negative one  \n            RETURN negative one  \n        END IF  \n        SET j TO length MINUS one  \n        WHILE element at position j of digits IS LESS THAN OR EQUAL TO element at position i of digits  \n            DECREMENT j BY one  \n        END WHILE  \n        SET temporary variable TO element at position i of digits  \n        SET element at position i of digits TO element at position j of digits  \n        SET element at position j of digits TO temporary variable  \n        SET digits TO concatenation of elements from position zero TO position i of digits PLUS elements from position i PLUS one TO the last position of digits in reverse order  \n        SET result TO the integer value represented by concatenating elements of digits in order  \n        IF result IS GREATER THAN the largest value representable by a signed thirty two bit integer  \n            RETURN negative one  \n        END IF  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subarray-sum-equals-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subarraySum(nums k)  \n        SET cumulative_sum_freq TO a dictionary with the element zero mapped to the element one  \n        SET current_sum TO zero  \n        SET count TO zero  \n        FOR each num IN nums  \n            SET current_sum TO current_sum PLUS num  \n            IF current_sum MINUS k EXISTS AS A KEY IN cumulative_sum_freq  \n                SET count TO count PLUS the value mapped to the key current_sum MINUS k in cumulative_sum_freq  \n            END IF  \n            IF current_sum EXISTS AS A KEY IN cumulative_sum_freq  \n                SET the value mapped to the key current_sum in cumulative_sum_freq TO the value mapped to the key current_sum in cumulative_sum_freq PLUS one  \n            ELSE  \n                SET the value mapped to the key current_sum in cumulative_sum_freq TO one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-line-of-consecutive-one-in-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestLine(mat)  \n        IF mat EQUALS empty OR element at position zero of mat EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF element at position zero of mat  \n        \n        SET directions TO a collection of pairs consisting of zero PLUS one second element zero PLUS zero second element one PLUS one second element one PLUS negative one  \n        SET max_length TO zero  \n        \n        FUNCTION check(x, y, dx, dy)  \n            SET length TO zero  \n            WHILE x GREATER THAN OR EQUAL TO zero AND x LESS THAN m AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n AND element at position x of mat AND element at position y of element at position x of mat EQUALS one  \n                INCREMENT length BY one  \n                SET x TO x PLUS dx  \n                SET y TO y PLUS dy  \n            END WHILE  \n            RETURN length  \n        END FUNCTION  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of mat AND element at position j of element at position i of mat EQUALS one  \n                    FOR each dx dy IN directions  \n                        IF i MINUS dx LESS THAN zero OR j MINUS dy LESS THAN zero OR j MINUS dy GREATER THAN OR EQUAL TO n OR element at position i MINUS dx of mat AND element at position j MINUS dy of element at position i MINUS dx of mat EQUALS zero  \n                            SET max_length TO the GREATER VALUE BETWEEN max_length AND the RESULT OF check WITH PARAMETERS i j dx dy  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "array-nesting", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION arrayNesting(nums)  \n        SET visited TO a list of False values with the LENGTH OF nums  \n        SET max_length TO zero  \n        FOR index i FROM zero TO the LENGTH OF nums MINUS one  \n            IF the element at position i of visited EQUALS False  \n                SET current_length TO zero  \n                SET k TO i  \n                WHILE the element at position k of visited EQUALS False  \n                    SET the element at position k of visited TO True  \n                    SET k TO the element at position k of nums  \n                    INCREMENT current_length BY one  \n                END WHILE  \n                SET max_length TO the GREATER OF max_length AND current_length  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutation-in-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkInclusion(s1  s2)  \n        SET length of s1 TO the LENGTH OF s1  \n        SET length of s2 TO the LENGTH OF s2  \n        IF length of s1 GREATER THAN length of s2  \n            RETURN False  \n        END IF  \n        SET count of characters in s1 TO the frequency count of each character in s1  \n        SET count of characters in the first window of s2 TO the frequency count of each character in the substring from position one TO position length of s1 of s2  \n        IF count of characters in s1 EQUALS count of characters in the first window of s2  \n            RETURN True  \n        END IF  \n        FOR index FROM position length of s1 PLUS one TO position length of s2  \n            INCREMENT the frequency count of the character at position index of s2 BY one in the current window count  \n            DECREMENT the frequency count of the character at the position index MINUS length of s1 in s2 BY one in the current window count  \n            IF the frequency count of the character at the position index MINUS length of s1 in s2 EQUALS zero in the current window count  \n                REMOVE the character at the position index MINUS length of s1 in s2 FROM the current window count  \n            END IF  \n            IF count of characters in s1 EQUALS the current window count  \n                RETURN True  \n            END IF  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-vacation-days", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxVacationDays(flights, days)  \n        SET n TO the LENGTH OF flights  \n        SET k TO the LENGTH OF the element at position zero of days  \n        \n        SET dp TO a list of negative one repeated n times  \n        SET the element at position zero of dp TO zero  \n        \n        SET graph TO an empty dictionary mapping each integer i from zero TO n MINUS one TO an empty list  \n        FOR each integer i FROM zero TO n MINUS one  \n            FOR each integer j FROM zero TO n MINUS one  \n                IF the element at position i of flights EQUALS one AT the element at position j THEN  \n                    APPEND j TO the list mapped by i in graph  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR each integer week FROM zero TO k MINUS one  \n            SET new_dp TO a list of negative one repeated n times  \n            FOR each integer i FROM zero TO n MINUS one  \n                IF the element at position i of dp EQUALS negative one THEN  \n                    CONTINUE TO the next iteration  \n                END IF  \n                SET the element at position i of new_dp TO the maximum VALUE BETWEEN the element at position i of new_dp AND the element at position i of dp PLUS the element at position i of days PLUS the element at position week of days  \n                FOR each integer j IN the list mapped by i in graph  \n                    SET the element at position j of new_dp TO the maximum VALUE BETWEEN the element at position j of new_dp AND the element at position i of dp PLUS the element at position j of days PLUS the element at position week of days  \n                END FOR  \n            END FOR  \n            SET dp TO new_dp  \n        END FOR  \n        \n        RETURN the maximum VALUE IN dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "squirrel-simulation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(height  \n                         width  \n                         tree  \n                         squirrel  \n                         nuts)  \n        FUNCTION distance(p1  \n                          p2)  \n            RETURN the absolute value of the element at position zero of p1 MINUS the element at position zero of p2 PLUS the absolute value of the element at position one of p1 MINUS the element at position one of p2  \n        END FUNCTION  \n        \n        SET total_distance TO zero  \n        SET max_save TO the smallest possible floating point value  \n        \n        FOR each nut IN nuts  \n            INCREMENT total_distance BY two MULTIPLIED BY distance of nut and tree  \n            SET first_nut_distance TO distance of squirrel and nut PLUS distance of nut and tree  \n            SET later_nut_distance TO two MULTIPLIED BY distance of nut and tree  \n            SET save TO later_nut_distance MINUS first_nut_distance  \n            SET max_save TO the larger value BETWEEN max_save AND save  \n        END FOR  \n        \n        RETURN total_distance MINUS max_save  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "out-of-boundary-paths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findPaths(m INTEGER n INTEGER maxMove INTEGER startRow INTEGER startColumn INTEGER) RETURNS INTEGER  \n        SET MOD TO one billion PLUS seven  \n        SET directions TO list of tuples of zero and one zero and negative one one and zero negative one and zero representing right left down up  \n        INITIALIZE dp TO three dimensional list of zeros with dimensions m by n by maxMove PLUS one  \n        FOR k FROM one TO maxMove  \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    FOR each pair di dj IN directions  \n                        SET ni TO i PLUS di  \n                        SET nj TO j PLUS dj  \n                        IF ni LESS THAN zero OR ni GREATER THAN OR EQUAL TO m OR nj LESS THAN zero OR nj GREATER THAN OR EQUAL TO n THEN  \n                            SET dp at position i j k TO dp at position i j k PLUS one MODULO MOD  \n                        ELSE  \n                            SET dp at position i j k TO dp at position i j k PLUS dp at position ni nj k MINUS one MODULO MOD  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp at position startRow startColumn maxMove  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-unsorted-continuous-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findUnsortedSubarray(nums)  \n        SET sorted_nums TO nums arranged in ascending order  \n        SET start TO negative one  \n        SET end TO negative two  \n        FOR index FROM zero TO the LENGTH OF nums MINUS one  \n            IF element at position index of nums NOT EQUALS element at position index of sorted_nums  \n                IF start EQUALS negative one  \n                    SET start TO index  \n                END IF  \n                SET end TO index  \n            END IF  \n        END FOR  \n        RETURN end MINUS start PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-operation-for-two-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        SET m TO the LENGTH OF word1  \n        SET n TO the LENGTH OF word2  \n        SET dp TO a two dimensional list with m PLUS one ROWS and n PLUS one COLUMNS each initialized TO zero  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF the element at position i MINUS one of word1 EQUALS the element at position j MINUS one of word2  \n                    SET the element at position i and j of dp TO the element at position i MINUS one and j MINUS one of dp PLUS one  \n                ELSE  \n                    SET the element at position i and j of dp TO the GREATER OF the element at position i MINUS one and j of dp AND the element at position i and j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        SET lcs_length TO the element at position m and n of dp  \n        RETURN m MINUS lcs_length PLUS n MINUS lcs_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "erect-the-fence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION outerTrees(trees)  \n        FUNCTION cross(i, j, k)  \n            SET a TO element at position i of trees  \n            SET b TO element at position j of trees  \n            SET c TO element at position k of trees  \n            RETURN (the first element of b MINUS the first element of a) MULTIPLIED BY (the second element of c MINUS the second element of b) MINUS (the second element of b MINUS the second element of a) MULTIPLIED BY (the first element of c MINUS the first element of b)  \n        END FUNCTION  \n  \n        SET n TO the LENGTH OF trees  \n        IF n LESS THAN four THEN  \n            RETURN trees  \n        END IF  \n  \n        SORT trees in ascending order  \n        SET vis TO a list of boolean False of length n  \n        SET stk TO a list containing zero  \n        FOR i FROM one TO n MINUS one  \n            WHILE the LENGTH OF stk GREATER THAN one AND cross(element at position LENGTH OF stk MINUS two of stk, element at position LENGTH OF stk MINUS one of stk, i) LESS THAN zero HOLDS  \n                SET the element at position LENGTH OF stk MINUS one TO be removed from stk and assign to discarded  \n                SET the element at position discarded of vis TO False  \n            END WHILE  \n            SET the element at position i of vis TO True  \n            APPEND i TO stk  \n        END FOR  \n  \n        SET m TO the LENGTH OF stk  \n        FOR i FROM n MINUS two DOWN TO zero STEP minus one  \n            IF the element at position i of vis EQUALS True THEN  \n                CONTINUE to next iteration  \n            END IF  \n            WHILE the LENGTH OF stk GREATER THAN m AND cross(element at position LENGTH OF stk MINUS two of stk, element at position LENGTH OF stk MINUS one of stk, i) LESS THAN zero HOLDS  \n                REMOVE the element at position LENGTH OF stk MINUS one FROM stk  \n            END WHILE  \n            APPEND i TO stk  \n        END FOR  \n  \n        REMOVE the element at position LENGTH OF stk MINUS one FROM stk  \n        SET result TO empty list  \n        FOR each index i IN stk  \n            APPEND element at position i of trees TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-square", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validSquare(p1 p2 p3 p4)  \n        FUNCTION squared_distance(point1 point2)  \n            SET difference_in_x TO element at position zero of point1 MINUS element at position zero of point2  \n            SET difference_in_y TO element at position one of point1 MINUS element at position one of point2  \n            SET squared_difference_x TO difference_in_x MULTIPLIED BY difference_in_x  \n            SET squared_difference_y TO difference_in_y MULTIPLIED BY difference_in_y  \n            SET total_squared_distance TO squared_difference_x PLUS squared_difference_y  \n            RETURN total_squared_distance  \n        END FUNCTION  \n      \n        SET points TO list consisting of p1 p2 p3 p4  \n        SET distances TO empty set  \n  \n        FOR i FROM zero TO three  \n            FOR j FROM i PLUS one TO three  \n                SET dist TO squared_distance element at position i of points element at position j of points  \n                IF dist EQUALS zero  \n                    RETURN false  \n                END IF  \n                ADD dist TO distances  \n            END FOR  \n        END FOR  \n  \n        IF the size of distances EQUALS two  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-duplicate-file-in-system", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findDuplicate(paths)  \n        SET content_to_paths TO an empty map from content TO list of file paths  \n        FOR each path IN paths  \n            SET parts TO the list of elements obtained by splitting path at each space  \n            SET directory TO element at position one of parts  \n            FOR each file_info IN the elements of parts starting from position two to the last element  \n                SET file_name TO the substring of file_info from the start TO the position before the first opening parenthesis  \n                SET content TO the substring of file_info from the position after the first opening parenthesis TO the position before the last character  \n                APPEND the concatenation of directory PLUS the forward slash PLUS file_name TO the list associated with content in content_to_paths  \n            END FOR  \n        END FOR  \n        SET result TO an empty list  \n        FOR each group_of_paths IN the values of content_to_paths  \n            IF the size of group_of_paths GREATER THAN one  \n                APPEND group_of_paths TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-triangle-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION triangleNumber(nums)  \n        SORT nums IN ASCENDING ORDER  \n        SET count TO zero  \n        SET n TO the LENGTH OF nums  \n        FOR k FROM n MINUS one DOWNTO two  \n            SET i TO zero  \n            SET j TO k MINUS one  \n            WHILE i LESS THAN j  \n                IF element at position i of nums PLUS element at position j of nums GREATER THAN element at position k of nums  \n                    INCREMENT count BY j MINUS i  \n                    DECREMENT j BY one  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "add-bold-tag-in-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION addBoldTag s words  \n        IF the LENGTH OF words EQUALS zero  \n            RETURN s  \n        END IF  \n\n        SET n TO the LENGTH OF s  \n        SET mask TO a list of False with LENGTH equal to n  \n\n        FOR each word IN words  \n            SET start TO zero  \n            WHILE start LESS THAN OR EQUAL TO n MINUS the LENGTH OF word  \n                SET start TO the POSITION OF the FIRST occurrence of word IN s STARTING FROM start  \n                IF start EQUALS negative one  \n                    BREAK  \n                END IF  \n                FOR i FROM start TO start PLUS the LENGTH OF word MINUS one  \n                    SET the element at position i of mask TO True  \n                END FOR  \n                INCREMENT start BY one  \n            END WHILE  \n        END FOR  \n\n        SET result TO an empty list  \n        SET i TO zero  \n        WHILE i LESS THAN n  \n            IF the element at position i of mask EQUALS True  \n                APPEND the string starting-bold-tag to result  \n                WHILE i LESS THAN n AND the element at position i of mask EQUALS True  \n                    APPEND the element at position i of s TO result  \n                    INCREMENT i BY one  \n                END WHILE  \n                APPEND the string ending-bold-tag to result  \n            ELSE  \n                APPEND the element at position i of s TO result  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n\n        RETURN the concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-distance-in-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxDistance(arrays)  \n        SET min_val TO element at position zero of element at position zero of arrays  \n        SET max_val TO element at position zero of element at position equal to the length of element at position zero of arrays MINUS one of arrays  \n        SET max_distance TO zero  \n        FOR i FROM one TO the length of arrays MINUS one  \n            SET current_array TO element at position i of arrays  \n            SET current_min TO element at position zero of current_array  \n            SET current_max TO element at position zero of current_array PLUS the length of current_array MINUS one  \n            SET max_distance TO the greatest value among max_distance AND the absolute value of current_max MINUS min_val AND the absolute value of max_val MINUS current_min  \n            IF min_val GREATER THAN current_min  \n                SET min_val TO current_min  \n            END IF  \n            IF max_val LESS THAN current_max  \n                SET max_val TO current_max  \n            END IF  \n        END FOR  \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-factorization", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestFactorization(num)  \n        IF num EQUALS one  \n            RETURN one  \n        END IF  \n        \n        SET factors TO empty list  \n        \n        FOR digit FROM nine TO two DECREMENTING BY one  \n            WHILE remainder of num DIVIDED BY digit EQUALS zero  \n                APPEND digit TO factors  \n                SET num TO integer division of num BY digit  \n            END WHILE  \n        END FOR  \n        \n        IF num NOT EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        SORT factors in ascending order  \n        \n        SET result TO number formed by concatenating each element in factors as string in order  \n        \n        IF result GREATER THAN two raised to the power of thirty one MINUS one  \n            RETURN zero  \n        END IF  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-inverse-pairs-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kInversePairs(n INTEGER, k INTEGER) RETURNS INTEGER  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE dp AS a two dimensional list of size n PLUS one BY k PLUS one WITH all elements SET TO zero  \n        SET element at position zero of list at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of list at position i MINUS one of dp  \n                IF prefix_sum IS GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                \n                IF j IS GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of list at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum IS GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                \n                SET element at position j of list at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position k of list at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION scheduleCourse(courses)  \n        SORT courses BY the second element of each course representing the last day  \n        SET max_heap TO an empty list  \n        SET current_end_day TO zero  \n        FOR each course IN courses  \n            SET duration TO the first element of course  \n            SET last_day TO the second element of course  \n            IF current_end_day PLUS duration LESS THAN OR EQUAL TO last_day THEN  \n                ADD the negative value of duration TO max_heap maintaining max-heap property  \n                INCREMENT current_end_day BY duration  \n            ELSE  \n                IF max_heap is not empty AND the negative of the element at position zero of max_heap GREATER THAN duration THEN  \n                    INCREMENT current_end_day BY duration PLUS REMOVE and return the smallest element from max_heap  \n                    ADD the negative value of duration TO max_heap maintaining max-heap property  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF max_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-range-covering-elements-from-k-lists", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestRange(nums)  \n        SET min_heap TO empty list  \n        SET max_value TO negative infinity  \n        \n        FOR index FROM zero TO the LENGTH OF nums MINUS one  \n            CALL push element at position zero of list at position index of nums index index zero TO min_heap  \n            SET max_value TO greater value BETWEEN max_value AND element at position zero of list at position index of nums  \n        END FOR  \n        \n        SET smallest_range TO positive infinity  \n        SET result TO list containing negative one hundred thousand AND positive one hundred thousand  \n        \n        WHILE min_heap is not empty  \n            CALL pop from min_heap AND ASSIGN the returned tuple TO min_value list_index element_index  \n            \n            IF max_value MINUS min_value LESS THAN smallest_range  \n                SET smallest_range TO max_value MINUS min_value  \n                SET result TO list containing min_value AND max_value  \n            END IF  \n            \n            IF element_index PLUS one LESS THAN the LENGTH OF list at position list_index of nums  \n                SET next_value TO element at position element_index PLUS one of list at position list_index of nums  \n                CALL push tuple of next_value list_index element_index PLUS one TO min_heap  \n                SET max_value TO greater value BETWEEN max_value AND next_value  \n            ELSE  \n                BREAK  \n            END IF  \n        END WHILE  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-square-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET left TO zero  \n        SET right TO the integer value of the square root of c  \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            SET current_sum TO left MULTIPLIED BY left PLUS right MULTIPLIED BY right  \n            IF current_sum EQUALS c  \n                RETURN True  \n            ELSE IF current_sum IS LESS THAN c  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "exclusive-time-of-functions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION exclusiveTime WITH PARAMETERS n logs  \n        SET exclusive_time TO a list of zero values of length n  \n        SET stack TO an empty list  \n        FOR each log IN logs  \n            SET function_id action timestamp TO the result of splitting log by the word colon  \n            CONVERT function_id TO an integer  \n            CONVERT timestamp TO an integer  \n            IF action EQUALS the word start  \n                IF stack is not empty  \n                    SET prev_function_id prev_timestamp TO the last element in stack  \n                    INCREMENT the element at position prev_function_id of exclusive_time BY timestamp MINUS prev_timestamp  \n                END IF  \n                APPEND a pair consisting of function_id and timestamp TO stack  \n            ELSE  \n                SET prev_function_id prev_timestamp TO the result of removing the last element from stack  \n                INCREMENT the element at position prev_function_id of exclusive_time BY timestamp MINUS prev_timestamp PLUS one  \n                IF stack is not empty  \n                    SET last_function_id last_timestamp TO the last element in stack  \n                    REPLACE the last element in stack WITH a pair consisting of last_function_id and timestamp PLUS one  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN exclusive_time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shopping-offers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shoppingOffers(price, special, needs)  \n        SET special TO an empty list  \n        FOR each offer IN the original special list  \n            IF the sum of elements at all positions except the last in offer IS GREATER THAN zero AND  \n               the last element of offer IS LESS THAN the sum of the product of corresponding elements of price and offer except the last element  \n                APPEND offer TO special  \n            END IF  \n        END FOR  \n        \n        FUNCTION dfs(needs)  \n            SET min_cost TO zero  \n            FOR each element at position index FROM zero TO the length of price MINUS one  \n                INCREMENT min_cost BY the element at position index of price MULTIPLIED BY the element at position index of needs  \n            END FOR  \n            \n            FOR each offer IN special  \n                SET new_needs TO an empty list  \n                FOR each index FROM zero TO the length of needs MINUS one  \n                    APPEND to new_needs the element at position index of needs MINUS the element at position index of offer  \n                END FOR  \n                \n                SET can_use_offer TO true  \n                FOR each element n IN new_needs  \n                    IF n IS LESS THAN zero  \n                        SET can_use_offer TO false  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n                \n                IF can_use_offer EQUALS true  \n                    SET possible_cost TO the last element of offer PLUS dfs(the tuple version of new_needs)  \n                    IF possible_cost IS LESS THAN min_cost  \n                        SET min_cost TO possible_cost  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dfs(the tuple version of needs)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decode-ways-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDecodings(s)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY million PLUS seven  \n        SET dp TO a list of zeroes with the length EQUAL TO the LENGTH OF s PLUS one  \n        SET the element at position zero of dp TO one\n\n        FUNCTION ways_to_decode_single(char)  \n            IF char EQUALS the character star THEN  \n                RETURN nine  \n            ELSE IF char EQUALS the character zero THEN  \n                RETURN zero  \n            ELSE  \n                RETURN one  \n            END IF  \n        END FUNCTION\n\n        FUNCTION ways_to_decode_pair(char1, char2)  \n            IF char1 EQUALS the character star AND char2 EQUALS the character star THEN  \n                RETURN fifteen  \n            ELSE IF char1 EQUALS the character star THEN  \n                IF char2 LESS THAN OR EQUAL TO the character six THEN  \n                    RETURN two  \n                ELSE  \n                    RETURN one  \n                END IF  \n            ELSE IF char2 EQUALS the character star THEN  \n                IF char1 EQUALS the character one THEN  \n                    RETURN nine  \n                ELSE IF char1 EQUALS the character two THEN  \n                    RETURN six  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            ELSE  \n                SET num TO the integer VALUE OF the concatenation of char1 PLUS char2  \n                IF num GREATER THAN OR EQUAL TO ten AND num LESS THAN OR EQUAL TO twenty six THEN  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n        END FUNCTION\n\n        FOR i FROM one TO the LENGTH OF s  \n            SET element at position i of dp TO the element at position i of dp PLUS the element at position i MINUS one of dp MULTIPLIED BY ways_to_decode_single(element at position i MINUS one of s)  \n            SET element at position i of dp TO element at position i of dp MODULO MOD\n            IF i GREATER THAN one THEN  \n                SET element at position i of dp TO element at position i of dp PLUS element at position i MINUS two of dp MULTIPLIED BY ways_to_decode_pair(element at position i MINUS two of s, element at position i MINUS one of s)  \n                SET element at position i of dp TO element at position i of dp MODULO MOD  \n            END IF  \n        END FOR  \n\n        RETURN the element at the last position of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "solve-the-equation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION solveEquation(equation)  \n        FUNCTION parse_side(side)  \n            SET tokens TO the result of replacing each plus sign in side with a special separator followed by plus sign THEN replacing each minus sign in side with a special separator followed by minus sign THEN splitting the resulting string by the special separator  \n            SET x_count TO zero  \n            SET num_sum TO zero  \n            FOR each token IN tokens  \n                IF token is empty string  \n                    CONTINUE to next iteration  \n                END IF  \n                IF token contains the character x  \n                    IF token EQUALS the character x OR token EQUALS plus sign followed by character x  \n                        INCREMENT x_count BY one  \n                    ELSE IF token EQUALS minus sign followed by character x  \n                        DECREMENT x_count BY one  \n                    ELSE  \n                        SET integer_representation TO the integer value of token after removing the character x  \n                        INCREMENT x_count BY integer_representation  \n                    END IF  \n                ELSE  \n                    SET integer_value TO the integer value of token  \n                    INCREMENT num_sum BY integer_value  \n                END IF  \n            END FOR  \n            RETURN x_count AND num_sum  \n        END FUNCTION  \n\n        SET left_side AND right_side TO the two parts of equation separated by equal sign  \n        SET left_x AND left_num TO the values returned by parse_side with left_side as argument  \n        SET right_x AND right_num TO the values returned by parse_side with right_side as argument  \n\n        SET total_x TO left_x MINUS right_x  \n        SET total_num TO right_num MINUS left_num  \n\n        IF total_x EQUALS zero  \n            IF total_num EQUALS zero  \n                RETURN the phrase Infinite solutions  \n            ELSE  \n                RETURN the phrase No solution  \n            END IF  \n        ELSE  \n            SET quotient TO total_num DIVIDED BY total_x using integer division  \n            RETURN the string concatenation of character x followed by equal sign followed by quotient  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-average-subarray-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxAverage(nums k)  \n        FUNCTION canFindAverage(mid)  \n            SET prefix_sums TO a list of zero repeated the LENGTH OF nums PLUS one times  \n            SET min_prefix_sum TO a list of zero repeated the LENGTH OF nums PLUS one times  \n            FOR i FROM zero TO the LENGTH OF nums MINUS one  \n                SET element at position i PLUS one of prefix_sums TO element at position i of prefix_sums PLUS element at position i of nums MINUS mid  \n                IF i GREATER THAN OR EQUAL TO k  \n                    SET element at position i PLUS one of min_prefix_sum TO the smaller VALUE BETWEEN element at position i of min_prefix_sum AND element at position i PLUS one MINUS k of prefix_sums  \n                ELSE  \n                    SET element at position i PLUS one of min_prefix_sum TO element at position i of min_prefix_sum  \n                END IF  \n                IF i GREATER THAN OR EQUAL TO k MINUS one AND element at position i PLUS one of prefix_sums MINUS element at position i PLUS one of min_prefix_sum GREATER THAN OR EQUAL TO zero  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        SET low TO the smallest VALUE IN nums  \n        SET high TO the greatest VALUE IN nums  \n        WHILE high MINUS low GREATER THAN zero POINT zero zero zero zero one  \n            SET mid TO low PLUS high DIVIDED BY two  \n            IF canFindAverage(mid)  \n                SET low TO mid  \n            ELSE  \n                SET high TO mid  \n            END IF  \n        END WHILE  \n        RETURN low  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-length-of-pair-chain", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLongestChain WITH parameter pairs  \n        SORT pairs IN ORDER OF the second element of each element IN pairs  \n        SET current_end TO the smallest possible value of negative infinity  \n        SET chain_length TO zero  \n        FOR each start AND end IN pairs  \n            IF start GREATER THAN current_end THEN  \n                SET current_end TO end  \n                INCREMENT chain_length BY one  \n            END IF  \n        END FOR  \n        RETURN chain_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindromic-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSubstrings(s)  \n        FUNCTION expand_around_center(left, right)  \n            SET count TO zero  \n            WHILE left GREATER THAN OR EQUAL TO zero AND right LESS THAN the LENGTH OF s AND the element at position left of s EQUALS the element at position right of s  \n                INCREMENT count BY one  \n                DECREMENT left BY one  \n                INCREMENT right BY one  \n            END WHILE  \n            RETURN count  \n        END FUNCTION  \n        \n        SET total_palindromes TO zero  \n        FOR i FROM zero TO the LENGTH OF s MINUS one  \n            INCREMENT total_palindromes BY the RESULT OF expand_around_center WITH PARAMETERS i AND i  \n            INCREMENT total_palindromes BY the RESULT OF expand_around_center WITH PARAMETERS i AND i PLUS one  \n        END FOR  \n        \n        RETURN total_palindromes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "replace-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION replaceWords WITH PARAMETERS dictionary sentence  \n        SORT dictionary BY LENGTH OF each element IN dictionary FROM smallest TO largest  \n        SET words TO the SPLIT of sentence INTO individual words  \n        \n        FUNCTION replace WITH PARAMETER word  \n            FOR each root IN dictionary  \n                IF word STARTS WITH root THEN  \n                    RETURN root  \n                END IF  \n            END FOR  \n            RETURN word  \n        END FUNCTION  \n        \n        SET replaced_words TO an EMPTY list  \n        FOR each word IN words  \n            APPEND the RESULT OF replace WITH PARAMETER word TO replaced_words  \n        END FOR  \n        \n        SET result_sentence TO the JOIN of replaced_words WITH SPACES separating elements  \n        RETURN result_sentence  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dota2-senate", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        CREATE empty queue radiant  \n        CREATE empty queue dire  \n        FOR each index i FROM zero TO the LENGTH OF senate MINUS one  \n            SET s TO element at position i of senate  \n            IF s EQUALS the character R  \n                APPEND i TO radiant  \n            ELSE  \n                APPEND i TO dire  \n            END IF  \n        END FOR  \n        WHILE radiant is not empty AND dire is not empty  \n            SET r_index TO first element removed from radiant  \n            SET d_index TO first element removed from dire  \n            IF r_index LESS THAN d_index  \n                APPEND r_index PLUS the LENGTH OF senate TO radiant  \n            ELSE  \n                APPEND d_index PLUS the LENGTH OF senate TO dire  \n            END IF  \n        END WHILE  \n        IF radiant is not empty  \n            RETURN the string Radiant  \n        ELSE  \n            RETURN the string Dire  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "2-keys-keyboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSteps(n)  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET operations TO zero  \n        SET factor TO two  \n        WHILE n GREATER THAN one  \n            WHILE element at position n MODULO factor EQUALS zero  \n                INCREMENT operations BY factor  \n                SET n TO n DIVIDED BY factor  \n            END WHILE  \n            INCREMENT factor BY one  \n        END WHILE  \n        RETURN operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-k-closest-elements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findClosestElements(arr k x)  \n        SET left TO the position found by bisecting arr with x to the left MINUS one  \n        SET right TO left PLUS one  \n        WHILE the difference between right and left MINUS one is LESS THAN k  \n            IF left EQUALS minus one OR (right is LESS THAN the LENGTH OF arr AND the absolute value of element at position right of arr MINUS x is LESS THAN the absolute value of element at position left of arr MINUS x)  \n                INCREMENT right BY one  \n            ELSE  \n                DECREMENT left BY one  \n            END IF  \n        END WHILE  \n        RETURN the list of elements from position left PLUS one TO position right MINUS one of arr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-into-consecutive-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isPossible(nums)  \n        SET num_count TO a mapping of each number in nums to the count of its occurrences  \n        SET end_with TO a mapping of each number to the count of subsequences ending with that number  \n        \n        FOR each num IN nums  \n            IF the count of num in num_count EQUALS zero  \n                CONTINUE to next iteration  \n            END IF  \n            \n            IF the count of subsequences ending with the number which is one less than num in end_with GREATER THAN zero  \n                DECREMENT the count of subsequences ending with the number which is one less than num in end_with BY one  \n                INCREMENT the count of subsequences ending with num in end_with BY one  \n            ELSE IF the count of num plus one in num_count GREATER THAN zero AND the count of num plus two in num_count GREATER THAN zero  \n                DECREMENT the count of num plus one in num_count BY one  \n                DECREMENT the count of num plus two in num_count BY one  \n                INCREMENT the count of subsequences ending with num plus two in end_with BY one  \n            ELSE  \n                RETURN false  \n            END IF  \n            \n            DECREMENT the count of num in num_count BY one  \n        END FOR  \n        \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strange-printer", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION strangePrinter(s)  \n        FUNCTION dp(i, j, memo)  \n            IF i GREATER THAN j THEN  \n                RETURN zero  \n            END IF  \n            IF the tuple of i and j EXISTS IN memo THEN  \n                RETURN the value ASSOCIATED WITH the tuple of i and j IN memo  \n            END IF  \n            SET result TO the value RETURNED BY dp WITH parameters i AND j MINUS one AND memo PLUS one  \n            FOR each k FROM i TO j MINUS one  \n                IF the character at position k of s EQUALS the character at position j of s THEN  \n                    SET candidate TO the value RETURNED BY dp WITH parameters i AND k MINUS one AND memo PLUS the value RETURNED BY dp WITH parameters k AND j MINUS one AND memo  \n                    IF candidate LESS THAN result THEN  \n                        SET result TO candidate  \n                    END IF  \n                END IF  \n            END FOR  \n            ASSIGN result TO the tuple of i and j IN memo  \n            RETURN result  \n        END FUNCTION  \n        RETURN the value RETURNED BY dp WITH parameters zero AND the length of s MINUS one AND an empty dictionary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR index i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "path-sum-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pathSum(nums)  \n        SET tree TO an empty collection of key value pairs  \n        FOR each num IN nums  \n            SET depth TO the integer division of num BY one hundred  \n            SET pos TO the integer division of num BY ten MODULO ten  \n            SET value TO num MODULO ten  \n            ASSIGN value TO the element at key composed of depth and pos IN tree  \n        END FOR  \n        \n        FUNCTION dfs(depth, pos, path_sum)  \n            SET current_value TO the element at key composed of depth and pos IN tree  \n            IF current_value EQUALS nothing  \n                RETURN zero  \n            END IF  \n            SET new_path_sum TO path_sum PLUS current_value  \n            SET left_child TO a pair composed of depth PLUS one and pos MULTIPLIED BY two MINUS one  \n            SET right_child TO a pair composed of depth PLUS one and pos MULTIPLIED BY two  \n            IF the element at key left_child IN tree EQUALS nothing AND the element at key right_child IN tree EQUALS nothing  \n                RETURN new_path_sum  \n            END IF  \n            SET left_sum TO the result of calling dfs WITH the first element of left_child the second element of left_child and new_path_sum  \n            SET right_sum TO the result of calling dfs WITH the first element of right_child the second element of right_child and new_path_sum  \n            RETURN left_sum PLUS right_sum  \n        END FUNCTION  \n        \n        RETURN the result of calling dfs WITH one one and zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-number-in-multiplication-table", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findKthNumber(m n k)  \n        FUNCTION enough(x)  \n            SET count TO zero  \n            FOR i FROM one TO m  \n                IF x DIVIDED BY i LESS THAN n  \n                    INCREMENT count BY x DIVIDED BY i  \n                ELSE  \n                    INCREMENT count BY n  \n                END IF  \n            END FOR  \n            IF count GREATER THAN OR EQUAL TO k  \n                RETURN true  \n            ELSE  \n                RETURN false  \n            END IF  \n        END FUNCTION  \n\n        SET low TO one  \n        SET high TO m MULTIPLIED BY n  \n        WHILE low LESS THAN high  \n            SET mid TO low PLUS high DIVIDED BY two  \n            IF enough(mid)  \n                SET high TO mid  \n            ELSE  \n                SET low TO mid PLUS one  \n            END IF  \n        END WHILE  \n        RETURN low  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-swap", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumSwap(num)  \n        SET digits TO list of characters representing num converted to string form  \n        SET last TO an empty dictionary mapping digit values TO their last position index in digits  \n        FOR each index i AND digit_char d IN digits with their indices  \n            SET digit_value TO integer value of digit_char d  \n            SET last at key digit_value TO i  \n        END FOR  \n        FOR each index i AND digit_char d IN digits with their indices  \n            SET current_digit TO integer value of digit_char d  \n            FOR possible_digit d2 FROM nine DOWN TO current_digit PLUS one BY negative one step  \n                IF last at key d2 EXISTS AND last at key d2 GREATER THAN i  \n                    SET swap_position TO last at key d2  \n                    SET temp TO element at position i of digits  \n                    SET element at position i of digits TO element at position swap_position of digits  \n                    SET element at position swap_position of digits TO temp  \n                    RETURN integer value of string formed by concatenating elements of digits in order  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN num  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulb-switcher-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION flipLights(n presses)  \n        SET n TO the minimum OF n AND six  \n        IF presses EQUALS zero  \n            RETURN one  \n        END IF  \n        IF n EQUALS one  \n            RETURN two  \n        END IF  \n        IF n EQUALS two  \n            IF presses EQUALS one  \n                RETURN three  \n            ELSE  \n                RETURN four  \n            END IF  \n        END IF  \n        IF presses EQUALS one  \n            RETURN four  \n        END IF  \n        IF presses EQUALS two  \n            RETURN seven  \n        END IF  \n        RETURN eight  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-longest-increasing-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findNumberOfLIS(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF nums  \n        SET lengths TO a list of value one REPEATED n times  \n        SET counts TO a list of value one REPEATED n times  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF the element at position i of nums GREATER THAN the element at position j of nums THEN  \n                    IF the element at position j of lengths PLUS one GREATER THAN the element at position i of lengths THEN  \n                        SET the element at position i of lengths TO the element at position j of lengths PLUS one  \n                        SET the element at position i of counts TO the element at position j of counts  \n                    ELSE IF the element at position j of lengths PLUS one EQUALS the element at position i of lengths THEN  \n                        SET the element at position i of counts TO the element at position i of counts PLUS the element at position j of counts  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET longest TO the maximum value IN lengths  \n        SET result TO zero  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of lengths EQUALS longest THEN  \n                INCREMENT result BY the element at position i of counts  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cut-off-trees-for-golf-event", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION cutOffTree(forest)  \n        IF forest EQUALS empty OR element at position zero of forest EQUALS empty  \n            RETURN negative one  \n        END IF  \n\n        SET trees TO an empty list  \n        FOR index i FROM zero TO the LENGTH OF forest MINUS one  \n            FOR index j FROM zero TO the LENGTH OF element at position i of forest MINUS one  \n                IF element at position i of forest at position j GREATER THAN one  \n                    APPEND a tuple of element at position i of forest at position j AND i AND j TO trees  \n                END IF  \n            END FOR  \n        END FOR  \n        SORT trees IN ascending order BY the first element of each tuple  \n\n        FUNCTION bfs(start, end)  \n            IF start EQUALS end  \n                RETURN zero  \n            END IF  \n            SET m TO the LENGTH OF forest  \n            SET n TO the LENGTH OF element at position zero of forest  \n            SET queue TO a deque initialized with start  \n            SET visited TO a set initialized with start  \n            SET steps TO zero  \n\n            WHILE queue is not empty  \n                SET current_queue_length TO the LENGTH OF queue  \n                FOR index from zero TO current_queue_length MINUS one  \n                    REMOVE the first element FROM queue AND ASSIGN it TO x AND y  \n                    FOR each pair dx AND dy IN the list of pairs minus one zero AND plus one zero AND zero minus one AND zero plus one  \n                        SET nx TO x PLUS dx  \n                        SET ny TO y PLUS dy  \n                        IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n  \n                            AND the pair nx AND ny IS NOT IN visited  \n                            AND element at position nx of forest at position ny NOT EQUALS zero  \n                                IF the pair nx AND ny EQUALS end  \n                                    RETURN steps PLUS one  \n                                END IF  \n                                ADD the pair nx AND ny TO visited  \n                                APPEND the pair nx AND ny TO queue  \n                            END IF  \n                        END IF  \n                    END FOR  \n                END FOR  \n                INCREMENT steps BY one  \n            END WHILE  \n\n            RETURN negative one  \n        END FUNCTION  \n\n        SET x TO zero  \n        SET y TO zero  \n        SET total_steps TO zero  \n\n        FOR each tuple height AND tx AND ty IN trees  \n            SET steps TO bfs with parameters the pair x AND y AND the pair tx AND ty  \n            IF steps EQUALS negative one  \n                RETURN negative one  \n            END IF  \n            INCREMENT total_steps BY steps  \n            SET x TO tx  \n            SET y TO ty  \n        END FOR  \n\n        RETURN total_steps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-parenthesis-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkValidString(s)  \n        SET low TO zero  \n        SET high TO zero  \n        FOR each char IN s  \n            IF char EQUALS the character representing an open parenthesis  \n                INCREMENT low BY one  \n                INCREMENT high BY one  \n            ELSE IF char EQUALS the character representing a closing parenthesis  \n                DECREMENT low BY one  \n                DECREMENT high BY one  \n            ELSE  \n                DECREMENT low BY one  \n                INCREMENT high BY one  \n            END IF  \n            IF high LESS THAN zero  \n                RETURN false  \n            END IF  \n            IF low LESS THAN zero  \n                SET low TO zero  \n            END IF  \n        END FOR  \n        RETURN the result of checking if low EQUALS zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "24-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION judgePoint24(cards)  \n        FUNCTION solve(nums)  \n            IF the LENGTH OF nums EQUALS one  \n                RETURN the ABSOLUTE VALUE OF the ELEMENT at position zero of nums MINUS twenty four LESS THAN one divided BY ten to the power of six  \n            END IF  \n            \n            FOR i FROM zero TO the LENGTH OF nums MINUS one  \n                FOR j FROM zero TO the LENGTH OF nums MINUS one  \n                    IF i NOT EQUALS j  \n                        SET new_nums TO an EMPTY list  \n                        FOR k FROM zero TO the LENGTH OF nums MINUS one  \n                            IF k NOT EQUALS i AND k NOT EQUALS j  \n                                APPEND the ELEMENT at position k of nums TO new_nums  \n                            END IF  \n                        END FOR  \n                        \n                        FOR each operation IN the list of division operation and multiplication operation and addition operation and subtraction operation  \n                            IF operation IS addition operation OR operation IS multiplication operation THEN  \n                                IF j GREATER THAN i THEN  \n                                    CONTINUE to next operation  \n                                END IF  \n                            END IF  \n                            \n                            IF operation IS NOT division operation OR the ELEMENT at position j of nums NOT EQUALS zero THEN  \n                                APPEND the RESULT of APPLYING operation TO the ELEMENT at position i of nums AND the ELEMENT at position j of nums TO new_nums  \n                                IF solve(new_nums) RETURNS true THEN  \n                                    RETURN true  \n                                END IF  \n                                REMOVE the LAST element FROM new_nums  \n                            END IF  \n                        END FOR  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN solve(cards)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-empty-slots", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kEmptySlots(bulbs, k)  \n        SET bloom_days TO an empty list  \n        FOR each day AND position IN enumeration of bulbs starting from one  \n            SET i TO the position where position SHOULD BE INSERTED INTO bloom_days TO MAINTAIN SORT ORDER  \n            IF i GREATER THAN zero AND position MINUS the element at position i MINUS one of bloom_days MINUS one EQUALS k  \n                RETURN day  \n            END IF  \n            IF i LESS THAN the LENGTH OF bloom_days AND the element at position i of bloom_days MINUS position MINUS one EQUALS k  \n                RETURN day  \n            END IF  \n            INSERT position INTO bloom_days AT position i  \n        END FOR  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "redundant-connection", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO a list of integers starting from zero incremented by one until size MINUS one  \n        SET self.rank TO a list where the integer one is repeated size times  \n    END FUNCTION  \n  \n    FUNCTION find(self, p)  \n        IF the element at position p of self.parent NOT EQUALS p  \n            SET the element at position p of self.parent TO the result of calling self.find with the element at position p of self.parent  \n        END IF  \n        RETURN the element at position p of self.parent  \n    END FUNCTION  \n  \n    FUNCTION union(self, p, q)  \n        SET rootP TO the result of calling self.find with p  \n        SET rootQ TO the result of calling self.find with q  \n        IF rootP EQUALS rootQ  \n            RETURN false  \n        END IF  \n        IF the element at position rootP of self.rank GREATER THAN the element at position rootQ of self.rank  \n            SET the element at position rootQ of self.parent TO rootP  \n        ELSE IF the element at position rootP of self.rank LESS THAN the element at position rootQ of self.rank  \n            SET the element at position rootP of self.parent TO rootQ  \n        ELSE  \n            SET the element at position rootQ of self.parent TO rootP  \n            INCREMENT the element at position rootP of self.rank BY one  \n        END IF  \n        RETURN true  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION findRedundantConnection(self, edges)  \n        SET uf TO a new instance of UnionFind initialized with the LENGTH OF edges PLUS one  \n        FOR each pair u and v IN edges  \n            IF the result of calling uf.union with u and v NOT EQUALS true  \n                RETURN a list containing u followed by v  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "repeated-string-match", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a, b)  \n        SET minimum repetitions TO the ceiling of the length of b DIVIDED BY the length of a  \n        IF the string b is contained within the concatenation of the string a repeated minimum repetitions times  \n            RETURN minimum repetitions  \n        END IF  \n        IF the string b is contained within the concatenation of the string a repeated the sum of minimum repetitions PLUS one times  \n            RETURN the sum of minimum repetitions PLUS one  \n        END IF  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "knight-probability-in-chessboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION knightProbability(n k row column)  \n        SET moves TO list of pairs of integers representing possible knight moves with first element MINUS two MINUS one second element MINUS two PLUS one third element MINUS one MINUS two fourth element MINUS one PLUS two fifth element PLUS one MINUS two sixth element PLUS one PLUS two seventh element PLUS two MINUS one eighth element PLUS two PLUS one  \n        \n        SET dp TO two dimensional list with dimensions n by n filled with zero  \n        SET element at position row and position column of dp TO one  \n        \n        FOR each iteration FROM one TO k  \n            SET new_dp TO two dimensional list with dimensions n by n filled with zero  \n            \n            FOR each r FROM zero TO n MINUS one  \n                FOR each c FROM zero TO n MINUS one  \n                    IF element at position r and position c of dp EQUALS zero  \n                        CONTINUE to next iteration of inner loop  \n                    END IF  \n                    FOR each pair dr dc IN moves  \n                        SET nr TO r PLUS dr  \n                        SET nc TO c PLUS dc  \n                        IF nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN n AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN n  \n                            SET element at position nr and position nc of new_dp TO element at position nr and position nc of new_dp PLUS element at position r and position c of dp DIVIDED BY eight  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n            \n            SET dp TO new_dp  \n        END FOR  \n        \n        SET total_probability TO zero  \n        FOR each row_list IN dp  \n            FOR each value IN row_list  \n                INCREMENT total_probability BY value  \n            END FOR  \n        END FOR  \n        RETURN total_probability  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stickers-to-spell-word", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minStickers WITH PARAMETERS stickers AND target  \n        SET stickers TO a list formed by converting each sticker in stickers to a mapping of characters to their counts  \n        SORT stickers BY the negation of the maximum count among character counts in each sticker  \n        SET queue TO a double-ended queue containing a single pair consisting of the target and zero representing used stickers  \n        SET memo TO a mapping from target to zero representing the minimum number of stickers for each target state  \n        WHILE queue is not empty  \n            REMOVE and ASSIGN the first element of queue to current_target AND used_stickers  \n            FOR each sticker IN stickers  \n                IF the character at the first position of current_target is NOT PRESENT in the keys of sticker  \n                    CONTINUE to the next iteration of the loop  \n                END IF  \n                SET remaining TO a mapping formed by assigning the counts of characters in current_target and DECREMENT those counts by the counts in sticker  \n                SET new_target TO the string formed by concatenating the characters obtained by sorting all characters in remaining according to their counts expanded as individual elements  \n                IF the LENGTH OF new_target EQUALS zero  \n                    RETURN used_stickers PLUS one  \n                END IF  \n                IF new_target is NOT PRESENT as a key in memo  \n                    SET memo at new_target TO used_stickers PLUS one  \n                    APPEND the pair consisting of new_target AND used_stickers PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "top-k-frequent-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION topKFrequent(words AS List OF string, k AS integer) RETURNS List OF string  \n        SET count TO the result of counting frequencies of each word in words  \n        SET heap TO an empty list  \n        FOR each word AND frequency IN the items of count  \n            APPEND a tuple consisting of the negation of frequency AND the word TO heap  \n        END FOR  \n        TRANSFORM heap INTO a heap structure organizing elements by the first then second element in ascending order  \n        SET result TO an empty list  \n        FOR index FROM one TO k  \n            REMOVE the smallest element from heap AND APPEND the word part of that element TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands(grid)  \n        FUNCTION dfs(i, j, direction)  \n            IF i GREATER THAN OR EQUAL TO zero AND i LESS THAN the LENGTH OF grid AND j GREATER THAN OR EQUAL TO zero AND j LESS THAN the LENGTH OF element at position zero of grid AND element at position i of grid at position j EQUALS one  \n                SET element at position i of grid at position j TO zero  \n                APPEND direction TO path  \n                CALL dfs WITH parameters i PLUS one j direction as down  \n                CALL dfs WITH parameters i MINUS one j direction as up  \n                CALL dfs WITH parameters i j PLUS one direction as right  \n                CALL dfs WITH parameters i j MINUS one direction as left  \n                APPEND direction as backtrack TO path  \n            END IF  \n            RETURN path  \n        END FUNCTION  \n        \n        SET unique_islands TO empty set  \n        \n        FOR i FROM zero TO LENGTH OF grid MINUS one  \n            FOR j FROM zero TO LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET path TO empty list  \n                    ADD the tuple CONSTRUCTED FROM CALLING dfs WITH parameters i j origin TO unique_islands  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN the LENGTH OF unique_islands  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-area-of-island", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxAreaOfIsland(grid)  \n        IF grid EQUALS an empty collection THEN  \n            RETURN zero  \n        END IF  \n        \n        SET max_area TO zero  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dfs(r, c)  \n            IF r LESS THAN zero OR r GREATER THAN OR EQUAL TO rows OR c LESS THAN zero OR c GREATER THAN OR EQUAL TO cols OR element at position r of grid at position c EQUALS zero THEN  \n                RETURN zero  \n            END IF  \n            SET element at position r of grid at position c TO zero  \n            SET area TO one  \n            INCREMENT area BY dfs(r PLUS one, c)  \n            INCREMENT area BY dfs(r MINUS one, c)  \n            INCREMENT area BY dfs(r, c PLUS one)  \n            INCREMENT area BY dfs(r, c MINUS one)  \n            RETURN area  \n        END FUNCTION  \n        \n        FOR r FROM zero TO rows MINUS one  \n            FOR c FROM zero TO cols MINUS one  \n                IF element at position r of grid at position c EQUALS one THEN  \n                    SET max_area TO the GREATER VALUE OF max_area AND dfs(r, c)  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-to-k-equal-sum-subsets", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canPartitionKSubsets(nums k)  \n        SET total_sum TO zero  \n        FOR each number IN nums  \n            INCREMENT total_sum BY number  \n        END FOR  \n\n        IF total_sum MODULO k NOT EQUALS zero  \n            RETURN false  \n        END IF  \n\n        SET target TO total_sum DIVIDED BY k  \n\n        SORT nums IN DESCENDING ORDER  \n\n        FUNCTION can_partition(index k current_sum used)  \n            IF k EQUALS zero  \n                RETURN true  \n            END IF  \n\n            IF current_sum EQUALS target  \n                RETURN can_partition WITH PARAMETERS zero k MINUS one zero used  \n            END IF  \n\n            FOR i FROM index TO LENGTH OF nums MINUS one  \n                IF element at position i of used EQUALS false AND current_sum PLUS element at position i of nums LESS THAN OR EQUAL TO target  \n                    SET element at position i of used TO true  \n                    IF can_partition WITH PARAMETERS i PLUS one k current_sum PLUS element at position i of nums used  \n                        RETURN true  \n                    END IF  \n                    SET element at position i of used TO false  \n                END IF  \n            END FOR  \n\n            RETURN false  \n        END FUNCTION  \n\n        SET used TO list OF false WITH THE LENGTH OF nums  \n\n        RETURN can_partition WITH PARAMETERS zero k zero used  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "falling-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fallingSquares(positions)  \n        SET max_heights TO empty list  \n        SET intervals TO empty list  \n        SET current_max_height TO zero  \n        FOR each pair left AND side_length IN positions  \n            SET right TO left PLUS side_length MINUS one  \n            SET height TO side_length  \n            FOR each triple interval_left interval_right interval_height IN intervals  \n                IF left LESS THAN OR EQUAL TO interval_right AND right GREATER THAN OR EQUAL TO interval_left  \n                    IF side_length PLUS interval_height GREATER THAN height  \n                        SET height TO side_length PLUS interval_height  \n                    END IF  \n                END IF  \n            END FOR  \n            APPEND the triple left right height TO intervals  \n            IF height GREATER THAN current_max_height  \n                SET current_max_height TO height  \n            END IF  \n            APPEND current_max_height TO max_heights  \n        END FOR  \n        RETURN max_heights  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1 s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        SET dp TO a two dimensional list of zeros with the number of rows equal to m PLUS one and the number of columns equal to n PLUS one  \n        FOR j FROM one TO n  \n            SET element at position zero ROW and position j COLUMN of dp TO element at position zero ROW and position j MINUS one COLUMN of dp PLUS the ASCII value of the character at position j MINUS one in s2  \n        END FOR  \n        FOR i FROM one TO m  \n            SET element at position i ROW and position zero COLUMN of dp TO element at position i MINUS one ROW and position zero COLUMN of dp PLUS the ASCII value of the character at position i MINUS one in s1  \n        END FOR  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF the character at position i MINUS one in s1 EQUALS the character at position j MINUS one in s2 THEN  \n                    SET element at position i ROW and position j COLUMN of dp TO element at position i MINUS one ROW and position j MINUS one COLUMN of dp  \n                ELSE  \n                    SET element at position i ROW and position j COLUMN of dp TO the minimum BETWEEN element at position i MINUS one ROW and position j COLUMN of dp PLUS the ASCII value of the character at position i MINUS one in s1 AND element at position i ROW and position j MINUS one COLUMN of dp PLUS the ASCII value of the character at position j MINUS one in s2  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position m ROW and position n COLUMN of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subarray-product-less-than-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSubarrayProductLessThanK(nums parameter, k parameter) RETURNS integer  \n        IF k LESS THAN OR EQUAL TO one THEN  \n            RETURN zero  \n        END IF  \n        \n        SET product TO one  \n        SET left TO zero  \n        SET count TO zero  \n        \n        FOR right FROM zero TO the LENGTH OF nums MINUS one  \n            SET product TO product MULTIPLIED BY element at position right of nums  \n            \n            WHILE product GREATER THAN OR EQUAL TO k AND left LESS THAN OR EQUAL TO right  \n                SET product TO product DIVIDED BY element at position left of nums  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            INCREMENT count BY right MINUS left PLUS one  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-time-to-buy-and-sell-stock-with-transaction-fee", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfit(prices parameter OF TYPE List OF integers fee parameter OF TYPE integer) RETURNS integer  \n        SET cash TO zero  \n        SET hold TO negative infinity  \n        FOR each price IN prices  \n            SET cash TO the maximum value BETWEEN cash AND hold PLUS price MINUS fee  \n            SET hold TO the maximum value BETWEEN hold AND cash MINUS price  \n        END FOR  \n        RETURN cash  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-length-of-repeated-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findLength(nums1 nums2)  \n        SET dp TO a two dimensional collection of zeros with the count of the length of nums1 PLUS one by the length of nums2 PLUS one  \n        SET max_length TO zero  \n        FOR i FROM one TO the length of nums1  \n            FOR j FROM one TO the length of nums2  \n                IF element at position i MINUS one of nums1 EQUALS element at position j MINUS one of nums2  \n                    SET element at position i position j of dp TO element at position i MINUS one position j MINUS one of dp PLUS one  \n                    IF max_length LESS THAN element at position i position j of dp  \n                        SET max_length TO element at position i position j of dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-k-th-smallest-pair-distance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestDistancePair(nums k)  \n        SORT the list nums in ascending order  \n        SET n TO the LENGTH OF the list nums  \n        \n        FUNCTION count(mid)  \n            SET count TO zero  \n            SET left TO zero  \n            FOR each right FROM zero TO n MINUS one  \n                WHILE the element at position right of the list nums MINUS the element at position left of the list nums GREATER THAN mid  \n                    INCREMENT left BY one  \n                END WHILE  \n                INCREMENT count BY right MINUS left  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO the element at the last position of the list nums MINUS the element at the first position of the list nums  \n        WHILE left LESS THAN right  \n            SET mid TO the sum of left AND right DIVIDED BY two with integer division  \n            IF the result of count with mid AS argument LESS THAN k  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN alphabetical ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO the empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from the first character TO the character before the last character IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "accounts-merge", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self root TO a list containing each integer from zero to size MINUS one  \n        SET self rank TO a list containing size times the integer one  \n    END FUNCTION  \n  \n    FUNCTION find(self, x)  \n        IF element at position x of self root EQUALS x  \n            RETURN x  \n        END IF  \n        SET element at position x of self root TO the result of calling self find with argument element at position x of self root  \n        RETURN element at position x of self root  \n    END FUNCTION  \n  \n    FUNCTION union(self, x, y)  \n        SET rootX TO result of calling self find with argument x  \n        SET rootY TO result of calling self find with argument y  \n        IF rootX NOT EQUALS rootY  \n            IF element at position rootX of self rank GREATER THAN element at position rootY of self rank  \n                SET element at position rootY of self root TO rootX  \n            ELSE IF element at position rootX of self rank LESS THAN element at position rootY of self rank  \n                SET element at position rootX of self root TO rootY  \n            ELSE  \n                SET element at position rootY of self root TO rootX  \n                INCREMENT element at position rootX of self rank BY one  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION accountsMerge(self, accounts)  \n        SET email_to_id TO an empty dictionary  \n        SET uf TO a new instance of UnionFind initialized with the length of accounts  \n  \n        FOR index FROM zero TO length of accounts MINUS one  \n            SET the tuple with first element ignored and second element captured as emails TO element at position index of accounts  \n            FOR each email IN emails  \n                IF email NOT IN email_to_id  \n                    ASSIGN email_to_id at email TO index  \n                ELSE  \n                    CALL uf union with arguments index and value at key email of email_to_id  \n                END IF  \n            END FOR  \n        END FOR  \n  \n        SET merged_emails TO an empty dictionary with default value as a list  \n  \n        FOR each email and account_id IN items of email_to_id  \n            SET root_id TO result of calling uf find with argument account_id  \n            APPEND email TO list at key root_id of merged_emails  \n        END FOR  \n  \n        SET result TO an empty list  \n  \n        FOR each account_id and emails IN items of merged_emails  \n            SET name TO element at position zero of element at position account_id of accounts  \n            SET sorted_emails TO emails sorted in ascending order  \n            APPEND a list constructed by concatenating name and sorted_emails TO result  \n        END FOR  \n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-comments", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION removeComments(source)  \n        SET in_block_comment TO false  \n        SET result TO empty list  \n        SET current_line TO empty list  \n\n        FOR each line IN source  \n            SET i TO zero  \n            WHILE i IS LESS THAN the LENGTH OF line  \n                IF in_block_comment IS true  \n                    IF the element at position i AND the element at position i PLUS one of line EQUALS character slash FOLLOWED BY character star  \n                        SET in_block_comment TO false  \n                        INCREMENT i BY one  \n                    END IF  \n                ELSE  \n                    IF the element at position i AND the element at position i PLUS one of line EQUALS character slash FOLLOWED BY character slash  \n                        BREAK the current WHILE loop  \n                    ELSE IF the element at position i AND the element at position i PLUS one of line EQUALS character slash FOLLOWED BY character star  \n                        SET in_block_comment TO true  \n                        INCREMENT i BY one  \n                    ELSE  \n                        APPEND the element at position i of line TO current_line  \n                    END IF  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n\n            IF current_line IS NOT empty AND in_block_comment IS false  \n                APPEND the concatenation of elements in current_line TO result  \n                SET current_line TO empty list  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-atoms", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countOfAtoms(formula)  \n        FUNCTION parse(segment)  \n            SET atom_count TO a new map that returns zero for missing keys  \n            SET elements TO all pairs of an element starting with a capital letter followed by zero or more lowercase letters AND a following number or empty string found in segment  \n            FOR each element AND count IN elements  \n                IF count IS NOT an empty string  \n                    INCREMENT atom_count at element BY the integer value of count  \n                ELSE  \n                    INCREMENT atom_count at element BY one  \n                END IF  \n            END FOR  \n            RETURN atom_count  \n        END FUNCTION  \n        \n        FUNCTION multiply_counts(counts, multiplier)  \n            FOR each element IN counts  \n                SET counts at element TO counts at element MULTIPLIED BY multiplier  \n            END FOR  \n            RETURN counts  \n        END FUNCTION  \n        \n        SET stack TO a list containing one new map that returns zero for missing keys  \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF formula  \n            IF the element at position i of formula EQUALS an opening parenthesis  \n                APPEND a new map that returns zero for missing keys TO stack  \n                INCREMENT i BY one  \n            ELSE IF the element at position i of formula EQUALS a closing parenthesis  \n                SET segment_count TO a new map that returns zero for missing keys  \n                SET j TO i PLUS one  \n                WHILE j LESS THAN the LENGTH OF formula AND the element at position j of formula IS a digit  \n                    INCREMENT j BY one  \n                END WHILE  \n                IF j GREATER THAN i PLUS one  \n                    SET multiplier TO the integer value of the substring from position i PLUS one TO position j of formula  \n                ELSE  \n                    SET multiplier TO one  \n                END IF  \n                SET segment_count TO multiply_counts(the last element popped from stack, multiplier)  \n                FOR each element IN segment_count  \n                    INCREMENT the last element of stack at element BY segment_count at element  \n                END FOR  \n                SET i TO j  \n            ELSE  \n                SET j TO i PLUS one  \n                WHILE j LESS THAN the LENGTH OF formula AND (the element at position j of formula IS a lowercase letter OR the element at position j of formula IS a digit)  \n                    INCREMENT j BY one  \n                END WHILE  \n                SET segment_count TO parse(the substring from position i TO position j of formula)  \n                FOR each element IN segment_count  \n                    INCREMENT the last element of stack at element BY segment_count at element  \n                END FOR  \n                SET i TO j  \n            END IF  \n        END WHILE  \n        \n        SET final_count TO the last element popped from stack  \n        SET result TO an empty string  \n        FOR each element IN the sorted keys of final_count  \n            APPEND element TO result  \n            IF final_count at element GREATER THAN one  \n                APPEND the string representation of final_count at element TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-window-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minWindow(s1, s2)  \n        SET min_len TO a very large number  \n        SET min_start TO negative one  \n        SET len1 TO the LENGTH OF s1  \n        SET len2 TO the LENGTH OF s2  \n        \n        FOR i FROM zero TO len1 MINUS one  \n            SET j TO zero  \n            FOR k FROM i TO len1 MINUS one  \n                IF the element at position k of s1 EQUALS the element at position j of s2 THEN  \n                    INCREMENT j BY one  \n                    IF j EQUALS len2 THEN  \n                        IF the difference between k AND i PLUS one LESS THAN min_len THEN  \n                            SET min_len TO the difference between k AND i PLUS one  \n                            SET min_start TO i  \n                        END IF  \n                        BREAK  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF min_start EQUALS negative one THEN  \n            RETURN an empty string  \n        ELSE  \n            RETURN the substring of s1 from position min_start TO position min_start PLUS min_len MINUS one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-different-palindromic-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPalindromicSubsequences(s)  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        \n        SET next_occurrence TO a two dimensional list with four rows and n columns each initialized to negative one  \n        SET prev_occurrence TO a two dimensional list with four rows and n columns each initialized to negative one  \n        \n        FOR c FROM zero TO three  \n            SET char TO the character that is the letter a PLUS c positions forward in the alphabet  \n            SET last TO negative one  \n            FOR i FROM zero TO n MINUS one  \n                IF element at position i of s EQUALS char  \n                    SET last TO i  \n                END IF  \n                SET element at position c and i of prev_occurrence TO last  \n            END FOR  \n            \n            SET last TO negative one  \n            FOR i FROM n MINUS one DOWN TO zero  \n                IF element at position i of s EQUALS char  \n                    SET last TO i  \n                END IF  \n                SET element at position c and i of next_occurrence TO last  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a two dimensional list with n rows and n columns each initialized to zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i and i of dp TO one  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                FOR c FROM zero TO three  \n                    SET char TO the character that is the letter a PLUS c positions forward in the alphabet  \n                    SET left TO element at position c and i of next_occurrence  \n                    SET right TO element at position c and j of prev_occurrence  \n                    \n                    IF left GREATER THAN j OR right LESS THAN i  \n                        CONTINUE TO the next iteration of the loop  \n                    ELSE IF left EQUALS right  \n                        SET element at position i and j of dp TO the element at position i and j of dp PLUS one MODULO MOD  \n                    ELSE  \n                        SET element at position i and j of dp TO the element at position i and j of dp PLUS the element at position left PLUS one and right MINUS one of dp PLUS two MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero and n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "asteroid-collision", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION asteroidCollision(asteroids)  \n        SET stack TO empty list  \n        \n        FOR each asteroid IN asteroids  \n            WHILE the LENGTH OF stack is greater than zero AND asteroid is less than zero AND element at position the LENGTH OF stack MINUS one of stack is greater than zero  \n                IF element at position the LENGTH OF stack MINUS one of stack is less than negative asteroid  \n                    REMOVE element at position the LENGTH OF stack MINUS one of stack FROM stack  \n                    CONTINUE to the next iteration of the WHILE loop  \n                ELSE IF element at position the LENGTH OF stack MINUS one of stack EQUALS negative asteroid  \n                    REMOVE element at position the LENGTH OF stack MINUS one of stack FROM stack  \n                END IF  \n                BREAK out of the WHILE loop  \n            END WHILE  \n            IF the WHILE loop did not BREAK  \n                APPEND asteroid TO stack  \n            END IF  \n        END FOR  \n        \n        RETURN stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sentence-similarity-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION areSentencesSimilarTwo(sentence1 sentence1 TO sentence1 OF TYPE list OF strings sentence2 sentence2 TO sentence2 OF TYPE list OF strings similarPairs similarPairs TO similarPairs OF TYPE list OF list OF strings) RETURNS boolean  \n        IF the LENGTH OF sentence1 NOT EQUALS the LENGTH OF sentence2  \n            RETURN false  \n        END IF  \n\n        SET parent TO empty dictionary  \n\n        FUNCTION find(x x TO x) RETURNS x  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO find(element at position x of parent)  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n\n        FUNCTION union(x x TO x y y TO y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootY of parent TO rootX  \n            END IF  \n        END FUNCTION  \n\n        FOR each pair IN similarPairs  \n            FOR each word IN pair  \n                IF word NOT IN parent  \n                    SET element at position word of parent TO word  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each x y IN similarPairs  \n            union(x y)  \n        END FOR  \n\n        FOR each w1 w2 IN sentence1 sentence2  \n            IF w1 NOT IN parent  \n                SET element at position w1 of parent TO w1  \n            END IF  \n            IF w2 NOT IN parent  \n                SET element at position w2 of parent TO w2  \n            END IF  \n            IF find(w1) NOT EQUALS find(w2)  \n                RETURN false  \n            END IF  \n        END FOR  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "monotone-increasing-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION monotoneIncreasingDigits(n)  \n        SET digits TO list of each character in the string representation of n  \n        SET length TO the length of digits  \n        SET marker TO length  \n        FOR i FROM length MINUS one TO one stepping backwards by one  \n            IF the element at position i of digits LESS THAN the element at position i MINUS one of digits  \n                SET element at position i MINUS one of digits TO the string representation of the integer value of element at position i MINUS one of digits MINUS one  \n                SET marker TO i  \n            END IF  \n        END FOR  \n        FOR i FROM marker TO length MINUS one  \n            SET element at position i of digits TO the character representing the digit nine  \n        END FOR  \n        SET result_string TO concatenation of all elements in digits  \n        RETURN the integer value of result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "daily-temperatures", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION dailyTemperatures WITH PARAMETER temperatures  \n        SET n TO the LENGTH OF temperatures  \n        SET answer TO a list of n elements each SET TO zero  \n        SET stack TO an empty list  \n        \n        FOR i FROM zero TO n MINUS one  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND element at position i of temperatures IS GREATER THAN element at position element at position the LENGTH OF stack MINUS one MINUS one of stack of temperatures  \n                SET prev_index TO the REMOVAL of the last element FROM stack  \n                SET element at position prev_index of answer TO i MINUS prev_index  \n            END WHILE  \n            APPEND i TO stack  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-and-earn", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION deleteAndEarn(nums)  \n        SET count TO the count of each element in nums  \n        SET unique_nums TO the sorted list of distinct elements in count  \n        SET dp TO a list of zeros with the length equal to the length of unique_nums PLUS one  \n        SET element at position one of dp TO the element at position zero of unique_nums MULTIPLIED BY the count of the element at position zero of unique_nums  \n        \n        FOR index i FROM two TO the length of unique_nums PLUS one  \n            SET num TO the element at position i MINUS one of unique_nums  \n            \n            IF num EQUALS the element at position i MINUS two of unique_nums PLUS one  \n                SET element at position i of dp TO the maximum of element at position i MINUS one of dp AND the element at position i MINUS two of dp PLUS num MULTIPLIED BY the count of num  \n            ELSE  \n                SET element at position i of dp TO the element at position i MINUS one of dp PLUS num MULTIPLIED BY the count of num  \n            END IF  \n        END FOR  \n        \n        RETURN the element at the last position of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "network-delay-time", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION networkDelayTime(times PARAMETER, n PARAMETER, k PARAMETER)  \n        SET graph TO an empty mapping from integers to lists  \n        FOR index FROM one TO n  \n            SET element at position index of graph TO an empty list  \n        END FOR  \n        FOR each triple u v w IN times  \n            APPEND the pair of v AND w TO the list assigned to element at position u of graph  \n        END FOR  \n        SET dist TO an empty mapping from integers to values  \n        FOR index FROM one TO n  \n            SET element at position index of dist TO positive infinity  \n        END FOR  \n        SET element at position k of dist TO zero  \n        SET min_heap TO a list containing a pair of zero AND k  \n        WHILE the length of min_heap is greater than zero  \n            REMOVE the element with the smallest first component FROM min_heap AND ASSIGN those two components TO current_dist AND node  \n            IF current_dist GREATER THAN element at position node of dist  \n                CONTINUE to the next iteration of the WHILE loop  \n            END IF  \n            FOR each pair neighbor AND weight IN element at position node of graph  \n                SET distance TO current_dist PLUS weight  \n                IF distance LESS THAN element at position neighbor of dist  \n                    SET element at position neighbor of dist TO distance  \n                    ADD the pair of distance AND neighbor TO min_heap maintaining heap property  \n                END IF  \n            END FOR  \n        END WHILE  \n        SET max_time TO the maximum value among all values in dist  \n        IF max_time NOT EQUALS positive infinity  \n            RETURN max_time  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "contain-virus", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION containVirus(isInfected)  \n        FUNCTION neighbors(r, c)  \n            RETURN list consisting of pairs where first pair is r PLUS one and c  \n            second pair is r MINUS one and c  \n            third pair is r and c PLUS one  \n            fourth pair is r and c MINUS one  \n        END FUNCTION  \n\n        FUNCTION bfs(r, c)  \n            SET infected TO empty set  \n            SET threatened TO empty set  \n            SET queue TO deque containing pair r and c  \n            SET visited TO set containing pair r and c  \n            WHILE queue is not empty  \n                REMOVE first element from queue and ASSIGN to x and y  \n                ADD pair x and y TO infected  \n                FOR each pair nx and ny IN neighbors of x and y  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND pair nx and ny NOT IN visited  \n                        ADD pair nx and ny TO visited  \n                        IF element at position nx of isInfected at position ny EQUALS one  \n                            APPEND pair nx and ny TO queue  \n                        ELSE IF element at position nx of isInfected at position ny EQUALS zero  \n                            ADD pair nx and ny TO threatened  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            RETURN infected and threatened  \n        END FUNCTION  \n\n        FUNCTION build_walls(infected)  \n            SET walls TO zero  \n            FOR each pair x and y IN infected  \n                FOR each pair nx and ny IN neighbors of x and y  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx of isInfected at position ny EQUALS zero  \n                        INCREMENT walls BY one  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN walls  \n        END FUNCTION  \n\n        FUNCTION spread_virus(threatened)  \n            FOR each pair x and y IN threatened  \n                SET element at position x of isInfected at position y TO one  \n            END FOR  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF isInfected  \n        SET n TO the LENGTH OF element at position zero of isInfected  \n        SET total_walls TO zero  \n\n        WHILE true  \n            SET regions TO empty list  \n            SET visited TO empty set  \n            FOR r FROM zero TO m MINUS one  \n                FOR c FROM zero TO n MINUS one  \n                    IF element at position r of isInfected at position c EQUALS one AND pair r and c NOT IN visited  \n                        CALL bfs with r and c AND ASSIGN result TO infected and threatened  \n                        APPEND pair infected and threatened TO regions  \n                        SET visited TO union of visited and infected  \n                    END IF  \n                END FOR  \n            END FOR  \n\n            IF LENGTH OF regions EQUALS zero  \n                BREAK  \n            END IF  \n\n            SORT regions IN descending order BY the LENGTH OF their second element  \n\n            INCREMENT total_walls BY result of calling build_walls with first element of first pair in regions  \n            FOR each pair x and y IN first element of first pair in regions  \n                SET element at position x of isInfected at position y TO minus one  \n            END FOR  \n\n            FOR i FROM one TO LENGTH OF regions MINUS one  \n                CALL spread_virus with second element of pair at position i in regions  \n            END FOR  \n        END WHILE  \n\n        RETURN total_walls  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-corner-rectangles", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countCornerRectangles WITH PARAMETERS grid  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET count TO zero  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM i PLUS one TO m MINUS one  \n                SET cols_with_ones TO zero  \n                FOR k FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one AT POSITION k AND element at position j of grid EQUALS one AT POSITION k  \n                        INCREMENT cols_with_ones BY one  \n                    END IF  \n                END FOR  \n                IF cols_with_ones GREATER THAN OR EQUAL TO two  \n                    INCREMENT count BY cols_with_ones MULTIPLIED BY cols_with_ones MINUS one DIVIDED BY two  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ip-to-cidr", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION ipToCIDR(ip, n)  \n        FUNCTION ip_to_int(ip)  \n            SET parts TO list of elements obtained by converting to integer each part of ip separated by the full stop character  \n            SET res TO zero  \n            FOR each part IN parts  \n                SET res TO res MULTIPLIED BY two TO THE POWER OF eight PLUS part  \n            END FOR  \n            RETURN res  \n        END FUNCTION  \n        \n        FUNCTION int_to_ip(num)  \n            SET list_of_strings TO empty list  \n            FOR index FROM three DOWN TO zero BY negative one  \n                SET current_value TO num DIVIDED BY two TO THE POWER OF eight MULTIPLIED BY index MODULO two HUNDRED AND FIFTY SIX  \n                APPEND string representation of current_value TO list_of_strings  \n            END FOR  \n            RETURN concatenation of list_of_strings joined by the full stop character  \n        END FUNCTION  \n        \n        FUNCTION largest_cidr_size(start, n)  \n            IF bitwise AND of start AND one EQUALS one  \n                RETURN one  \n            END IF  \n            SET x TO one  \n            WHILE x LESS THAN OR EQUAL TO n AND bitwise AND of start AND x MINUS one EQUALS zero  \n                SET x TO x MULTIPLIED BY two  \n            END WHILE  \n            RETURN x DIVIDED BY two  \n        END FUNCTION  \n        \n        SET result TO empty list  \n        SET start_ip TO ip_to_int(ip)  \n        \n        WHILE n GREATER THAN zero  \n            SET size TO largest_cidr_size(start_ip, n)  \n            SET cidr_suffix_length TO thirty two MINUS bit length of size PLUS one  \n            SET cidr_string TO concatenation of int_to_ip(start_ip) PLUS forward slash character PLUS string representation of cidr_suffix_length  \n            APPEND cidr_string TO result  \n            SET start_ip TO start_ip PLUS size  \n            SET n TO n MINUS size  \n        END WHILE  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reach-a-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reachNumber(target)  \n        SET target TO the absolute value of target  \n        SET k TO zero  \n        SET sum_steps TO zero  \n        WHILE sum_steps LESS THAN target  \n            INCREMENT k BY one  \n            INCREMENT sum_steps BY k  \n        END WHILE  \n        IF the difference between sum_steps and target MODULO two EQUALS zero  \n            RETURN k  \n        ELSE  \n            IF k MODULO two EQUALS zero  \n                RETURN k PLUS one  \n            ELSE  \n                RETURN k PLUS two  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pour-water", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pourWater(heights the list of integers volume the integer k the integer) RETURNS the list of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN one AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights HOLDS  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights HOLDS  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k THEN  \n                SET element at position i of heights TO element at position i of heights PLUS one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights HOLDS  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights HOLDS  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k THEN  \n                SET element at position i of heights TO element at position i of heights PLUS one  \n                CONTINUE  \n            END IF  \n            \n            SET element at position k of heights TO element at position k of heights PLUS one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pyramid-transition-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pyramidTransition with parameters bottom AND allowed  \n        SET allowed_map TO a mapping where each key maps to a mapping that maps to a list  \n        FOR each rule IN allowed  \n            SET left TO the first element of rule  \n            SET right TO the second element of rule  \n            SET top TO the third element of rule  \n            APPEND top TO the list at allowed_map at left then at right  \n        END FOR  \n      \n        FUNCTION can_build_pyramid with parameters current_bottom AND current_top  \n            IF the LENGTH OF current_bottom EQUALS one  \n                RETURN true  \n            END IF  \n            IF the LENGTH OF current_top EQUALS the LENGTH OF current_bottom MINUS one  \n                RETURN the result of calling can_build_pyramid with parameters current_top AND empty string  \n            END IF  \n          \n            SET left TO the element at position the LENGTH OF current_top of current_bottom  \n            SET right TO the element at position the LENGTH OF current_top PLUS one of current_bottom  \n            IF left EXISTS AS A KEY in allowed_map AND right EXISTS AS A KEY in allowed_map at left  \n                FOR each top IN the list at allowed_map at left then at right  \n                    IF calling can_build_pyramid with parameters current_bottom AND the concatenation of current_top AND top RETURNS true  \n                        RETURN true  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN false  \n        END FUNCTION  \n      \n        RETURN the result of calling can_build_pyramid with parameters bottom AND empty string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "set-intersection-size-at-least-two", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION intersectionSizeTwo(intervals)  \n        SORT intervals BY the element at position one of each interval AND THEN BY the NEGATION OF the element at position zero of each interval  \n        SET first TO the element at position one of the first interval MINUS one  \n        SET second TO the element at position one of the first interval  \n        SET count TO two  \n        FOR each interval from the second interval TO the last interval as start and end  \n            IF start IS GREATER THAN second  \n                SET first TO end MINUS one  \n                SET second TO end  \n                INCREMENT count BY two  \n            ELSE IF start IS GREATER THAN first  \n                SET first TO second  \n                SET second TO end  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bold-words-in-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION boldWords(words, s)  \n        SET bold TO a list of Boolean false values with the length of s  \n        FOR each word IN words  \n            SET start TO the position in s where word first appears or negative one if not found  \n            WHILE start is NOT EQUALS to negative one  \n                FOR i FROM start TO start PLUS the length of word MINUS one  \n                    SET element at position i of bold TO true  \n                END FOR  \n                SET start TO the position in s where word appears starting from position start PLUS one or negative one if not found  \n            END WHILE  \n        END FOR  \n        SET result TO an empty list  \n        SET i TO zero  \n        WHILE i LESS THAN the length of s  \n            IF element at position i of bold EQUALS true  \n                APPEND the string b tag start TO result  \n                WHILE i LESS THAN the length of s AND element at position i of bold EQUALS true  \n                    APPEND element at position i of s TO result  \n                    INCREMENT i BY one  \n                END WHILE  \n                APPEND the string b tag end TO result  \n            ELSE  \n                APPEND element at position i of s TO result  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        RETURN the concatenation of all elements of result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "special-binary-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION makeLargestSpecial(s)  \n        FUNCTION dfs(s)  \n            SET count TO zero  \n            SET start TO zero  \n            SET specials TO empty list  \n            FOR each position i AND character char IN the enumeration of s  \n                IF character EQUALS the character one  \n                    INCREMENT count BY one  \n                ELSE  \n                    DECREMENT count BY one  \n                END IF  \n                IF count EQUALS zero  \n                    APPEND the concatenation of the character one WITH the result of calling dfs on the substring from position start PLUS one TO position i AND the character zero TO specials  \n                    SET start TO position i PLUS one  \n                END IF  \n            END FOR  \n            SORT the list specials in reverse lexicographical order  \n            RETURN the concatenation of all elements of specials  \n        END FUNCTION  \n        RETURN the result of calling dfs on s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-labels", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION partitionLabels(s)  \n        SET last_occurrence TO empty mapping from character to position  \n        FOR index FROM zero TO the LENGTH OF s MINUS one  \n            SET character TO element at position index of s  \n            SET last_occurrence at key character TO index  \n        END FOR  \n        SET start TO zero  \n        SET end TO zero  \n        SET partition_sizes TO empty list  \n        FOR index FROM zero TO the LENGTH OF s MINUS one  \n            SET character TO element at position index of s  \n            IF end LESS THAN last_occurrence at key character THEN  \n                SET end TO last_occurrence at key character  \n            END IF  \n            IF index EQUALS end THEN  \n                APPEND end MINUS start PLUS one TO partition_sizes  \n                SET start TO index PLUS one  \n            END IF  \n        END FOR  \n        RETURN partition_sizes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-plus-sign", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION orderOfLargestPlusSign(n, mines)  \n        SET mines_set TO an empty set  \n        FOR each mine IN mines  \n            ADD the tuple formed by the elements of mine TO mines_set  \n        END FOR  \n        \n        SET dp TO a list containing n elements each of which is a list containing n elements each of which is a list of four zeros representing directions right down left up  \n        \n        SET directions TO a list containing the pairs representing zero one one zero zero minus one minus one zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the pair consisting of i and j is NOT IN mines_set THEN  \n                    IF j GREATER THAN zero THEN  \n                        SET element at position zero of element at position j of element at position i of dp TO the value of element at position zero of element at position j MINUS one of element at position i of dp PLUS one  \n                    END IF  \n                    IF i GREATER THAN zero THEN  \n                        SET element at position one of element at position j of element at position i of dp TO the value of element at position one of element at position j of element at position i MINUS one of dp PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET result TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM n MINUS one DOWN TO zero  \n                IF the pair consisting of i and j is NOT IN mines_set THEN  \n                    IF j LESS THAN n MINUS one THEN  \n                        SET element at position two of element at position j of element at position i of dp TO the value of element at position two of element at position j PLUS one of element at position i of dp PLUS one  \n                    END IF  \n                    IF i LESS THAN n MINUS one THEN  \n                        SET element at position three of element at position j of element at position i of dp TO the value of element at position three of element at position j of element at position i PLUS one of dp PLUS one  \n                    END IF  \n                    SET plus_sign_order TO the minimum value among the elements of element at position j of element at position i of dp  \n                    IF plus_sign_order GREATER THAN result THEN  \n                        SET result TO plus_sign_order  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "couples-holding-hands", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSwapsCouples(row)  \n        SET position TO an empty dictionary  \n        FOR each index i FROM zero TO the LENGTH OF row MINUS one  \n            SET person TO element at position i of row  \n            SET element at key person IN position TO i  \n        END FOR  \n        SET swaps TO zero  \n        FOR each index i FROM zero TO the LENGTH OF row MINUS one STEP two  \n            SET current_person TO element at position i of row  \n            SET correct_pair TO current_person PLUS one IF current_person IS EVEN ELSE current_person MINUS one  \n            SET adjacent_person TO element at position i PLUS one of row  \n            IF adjacent_person NOT EQUALS correct_pair  \n                SET swap_idx TO the value at key correct_pair IN position  \n                SET element at position swap_idx of row TO adjacent_person  \n                SET element at position i PLUS one of row TO correct_pair  \n                SET value at key adjacent_person IN position TO swap_idx  \n                SET value at key correct_pair IN position TO i PLUS one  \n                INCREMENT swaps BY one  \n            END IF  \n        END FOR  \n        RETURN swaps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-chunks-to-make-sorted", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxChunksToSorted(arr)  \n        SET max_so_far TO zero  \n        SET chunks TO zero  \n        FOR i FROM zero TO the LENGTH OF arr MINUS one  \n            SET max_so_far TO the GREATER OF max_so_far AND element at position i of arr  \n            IF max_so_far EQUALS i  \n                INCREMENT chunks BY one  \n            END IF  \n        END FOR  \n        RETURN chunks  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "basic-calculator-iv", "passing_rate": 1.0, "pseudocode": "CLASS Term  \n    FUNCTION __init__(self, coefficient, variables)  \n        SET self.coefficient TO coefficient  \n        SET self.variables TO variables  \n    END FUNCTION  \n  \n    FUNCTION __lt__(self, other)  \n        IF the LENGTH OF self.variables NOT EQUALS the LENGTH OF other.variables THEN  \n            RETURN the LENGTH OF self.variables GREATER THAN the LENGTH OF other.variables  \n        END IF  \n        SET self_joined TO the CONCATENATION OF the ELEMENTS OF self.variables WITH each ELEMENT JOINED BY the WORD STAR  \n        SET other_joined TO the CONCATENATION OF the ELEMENTS OF other.variables WITH each ELEMENT JOINED BY the WORD STAR  \n        RETURN self_joined LESS THAN other_joined  \n    END FUNCTION  \n  \n    FUNCTION __repr__(self)  \n        IF the LENGTH OF self.variables EQUALS zero THEN  \n            RETURN the STRING REPRESENTATION OF self.coefficient  \n        END IF  \n        SET joined_vars TO the CONCATENATION OF the ELEMENTS OF self.variables WITH each ELEMENT JOINED BY the WORD STAR  \n        RETURN the STRING REPRESENTATION OF self.coefficient FOLLOWED BY the WORD STAR FOLLOWED BY joined_vars  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Expression  \n    FUNCTION __init__(self)  \n        SET self.terms TO a mapping FROM default integer value  \n    END FUNCTION  \n  \n    FUNCTION add_term(self, term)  \n        SET key TO the TUPLE OF the SORTED ELEMENTS OF term.variables  \n        INCREMENT the VALUE at key IN self.terms BY term.coefficient  \n    END FUNCTION  \n  \n    FUNCTION multiply(self, other)  \n        CREATE result AS a NEW Expression  \n        FOR each vars1 AND coeff1 IN the ITEMS OF self.terms  \n            FOR each vars2 AND coeff2 IN the ITEMS OF other.terms  \n                SET combined_vars_list TO the SORTED LIST OF the ELEMENTS OF vars1 PLUS the ELEMENTS OF vars2  \n                CREATE new_term AS a NEW Term WITH coefficient coeff1 MULTIPLIED BY coeff2 AND variables combined_vars_list  \n                CALL add_term ON result WITH new_term  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \n  \n    FUNCTION add(self, other)  \n        FOR each vars AND coeff IN the ITEMS OF other.terms  \n            CREATE new_term AS a NEW Term WITH coefficient coeff AND variables AS the LIST OF vars  \n            CALL add_term ON self WITH new_term  \n        END FOR  \n        RETURN self  \n    END FUNCTION  \n  \n    FUNCTION subtract(self, other)  \n        FOR each vars AND coeff IN the ITEMS OF other.terms  \n            CREATE new_term AS a NEW Term WITH coefficient MINUS coeff AND variables AS the LIST OF vars  \n            CALL add_term ON self WITH new_term  \n        END FOR  \n        RETURN self  \n    END FUNCTION  \n  \n    FUNCTION evaluate(self, var_map)  \n        CREATE result AS a NEW Expression  \n        FOR each vars AND coeff IN the ITEMS OF self.terms  \n            CREATE new_vars AS an EMPTY LIST  \n            FOR each var IN vars  \n                IF var IS A KEY IN var_map THEN  \n                    APPEND the STRING REPRESENTATION OF the VALUE at var IN var_map TO new_vars  \n                ELSE  \n                    APPEND var TO new_vars  \n                END IF  \n            END FOR  \n            IF the LENGTH OF new_vars EQUALS zero THEN  \n                SET new_coeff TO one  \n            ELSE  \n                SET new_coeff TO the EVALUATION OF the CONCATENATION OF the ELEMENTS OF new_vars WITH no SEPARATORS  \n            END IF  \n            CREATE new_term AS a NEW Term WITH coefficient coeff MULTIPLIED BY new_coeff AND variables AS an EMPTY LIST  \n            CALL add_term ON result WITH new_term  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \n  \n    FUNCTION simplify(self)  \n        CREATE simplified_terms AS an EMPTY LIST  \n        FOR each vars AND coeff IN the ITEMS OF self.terms  \n            IF coeff NOT EQUALS zero THEN  \n                CREATE new_term AS a NEW Term WITH coefficient coeff AND variables AS the LIST OF vars  \n                APPEND new_term TO simplified_terms  \n            END IF  \n        END FOR  \n        SORT simplified_terms USING THE __lt__ METHOD OF Term  \n        RETURN simplified_terms  \n    END FUNCTION  \n  \n    FUNCTION __repr__(self)  \n        SET simplified_list TO the CALL TO simplify METHOD OF self  \n        SET string_list TO an EMPTY LIST  \n        FOR each term IN simplified_list  \n            APPEND the RESULT OF the CALL TO __repr__ METHOD OF term TO string_list  \n        END FOR  \n        RETURN the CONCATENATION OF the ELEMENTS OF string_list WITH the STRING literal space PLUS space AS SEPARATOR  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION basicCalculatorIV(self, expression, evalvars, evalints)  \n        SET var_map TO a MAPPING FROM evalvars TO evalints BY PAIRING CORRESPONDING ELEMENTS  \n        SET tokens TO the LIST OF substrings IN expression MATCHING the PATTERN of LEFT PARENTHESIS OR RIGHT PARENTHESIS OR PLUS OR MINUS OR STAR OR one OR MORE DIGITS OR one OR MORE LETTERS  \n        SET output TO an EMPTY LIST  \n        SET operators TO an EMPTY LIST  \n  \n        FUNCTION apply_operator()  \n            SET right TO the LAST ELEMENT REMOVED FROM output  \n            SET left TO the LAST ELEMENT REMOVED FROM output  \n            SET op TO the LAST ELEMENT REMOVED FROM operators  \n            IF op EQUALS the STRING plus THEN  \n                APPEND the RESULT OF CALLING add METHOD ON left WITH right TO output  \n            ELSE IF op EQUALS the STRING minus THEN  \n                APPEND the RESULT OF CALLING subtract METHOD ON left WITH right TO output  \n            ELSE IF op EQUALS the STRING star THEN  \n                APPEND the RESULT OF CALLING multiply METHOD ON left WITH right TO output  \n            END IF  \n        END FUNCTION  \n  \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF tokens DO  \n            SET token TO the ELEMENT AT POSITION i OF tokens  \n            IF token CONTAINS only DIGITS THEN  \n                CREATE new_expression AS a NEW Expression  \n                CREATE new_term AS a NEW Term WITH coefficient THE INTEGER VALUE OF token AND variables AS an EMPTY LIST  \n                CALL add_term ON new_expression WITH new_term  \n                APPEND new_expression TO output  \n            ELSE IF token CONTAINS only LETTERS THEN  \n                CREATE new_expression AS a NEW Expression  \n                SET coef TO the VALUE at token IN var_map IF token IS A KEY IN var_map OTHERWISE one  \n                IF coef EQUALS one THEN  \n                    IF token IS NOT A KEY IN var_map THEN  \n                        CREATE new_term AS a NEW Term WITH coefficient one AND variables AS a LIST CONTAINING token  \n                    ELSE  \n                        CREATE new_term AS a NEW Term WITH coefficient one AND variables AS an EMPTY LIST  \n                    END IF  \n                ELSE  \n                    CREATE new_term AS a NEW Term WITH coefficient coef AND variables AS an EMPTY LIST  \n                END IF  \n                CALL add_term ON new_expression WITH new_term  \n                APPEND new_expression TO output  \n            ELSE IF token EQUALS the LEFT PARENTHESIS THEN  \n                APPEND token TO operators  \n            ELSE IF token EQUALS the RIGHT PARENTHESIS THEN  \n                WHILE operators IS NOT EMPTY AND the LAST ELEMENT OF operators NOT EQUALS the LEFT PARENTHESIS DO  \n                    CALL apply_operator()  \n                END WHILE  \n                REMOVE the LAST ELEMENT FROM operators  \n            ELSE IF token EQUALS the STRING plus OR token EQUALS the STRING minus OR token EQUALS the STRING star THEN  \n                WHILE operators IS NOT EMPTY AND the LAST ELEMENT OF operators NOT EQUALS the LEFT PARENTHESIS AND  \n                      (token EQUALS the STRING plus OR token EQUALS the STRING minus OR the LAST ELEMENT OF operators EQUALS the STRING star) DO  \n                    CALL apply_operator()  \n                END WHILE  \n                APPEND token TO operators  \n            END IF  \n            INCREMENT i BY one  \n        END WHILE  \n  \n        WHILE operators IS NOT EMPTY DO  \n            CALL apply_operator()  \n        END WHILE  \n  \n        SET simplified_terms TO the RESULT OF CALLING simplify METHOD ON the FIRST ELEMENT OF output  \n        CREATE result_strings AS an EMPTY LIST  \n        FOR each term IN simplified_terms  \n            IF the LENGTH OF term.variables EQUALS zero THEN  \n                APPEND the STRING REPRESENTATION OF term.coefficient TO result_strings  \n            ELSE  \n                SET joined_vars TO the CONCATENATION OF the ELEMENTS OF term.variables WITH each ELEMENT JOINED BY the WORD STAR  \n                APPEND the STRING REPRESENTATION OF term.coefficient FOLLOWED BY the WORD STAR FOLLOWED BY joined_vars TO result_strings  \n            END IF  \n        END FOR  \n        RETURN result_strings  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "basic-calculator-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION calculate WITH PARAMETER s  \n        FUNCTION helper WITH PARAMETER s  \n            SET stack TO empty list  \n            SET num TO zero  \n            SET sign TO the plus character  \n            WHILE the LENGTH OF s GREATER THAN zero holds  \n                SET char TO the element at position zero of s  \n                REMOVE the element at position zero FROM s  \n                IF char IS a digit  \n                    SET num TO num MULTIPLIED BY ten PLUS the integer value of char  \n                END IF  \n                IF char EQUALS open parenthesis character  \n                    SET num TO the result of calling helper WITH PARAMETER s  \n                END IF  \n                IF char IS one of the characters plus OR minus OR multiplication OR division OR open parenthesis OR close parenthesis OR the LENGTH OF s EQUALS zero  \n                    IF sign EQUALS the plus character  \n                        APPEND num TO stack  \n                    ELSE IF sign EQUALS the minus character  \n                        APPEND the negation of num TO stack  \n                    ELSE IF sign EQUALS the multiplication character  \n                        SET the last element of stack TO the last element of stack MULTIPLIED BY num  \n                    ELSE IF sign EQUALS the division character  \n                        SET the last element of stack TO the integer value of the last element of stack DIVIDED BY num with truncation towards zero  \n                    END IF  \n                    SET sign TO char  \n                    SET num TO zero  \n                END IF  \n                IF char EQUALS close parenthesis character  \n                    BREAK the while loop  \n                END IF  \n            END WHILE  \n            RETURN the sum of all elements in stack  \n        END FUNCTION  \n        SET s TO the list of all characters in s  \n        RETURN the result of calling helper WITH PARAMETER s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-puzzle", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION slidingPuzzle(board)  \n        SET start TO tuple of tuples where each tuple is each row of board  \n        SET target TO tuple of tuples where first tuple is one two three and second tuple is four five zero  \n        SET neighbors TO dictionary with keys zero mapping to set of one and three one mapping to set of zero two and four two mapping to set of one and five three mapping to set of zero and four four mapping to set of one three and five five mapping to set of two and four  \n        \n        FOR i FROM zero TO one  \n            FOR j FROM zero TO two  \n                IF element at position j of element at position i of start EQUALS zero  \n                    SET zero_pos TO i MULTIPLIED BY three PLUS j  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET queue TO deque containing tuple of start zero_pos and zero  \n        SET visited TO set containing start  \n        \n        WHILE queue is not empty  \n            REMOVE the leftmost element from queue and ASSIGN to state zero_pos and moves  \n            \n            IF state EQUALS target  \n                RETURN moves  \n            END IF  \n            \n            FOR each neighbor IN neighbors at zero_pos  \n                SET new_state TO list of lists converted from state  \n                SET i TO integer division of zero_pos BY three  \n                SET j TO remainder of zero_pos DIVIDED BY three  \n                SET ni TO integer division of neighbor BY three  \n                SET nj TO remainder of neighbor DIVIDED BY three  \n                \n                SET element at position j of element at position i of new_state TO element at position nj of element at position ni of new_state and element at position nj of element at position ni of new_state TO element at position j of element at position i of new_state swapped  \n                \n                SET new_tuple_state TO tuple of tuples where each tuple is each row of new_state  \n                \n                IF new_tuple_state is not an element of visited  \n                    ADD new_tuple_state TO visited  \n                    APPEND tuple of new_tuple_state neighbor moves PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-max-distance-to-gas-station", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minmaxGasDist(stations PARAMETER, k PARAMETER)  \n        FUNCTION possible(max_dist PARAMETER)  \n            SET additional_stations TO zero  \n            FOR index FROM one TO the LENGTH OF stations MINUS one  \n                INCREMENT additional_stations BY the INTEGER PART OF the DIFFERENCE BETWEEN the element at position index of stations MINUS the element at position index MINUS one of stations DIVIDED BY max_dist  \n            END FOR  \n            RETURN whether additional_stations IS LESS THAN OR EQUAL TO k  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO ten RAISED TO THE POWER OF eight  \n        WHILE the DIFFERENCE BETWEEN right AND left IS GREATER THAN one MULTIPLIED BY ten TO THE POWER OF MINUS six  \n            SET mid TO the SUM OF left AND right DIVIDED BY two  \n            IF possible(mid) IS TRUE  \n                SET right TO mid  \n            ELSE  \n                SET left TO mid  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "global-and-local-inversions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isIdealPermutation(nums)  \n        FOR each index i FROM zero TO the LENGTH OF nums MINUS one  \n            IF the ABSOLUTE VALUE OF the difference BETWEEN the element at position i of nums AND i IS GREATER THAN one  \n                RETURN False  \n            END IF  \n        END FOR  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swap-adjacent-in-lr-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start, end)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start MINUS one  \n            SET character_at_index TO element at position index of start  \n            IF character_at_index NOT EQUALS the character \"X\"  \n                APPEND the pair of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end MINUS one  \n            SET character_at_index TO element at position index of end  \n            IF character_at_index NOT EQUALS the character \"X\"  \n                APPEND the pair of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair_of_c1_i1 AND pair_of_c2_i2 IN the pairs FROM start_filtered AND end_filtered  \n            SET c1 TO the first element of pair_of_c1_i1  \n            SET i1 TO the second element of pair_of_c1_i1  \n            SET c2 TO the first element of pair_of_c2_i2  \n            SET i2 TO the second element of pair_of_c2_i2  \n            IF c1 NOT EQUALS c2  \n                RETURN false  \n            END IF  \n            IF c1 EQUALS the character \"L\" AND i1 LESS THAN i2  \n                RETURN false  \n            END IF  \n            IF c1 EQUALS the character \"R\" AND i1 GREATER THAN i2  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-symbol-in-grammar", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthGrammar(n n INTEGER, k k INTEGER) RETURNS INTEGER  \n        IF n EQUALS one THEN  \n            RETURN zero  \n        END IF  \n        SET length_of_previous_row TO two MULTIPLIED BY two RAISED TO THE POWER OF n MINUS two MINUS two  \n        IF k LESS THAN OR EQUAL TO length_of_previous_row THEN  \n            RETURN CALL kthGrammar WITH n MINUS one AND k  \n        ELSE  \n            RETURN one MINUS CALL kthGrammar WITH n MINUS one AND k MINUS length_of_previous_row  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reachingPoints(sx sy tx ty)  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of the difference of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of the difference of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rabbits-in-forest", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numRabbits(answers)  \n        SET answer_counts TO the count of each distinct element IN answers  \n        SET total_rabbits TO zero  \n        FOR each pair of answer AND count IN the pairs of answer_counts  \n            SET group_size TO answer PLUS one  \n            SET groups TO the result of count PLUS answer DIVIDED BY group_size rounded down to the nearest whole number  \n            INCREMENT total_rabbits BY groups MULTIPLIED BY group_size  \n        END FOR  \n        RETURN total_rabbits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "transform-to-chessboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION movesToChessboard(board)  \n        SET N TO the LENGTH OF board  \n        SET rowSum TO zero  \n        SET colSum TO zero  \n        SET rowSwap TO zero  \n        SET colSwap TO zero  \n        \n        FOR i FROM zero TO N MINUS one  \n            FOR j FROM zero TO N MINUS one  \n                IF element at position i of board AND element at position j of element at position i of board NOT EQUALS element at position zero of element at position i of board OR element at position j of element at position zero of board NOT EQUALS element at position zero of element at position zero of board  \n                    RETURN negative one  \n                END IF  \n            END FOR  \n            \n            INCREMENT rowSum BY element at position zero of element at position i of board  \n            INCREMENT colSum BY element at position i of element at position zero of board  \n            \n            IF element at position zero of element at position i of board EQUALS the remainder when i DIVIDED BY two  \n                INCREMENT rowSwap BY one  \n            END IF  \n            IF element at position i of element at position zero of board EQUALS the remainder when i DIVIDED BY two  \n                INCREMENT colSwap BY one  \n            END IF  \n        END FOR  \n        \n        IF the integer division of N by two GREATER THAN rowSum OR rowSum GREATER THAN the integer division of N PLUS one by two  \n            RETURN negative one  \n        END IF  \n        IF the integer division of N by two GREATER THAN colSum OR colSum GREATER THAN the integer division of N PLUS one by two  \n            RETURN negative one  \n        END IF  \n        \n        IF the remainder when N DIVIDED BY two EQUALS one  \n            IF the remainder when rowSwap DIVIDED BY two EQUALS one  \n                SET rowSwap TO N MINUS rowSwap  \n            END IF  \n            IF the remainder when colSwap DIVIDED BY two EQUALS one  \n                SET colSwap TO N MINUS colSwap  \n            END IF  \n        ELSE  \n            SET rowSwap TO the minimum of rowSwap AND N MINUS rowSwap  \n            SET colSwap TO the minimum of colSwap AND N MINUS colSwap  \n        END IF  \n        \n        SET result TO the integer division of the sum of rowSwap AND colSwap by two  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "is-graph-bipartite", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        SET n TO the LENGTH OF graph  \n        SET color TO a list of n elements each SET TO zero  \n\n        FUNCTION dfs(node, c)  \n            SET element at position node of color TO c  \n            FOR each neighbor IN element at position node of graph  \n                IF element at position neighbor of color EQUALS c THEN  \n                    RETURN False  \n                END IF  \n                IF element at position neighbor of color EQUALS zero THEN  \n                    IF NOT dfs(neighbor, MINUS c) THEN  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n\n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of color EQUALS zero THEN  \n                IF NOT dfs(i, one) THEN  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-smallest-prime-fraction", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPrimeFraction(arr k)  \n        SET n TO the LENGTH OF arr  \n        SET min_heap TO an empty list  \n        \n        FOR i FROM zero TO n MINUS one MINUS one  \n            PUSH onto min_heap the tuple of the element at position i of arr DIVIDED BY the element at position n MINUS one of arr the value i and the value n MINUS one  \n        END FOR  \n        \n        FOR temporary_variable FROM zero TO k MINUS one MINUS one  \n            POP from min_heap into underscore_variable i j  \n            IF the value j MINUS one GREATER THAN i THEN  \n                PUSH onto min_heap the tuple of the element at position i of arr DIVIDED BY the element at position j MINUS one of arr the value i and the value j MINUS one  \n            END IF  \n        END FOR  \n        \n        POP from min_heap into underscore_variable i j  \n        RETURN a list containing the element at position i of arr and the element at position j of arr  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotated-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rotatedDigits(n)  \n        SET change_digits TO collection of characters two five six nine  \n        SET same_digits TO collection of characters zero one eight  \n        \n        FUNCTION is_good_number(num)  \n            SET num_str TO string representation of num  \n            IF all digit IN union of change_digits and same_digits for each digit IN num_str THEN  \n                IF any digit IN change_digits for each digit IN num_str THEN  \n                    RETURN true  \n                END IF  \n            END IF  \n            RETURN false  \n        END FUNCTION  \n        \n        SET good_count TO zero  \n        FOR i FROM one TO n DO  \n            IF is_good_number(i) EQUALS true THEN  \n                INCREMENT good_count BY one  \n            END IF  \n        END FOR  \n        RETURN good_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-the-ghosts", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION escapeGhosts(ghosts, target)  \n        SET player_distance TO the absolute value of the element at position zero of target PLUS the absolute value of the element at position one of target  \n        FOR each ghost IN ghosts  \n            SET ghost_distance TO the absolute value of the element at position zero of ghost MINUS the element at position zero of target PLUS the absolute value of the element at position one of ghost MINUS the element at position one of target  \n            IF ghost_distance LESS THAN OR EQUAL TO player_distance  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO one billion plus seven  \n        SET dp TO a list of zeros of length n plus one  \n        SET dp1 TO a list of zeros of length n plus one  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder after division by MOD of the sum of element at position i minus one of dp PLUS element at position i minus two of dp PLUS two MULTIPLIED BY element at position i minus one of dp1  \n            SET element at position i of dp1 TO the remainder after division by MOD of the sum of element at position i minus two of dp PLUS element at position i minus one of dp1  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "custom-sort-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION customSortString(order  \n                                s)  \n        SET d TO empty dictionary  \n        FOR each index IN range from zero TO the length of order MINUS one  \n            ASSIGN element at position index of order TO current_character  \n            SET current_character in dictionary d TO index  \n        END FOR  \n        SET sorted_list TO the result of sorting string s WHERE the key FOR each character x IS the value FROM dictionary d AT key x IF it exists OTHERWISE zero  \n        SET result_string TO the concatenation of all elements in sorted_list in order  \n        RETURN result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-matching-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numMatchingSubseq(s AS string PARAMETER, words AS list of strings PARAMETER)  \n        CREATE empty dictionary named waiting WHERE keys are characters present in the set of characters from s AND values are empty double-ended queues  \n        FOR each word IN words  \n            CREATE iterator named it FOR word  \n            SET first_letter TO next element from iterator it  \n            IF first_letter IS a key in waiting  \n                APPEND iterator it TO waiting at key first_letter  \n            END IF  \n        END FOR  \n        SET match_count TO zero  \n        FOR each character c IN s  \n            IF c IS a key in waiting  \n                SET current_iterators TO the value at key c in waiting  \n                SET waiting at key c TO an empty double-ended queue  \n                FOR each iterator it IN current_iterators  \n                    SET next_char TO next element from iterator it OR null if exhausted  \n                    IF next_char IS null  \n                        INCREMENT match_count BY one  \n                    ELSE  \n                        IF next_char IS a key in waiting  \n                            APPEND iterator it TO waiting at key next_char  \n                        END IF  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        RETURN match_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-tic-tac-toe-state", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of times element X appears in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of times element O appears in row  \n        END FOR  \n        \n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n        \n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF each element IN row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n            \n            FOR col FROM zero TO two  \n                IF element at position col of element at position zero of board EQUALS player AND element at position col of element at position one of board EQUALS player AND element at position col of element at position two of board EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n            \n            IF element at position zero of element at position zero of board EQUALS player AND element at position one of element at position one of board EQUALS player AND element at position two of element at position two of board EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of element at position zero of board EQUALS player AND element at position one of element at position one of board EQUALS player AND element at position zero of element at position two of board EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n        \n        SET winX TO check_win with argument element X  \n        SET winO TO check_win with argument element O  \n        \n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-subarrays-with-bounded-maximum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSubarrayBoundedMax(nums list of integers left integer right integer) RETURNS integer  \n        FUNCTION count(max_value integer) RETURNS integer  \n            SET count TO zero  \n            SET current_length TO zero  \n            FOR each num IN nums  \n                IF num LESS THAN OR EQUAL TO max_value  \n                    INCREMENT current_length BY one  \n                    INCREMENT count BY current_length  \n                ELSE  \n                    SET current_length TO zero  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN result of count with parameter right MINUS result of count with parameter left MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "all-paths-from-source-to-target", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION allPathsSourceTarget(graph)  \n        SET n TO the LENGTH OF graph  \n        SET q TO an empty double ended queue initialized with a list containing the element zero  \n        SET ans TO an empty list  \n        WHILE q is not empty  \n            SET path TO the element removed from the front of q  \n            SET u TO the element at the last position of path  \n            IF u EQUALS n MINUS one  \n                APPEND path TO ans  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            FOR each v IN the element at position u of graph  \n                SET new_path TO path with element v appended at the end  \n                APPEND new_path TO q  \n            END FOR  \n        END WHILE  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "champagne-tower", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION champagneTower(poured query_poured AS integer query_row AS integer query_glass AS integer) AS floating point  \n        SET current_row TO list containing the single element query_poured  \n        FOR each row FROM one TO query_row  \n            SET next_row TO list of zeros with length equal to row PLUS one  \n            FOR each index i FROM zero TO the length of current_row MINUS one  \n                IF element at position i of current_row GREATER THAN one  \n                    SET excess TO element at position i of current_row MINUS one DIVIDED BY two  \n                    INCREMENT element at position i of next_row BY excess  \n                    INCREMENT element at position i PLUS one of next_row BY excess  \n                END IF  \n            END FOR  \n            ASSIGN current_row TO next_row  \n        END FOR  \n        IF element at position query_glass of current_row LESS THAN OR EQUAL TO one  \n            RETURN element at position query_glass of current_row  \n        ELSE  \n            RETURN one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-swaps-to-make-sequences-increasing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSwap(nums1 nums1 PARAMETER nums2 nums2 PARAMETER)  \n        SET n TO the LENGTH OF nums1  \n        SET dp TO a list of n elements each containing a list of two elements initialized to zero  \n        SET element at position zero and position zero of dp TO zero  \n        SET element at position zero and position one of dp TO one  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of nums1 GREATER THAN element at position i MINUS one of nums1 AND element at position i of nums2 GREATER THAN element at position i MINUS one of nums2 THEN  \n                IF element at position i of nums1 GREATER THAN element at position i MINUS one of nums2 AND element at position i of nums2 GREATER THAN element at position i MINUS one of nums1 THEN  \n                    SET element at position i and position zero of dp TO the MINIMUM of element at position i MINUS one and position zero of dp AND element at position i MINUS one and position one of dp  \n                    SET element at position i and position one of dp TO element at position i and position zero of dp PLUS one  \n                ELSE  \n                    SET element at position i and position zero of dp TO element at position i MINUS one and position zero of dp  \n                    SET element at position i and position one of dp TO element at position i MINUS one and position one of dp PLUS one  \n                END IF  \n            ELSE  \n                IF element at position i of nums1 GREATER THAN element at position i MINUS one of nums2 AND element at position i of nums2 GREATER THAN element at position i MINUS one of nums1 THEN  \n                    SET element at position i and position zero of dp TO element at position i MINUS one and position one of dp  \n                    SET element at position i and position one of dp TO element at position i MINUS one and position zero of dp PLUS one  \n                ELSE  \n                    SET element at position i and position zero of dp TO element at position i MINUS one and position one of dp  \n                    SET element at position i and position one of dp TO element at position i MINUS one and position zero of dp PLUS one  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN the MINIMUM of element at position n MINUS one and position zero of dp AND element at position n MINUS one and position one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-with-same-average", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitArraySameAverage(nums)  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO the SUM OF nums  \n        IF n EQUALS one  \n            RETURN False  \n        END IF  \n        SET dp TO a LIST containing SETS for EACH index FROM zero TO n DIVIDED BY two PLUS one  \n        ADD zero TO the SET at position zero of dp  \n        FOR each num IN nums  \n            FOR size FROM n DIVIDED BY two DOWN TO one  \n                FOR each s IN the SET at position size MINUS one of dp  \n                    SET new_sum TO s PLUS num  \n                    IF new_sum MULTIPLIED BY n EQUALS size MULTIPLIED BY total_sum  \n                        RETURN True  \n                    END IF  \n                    ADD new_sum TO the SET at position size of dp  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "soup-servings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred  \n            RETURN one  \n        END IF  \n        \n        SET n TO n PLUS twenty four DIVIDED BY twenty five rounded down to the nearest integer greater than or equal to the result  \n        \n        SET memo TO an empty collection mapping pairs to probabilities  \n        \n        FUNCTION dp(a b)  \n            IF the pair of a and b EXISTS AS A KEY IN memo  \n                RETURN the value FROM memo FOR the pair of a and b  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero  \n                RETURN zero point five  \n            END IF  \n            \n            IF a LESS THAN OR EQUAL TO zero  \n                RETURN one  \n            END IF  \n            \n            IF b LESS THAN OR EQUAL TO zero  \n                RETURN zero  \n            END IF  \n            \n            SET prob TO zero point two five MULTIPLIED BY the sum of dp of a MINUS four b, dp of a MINUS three b MINUS one, dp of a MINUS two b MINUS two, and dp of a MINUS one b MINUS three  \n            \n            SET the value in memo FOR the pair of a and b TO prob  \n            RETURN prob  \n        END FUNCTION  \n        \n        RETURN dp WITH parameters n and n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "expressive-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION expressiveWords(s, words)  \n        FUNCTION compress(word)  \n            IF word EQUALS empty  \n                RETURN empty list  \n            END IF  \n            SET count TO one  \n            SET compressed TO empty list  \n            FOR index FROM two TO LENGTH OF word  \n                IF element at position index of word EQUALS element at position index MINUS one of word  \n                    INCREMENT count BY one  \n                ELSE  \n                    APPEND tuple of element at position index MINUS one of word AND count TO compressed  \n                    SET count TO one  \n                END IF  \n            END FOR  \n            APPEND tuple of last element of word AND count TO compressed  \n            RETURN compressed  \n        END FUNCTION  \n        \n        FUNCTION is_stretchy(s_compressed, word_compressed)  \n            IF LENGTH OF s_compressed NOT EQUAL TO LENGTH OF word_compressed  \n                RETURN false  \n            END IF  \n            FOR each pair of (sc, sc_count) AND (wc, wc_count) IN zip of s_compressed AND word_compressed  \n                IF sc NOT EQUALS wc  \n                    RETURN false  \n                END IF  \n                IF sc_count NOT EQUAL TO wc_count AND (sc_count LESS THAN three OR sc_count LESS THAN wc_count)  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        SET s_compressed TO compress of s  \n        SET stretchy_count TO zero  \n        \n        FOR each word IN words  \n            SET word_compressed TO compress of word  \n            IF is_stretchy of s_compressed AND word_compressed  \n                INCREMENT stretchy_count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN stretchy_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "chalkboard-xor-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION xorGame(nums)  \n        SET total XOR TO zero  \n        FOR each num IN nums  \n            SET total XOR TO total XOR XOR num  \n        END FOR  \n        IF total XOR EQUALS zero  \n            RETURN true  \n        END IF  \n        IF the LENGTH OF nums MODULO two EQUALS zero  \n            RETURN true  \n        END IF  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subdomain-visit-count", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subdomainVisits(cpdomains)  \n        SET domain_count TO an empty mapping from string to integer with default zero  \n        FOR each cpdomain IN cpdomains  \n            SPLIT cpdomain by whitespace into count_string and domain_string  \n            CONVERT count_string TO integer and ASSIGN TO count  \n            SPLIT domain_string by the dot character INTO a list named subdomains  \n            FOR index FROM zero TO the LENGTH OF subdomains MINUS one  \n                JOIN the elements of subdomains FROM position index TO the last element USING the dot character INTO subdomain  \n                INCREMENT the value at domain_count for key subdomain BY count  \n            END FOR  \n        END FOR  \n        SET result_list TO an empty list  \n        FOR each key_value_pair IN the items of domain_count  \n            EXTRACT domain and count from key_value_pair  \n            CREATE a string consisting of the textual representation of count, a space, and domain  \n            APPEND this string TO result_list  \n        END FOR  \n        RETURN result_list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-sum-of-averages", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestSumOfAverages(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET prefix_sum TO a list of zeros with the LENGTH OF n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix_sum TO element at position i of prefix_sum PLUS element at position i of nums  \n        END FOR  \n        \n        FUNCTION average(i, j)  \n            RETURN the DIFFERENCE BETWEEN element at position j PLUS one of prefix_sum AND element at position i of prefix_sum DIVIDED BY the DIFFERENCE BETWEEN j AND i PLUS one  \n        END FUNCTION  \n        \n        SET dp TO a two dimensional list of zeros with DIMENSIONS n PLUS one BY k PLUS one  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at index one of dp TO the RESULT OF average WITH PARAMETERS i AND n MINUS one  \n        END FOR  \n        \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR partitions FROM two TO k  \n                FOR j FROM i PLUS one TO n MINUS one  \n                    SET element at position i at index partitions of dp TO the GREATER VALUE BETWEEN element at position i at index partitions of dp AND the SUM OF element at position j at index partitions MINUS one of dp AND the RESULT OF average WITH PARAMETERS i AND j MINUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero at index k of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bus-routes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes routes AS List OF List OF Integer, source source AS Integer, target target AS Integer) RETURNS Integer  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from stops TO lists OF buses  \n        FOR each bus WITH index bus_index AND route route_list IN routes  \n            FOR each stop IN route_list  \n                APPEND bus_index TO the list of buses at stop in stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double-ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at source in stop_to_buses  \n            APPEND the pair consisting of bus and one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element from bus_queue and ASSIGN the bus part TO current_bus and the bus count part TO bus_count  \n\n            FOR each stop IN the route at position current_bus of routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop is not an element of visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop in stop_to_buses  \n                        IF next_bus is not an element of visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the pair consisting of next_bus and bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ambiguous-coordinates", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION ambiguousCoordinates(s)  \n        FUNCTION make(frag)  \n            SET n TO the LENGTH OF frag  \n            FOR d FROM one TO n  \n                SET left TO the SUBSTRING from position one TO position d OF frag  \n                SET right TO the SUBSTRING from position d PLUS one TO position n OF frag  \n                IF (the FIRST CHARACTER OF left NOT EQUALS zero OR left EQUALS zero) AND (the LAST CHARACTER OF right NOT EQUALS zero)  \n                    YIELD THE CONCATENATION OF left PLUS IF d NOT EQUALS n THEN a PERIOD ELSE an EMPTY STRING PLUS right  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET s TO the SUBSTRING from position two TO the LENGTH OF s MINUS one OF s  \n\n        RETURN THE LIST OF STRINGS FOR i FROM one TO the LENGTH OF s MINUS one  \n            FOR a AND b IN THE CARTESIAN PRODUCT OF make of the SUBSTRING from position one TO position i OF s AND make of the SUBSTRING from position i PLUS one TO the LENGTH OF s OF s  \n                THE STRING OPENING PARENTHESIS PLUS a PLUS COMMA PLUS SPACE PLUS b PLUS CLOSING PARENTHESIS  \n            END FOR  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "race-car", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION racecar(target)  \n        ASSIGN reference TO an empty queue with initial element as a tuple of position zero speed one steps zero  \n        ASSIGN reference TO an empty set containing the tuple of position zero and speed one as visited states  \n        WHILE the queue is not empty  \n            REMOVE the first element from the queue and ASSIGN position speed and steps from that element  \n            IF position EQUALS target  \n                RETURN steps  \n            END IF  \n            SET next_position TO position PLUS speed  \n            SET next_speed TO speed MULTIPLIED BY two  \n            IF the tuple of next_position and next_speed is NOT IN visited AND next_position IS GREATER THAN OR EQUAL TO zero AND next_position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of next_position and next_speed TO visited  \n                APPEND the tuple of next_position next_speed steps PLUS one TO the queue  \n            END IF  \n            IF speed IS GREATER THAN zero  \n                SET next_speed TO negative one  \n            ELSE  \n                SET next_speed TO one  \n            END IF  \n            IF the tuple of position and next_speed is NOT IN visited AND position IS GREATER THAN OR EQUAL TO zero AND position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of position and next_speed TO visited  \n                APPEND the tuple of position next_speed steps PLUS one TO the queue  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "short-encoding-of-words", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumLengthEncoding(words)  \n        SET reversed_words TO sorted list of each word in words reversed in order of characters  \n        SET total_length TO zero  \n        FOR i FROM zero TO the length of reversed_words MINUS one  \n            IF i PLUS one EQUALS the length of reversed_words OR the element at position i PLUS one of reversed_words DOES NOT start with the element at position i of reversed_words  \n                INCREMENT total_length BY the length of the element at position i of reversed_words PLUS one  \n            END IF  \n        END FOR  \n        RETURN total_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "card-flipping-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each element x AND each element y in fronts AND backs in parallel  \n            IF x EQUALS y  \n                ADD x TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO the set of all elements in fronts and all elements in backs combined  \n        SET good_numbers TO all_numbers MINUS same  \n        IF good_numbers is not empty  \n            SET minimum_good_number TO the smallest element in good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-trees-with-factors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SORT arr in ascending order  \n        SET dp TO a mapping from each number in arr TO one  \n        FOR each index i FROM zero TO the length of arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR each index j FROM zero TO i MINUS one  \n                IF the remainder of num DIVIDED BY element at position j of arr EQUALS zero THEN  \n                    SET right_child TO the quotient of num DIVIDED BY element at position j of arr  \n                    IF right_child IS A key in dp THEN  \n                        SET dp[num] TO the sum of dp[num] PLUS the product of dp[element at position j of arr] AND dp[right_child] MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total_trees TO the sum of all values in dp  \n        RETURN the remainder of total_trees DIVIDED BY MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "most-profit-assigning-work", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProfitAssignment(difficulty, profit, worker)  \n        SET jobs TO list combining elements at corresponding positions of difficulty and profit into pairs  \n        SORT jobs by the first element of each pair in ascending order  \n        SORT worker in ascending order  \n        SET max_profit TO zero  \n        SET best_profit TO zero  \n        SET job_index TO zero  \n        SET n TO the length of jobs  \n        FOR each ability IN worker  \n            WHILE job_index LESS THAN n AND the first element of the pair at position job_index of jobs LESS THAN OR EQUAL TO ability  \n                IF the second element of the pair at position job_index of jobs GREATER THAN best_profit  \n                    SET best_profit TO the second element of the pair at position job_index of jobs  \n                END IF  \n                INCREMENT job_index BY one  \n            END WHILE  \n            INCREMENT max_profit BY best_profit  \n        END FOR  \n        RETURN max_profit  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "making-a-large-island", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestIsland(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF grid  \n        SET directions TO list of pair of numbers zero and one PLUS one and zero PLUS zero and MINUS one PLUS MINUS one and zero  \n        \n        FUNCTION is_valid(x, y)  \n            RETURN x GREATER THAN OR EQUAL TO zero AND x LESS THAN n AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n  \n        END FUNCTION  \n        \n        FUNCTION dfs(x, y, index)  \n            SET area TO one  \n            SET element at position x of element at position y of grid TO index  \n            FOR each pair dx, dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF is_valid(nx, ny) AND element at position nx of element at position ny of grid EQUALS one  \n                    INCREMENT area BY dfs(nx, ny, index)  \n                END IF  \n            END FOR  \n            RETURN area  \n        END FUNCTION  \n        \n        SET island_areas TO empty dictionary  \n        SET index TO two  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of element at position j of grid EQUALS one  \n                    SET element at position index of island_areas TO dfs(i, j, index)  \n                    INCREMENT index BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF island_areas EQUALS empty  \n            RETURN one  \n        END IF  \n        \n        SET max_island_size TO the MAXIMUM of the VALUES in island_areas  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of element at position j of grid EQUALS zero  \n                    SET neighbors TO empty set  \n                    FOR each pair dx, dy IN directions  \n                        SET nx TO i PLUS dx  \n                        SET ny TO j PLUS dy  \n                        IF is_valid(nx, ny) AND element at position nx of element at position ny of grid GREATER THAN one  \n                            ADD element at position nx of element at position ny of grid TO neighbors  \n                        END IF  \n                    END FOR  \n                    SET current_island_size TO one PLUS the SUM of element at position index of island_areas FOR each index IN neighbors  \n                    IF current_island_size GREATER THAN max_island_size  \n                        SET max_island_size TO current_island_size  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_island_size  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "consecutive-numbers-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION consecutiveNumbersSum(n)  \n        SET count TO zero  \n        FOR k FROM one TO n  \n            IF two MULTIPLIED BY n MODULO k EQUALS zero  \n                SET m TO open parenthesis two MULTIPLIED BY n DIVIDED BY k MINUS k PLUS one close parenthesis DIVIDED BY two  \n                IF m GREATER THAN zero AND m EQUALS integer part of m  \n                    INCREMENT count BY one  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "masking-personal-information", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maskPII WITH PARAMETER s  \n        IF string s CONTAINS character at position any_position EQUALS at symbol  \n            SET local_part TO substring of s from position start TO position before at symbol  \n            SET domain_part TO substring of s from position after at symbol TO position end  \n            SET masked_local_part TO first character of local_part CONCATENATED WITH five times the character asterisk CONCATENATED WITH last character of local_part  \n            SET lowercased_masked_local_part TO masked_local_part converted to lowercase letters  \n            SET lowercased_domain_part TO domain_part converted to lowercase letters  \n            RETURN lowercased_masked_local_part CONCATENATED WITH at symbol CONCATENATED WITH lowercased_domain_part  \n        ELSE  \n            SET digits_only TO empty string  \n            FOR each character c IN string s  \n                IF character c is a digit  \n                    APPEND character c TO digits_only  \n                END IF  \n            END FOR  \n            SET local_number_mask TO three times character asterisk CONCATENATED WITH hyphen CONCATENATED WITH three times character asterisk CONCATENATED WITH hyphen CONCATENATED WITH last four characters of digits_only  \n            IF length of digits_only EQUALS ten  \n                RETURN local_number_mask  \n            ELSE  \n                SET country_code_length TO length of digits_only MINUS ten  \n                SET country_code_mask TO plus symbol CONCATENATED WITH country_code_length times character asterisk CONCATENATED WITH hyphen  \n                RETURN country_code_mask CONCATENATED WITH local_number_mask  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-distances-in-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumOfDistancesInTree(n parameter, edges parameter)  \n        SET graph TO a mapping with default empty list for each key  \n        FOR each pair a and b IN edges parameter  \n            APPEND element b TO list at key a in graph  \n            APPEND element a TO list at key b in graph  \n        END FOR  \n        \n        SET count TO a list of size n parameter with each element set to one  \n        SET dist TO a list of size n parameter with each element set to zero  \n        \n        FUNCTION dfs1(u parameter, p parameter)  \n            FOR each element v IN list at key u parameter in graph  \n                IF element v NOT EQUALS p parameter THEN  \n                    CALL dfs1 WITH arguments v and u parameter  \n                    INCREMENT element at position u parameter of count BY element at position v of count  \n                    INCREMENT element at position u parameter of dist BY element at position v of dist PLUS element at position v of count  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        CALL dfs1 WITH arguments zero and minus one  \n        \n        FUNCTION dfs2(u parameter, p parameter)  \n            FOR each element v IN list at key u parameter in graph  \n                IF element v NOT EQUALS p parameter THEN  \n                    SET element at position v of dist TO element at position u parameter of dist MINUS element at position v of count PLUS n parameter MINUS element at position v of count  \n                    CALL dfs2 WITH arguments v and u parameter  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        CALL dfs2 WITH arguments zero and minus one  \n        \n        RETURN dist  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "image-overlap", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestOverlap(img1, img2)  \n        SET n TO the LENGTH OF img1  \n        SET points1 TO an empty list  \n        FOR each i FROM zero TO n MINUS one  \n            FOR each j FROM zero TO n MINUS one  \n                IF the element at position i of img1 at position j EQUALS one  \n                    APPEND the pair of i and j TO points1  \n                END IF  \n            END FOR  \n        END FOR  \n        SET points2 TO an empty list  \n        FOR each i FROM zero TO n MINUS one  \n            FOR each j FROM zero TO n MINUS one  \n                IF the element at position i of img2 at position j EQUALS one  \n                    APPEND the pair of i and j TO points2  \n                END IF  \n            END FOR  \n        END FOR  \n        SET overlap_count TO a new mapping with default value zero  \n        FOR each pair x1 and y1 IN points1  \n            FOR each pair x2 and y2 IN points2  \n                SET dx TO x2 MINUS x1  \n                SET dy TO y2 MINUS y1  \n                INCREMENT the value associated with the pair dx and dy in overlap_count BY one  \n            END FOR  \n        END FOR  \n        SET maximum_overlap TO zero  \n        FOR each value IN the VALUES OF overlap_count  \n            IF value GREATER THAN maximum_overlap  \n                SET maximum_overlap TO value  \n            END IF  \n        END FOR  \n        RETURN maximum_overlap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "new-21-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION new21Game(n k maxPts)  \n        FUNCTION dfs(i)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF i LESS THAN OR EQUAL TO n  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF i EQUALS k MINUS one  \n                SET difference TO n MINUS k PLUS one  \n                IF difference LESS THAN maxPts  \n                    SET numerator TO difference  \n                ELSE  \n                    SET numerator TO maxPts  \n                END IF  \n                RETURN numerator DIVIDED BY maxPts  \n            END IF  \n            SET first_term TO dfs(i PLUS one)  \n            SET second_term TO dfs(i PLUS one) MINUS dfs(i PLUS maxPts PLUS one)  \n            RETURN first_term PLUS second_term DIVIDED BY maxPts  \n        END FUNCTION  \n        RETURN dfs(zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "push-dominoes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION pushDominoes(dominoes)  \n        SET n TO the LENGTH OF dominoes  \n        SET forces TO a list of zeroes with the LENGTH OF n  \n\n        SET force TO zero  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of dominoes EQUALS the character representing rightward push  \n                SET force TO n  \n            ELSE IF element at position i of dominoes EQUALS the character representing leftward push  \n                SET force TO zero  \n            ELSE  \n                IF force MINUS one GREATER THAN zero  \n                    SET force TO force MINUS one  \n                ELSE  \n                    SET force TO zero  \n                END IF  \n            END IF  \n            INCREMENT element at position i of forces BY force  \n        END FOR  \n\n        SET force TO zero  \n        FOR i FROM n MINUS one TO zero DECREMENT BY one  \n            IF element at position i of dominoes EQUALS the character representing leftward push  \n                SET force TO n  \n            ELSE IF element at position i of dominoes EQUALS the character representing rightward push  \n                SET force TO zero  \n            ELSE  \n                IF force MINUS one GREATER THAN zero  \n                    SET force TO force MINUS one  \n                ELSE  \n                    SET force TO zero  \n                END IF  \n            END IF  \n            DECREMENT element at position i of forces BY force  \n        END FOR  \n\n        SET result TO an empty list  \n        FOR each force_value IN forces  \n            IF force_value GREATER THAN zero  \n                APPEND the character representing rightward push TO result  \n            ELSE IF force_value LESS THAN zero  \n                APPEND the character representing leftward push TO result  \n            ELSE  \n                APPEND the character representing no push TO result  \n            END IF  \n        END FOR  \n\n        RETURN the concatenation of all elements in result as a string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "magic-squares-in-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numMagicSquaresInside(grid)  \n        FUNCTION is_magic(i, j)  \n            IF element at position i of grid AND element at position j of that row NOT EQUALS five  \n                RETURN false  \n            END IF  \n            SET numbers TO empty set  \n            FOR x FROM i MINUS one TO i PLUS one  \n                FOR y FROM j MINUS one TO j PLUS one  \n                    IF element at position x of grid AND element at position y of that row LESS THAN one OR element at position x of grid AND element at position y of that row GREATER THAN nine OR element at position x of grid AND element at position y of that row IN numbers  \n                        RETURN false  \n                    END IF  \n                    ADD element at position x of grid AND element at position y of that row TO numbers  \n                END FOR  \n            END FOR  \n            FOR start FROM i MINUS one TO i PLUS one  \n                IF sum of element at position start of grid AND element at position j MINUS one of that row PLUS element at position start of grid AND element at position j of that row PLUS element at position start of grid AND element at position j PLUS one of that row NOT EQUALS fifteen OR sum of element at position i MINUS one of grid AND element at position start of that row PLUS element at position i of grid AND element at position start of that row PLUS element at position i PLUS one of grid AND element at position start of that row NOT EQUALS fifteen  \n                    RETURN false  \n                END IF  \n            END FOR  \n            IF sum of element at position i MINUS one of grid AND element at position j MINUS one of that row PLUS element at position i of grid AND element at position j of that row PLUS element at position i PLUS one of grid AND element at position j PLUS one of that row NOT EQUALS fifteen OR sum of element at position i MINUS one of grid AND element at position j PLUS one of that row PLUS element at position i of grid AND element at position j of that row PLUS element at position i PLUS one of grid AND element at position j MINUS one of that row NOT EQUALS fifteen  \n                RETURN false  \n            END IF  \n            RETURN true  \n        END FUNCTION  \n        SET count TO zero  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        FOR i FROM one TO rows MINUS one  \n            FOR j FROM one TO cols MINUS one  \n                IF is_magic(i j)  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "keys-and-rooms", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canVisitAllRooms WITH PARAMETER rooms  \n        SET visited TO empty collection representing a set  \n        SET stack TO collection containing the element zero  \n        \n        WHILE the LENGTH OF stack IS GREATER THAN zero  \n            SET current_room TO the element REMOVED FROM the END OF stack  \n            ADD current_room TO the collection visited  \n            FOR each key IN the element at position current_room of rooms  \n                IF key IS NOT IN visited  \n                    ADD key TO the END OF stack  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        IF the LENGTH OF visited EQUALS the LENGTH OF rooms  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-into-fibonacci-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR each end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE to the next iteration  \n                END IF  \n                SET next_num TO the integer value of the substring from position start TO position end MINUS one of num  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at position the LENGTH OF path MINUS one of path PLUS the element at position the LENGTH OF path MINUS two of path  \n                    SET result TO the invocation of backtrack with arguments end and the concatenation of path and next_num  \n                    IF result IS NOT EMPTY  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        \n        RETURN the invocation of backtrack with arguments zero and an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-mountain-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestMountain(arr)  \n        SET n TO the LENGTH OF arr  \n        SET longest TO zero  \n        SET i TO one  \n        WHILE i LESS THAN n MINUS one MINUS one  \n            IF element at position i MINUS one of arr LESS THAN element at position i of arr AND element at position i of arr GREATER THAN element at position i PLUS one of arr  \n                SET left TO i MINUS one  \n                SET right TO i PLUS one  \n                WHILE left GREATER THAN zero AND element at position left MINUS one of arr LESS THAN element at position left of arr  \n                    DECREMENT left BY one  \n                END WHILE  \n                WHILE right LESS THAN n MINUS one AND element at position right of arr GREATER THAN element at position right PLUS one of arr  \n                    INCREMENT right BY one  \n                END WHILE  \n                IF longest LESS THAN right MINUS left PLUS one  \n                    SET longest TO right MINUS left PLUS one  \n                END IF  \n                SET i TO right  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        RETURN longest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "hand-of-straights", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isNStraightHand(hand groupSize)  \n        IF the LENGTH OF hand MODULO groupSize NOT EQUALS zero THEN  \n            RETURN False  \n        END IF  \n\n        SET count TO a collection of frequencies of elements in hand  \n        SET unique_cards TO the list of distinct elements in count sorted in ascending order  \n\n        FOR each card IN unique_cards  \n            IF the value associated with card in count GREATER THAN zero THEN  \n                SET needed TO the value associated with card in count  \n                FOR index FROM zero TO groupSize MINUS one  \n                    IF the value associated with card PLUS index in count LESS THAN needed THEN  \n                        RETURN False  \n                    END IF  \n                    DECREMENT the value associated with card PLUS index in count BY needed  \n                END FOR  \n            END IF  \n        END FOR  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-visiting-all-nodes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathLength(graph)  \n        IF graph EQUALS an empty collection  \n            RETURN zero  \n        END IF  \n        \n        SET n TO the LENGTH OF graph  \n        SET queue TO an empty double ended queue  \n        FOR node FROM zero TO n MINUS one  \n            APPEND a tuple of node AND a number with the bit at position node set TO queue  \n        END FOR  \n        \n        SET visited TO an empty set  \n        FOR node FROM zero TO n MINUS one  \n            ADD to visited a tuple of node AND a number with the bit at position node set  \n        END FOR  \n        \n        SET steps TO zero  \n        SET all_nodes_visited TO a number with the bit at each position from zero TO n MINUS one set  \n        \n        WHILE queue is not empty  \n            SET current_length TO the LENGTH OF queue  \n            FOR index FROM zero TO current_length MINUS one  \n                REMOVE from the front of queue AND ASSIGN TO current_node AND visited_nodes  \n                \n                IF visited_nodes EQUALS all_nodes_visited  \n                    RETURN steps  \n                END IF  \n                \n                FOR each neighbor IN the collection at position current_node of graph  \n                    SET next_visited_nodes TO visited_nodes OR a number with the bit at position neighbor set  \n                    SET next_state TO a tuple of neighbor AND next_visited_nodes  \n                    \n                    IF next_state is not in visited  \n                        ADD next_state TO visited  \n                        APPEND next_state TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT steps BY one  \n        END WHILE  \n        \n        RETURN a negative one value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-distance-to-closest-person", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxDistToClosest(seats)  \n        SET max_distance TO zero  \n        SET start TO zero  \n        SET end TO zero  \n        SET n TO the LENGTH OF seats  \n        \n        WHILE start LESS THAN n AND element at position start of seats EQUALS zero  \n            INCREMENT start BY one  \n        END WHILE  \n        \n        SET end TO n MINUS one  \n        WHILE end GREATER THAN OR EQUAL TO zero AND element at position end of seats EQUALS zero  \n            DECREMENT end BY one  \n        END WHILE  \n        \n        SET max_distance TO the GREATER OF max_distance AND start  \n        \n        SET max_distance TO the GREATER OF max_distance AND n MINUS end MINUS one  \n        \n        SET current_distance TO zero  \n        FOR i FROM start TO end  \n            IF element at position i of seats EQUALS zero  \n                INCREMENT current_distance BY one  \n                SET max_distance TO the GREATER OF max_distance AND current_distance PLUS one DIVIDED BY two  \n            ELSE  \n                SET current_distance TO zero  \n            END IF  \n        END FOR  \n        \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION rectangleArea(rectangles)  \n        SET MOD TO ten TO THE POWER OF nine PLUS one  \n        SET y_coords TO an empty set  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            ADD y1 TO y_coords  \n            ADD y2 TO y_coords  \n        END FOR  \n        \n        SET y_coords TO the sorted list of elements of y_coords  \n        SET y_index TO an empty dictionary  \n        FOR each index AND y IN the enumeration of y_coords  \n            ASSIGN y_index at key y TO index  \n        END FOR  \n        \n        SET count TO a list of zeros with the length equal to the length of y_coords  \n        SET events TO an empty list  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            APPEND a tuple containing x1 PLUS one PLUS y1 PLUS y2 TO events  \n            APPEND a tuple containing x2 MINUS one PLUS y1 PLUS y2 TO events  \n        END FOR  \n        \n        SORT events by the first element of each tuple in ascending order  \n        \n        SET prev_x TO zero  \n        SET area TO zero  \n        \n        FOR each event IN events  \n            SET x TO element at position zero of event  \n            SET eventType TO element at position one of event  \n            SET y1 TO element at position two of event  \n            SET y2 TO element at position three of event  \n            \n            SET current_length TO zero  \n            FOR index FROM one TO the length of count MINUS one  \n                IF element at position index MINUS one of count GREATER THAN zero THEN  \n                    INCREMENT current_length BY the difference between element at position index of y_coords AND element at position index MINUS one of y_coords  \n                END IF  \n            END FOR  \n            \n            INCREMENT area BY current_length MULTIPLIED BY the difference between x AND prev_x  \n            SET area TO area MODULO MOD  \n            \n            IF eventType EQUALS one THEN  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    INCREMENT element at position index of count BY one  \n                END FOR  \n            ELSE  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    DECREMENT element at position index of count BY one  \n                END FOR  \n            END IF  \n            \n            SET prev_x TO x  \n        END FOR  \n        \n        RETURN area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "loud-and-rich", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION loudAndRich WITH PARAMETERS richer quiet  \n        SET graph TO a new empty mapping from element to list  \n        FOR each pair a b IN richer  \n            APPEND element a TO the list at key b of graph  \n        END FOR  \n        SET n TO the LENGTH OF quiet  \n        SET answer TO a list of length n with each element set TO negative one  \n        FUNCTION dfs WITH PARAMETER person  \n            IF the element at position person of answer EQUALS negative one  \n                SET the element at position person of answer TO person  \n                FOR each neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs WITH argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position the element at position person of answer of quiet  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        FOR i FROM zero TO n MINUS one  \n            CALL dfs WITH argument i  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "peak-index-in-a-mountain-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION peakIndexInMountainArray(arr)  \n        SET left TO zero  \n        SET right TO the LENGTH OF arr MINUS one  \n        WHILE left LESS THAN right  \n            SET mid TO the INTEGER DIVISION OF the SUM of left PLUS right BY two  \n            IF the element at position mid of arr LESS THAN the element at position mid PLUS one of arr  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "car-fleet", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION carFleet(target position speed)  \n        SET pairs TO list of elements each is position element paired with speed element  \n        SORT pairs in order from largest to smallest based on the position element of each pair  \n        SET time_to_target TO empty list  \n        FOR each pair IN pairs  \n            SET p TO position element of pair  \n            SET s TO speed element of pair  \n            SET time TO the difference between target and p DIVIDED BY s  \n            APPEND time TO time_to_target  \n        END FOR  \n        SET fleets TO zero  \n        SET current_max_time TO zero  \n        FOR each time IN time_to_target  \n            IF time GREATER THAN current_max_time  \n                INCREMENT fleets BY one  \n                SET current_max_time TO time  \n            END IF  \n        END FOR  \n        RETURN fleets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-similar-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kSimilarity(s1, s2)  \n        FUNCTION neighbors(s)  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF s AND the element at position i of s EQUALS the element at position i of s2  \n                INCREMENT i BY one  \n            END WHILE  \n            FOR j FROM the position AFTER i TO one LESS THAN the LENGTH OF s  \n                IF the element at position j of s EQUALS the element at position i of s2 AND the element at position j of s NOT EQUALS the element at position j of s2  \n                    YIELD the string formed by concatenating the substring from start TO position i MINUS one of s PLUS the element at position j of s PLUS the substring from position i PLUS one TO position j MINUS one of s PLUS the element at position i of s PLUS the substring from position j PLUS one TO the end of s  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        ASSIGN reference TO a double-ended queue containing a pair consisting of s1 and zero  \n        ASSIGN reference TO a set containing s1  \n        \n        WHILE the queue is not empty  \n            SET s AND swaps TO the first element REMOVED FROM the queue  \n            IF s EQUALS s2  \n                RETURN swaps  \n            END IF  \n            FOR each neighbor IN the result of calling neighbors with s  \n                IF neighbor is not in the set of visited elements  \n                    ADD neighbor TO the set of visited elements  \n                    APPEND a pair consisting of neighbor and swaps PLUS one TO the queue  \n                END IF  \n            END FOR  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "score-of-parentheses", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION scoreOfParentheses WITH PARAMETER s  \n        SET stack TO empty list  \n        SET score TO zero  \n        FOR each char IN s  \n            IF char EQUALS left parenthesis  \n                APPEND score TO stack  \n                SET score TO zero  \n            ELSE  \n                SET score TO element removed from stack plus IF score EQUALS zero THEN one ELSE two MULTIPLIED BY score  \n            END IF  \n        END FOR  \n        RETURN score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-hire-k-workers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION mincostToHireWorkers(quality, wage, k)  \n        SET workers TO the SORTED LIST of PAIRS of WAGE element DIVIDED BY QUALITY element AND QUALITY element FOR each WAGE element AND QUALITY element FROM ZIP of wage AND quality  \n        SET max_heap TO an EMPTY LIST  \n        SET total_quality TO zero  \n        SET min_cost TO positive infinity  \n        FOR each ratio AND q IN workers  \n            PUSH the NEGATIVE of q INTO max_heap  \n            INCREMENT total_quality BY q  \n            IF the LENGTH OF max_heap GREATER THAN k THEN  \n                INCREMENT total_quality BY the ELEMENT REMOVED FROM max_heap VIA HEAP POP  \n            END IF  \n            IF the LENGTH OF max_heap EQUALS k THEN  \n                SET min_cost TO the MINIMUM OF min_cost AND total_quality MULTIPLIED BY ratio  \n            END IF  \n        END FOR  \n        RETURN min_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "mirror-reflection", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION mirrorReflection(p, q)  \n        DEFINE lcm AS the least common multiple of p AND q  \n        SET vertical_reflections TO lcm DIVIDED BY p  \n        SET horizontal_reflections TO lcm DIVIDED BY q  \n        IF the remainder when vertical_reflections is divided by two EQUALS zero  \n            RETURN zero  \n        ELSE IF the remainder when horizontal_reflections is divided by two EQUALS one  \n            RETURN one  \n        ELSE  \n            RETURN two  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "score-after-flipping-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION matrixScore(grid)  \n        FOR each row IN grid  \n            IF element at position zero of row EQUALS zero  \n                FOR index FROM zero TO length of row MINUS one  \n                    SET element at position index of row TO one MINUS element at position index of row  \n                END FOR  \n            END IF  \n        END FOR  \n        FOR col FROM one TO length of element at position zero of grid MINUS one  \n            SET count_ones TO zero  \n            FOR row FROM zero TO length of grid MINUS one  \n                INCREMENT count_ones BY element at position col of element at position row of grid  \n            END FOR  \n            IF count_ones LESS THAN length of grid DIVIDED BY two  \n                FOR row FROM zero TO length of grid MINUS one  \n                    SET element at position col of element at position row of grid TO one MINUS element at position col of element at position row of grid  \n                END FOR  \n            END IF  \n        END FOR  \n        SET score TO zero  \n        FOR each row IN grid  \n            SET binary_number TO empty string  \n            FOR each element IN row  \n                APPEND element CONVERTED TO string TO binary_number  \n            END FOR  \n            INCREMENT score BY integer value of binary_number INTERPRETED AS binary number  \n        END FOR  \n        RETURN score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-subarray-with-sum-at-least-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestSubarray(nums, k)  \n        SET prefix_sum TO a list containing a single element zero  \n        FOR each num IN nums  \n            APPEND element at the last position of prefix_sum PLUS num TO prefix_sum  \n        END FOR  \n        CREATE an empty double ended queue named dq  \n        SET min_length TO infinity  \n        FOR each index i and current_sum in the enumeration of prefix_sum  \n            WHILE dq is not empty AND current_sum MINUS the element at the position at the first element of dq in prefix_sum IS GREATER THAN OR EQUAL TO k  \n                SET min_length TO the smaller of min_length AND i MINUS the element removed from the first position of dq  \n            END WHILE  \n            WHILE dq is not empty AND current_sum IS LESS THAN OR EQUAL TO the element at the position at the last element of dq in prefix_sum  \n                REMOVE the element from the last position of dq  \n            END WHILE  \n            APPEND i TO dq  \n        END FOR  \n        IF min_length IS NOT EQUAL TO infinity  \n            RETURN min_length  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-to-get-all-keys", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathAllKeys(grid)  \n        SET directions TO list of pairs of zero and one zero and minus one one and zero minus one and zero  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET start TO none  \n        SET num_keys TO zero  \n          \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position i of grid IS EQUALS the character at position j  \n                    IF character at position j EQUALS the character AT POSITION symbol at position corresponding to at sign  \n                        SET start TO pair of i AND j  \n                    ELSE IF character at position j IS LOWERCASE LETTER  \n                        INCREMENT num_keys BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        SET queue TO a new double ended queue containing a tuple of element at position zero of start AND element at position one of start AND zero AND zero  \n        SET visited TO a new set containing a tuple of element at position zero of start AND element at position one of start AND zero  \n          \n        WHILE queue is not empty  \n            SET x, y, keys, steps TO the elements dequeued from the left of queue  \n              \n            FOR each dx, dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n  \n                    SET cell TO element at position nx of grid element at position ny  \n                      \n                    IF cell IS EQUALS wall symbol  \n                        CONTINUE to next iteration  \n                    END IF  \n                      \n                    IF cell IS UPPERCASE LETTER  \n                        SET key_needed TO one SHIFTED LEFT BY the position of lowercase of cell MINUS position of letter a  \n                        IF keys AND key_needed IS EQUALS zero  \n                            CONTINUE to next iteration  \n                        END IF  \n                    END IF  \n                      \n                    IF cell IS LOWERCASE LETTER  \n                        SET new_keys TO keys OR one SHIFTED LEFT BY the position of cell MINUS position of letter a  \n                        IF new_keys IS EQUALS one SHIFTED LEFT BY num_keys MINUS one  \n                            RETURN steps PLUS one  \n                        END IF  \n                    ELSE  \n                        SET new_keys TO keys  \n                    END IF  \n                      \n                    IF tuple of nx, ny, new_keys NOT IN visited  \n                        ADD tuple of nx, ny, new_keys TO visited  \n                        APPEND tuple of nx, ny, new_keys, steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n          \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reordered-power-of-2", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reorderedPowerOf2 WITH PARAMETER n  \n        SET power_of_2_sorted_digits TO empty set  \n        SET power_of_2 TO one  \n        WHILE power_of_2 LESS THAN OR EQUAL TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten  \n            ADD the tuple OF the digits IN sorted order OF the string REPRESENTATION OF power_of_2 TO power_of_2_sorted_digits  \n            SET power_of_2 TO power_of_2 MULTIPLIED BY two  \n        END WHILE  \n        SET sorted_n_digits TO the tuple OF the digits IN sorted order OF the string REPRESENTATION OF n  \n        IF sorted_n_digits IS IN power_of_2_sorted_digits  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-refueling-stops", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minRefuelStops(target startFuel stations)  \n        SET max_heap TO empty list  \n        SET current_fuel TO startFuel  \n        SET stops TO zero  \n        APPEND a list containing target AND zero TO stations  \n\n        FOR each element containing position AND fuel IN stations  \n            WHILE the LENGTH OF max_heap is greater than zero AND current_fuel is LESS THAN position  \n                SET current_fuel TO current_fuel MINUS the removal of the smallest element from max_heap  \n                INCREMENT stops BY one  \n            END WHILE  \n            IF current_fuel is LESS THAN position  \n                RETURN the negative one  \n            END IF  \n            ADD the negative of fuel TO max_heap  \n        END FOR  \n\n        RETURN stops  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "length-of-longest-fibonacci-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lenLongestFibSubseq(arr)  \n        SET index TO an empty dictionary  \n        FOR each element x AND its position i IN arr  \n            SET the element x in index WITH value i  \n        END FOR  \n        SET dp TO an empty dictionary  \n        SET max_length TO zero  \n        FOR variable k FROM zero TO the length of arr MINUS one  \n            FOR variable j FROM zero TO k MINUS one  \n                SET i TO the value at key equal to the element at position k of arr MINUS the element at position j of arr in index OR negative one if not present  \n                IF i GREATER THAN OR EQUAL TO zero AND i LESS THAN j THEN  \n                    SET the value at key pair j and k in dp TO the value at key pair i and j in dp OR two IF not present PLUS one  \n                    IF max_length LESS THAN the value at key pair j and k in dp THEN  \n                        SET max_length TO the value at key pair j and k in dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        IF max_length GREATER THAN OR EQUAL TO three THEN  \n            RETURN max_length  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "walking-robot-simulation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION robotSim(commands, obstacles)  \n        SET directions TO list of pairs consisting of zero PLUS one FOR north then one PLUS zero FOR east then zero MINUS one FOR south then MINUS one PLUS zero FOR west  \n        SET x TO zero  \n        SET y TO zero  \n        SET dir_index TO zero  \n        SET obstacles_set TO the set formed from each tuple corresponding to each element in obstacles  \n        SET max_distance TO zero  \n        FOR each command IN commands  \n            IF command EQUALS negative two  \n                SET dir_index TO dir_index MINUS one MODULO four  \n            ELSE IF command EQUALS negative one  \n                SET dir_index TO dir_index PLUS one MODULO four  \n            ELSE  \n                SET dx TO element at position dir_index of directions at position zero  \n                SET dy TO element at position dir_index of directions at position one  \n                FOR each iteration FROM one TO command  \n                    SET next_x TO x PLUS dx  \n                    SET next_y TO y PLUS dy  \n                    IF the pair consisting of next_x and next_y IS an element of obstacles_set  \n                        BREAK the inner loop  \n                    END IF  \n                    SET x TO next_x  \n                    SET y TO next_y  \n                END FOR  \n                SET current_distance TO x MULTIPLIED BY x PLUS y MULTIPLIED BY y  \n                IF current_distance GREATER THAN max_distance  \n                    SET max_distance TO current_distance  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "koko-eating-bananas", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minEatingSpeed WITH PARAMETERS piles AND h  \n        FUNCTION canFinish WITH PARAMETER k  \n            SET hours TO zero  \n            FOR each pile IN piles  \n                INCREMENT hours BY the result of ceiling of pile DIVIDED BY k  \n            END FOR  \n            RETURN hours LESS THAN OR EQUAL TO h  \n        END FUNCTION  \n        \n        SET left TO one  \n        SET right TO the maximum element of piles  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the result of left PLUS right DIVIDED BY two ignoring remainder  \n            IF canFinish WITH PARAMETER mid  \n                SET right TO mid MINUS one  \n            ELSE  \n                SET left TO mid PLUS one  \n            END IF  \n        END WHILE  \n        \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGame WITH PARAMETER piles  \n        FUNCTION dfs WITH PARAMETERS i j  \n            IF i GREATER THAN j THEN  \n                RETURN zero  \n            END IF  \n            RETURN the maximum value BETWEEN element at position i of piles MINUS dfs WITH PARAMETERS i PLUS one AND j AND element at position j of piles MINUS dfs WITH PARAMETERS i AND j MINUS one  \n        END FUNCTION  \n        RETURN result of dfs WITH PARAMETERS zero AND the LENGTH OF piles MINUS one GREATER THAN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "nth-magical-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nthMagicalNumber(n a b)  \n        SET MOD TO one billion PLUS seven  \n        \n        FUNCTION gcd(x y)  \n            WHILE y NOT EQUALS zero  \n                SET temporary_variable TO y  \n                SET y TO x MODULO y  \n                SET x TO temporary_variable  \n            END WHILE  \n            RETURN x  \n        END FUNCTION  \n        \n        FUNCTION lcm(x y)  \n            RETURN x MULTIPLIED BY y DIVIDED BY gcd(x y)  \n        END FUNCTION  \n        \n        SET L TO lcm(a b)  \n        \n        SET left TO one  \n        SET right TO n MULTIPLIED BY the smaller of a AND b  \n        \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right DIVIDED BY two  \n            SET count TO mid DIVIDED BY a PLUS mid DIVIDED BY b MINUS mid DIVIDED BY L  \n            \n            IF count LESS THAN n  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        \n        RETURN left MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "profitable-schemes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION profitableSchemes(n INTEGER_PARAMETER minProfit INTEGER_PARAMETER group LIST_OF_INTEGER_PARAMETER profit LIST_OF_INTEGER_PARAMETER) RETURNS INTEGER  \n        SET MOD TO one billion PLUS seven  \n        CREATE two dimensional list dp WITH n PLUS one rows EACH containing minProfit PLUS one zeroes  \n        FOR i FROM zero TO n  \n            SET element at position zero of element at position i of dp TO one  \n        END FOR  \n        FOR each element p IN profit AND corresponding element g IN group  \n            FOR i FROM n DOWN TO g  \n                FOR j FROM minProfit DOWN TO zero  \n                    SET element at position j of element at position i of dp TO element at position j of element at position i of dp PLUS element at position maximum of zero AND j MINUS p of element at position i MINUS g of dp  \n                    SET element at position j of element at position i of dp TO element at position j of element at position i of dp MODULO MOD  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN element at position minProfit of element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decoded-string-at-index", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION decodeAtIndex(s string_parameter k integer_parameter) RETURNS string  \n        SET length TO zero  \n        FOR each character IN s  \n            IF character IS DIGIT  \n                SET length TO length MULTIPLIED BY the INTEGER VALUE OF character  \n            ELSE  \n                INCREMENT length BY one  \n            END IF  \n        END FOR  \n        FOR each character IN the REVERSE ORDER OF s  \n            SET k TO k MODULO length  \n            IF k EQUALS zero AND character IS ALPHABETIC LETTER  \n                RETURN character  \n            END IF  \n            IF character IS DIGIT  \n                SET length TO length DIVIDED BY the INTEGER VALUE OF character  \n            ELSE  \n                DECREMENT length BY one  \n            END IF  \n        END FOR  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "boats-to-save-people", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numRescueBoats(people LIST OF INTEGER limit INTEGER) RETURNS INTEGER  \n        SORT the list of people by their weights in ascending order  \n        SET left TO zero  \n        SET right TO the length of people MINUS one  \n        SET boats TO zero  \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            IF the element at position left of people PLUS the element at position right of people IS LESS THAN OR EQUAL TO limit  \n                INCREMENT left BY one  \n            END IF  \n            DECREMENT right BY one  \n            INCREMENT boats BY one  \n        END WHILE  \n        RETURN boats  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reachable-nodes-in-subdivided-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION reachableNodes(edges AS list of list of integer, maxMoves AS integer, n AS integer) RETURNS integer  \n        SET graph TO empty mappings from integer TO empty list  \n        FOR index FROM zero TO n MINUS one  \n            SET element at position index of graph TO empty list  \n        END FOR  \n        \n        FOR each element u, v, cnt IN edges  \n            APPEND pair of v and cnt TO element at position u of graph  \n            APPEND pair of u and cnt TO element at position v of graph  \n        END FOR  \n        \n        SET distances TO list of length n with each element set to infinity  \n        SET element at position zero of distances TO zero  \n        SET priority_queue TO list containing pair of zero and zero  \n        \n        WHILE length of priority_queue IS greater than zero  \n            SET dist, node TO remove and return the smallest element from priority_queue  \n            IF dist GREATER THAN element at position node of distances  \n                CONTINUE  \n            END IF  \n            FOR each element neighbor, cnt IN element at position node of graph  \n                SET new_dist TO dist PLUS cnt PLUS one  \n                IF new_dist LESS THAN element at position neighbor of distances  \n                    SET element at position neighbor of distances TO new_dist  \n                    INSERT pair of new_dist and neighbor INTO priority_queue maintaining order  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        SET reachable_nodes TO zero  \n        \n        FOR each element d IN distances  \n            IF d LESS THAN OR EQUAL TO maxMoves  \n                INCREMENT reachable_nodes BY one  \n            END IF  \n        END FOR  \n        \n        SET used_edges TO empty mappings  \n        FOR each element u, v, cnt IN edges  \n            SET moves_u TO maximum of zero AND maxMoves MINUS element at position u of distances  \n            SET moves_v TO maximum of zero AND maxMoves MINUS element at position v of distances  \n            SET reachable_new_nodes TO minimum of cnt AND moves_u PLUS moves_v  \n            INCREMENT reachable_nodes BY reachable_new_nodes  \n            SET element at key pair of u and v of used_edges TO reachable_new_nodes  \n        END FOR  \n        \n        RETURN reachable_nodes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "spiral-matrix-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION spiralMatrixIII(rows  \n                             cols  \n                             rStart  \n                             cStart) RETURNS list of list of integers  \n        SET directions TO list of pairs of integers representing north-east-south-west unit moves one step at a time starting from east direction including east south west north  \n        SET direction_index TO zero representing starting facing east  \n        SET steps TO zero representing number of steps to move in current direction  \n        SET increment TO zero representing counter to track when to increase steps  \n        SET visited TO empty list representing visited coordinates  \n        SET x TO rStart  \n        SET y TO cStart  \n        \n        WHILE the LENGTH OF visited is LESS THAN rows MULTIPLIED BY cols  \n            IF increment MODULO two EQUALS zero  \n                INCREMENT steps BY one  \n            END IF  \n            FOR each count FROM one TO steps  \n                IF x IS GREATER THAN OR EQUAL TO zero AND x IS LESS THAN rows AND y IS GREATER THAN OR EQUAL TO zero AND y IS LESS THAN cols  \n                    APPEND list containing x and y TO visited  \n                END IF  \n                SET dx TO element at position direction_index of directions first element  \n                SET dy TO element at position direction_index of directions second element  \n                INCREMENT x BY dx  \n                INCREMENT y BY dy  \n            END FOR  \n            SET direction_index TO the remainder of direction_index PLUS one DIVIDED BY four  \n            INCREMENT increment BY one  \n        END WHILE  \n        \n        RETURN visited  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-egg-drop", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        SET dp TO a list of zeroes with length equal to k PLUS one  \n        SET moves TO zero  \n        WHILE element at position k of dp LESS THAN n  \n            INCREMENT moves BY one  \n            FOR eggs FROM k DOWN TO one  \n                SET element at position eggs of dp TO one PLUS element at position eggs MINUS one of dp PLUS element at position eggs of dp  \n            END FOR  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-subsequence-widths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MODULO TO ten POWERED BY nine PLUS one  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list WITH n elements EACH EQUAL TO one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO the element at position i MINUS one of power MULTIPLIED BY two MODULO MODULO  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS the element at position i of nums MULTIPLIED BY the element at position i of power MINUS the element at position n MINUS i MINUS one of power MODULO MODULO  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "orderly-queue", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION orderlyQueue(s, k)  \n        IF k GREATER THAN one  \n            RETURN the concatenation of all characters in the collection obtained by arranging all characters of input string in ascending lexicographical order  \n        ELSE  \n            SET n TO the length of input string s  \n            SET smallest TO s  \n            FOR i FROM one TO n MINUS one  \n                SET rotated TO the concatenation of substring from position i TO the end of string s PLUS substring from position zero TO position i MINUS one of string s  \n                IF rotated LESS THAN smallest  \n                    SET smallest TO rotated  \n                END IF  \n            END FOR  \n            RETURN smallest  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "numbers-at-most-n-given-digit-set", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION count_numbers_with_length(length)  \n            RETURN the LENGTH OF digits RAISED TO THE POWER OF length  \n        END FUNCTION  \n        \n        FUNCTION count_numbers_up_to_n(n)  \n            SET string_version_of_n TO the STRING REPRESENTATION OF n  \n            SET length TO the LENGTH OF string_version_of_n  \n            SET count TO zero  \n            \n            FOR each l FROM one TO length MINUS one  \n                INCREMENT count BY the RESULT OF count_numbers_with_length WITH l  \n            END FOR  \n            \n            FOR each i FROM zero TO length MINUS one  \n                SET current_digit TO the INTEGER REPRESENTATION OF the ELEMENT AT POSITION i OF string_version_of_n  \n                FOR each digit IN digits  \n                    SET digit_value TO the INTEGER REPRESENTATION OF digit  \n                    IF digit_value LESS THAN current_digit THEN  \n                        INCREMENT count BY the RESULT OF count_numbers_with_length WITH length MINUS i MINUS one  \n                    ELSE IF digit_value EQUALS current_digit THEN  \n                        IF i EQUALS length MINUS one THEN  \n                            INCREMENT count BY one  \n                        END IF  \n                    ELSE  \n                        BREAK out OF the INNER FOR loop  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the RESULT OF count_numbers_up_to_n WITH n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-permutations-for-di-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numPermsDISequence(s)  \n        SET MOD TO ten POWERED BY nine PLUS one  \n        SET n TO the LENGTH OF s  \n        SET dp TO a two-dimensional list of SIZE n PLUS one BY n PLUS one FILLED WITH zero  \n        \n        FOR j FROM zero TO n  \n            SET element at position j of element at position zero of dp TO one  \n        END FOR  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            \n            IF element at position i MINUS one of s EQUALS the character I  \n                FOR j FROM zero TO n PLUS one MINUS i MINUS one  \n                    SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp MODULO MOD  \n                    SET element at position j of element at position i of dp TO prefix_sum  \n                END FOR  \n            ELSE  \n                FOR j FROM n MINUS i DOWN TO zero BY MINUS one  \n                    SET prefix_sum TO prefix_sum PLUS element at position j PLUS one of element at position i MINUS one of dp MODULO MOD  \n                    SET element at position j of element at position i of dp TO prefix_sum  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        SET result TO zero  \n        FOR each value IN element at position n of dp  \n            SET result TO result PLUS value  \n        END FOR  \n        RETURN result MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-palindromes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION superpalindromesInRange(left right)  \n        FUNCTION is_palindrome(num)  \n            RETURN string representation of num EQUALS reversal of string representation of num  \n        END FUNCTION  \n        \n        FUNCTION generate_palindromes(limit)  \n            SET palindromes TO empty list  \n            FOR i FROM one TO one hundred thousand MINUS one  \n                SET s TO string representation of i  \n                APPEND integer conversion of concatenation of s PLUS substring from position length of s MINUS two DOWN TO position zero of s TO palindromes  \n                APPEND integer conversion of concatenation of s PLUS reversal of s TO palindromes  \n            END FOR  \n            RETURN list of elements p IN palindromes WHERE p LESS THAN OR EQUAL TO limit  \n        END FUNCTION  \n        \n        SET left TO integer conversion of left  \n        SET right TO integer conversion of right  \n        SET limit TO integer conversion of right RAISED TO power one DIVIDED BY two PLUS one  \n        SET palindromes TO generate_palindromes(limit)  \n        \n        SET count TO zero  \n        FOR each p IN palindromes  \n            SET square TO p MULTIPLIED BY p  \n            IF left LESS THAN OR EQUAL TO square AND square LESS THAN OR EQUAL TO right AND is_palindrome(square)  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-music-playlists", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numMusicPlaylists WITH PARAMETERS n goal k  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE dp AS a two dimensional list OF zeros with number of rows EQUAL TO goal PLUS one AND number of columns EQUAL TO n PLUS one  \n        SET element at position zero zero OF dp TO one  \n        FOR i FROM one TO goal  \n            FOR j FROM one TO n  \n                SET element at position i j OF dp TO element at position i MINUS one j MINUS one OF dp MULTIPLIED BY n MINUS j MINUS one  \n                SET element at position i j OF dp TO element at position i j OF dp MODULO MOD  \n                IF j GREATER THAN k THEN  \n                    INCREMENT element at position i j OF dp BY element at position i MINUS one j OF dp MULTIPLIED BY j MINUS k  \n                    SET element at position i j OF dp TO element at position i j OF dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position goal n OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-malware-spread", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMalwareSpread(graph parameter WHICH IS a list of lists of integers initial parameter WHICH IS a list of integers) RETURNS an integer  \n        FUNCTION dfs(node parameter WHICH IS an integer component parameter WHICH IS a set of integers)  \n            IF node IS IN visited SET  \n                RETURN  \n            END IF  \n            ADD node TO visited SET  \n            ADD node TO component SET  \n            FOR neighbor FROM zero TO the LENGTH OF graph MINUS one  \n                IF element at position node of graph AND element at position neighbor IS EQUALS one AND neighbor IS NOT IN visited SET  \n                    CALL dfs WITH neighbor AND component  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET visited TO an empty set  \n        SET components TO an empty list  \n        FOR node FROM zero TO the LENGTH OF graph MINUS one  \n            IF node IS NOT IN visited SET  \n                SET component TO an empty set  \n                CALL dfs WITH node AND component  \n                APPEND component TO components  \n            END IF  \n        END FOR  \n        \n        SET infected_count TO a list of zeros with the LENGTH OF graph  \n        FOR node IN initial  \n            SET element at position node OF infected_count TO one  \n        END FOR  \n        \n        SET component_infected_count TO a list of zeros with the LENGTH OF components  \n        FOR node IN initial  \n            FOR each index i AND each component IN components  \n                IF node IS IN component SET  \n                    INCREMENT element at position i OF component_infected_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET max_saving TO zero  \n        SET best_node TO the minimum element IN initial  \n        FOR node IN initial  \n            FOR each index i AND each component IN components  \n                IF node IS IN component AND element at position i OF component_infected_count IS EQUALS one  \n                    SET saving TO the SIZE OF component  \n                    IF saving IS GREATER THAN max_saving OR saving IS EQUALS max_saving AND node IS LESS THAN best_node  \n                        SET max_saving TO saving  \n                        SET best_node TO node  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN best_node  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stamping-the-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION movesToStamp(stamp, target)  \n        SET m TO the LENGTH OF stamp  \n        SET n TO the LENGTH OF target  \n        SET indeg TO a list OF m REPEATED for the QUANTITY OF the difference BETWEEN n AND m PLUS one  \n        SET q TO an empty double-ended queue  \n        SET g TO a list containing empty lists REPEATED for the QUANTITY OF n  \n        FOR i FROM zero TO the difference BETWEEN n AND m  \n            FOR each position j AND character c IN the enumeration OF stamp  \n                IF the element at position i PLUS j OF target EQUALS c THEN  \n                    DECREMENT the element at position i OF indeg BY one  \n                    IF the element at position i OF indeg EQUALS zero THEN  \n                        APPEND i TO q  \n                    END IF  \n                ELSE  \n                    APPEND i TO the element at position i PLUS j OF g  \n                END IF  \n            END FOR  \n        END FOR  \n        SET ans TO an empty list  \n        SET vis TO a list containing false values REPEATED for the QUANTITY OF n  \n        WHILE q is not empty  \n            REMOVE the element from the front of q AND ASSIGN TO i  \n            APPEND i TO ans  \n            FOR j FROM zero TO m MINUS one  \n                IF the element at position i PLUS j OF vis EQUALS false THEN  \n                    SET the element at position i PLUS j OF vis TO true  \n                    FOR each element k IN the element at position i PLUS j OF g  \n                        DECREMENT the element at position k OF indeg BY one  \n                        IF the element at position k OF indeg EQUALS zero THEN  \n                            APPEND k TO q  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n        IF every element OF vis EQUALS true THEN  \n            RETURN ans in reverse order  \n        ELSE  \n            RETURN an empty list  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tallest-billboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION tallestBillboard WITH PARAMETER rods  \n        SET dp TO a dictionary with key zero and value zero  \n        FOR each rod IN rods  \n            SET new_dp TO a new dictionary copying all key value pairs from dp  \n            FOR each key d and value y IN dp items  \n                SET sum_for_taller_support TO d PLUS rod  \n                IF new_dp contains key sum_for_taller_support THEN  \n                    SET new_dp value at key sum_for_taller_support TO the greater value BETWEEN the current value at key sum_for_taller_support in new_dp AND y  \n                ELSE  \n                    SET new_dp value at key sum_for_taller_support TO y  \n                END IF  \n                IF d GREATER THAN rod THEN  \n                    SET difference TO d MINUS rod  \n                ELSE  \n                    SET difference TO rod MINUS d  \n                END IF  \n                IF new_dp contains key difference THEN  \n                    SET candidate_value TO y PLUS the smaller value BETWEEN d AND rod  \n                    SET new_dp value at key difference TO the greater value BETWEEN the current value at key difference in new_dp AND candidate_value  \n                ELSE  \n                    SET new_dp value at key difference TO y PLUS the smaller value BETWEEN d AND rod  \n                END IF  \n            END FOR  \n            SET dp TO new_dp  \n        END FOR  \n        RETURN the value in dp at key zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-columns-to-make-sorted-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDeletionSize(strs)  \n        SET m TO the LENGTH OF strs  \n        SET n TO the LENGTH OF element at position zero of strs  \n        SET dp TO a list of size n where each element is set TO one  \n        FOR i FROM one TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF FOR each k FROM zero TO m MINUS one the element at position k of strs at position j IS LESS THAN OR EQUAL TO the element at position k of strs at position i  \n                    SET dp at position i TO the GREATER OF dp at position i AND dp at position j PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN n MINUS the GREATEST element in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "least-operators-to-express-number", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION leastOpsExpressTarget(x target)  \n        FUNCTION dp(target)  \n            IF target EQUALS zero  \n                RETURN negative one  \n            END IF  \n            IF target LESS THAN x  \n                RETURN the MINIMUM BETWEEN the value of two MULTIPLIED BY target MINUS one AND the value of two MULTIPLIED BY the difference BETWEEN x AND target  \n            END IF  \n            SET power TO one  \n            WHILE the value of x RAISED TO THE power IS LESS THAN OR EQUAL TO target  \n                INCREMENT power BY one  \n            END WHILE  \n            DECREMENT power BY one  \n            SET res TO the result of dp of the difference BETWEEN target AND the value of x RAISED TO THE power PLUS the value of power  \n            IF the value of x RAISED TO THE sum of power AND one MINUS target IS LESS THAN target  \n                SET res TO the MINIMUM BETWEEN res AND the result of dp of the difference BETWEEN the value of x RAISED TO THE sum of power AND one AND target PLUS the value of power PLUS one  \n            END IF  \n            RETURN res  \n        END FUNCTION  \n        RETURN dp of target  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-rational-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isRationalEqual(s, t)  \n        SET ratios TO list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf(s)  \n            IF the position of the opening parenthesis character in s EQUALS negative one THEN  \n                RETURN the floating point conversion of s  \n            END IF  \n\n            SET leftParenIndex TO the position of the opening parenthesis character in s  \n            SET rightParenIndex TO the position of the closing parenthesis character in s  \n            SET dotIndex TO the position of the decimal point character in s  \n\n            SET integerAndNonRepeating TO the floating point conversion of the substring from the start of s TO the position before leftParenIndex of s  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the integer conversion of the substring from the position after leftParenIndex TO the position before rightParenIndex of s  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY zero POINT one RAISED TO THE POWER OF nonRepeatingLength MULTIPLIED BY the element at position repeatingLength of ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of the result of valueOf applied to s MINUS the result of valueOf applied to t LESS THAN one TIMES ten RAISED TO THE POWER OF negative nine  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION uniquePathsIII(grid)  \n        FUNCTION dfs(x, y, steps)  \n            IF element at position x of grid IS GREATER THAN OR EQUAL TO zero AND element at position y of element at position x of grid EQUALS two THEN  \n                RETURN steps EQUALS zero  \n            END IF  \n            \n            SET original TO element at position y of element at position x of grid  \n            SET element at position y of element at position x of grid TO negative two  \n            SET count TO zero  \n            \n            FOR each dx dy IN list of values negative one zero AND one zero AND zero negative one AND zero one  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN LENGTH OF grid AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN LENGTH OF element at position zero of grid AND element at position ny of element at position nx of grid IS GREATER THAN OR EQUAL TO zero THEN  \n                    INCREMENT count BY result of dfs WITH PARAMETERS nx ny steps MINUS one  \n                END IF  \n            END FOR  \n            \n            SET element at position y of element at position x of grid TO original  \n            RETURN count  \n        END FUNCTION  \n        \n        SET m TO LENGTH OF grid  \n        SET n TO LENGTH OF element at position zero of grid  \n        SET start_x TO zero  \n        SET start_y TO zero  \n        SET empty_squares TO one  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position j of element at position i of grid EQUALS one THEN  \n                    SET start_x TO i  \n                    SET start_y TO j  \n                ELSE IF element at position j of element at position i of grid EQUALS zero THEN  \n                    INCREMENT empty_squares BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result of dfs WITH PARAMETERS start_x start_y empty_squares  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "triples-with-bitwise-and-equal-to-zero", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        SET pair_and_count TO an empty mapping with default value zero  \n        FOR each element i IN nums  \n            FOR each element j IN nums  \n                SET bitwise_and_result TO bitwise AND of i AND j  \n                INCREMENT the value associated with bitwise_and_result in pair_and_count BY one  \n            END FOR  \n        END FOR  \n        SET triplet_count TO zero  \n        FOR each element k IN nums  \n            FOR each key pair_and AND value count IN pair_and_count  \n                IF bitwise AND of pair_and AND k EQUALS zero THEN  \n                    INCREMENT triplet_count BY count  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN triplet_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subarrays-with-k-different-integers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subarraysWithKDistinct(nums k)  \n        FUNCTION atMostKDistinct(t)  \n            SET count TO a mapping from elements to zero counts  \n            SET left TO zero  \n            SET result TO zero  \n            FOR right FROM zero TO the length of nums MINUS one  \n                INCREMENT the count of the element at position right of nums BY one  \n                WHILE the number of distinct keys in count GREATER THAN t  \n                    DECREMENT the count of the element at position left of nums BY one  \n                    IF the count of the element at position left of nums EQUALS zero  \n                        REMOVE the element at position left of nums FROM count  \n                    END IF  \n                    INCREMENT left BY one  \n                END WHILE  \n                INCREMENT result BY the value of right MINUS left PLUS one  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        RETURN the result of calling atMostKDistinct with k MINUS the result of calling atMostKDistinct with k MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-k-consecutive-bit-flips", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minKBitFlips(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET flip_count TO zero  \n        SET flipped TO a list consisting of zero repeated n PLUS one times  \n        SET flip_state TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET flip_state TO flip_state XOR element at position i of flipped  \n            \n            IF element at position i of nums EQUALS flip_state  \n                IF i PLUS k GREATER THAN n  \n                    RETURN negative one  \n                END IF  \n                SET flip_state TO flip_state XOR one  \n                SET element at position i PLUS k of flipped TO element at position i PLUS k of flipped XOR one  \n                INCREMENT flip_count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN flip_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-squareful-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSquarefulPerms(nums)  \n        FUNCTION is_square(n)  \n            SET square_root TO the integer part of the square root of n  \n            RETURN square_root MULTIPLIED BY square_root EQUALS n  \n        END FUNCTION  \n\n        FUNCTION backtrack(path, count)  \n            IF the LENGTH OF path EQUALS the LENGTH OF nums  \n                RETURN one  \n            END IF  \n\n            SET ans TO zero  \n            FOR each x IN the keys of count  \n                IF the value of count at x GREATER THAN zero AND (the LENGTH OF path EQUALS zero OR is_square(the last element at position the LENGTH OF path MINUS one OF path PLUS x))  \n                    DECREMENT the value of count at x BY one  \n                    SET ans TO ans PLUS backtrack(path WITH x APPENDED, count)  \n                    INCREMENT the value of count at x BY one  \n                END IF  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n\n        SET count TO the frequency mapping of elements in nums  \n        RETURN backtrack(an empty list, count)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "grid-illumination", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION gridIllumination(n, lamps, queries)  \n        INITIALIZE row_count AS a mapping from integer to integer defaulting to zero  \n        INITIALIZE col_count AS a mapping from integer to integer defaulting to zero  \n        INITIALIZE diag_count AS a mapping from integer to integer defaulting to zero where the key is row MINUS column  \n        INITIALIZE anti_diag_count AS a mapping from integer to integer defaulting to zero where the key is row PLUS column  \n        \n        INITIALIZE lamp_positions AS an empty set  \n        \n        FOR each pair of values r and c IN lamps  \n            IF pair of values r and c is NOT in lamp_positions  \n                ADD pair of values r and c TO lamp_positions  \n                INCREMENT the value at key r in row_count BY one  \n                INCREMENT the value at key c in col_count BY one  \n                INCREMENT the value at key of the difference between r and c in diag_count BY one  \n                INCREMENT the value at key of the sum of r and c in anti_diag_count BY one  \n            END IF  \n        END FOR  \n        \n        SET directions TO the collection of pairs minus one minus one and minus one zero and minus one one and zero minus one and zero zero and zero one and one minus one and one zero and one one  \n        \n        INITIALIZE result AS an empty list  \n        \n        FOR each pair of values r and c IN queries  \n            IF the value at key r in row_count GREATER THAN zero OR the value at key c in col_count GREATER THAN zero OR the value at key of the difference between r and c in diag_count GREATER THAN zero OR the value at key of the sum of r and c in anti_diag_count GREATER THAN zero  \n                APPEND one TO result  \n            ELSE  \n                APPEND zero TO result  \n            END IF  \n            \n            FOR each pair of values dr and dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF pair of values nr and nc IS IN lamp_positions  \n                    REMOVE pair of values nr and nc FROM lamp_positions  \n                    DECREMENT the value at key nr in row_count BY one  \n                    DECREMENT the value at key nc in col_count BY one  \n                    DECREMENT the value at key of the difference between nr and nc in diag_count BY one  \n                    DECREMENT the value at key of the sum of nr and nc in anti_diag_count BY one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "numbers-with-repeated-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numDupDigitsAtMostN(n)  \n        FUNCTION count_unique_digits(x)  \n            SET s TO the string representation of x  \n            SET length TO the number of characters in s  \n            SET count TO zero  \n            FOR i FROM one TO length MINUS one  \n                INCREMENT count BY the product of nine AND perm(nine MINUS (i MINUS one), i MINUS one)  \n            END FOR  \n            SET seen TO an empty set  \n            FOR i FROM zero TO length MINUS one  \n                SET digit TO the character at position i of s converted to an integer  \n                IF i EQUALS zero THEN  \n                    SET start_digit TO one  \n                ELSE  \n                    SET start_digit TO zero  \n                END IF  \n                FOR d FROM start_digit TO digit MINUS one  \n                    IF d NOT IN seen THEN  \n                        INCREMENT count BY perm(nine MINUS i, length MINUS i MINUS one)  \n                    END IF  \n                END FOR  \n                IF digit IN seen THEN  \n                    EXIT FROM the current FOR loop  \n                END IF  \n                ADD digit TO seen  \n            END FOR  \n            IF the FOR loop completed without break THEN  \n                INCREMENT count BY one  \n            END IF  \n            RETURN count  \n        END FUNCTION  \n\n        RETURN n MINUS count_unique_digits(n)  \n    END FUNCTION  \n\n    FUNCTION perm(m, n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        SET result TO one  \n        FOR i FROM zero TO n MINUS one  \n            SET result TO result MULTIPLIED BY (m MINUS i)  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-a-large-maze", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isEscapePossible(blocked, source, target)  \n        IF blocked EQUALS an empty collection  \n            RETURN True  \n        END IF  \n        \n        SET blocked_set TO an empty set  \n        FOR each block IN blocked  \n            APPEND an immutable pair constructed from block TO blocked_set  \n        END FOR  \n        \n        SET n TO the LENGTH OF blocked  \n        SET max_steps TO n MULTIPLIED BY n MINUS one THEN DIVIDED BY two  \n        \n        FUNCTION bfs(start, end)  \n            SET queue TO a new double ended queue containing an immutable pair constructed from start  \n            SET visited TO a new set initialized with the contents of queue  \n            \n            WHILE queue is not empty  \n                SET current_position TO the element removed from the front of queue  \n                DESTRUCTURE current_position INTO x and y  \n                \n                IF the LENGTH OF visited GREATER THAN max_steps OR x EQUALS the element at position zero of end AND y EQUALS the element at position one of end  \n                    RETURN True  \n                END IF  \n                \n                FOR each delta_x and delta_y IN the collection of pairs consisting of zero and one zero and negative one one and zero and negative one and zero  \n                    SET nx TO x PLUS delta_x  \n                    SET ny TO y PLUS delta_y  \n                    \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN one million AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN one million AND an immutable pair constructed from nx and ny NOT IN blocked_set AND an immutable pair constructed from nx and ny NOT IN visited  \n                        ADD an immutable pair constructed from nx and ny TO visited  \n                        APPEND an immutable pair constructed from nx and ny TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN the result of calling bfs with source and target AND the result of calling bfs with target and source  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-duplicate-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestDupSubstring(s)  \n        FUNCTION search(length)  \n            SET seen TO empty set  \n            FOR i FROM zero TO the LENGTH OF s MINUS length PLUS one  \n                SET substring TO the sequence of characters from position i TO position i PLUS length MINUS one of s  \n                IF substring IS IN seen THEN  \n                    RETURN substring  \n                END IF  \n                ADD substring TO seen  \n            END FOR  \n            RETURN empty string  \n        END FUNCTION  \n        \n        SET left TO one  \n        SET right TO the LENGTH OF s MINUS one  \n        SET longest TO empty string  \n        \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n            SET candidate TO search(mid)  \n            IF candidate IS NOT empty string THEN  \n                SET longest TO candidate  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        RETURN longest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-valid-subarrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validSubarrays(nums)  \n        SET stack TO empty list  \n        SET count TO zero  \n        FOR each num IN nums  \n            WHILE the LENGTH OF stack is greater than zero AND element at position the LENGTH OF stack MINUS one of stack GREATER THAN num  \n                REMOVE element at position the LENGTH OF stack MINUS one FROM stack  \n            END WHILE  \n            APPEND num TO stack  \n            INCREMENT count BY the LENGTH OF stack  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "digit-count-in-range", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION digitsCount(d, low, high)  \n        FUNCTION count_digit(n, digit)  \n            SET count TO zero  \n            SET power_of_10 TO one  \n            SET current TO n  \n            WHILE current GREATER THAN zero  \n                SET last TO the remainder of current DIVIDED BY ten  \n                SET current TO the quotient of current DIVIDED BY ten  \n                SET full_cycles TO current  \n                IF digit EQUALS zero  \n                    DECREMENT full_cycles BY one  \n                END IF  \n                INCREMENT count BY full_cycles MULTIPLIED BY power_of_10  \n                IF last GREATER THAN digit  \n                    INCREMENT count BY power_of_10  \n                ELSE IF last EQUALS digit  \n                    INCREMENT count BY the remainder of n DIVIDED BY power_of_10 PLUS one  \n                END IF  \n                SET power_of_10 TO power_of_10 MULTIPLIED BY ten  \n            END WHILE  \n            RETURN count  \n        END FUNCTION  \n\n        RETURN the value of count_digit with arguments high and d MINUS the value of count_digit with arguments low MINUS one and d  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-submatrices-that-sum-to-target", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numSubmatrixSumTarget(matrix, target)  \n        FUNCTION subarraySum(nums, target)  \n            SET count TO zero  \n            ASSIGN reference TO a new mapping from integers to integers called seen_sums  \n            SET cumulative_sum TO zero  \n            FOR each num IN nums  \n                SET cumulative_sum TO cumulative_sum PLUS num  \n                IF cumulative_sum EQUALS target THEN  \n                    INCREMENT count BY one  \n                END IF  \n                IF cumulative_sum MINUS target EXISTS AS A KEY IN seen_sums THEN  \n                    INCREMENT count BY the value associated with the key cumulative_sum MINUS target in seen_sums  \n                END IF  \n                INCREMENT the value associated with the key cumulative_sum in seen_sums BY one  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        SET rows TO the LENGTH OF matrix  \n        SET cols TO the LENGTH OF element at position zero of matrix  \n        SET total_count TO zero  \n        \n        FOR top FROM zero TO rows MINUS one  \n            ASSIGN reference TO a new list called current_cols containing cols number of zeros  \n            FOR bottom FROM top TO rows MINUS one  \n                FOR col FROM zero TO cols MINUS one  \n                    SET element at position col of current_cols TO element at position col of current_cols PLUS element at position col of element at position bottom of matrix  \n                END FOR  \n                SET total_count TO total_count PLUS subarraySum(current_cols, target)  \n            END FOR  \n        END FOR  \n        \n        RETURN total_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "confusing-number-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION confusingNumberII(n)  \n        SET rotate_map TO a collection mapping zero TO zero one TO one six TO nine eight TO eight nine TO six  \n        SET valid_digits TO a collection containing zero one six eight nine  \n        \n        FUNCTION is_confusing(num)  \n            SET original_num TO num  \n            SET rotated_num TO zero  \n            WHILE num GREATER THAN zero  \n                SET digit TO the remainder of num DIVIDED BY ten  \n                SET rotated_num TO rotated_num MULTIPLIED BY ten PLUS the value in rotate_map corresponding to digit  \n                SET num TO the integer division of num BY ten  \n            END WHILE  \n            RETURN rotated_num NOT EQUALS original_num  \n        END FUNCTION  \n        \n        FUNCTION count_confusing_numbers(limit current)  \n            IF current GREATER THAN limit  \n                RETURN zero  \n            END IF  \n            SET count TO one IF current NOT EQUALS zero AND is_confusing(current) IS true OTHERWISE zero  \n            FOR each digit IN valid_digits  \n                SET new_number TO current MULTIPLIED BY ten PLUS digit  \n                IF new_number EQUALS zero  \n                    CONTINUE TO next iteration  \n                END IF  \n                SET count TO count PLUS the result of count_confusing_numbers with arguments limit and new_number  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of count_confusing_numbers with arguments n and zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "divide-array-into-increasing-sequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canDivideIntoSubsequences(nums parameter, k parameter)  \n        SET freq TO the result of counting the frequency of each element in nums parameter  \n        SET max_freq TO the greatest value among all values in freq  \n        IF the length of nums parameter DIVIDED BY k parameter IS GREATER THAN OR EQUAL TO max_freq  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-sufficient-team", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestSufficientTeam(self, req_skills, people)  \n        SET skill_to_index TO empty dictionary  \n        SET index_counter TO zero  \n        FOR each skill IN req_skills  \n            ASSIGN skill_to_index at skill TO index_counter  \n            INCREMENT index_counter BY one  \n        END FOR  \n        SET total_skills TO the LENGTH OF req_skills  \n        SET total_people TO the LENGTH OF people  \n        SET people_skill_masks TO empty list of size total_people filled with zeroes  \n        FOR i FROM zero TO total_people MINUS one  \n            SET skill_list TO element at position i of people  \n            SET skill_mask TO zero  \n            FOR each skill IN skill_list  \n                SET skill_mask TO skill_mask OR one shifted LEFT BY skill_to_index at skill  \n            END FOR  \n            SET element at position i OF people_skill_masks TO skill_mask  \n        END FOR  \n        SET infinite_value TO infinity  \n        SET dp_min_team_size TO list of size two raised to total_skills filled with infinite_value  \n        SET dp_last_person_index TO list of size two raised to total_skills filled with zero  \n        SET dp_previous_skill_set TO list of size two raised to total_skills filled with zero  \n        SET element at position zero OF dp_min_team_size TO zero  \n        FOR current_skill_set FROM zero TO two raised to total_skills MINUS one  \n            IF element at position current_skill_set OF dp_min_team_size EQUALS infinite_value  \n                CONTINUE TO next iteration  \n            END IF  \n            FOR person_index FROM zero TO total_people MINUS one  \n                SET combined_skill_set TO current_skill_set OR element at position person_index OF people_skill_masks  \n                IF element at position current_skill_set OF dp_min_team_size PLUS one LESS THAN element at position combined_skill_set OF dp_min_team_size  \n                    SET element at position combined_skill_set OF dp_min_team_size TO element at position current_skill_set OF dp_min_team_size PLUS one  \n                    SET element at position combined_skill_set OF dp_last_person_index TO person_index  \n                    SET element at position combined_skill_set OF dp_previous_skill_set TO current_skill_set  \n                END IF  \n            END FOR  \n        END FOR  \n        SET final_skill_set TO two raised to total_skills MINUS one  \n        SET answer_team TO empty list  \n        WHILE final_skill_set NOT EQUALS zero  \n            APPEND element at position final_skill_set OF dp_last_person_index TO answer_team  \n            SET final_skill_set TO element at position final_skill_set OF dp_previous_skill_set  \n        END WHILE  \n        RETURN answer_team  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-chunked-palindrome-decomposition", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestDecomposition(text)  \n        SET left TO zero  \n        SET right TO the LENGTH OF text MINUS one  \n        SET left_part TO empty string  \n        SET right_part TO empty string  \n        SET k TO zero  \n        \n        WHILE left IS LESS THAN right  \n            SET left_part TO left_part CONCATENATED WITH the element at position left of text  \n            SET right_part TO the element at position right of text CONCATENATED WITH right_part  \n            \n            IF left_part EQUALS right_part  \n                INCREMENT k BY two  \n                SET left_part TO empty string  \n                SET right_part TO empty string  \n            END IF  \n            \n            INCREMENT left BY one  \n            DECREMENT right BY one  \n        END WHILE  \n        \n        IF left_part IS NOT empty string OR left EQUALS right  \n            INCREMENT k BY one  \n        END IF  \n        \n        RETURN k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-transforms-into-another-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canConvert(str1 str2)  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO empty mapping  \n        FOR each pair of char1 AND char2 IN corresponding elements of str1 AND str2  \n            IF char1 IN keys of conversion_map  \n                IF value at key char1 of conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET value at key char1 of conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the LENGTH OF the set of all unique characters in str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "last-substring-in-lexicographical-order", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM character IN s  \n        SET max_indices TO an EMPTY list  \n        FOR index FROM zero TO n MINUS one  \n            IF the element at position index of s EQUALS max_char  \n                APPEND index TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO an EMPTY string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF the natural language comparison of current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ones", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumNumberOfOnes(width height sideLength maxOnes)  \n        SET freq TO an empty list of zeros with length sideLength MULTIPLIED BY sideLength  \n        FOR variable i FROM zero TO width MINUS one  \n            FOR variable j FROM zero TO height MINUS one  \n                SET position TO the remainder of variable i DIVIDED BY sideLength MULTIPLIED BY sideLength PLUS the remainder of variable j DIVIDED BY sideLength  \n                INCREMENT element at position position of freq BY one  \n            END FOR  \n        END FOR  \n        SORT freq IN descending order  \n        SET total_sum TO zero  \n        FOR index FROM zero TO maxOnes MINUS one  \n            INCREMENT total_sum BY element at position index of freq  \n        END FOR  \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "make-array-strictly-increasing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION makeArrayIncreasing(arr1, arr2)  \n        CALL sort arr2 in ascending order  \n        SET dp TO a dictionary with key negative one mapped to value zero  \n        \n        FOR each num IN arr1  \n            SET new_dp TO an empty dictionary  \n            FOR each last_num and ops IN the items of dp  \n                IF the current num is GREATER THAN last_num THEN  \n                    SET the element at key num of new_dp TO the MINIMUM between the current value at key num of new_dp or positive infinity AND ops  \n                END IF  \n                \n                SET idx TO the position after the last occurrence of last_num in arr2 using binary search  \n                IF idx is LESS THAN the length of arr2 THEN  \n                    SET the element at key element at position idx of arr2 in new_dp TO the MINIMUM between the current value at that key or positive infinity AND ops PLUS one  \n                END IF  \n            END FOR  \n            \n            IF new_dp is empty THEN  \n                RETURN negative one  \n            END IF  \n            \n            ASSIGN dp TO new_dp  \n        END FOR  \n        \n        RETURN the MINIMUM value among all values in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "critical-connections-in-a-network", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION criticalConnections(n, connections)  \n        FUNCTION dfs(node, parent, disc, low, time, graph, critical)  \n            SET element at position node of disc TO element at position zero of time  \n            SET element at position node of low TO element at position zero of time  \n            INCREMENT element at position zero of time BY one  \n            \n            FOR each neighbor IN element at position node of graph  \n                IF element at position neighbor of disc EQUALS minus one THEN  \n                    CALL dfs WITH neighbor parent node disc low time graph critical  \n                    SET element at position node of low TO minimum value BETWEEN element at position node of low AND element at position neighbor of low  \n                    IF element at position neighbor of low GREATER THAN element at position node of disc THEN  \n                        APPEND list containing node and neighbor TO critical  \n                    END IF  \n                ELSE IF neighbor NOT EQUALS parent THEN  \n                    SET element at position node of low TO minimum value BETWEEN element at position node of low AND element at position neighbor of disc  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET graph TO empty list repeated n times  \n        FOR each pair u v IN connections  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n        \n        SET disc TO list containing minus one repeated n times  \n        SET low TO list containing minus one repeated n times  \n        SET time TO list containing zero  \n        \n        SET critical TO empty list  \n        \n        FOR each node FROM zero TO n MINUS one  \n            IF element at position node of disc EQUALS minus one THEN  \n                CALL dfs WITH node minus one disc low time graph critical  \n            END IF  \n        END FOR  \n        \n        RETURN critical  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-build-blocks", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minBuildTime(blocks AS list OF integers split AS integer)  \n        TRANSFORM blocks INTO a structure where the smallest element can be efficiently extracted repeatedly  \n        WHILE the count of elements in blocks GREATER THAN one  \n            EXTRACT the smallest element from blocks and ASSIGN it to first  \n            EXTRACT the next smallest element from blocks and ASSIGN it to second  \n            SET combined_time TO split PLUS the value of second  \n            INSERT combined_time INTO blocks maintaining the efficient smallest element extraction structure  \n        END WHILE  \n        RETURN the element at position one of blocks  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-items-by-groups-respecting-dependencies", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sortItems(n, m, group, beforeItems)  \n        FOR i FROM zero TO n MINUS one  \n            IF element at position i of group EQUALS negative one  \n                SET element at position i of group TO m  \n                INCREMENT m BY one  \n            END IF  \n        END FOR  \n\n        SET group_items TO empty mapping from key to list  \n        SET group_graph TO empty mapping from key to list  \n        SET item_graph TO empty mapping from key to list  \n        SET item_in_degree TO list of zeros with length n  \n        SET group_in_degree TO list of zeros with length m  \n\n        FOR i FROM zero TO n MINUS one  \n            APPEND i TO the list corresponding to key element at position i of group in group_items  \n        END FOR  \n\n        FOR i FROM zero TO n MINUS one  \n            FOR each before_element IN element at position i of beforeItems  \n                IF element at position before_element of group EQUALS element at position i of group  \n                    APPEND i TO the list corresponding to key before_element in item_graph  \n                    INCREMENT element at position i of item_in_degree BY one  \n                ELSE  \n                    APPEND element at position i of group TO the list corresponding to key element at position before_element of group in group_graph  \n                    INCREMENT element at position element at position i of group of group_in_degree BY one  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FUNCTION topological_sort(graph, in_degree, items)  \n            SET queue TO empty double ended queue containing each item from items WHERE element at position item of in_degree EQUALS zero  \n            SET result TO empty list  \n            WHILE queue is not empty  \n                SET u TO the element removed from the front of queue  \n                APPEND u TO result  \n                FOR each v IN element at position u of graph  \n                    DECREMENT element at position v of in_degree BY one  \n                    IF element at position v of in_degree EQUALS zero  \n                        APPEND v TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            IF the LENGTH OF result EQUALS the LENGTH OF items  \n                RETURN result  \n            ELSE  \n                RETURN empty list  \n            END IF  \n        END FUNCTION  \n\n        SET sorted_within_groups TO empty list  \n        FOR each items IN the values of group_items  \n            SET sorted_items TO CALL topological_sort WITH item_graph AND item_in_degree AND items  \n            IF LENGTH OF sorted_items EQUALS zero  \n                RETURN empty list  \n            END IF  \n            EXTEND sorted_within_groups BY sorted_items  \n        END FOR  \n\n        SET sorted_groups TO CALL topological_sort WITH group_graph AND group_in_degree AND list of integers from zero TO m MINUS one  \n        IF LENGTH OF sorted_groups EQUALS zero  \n            RETURN empty list  \n        END IF  \n\n        SET group_to_items_map TO empty mapping from key to list  \n        FOR each item IN sorted_within_groups  \n            APPEND item TO the list corresponding to key element at position item of group in group_to_items_map  \n        END FOR  \n\n        SET result TO empty list  \n        FOR each group_key IN sorted_groups  \n            EXTEND result BY the list corresponding to key group_key in group_to_items_map  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-reach-target-with-rotations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumMoves(grid)  \n        SET n TO the LENGTH OF grid  \n        SET queue TO a double ended queue CONTAINING a tuple of zero zero zero one zero  \n        SET visited TO a set CONTAINING a tuple of zero zero zero one  \n\n        WHILE the queue is not empty  \n            REMOVE from the left of queue and UNPACK INTO r1 c1 r2 c2 steps  \n            \n            IF r1 EQUALS n MINUS one AND c1 EQUALS n MINUS two AND r2 EQUALS n MINUS one AND c2 EQUALS n MINUS one  \n                RETURN steps  \n            END IF  \n            \n            IF c2 PLUS one LESS THAN n AND element at position r1 of grid AT position c1 PLUS one EQUALS zero AND element at position r2 of grid AT position c2 PLUS one EQUALS zero AND tuple of r1 c1 PLUS one r2 c2 PLUS one NOT IN visited  \n                ADD tuple of r1 c1 PLUS one r2 c2 PLUS one TO visited  \n                APPEND tuple of r1 c1 PLUS one r2 c2 PLUS one steps PLUS one TO queue  \n            END IF  \n            \n            IF r2 PLUS one LESS THAN n AND element at position r1 PLUS one of grid AT position c1 EQUALS zero AND element at position r2 PLUS one of grid AT position c2 EQUALS zero AND tuple of r1 PLUS one c1 r2 PLUS one c2 NOT IN visited  \n                ADD tuple of r1 PLUS one c1 r2 PLUS one c2 TO visited  \n                APPEND tuple of r1 PLUS one c1 r2 PLUS one c2 steps PLUS one TO queue  \n            END IF  \n            \n            IF r1 EQUALS r2 AND r1 PLUS one LESS THAN n AND element at position r1 PLUS one of grid AT position c1 EQUALS zero AND element at position r1 PLUS one of grid AT position c2 EQUALS zero AND tuple of r1 c1 r1 PLUS one c1 NOT IN visited  \n                ADD tuple of r1 c1 r1 PLUS one c1 TO visited  \n                APPEND tuple of r1 c1 r1 PLUS one c1 steps PLUS one TO queue  \n            END IF  \n            \n            IF c1 EQUALS c2 AND c1 PLUS one LESS THAN n AND element at position r1 of grid AT position c1 PLUS one EQUALS zero AND element at position r2 of grid AT position c2 PLUS one EQUALS zero AND tuple of r1 c1 r1 c1 PLUS one NOT IN visited  \n                ADD tuple of r1 c1 r1 c1 PLUS one TO visited  \n                APPEND tuple of r1 c1 r1 c1 PLUS one steps PLUS one TO queue  \n            END IF  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-palindrome-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isValidPalindrome(s, k)  \n        FUNCTION longest_palindromic_subseq(s)  \n            SET n TO the LENGTH OF s  \n            SET dp TO a two dimensional list with dimensions n BY n FILLED WITH zero  \n            FOR i FROM zero TO n MINUS one  \n                SET element at position i of element at position i of dp TO one  \n            END FOR  \n            FOR length FROM two TO n  \n                FOR i FROM zero TO n MINUS length  \n                    SET j TO i PLUS length MINUS one  \n                    IF element at position i of s EQUALS element at position j of s  \n                        SET element at position i of element at position j of dp TO element at position i PLUS one of element at position j MINUS one of dp PLUS two  \n                    ELSE  \n                        SET element at position i of element at position j of dp TO the GREATER OF element at position i PLUS one of element at position j of dp AND element at position i of element at position j MINUS one of dp  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN element at position zero of element at position n MINUS one of dp  \n        END FUNCTION  \n        SET longest_palindrome_length TO the RESULT OF longest_palindromic_subseq WITH PARAMETER s  \n        RETURN the LENGTH OF s MINUS longest_palindrome_length LESS THAN OR EQUAL TO k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dice-roll-simulation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION dieSimulator(n, rollMax)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a three dimensional list with dimensions n plus one by six by one more than the maximum value in rollMax filled with zero  \n        \n        FOR j FROM zero TO five  \n            SET element at position one of element at position j of element at position one of dp TO one  \n        END FOR  \n        \n        FOR i FROM two TO n  \n            FOR j FROM zero TO five  \n                FOR k FROM one TO the element at position j of rollMax  \n                    IF k GREATER THAN one  \n                        SET element at position k of element at position j of element at position i of dp TO the element at position k minus one of element at position j of element at position i minus one of dp  \n                    ELSE  \n                        SET temp_sum TO zero  \n                        FOR x FROM zero TO five  \n                            IF x NOT EQUALS j  \n                                FOR y FROM one TO the element at position x of rollMax  \n                                    INCREMENT temp_sum BY the element at position y of element at position x of element at position i minus one of dp  \n                                END FOR  \n                            END IF  \n                        END FOR  \n                        SET element at position k of element at position j of element at position i of dp TO temp_sum MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        SET result TO zero  \n        FOR j FROM zero TO five  \n            FOR k FROM one TO the element at position j of rollMax  \n                INCREMENT result BY the element at position k of element at position j of element at position n of dp  \n            END FOR  \n        END FOR  \n        \n        RETURN result MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-equal-frequency", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxEqualFreq(nums)  \n        SET count TO a new Counter object that counts each number's frequency  \n        SET freq TO a new Counter object that counts frequencies of frequencies  \n        SET max_len TO zero  \n        \n        FOR each index i AND each number num IN enumeration of nums  \n            INCREMENT the count of num BY one  \n            \n            IF the count of num is GREATER THAN one  \n                DECREMENT the frequency of the count of num MINUS one BY one  \n                IF the frequency of the count of num MINUS one EQUALS zero  \n                    REMOVE the frequency entry corresponding to count of num MINUS one from freq  \n                END IF  \n            END IF  \n            \n            INCREMENT the frequency of the count of num BY one  \n            \n            IF the LENGTH OF freq EQUALS one AND (the frequency for one EXISTS IN freq OR the only frequency value EQUALS one)  \n                SET max_len TO i PLUS one  \n            ELSE IF the LENGTH OF freq EQUALS two AND (the frequency for one EXISTS IN freq AND the frequency for one EQUALS one OR (the DIFFERENCE BETWEEN the maximum key of freq AND the minimum key of freq EQUALS one AND the frequency for the maximum key of freq EQUALS one))  \n                SET max_len TO i PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN max_len  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "divide-chocolate", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximizeSweetness(sweetness, k)  \n        FUNCTION canDivide(min_sweet)  \n            SET pieces TO zero  \n            SET current_sweet TO zero  \n            FOR each sweet IN sweetness  \n                SET current_sweet TO current_sweet PLUS sweet  \n                IF current_sweet GREATER THAN OR EQUAL TO min_sweet  \n                    INCREMENT pieces BY one  \n                    SET current_sweet TO zero  \n                    IF pieces GREATER THAN k  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN pieces GREATER THAN k  \n        END FUNCTION  \n\n        SET left TO the smallest element IN sweetness  \n        SET right TO the total sum OF sweetness DIVIDED BY k PLUS one  \n        SET result TO zero  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the sum OF left AND right DIVIDED BY two  \n            IF canDivide(mid) IS true  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tiling-a-rectangle-with-the-fewest-squares", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION tilingRectangle(n m)  \n        FUNCTION backtrack(heights moves)  \n            IF all elements of heights EQUALS n THEN  \n                SET min_moves TO the smaller value BETWEEN min_moves AND moves  \n                RETURN  \n            END IF  \n            \n            IF moves GREATER THAN OR EQUAL TO min_moves THEN  \n                RETURN  \n            END IF  \n            \n            SET min_height TO the smallest value IN heights  \n            SET left TO the position OF the first occurrence OF min_height IN heights  \n            SET right TO left  \n            \n            WHILE right LESS THAN m AND element at position right OF heights EQUALS min_height DO  \n                INCREMENT right BY one  \n            END WHILE  \n            \n            FOR size FROM the difference BETWEEN right AND left DOWN TO one DO  \n                IF FOR every index i FROM zero TO size MINUS one element at position left PLUS i OF heights PLUS size LESS THAN OR EQUAL TO n THEN  \n                    SET new_heights TO a copy OF heights  \n                    FOR i FROM zero TO size MINUS one DO  \n                        INCREMENT element at position left PLUS i OF new_heights BY size  \n                    END FOR  \n                    CALL backtrack WITH new_heights AND moves PLUS one  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET min_moves TO positive infinity  \n        CALL backtrack WITH a list OF zero REPEATED m TIMES AND zero  \n        RETURN min_moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-removal", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumMoves(arr)  \n        SET n TO the LENGTH OF arr  \n        SET dp TO a two dimensional list of zeros with n rows and n columns  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i of element at position i of dp TO one  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS two  \n            IF element at position i of arr EQUALS element at position i PLUS one of arr  \n                SET element at position i of element at position i PLUS one of dp TO one  \n            ELSE  \n                SET element at position i of element at position i PLUS one of dp TO two  \n            END IF  \n        END FOR  \n        \n        FOR length FROM three TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                IF element at position i of arr EQUALS element at position j of arr  \n                    SET element at position i of element at position j of dp TO element at position i PLUS one of element at position j MINUS one of dp  \n                ELSE  \n                    SET element at position i of element at position j of dp TO positive infinity  \n                    FOR k FROM i TO j MINUS one  \n                        SET current_sum TO element at position i of element at position k of dp PLUS element at position k PLUS one of element at position j of dp  \n                        IF current_sum LESS THAN element at position i of element at position j of dp  \n                            SET element at position i of element at position j of dp TO current_sum  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position zero of element at position n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-it-is-a-good-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isGoodArray(nums)  \n        SET total_gcd TO the result of applying the greatest common divisor function cumulatively over all elements of nums  \n        IF total_gcd EQUALS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "handshakes-that-dont-cross", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfWays(numPeople)  \n        SET MODULO TO ten RAISED TO THE POWER OF nine PLUS seven  \n        INITIALIZE dp AS a list of zeros with LENGTH EQUAL TO numPeople PLUS one  \n        SET element at position zero of dp TO one  \n        SET element at position two of dp TO one  \n        \n        FOR i FROM four TO numPeople IN STEPS OF two  \n            FOR j FROM zero TO i MINUS one IN STEPS OF two  \n                SET element at position i of dp TO element at position i of dp PLUS element at position j of dp MULTIPLIED BY element at position i MINUS two MINUS j of dp  \n                SET element at position i of dp TO element at position i of dp MODULO MODULO  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position numPeople of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-moves-to-move-a-box-to-their-target-location", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minPushBox(grid)  \n        SET directions TO list containing tuple with negative one and zero, tuple with one and zero, tuple with zero and negative one, tuple with zero and one  \n        FOR variable i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR variable j FROM zero TO the LENGTH OF the element at position i of grid MINUS one  \n                IF element at position i of grid at position j EQUALS the character S  \n                    SET player_start TO tuple containing i and j  \n                ELSE IF element at position i of grid at position j EQUALS the character B  \n                    SET box_start TO tuple containing i and j  \n                ELSE IF element at position i of grid at position j EQUALS the character T  \n                    SET target TO tuple containing i and j  \n                END IF  \n            END FOR  \n        END FOR  \n        ASSIGN reference TO a new empty double-ended queue containing tuple with player_start box_start and zero  \n        ASSIGN reference TO a new empty set  \n        ADD tuple with player_start and box_start TO the set referenced by visited  \n        WHILE the queue referenced by queue is not empty  \n            REMOVE and ASSIGN the leftmost element of the queue referenced by queue TO variables player_pos box_pos and push_count  \n            IF variable box_pos EQUALS variable target  \n                RETURN push_count  \n            END IF  \n            FOR each tuple dx and dy IN directions  \n                SET new_player_pos TO tuple containing the element at position zero of player_pos PLUS dx and element at position one of player_pos PLUS dy  \n                IF the result of calling FUNCTION is_valid_position with arguments self new_player_pos and grid  \n                    IF new_player_pos EQUALS box_pos  \n                        SET new_box_pos TO tuple containing the element at position zero of box_pos PLUS dx and element at position one of box_pos PLUS dy  \n                        IF the result of calling FUNCTION is_valid_position with arguments self new_box_pos and grid AND tuple with new_player_pos and new_box_pos NOT IN visited  \n                            ADD tuple with new_player_pos and new_box_pos TO visited  \n                            APPEND tuple with new_player_pos new_box_pos and push_count PLUS one TO the queue referenced by queue  \n                        END IF  \n                    ELSE  \n                        IF tuple with new_player_pos and box_pos NOT IN visited  \n                            ADD tuple with new_player_pos and box_pos TO visited  \n                            APPEND tuple with new_player_pos box_pos and push_count TO the queue referenced by queue  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN result of negative one  \n    END FUNCTION  \n\n    FUNCTION is_valid_position(position grid)  \n        SET x TO the element at position zero of position  \n        SET y TO the element at position one of position  \n        RETURN the result of zero LESS THAN OR EQUAL TO x AND x LESS THAN the LENGTH OF grid AND zero LESS THAN OR EQUAL TO y AND y LESS THAN the LENGTH OF the element at position zero of grid AND element at position x of grid at position y NOT EQUALS the character representing a hash  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-stay-in-the-same-place-after-some-steps", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numWays(steps arrLen)  \n        SET MOD TO ten POWERED BY nine PLUS seven  \n        SET max_index TO the MINIMUM OF the INTEGER DIVISION OF steps BY two AND arrLen MINUS one  \n        INITIALIZE dp AS a list WITH max_index PLUS one ELEMENTS ALL SET TO zero  \n        SET element at position zero OF dp TO one  \n        FOR each iteration FROM one TO steps  \n            SET prev_dp TO a COPY OF dp  \n            FOR each index i FROM zero TO max_index  \n                SET element at position i OF dp TO element at position i OF prev_dp  \n                IF i GREATER THAN zero THEN  \n                    SET element at position i OF dp TO element at position i OF dp PLUS element at position i MINUS one OF prev_dp  \n                    SET element at position i OF dp TO element at position i OF dp MODULO MOD  \n                END IF  \n                IF i LESS THAN max_index THEN  \n                    SET element at position i OF dp TO element at position i OF dp PLUS element at position i PLUS one OF prev_dp  \n                    SET element at position i OF dp TO element at position i OF dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position zero OF dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION palindromePartition(s k)  \n        FUNCTION min_changes_to_palindrome(sub)  \n            SET i TO zero  \n            SET j TO the LENGTH OF sub MINUS one  \n            SET changes TO zero  \n            WHILE i LESS THAN j  \n                IF element at position i of sub NOT EQUALS element at position j of sub  \n                    INCREMENT changes BY one  \n                END IF  \n                INCREMENT i BY one  \n                DECREMENT j BY one  \n            END WHILE  \n            RETURN changes  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF s  \n        CREATE dp AS two dimensional list WITH n PLUS one rows AND k PLUS one columns FILLED WITH infinity  \n        SET element at position zero row AND position zero column of dp TO zero  \n\n        FOR i FROM one TO n  \n            FOR j FROM one TO the smaller value BETWEEN k AND i  \n                FOR start FROM zero TO i MINUS one  \n                    SET changes TO CALL min_changes_to_palindrome WITH substring from position start TO position i MINUS one OF s  \n                    SET element at position i row AND position j column of dp TO the smaller value BETWEEN element at position i row AND position j column of dp AND element at position start row AND position j MINUS one column of dp PLUS changes  \n                END FOR  \n            END FOR  \n        END FOR  \n\n        RETURN element at position n row AND position k column of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minFlips(mat)  \n        FUNCTION flip(matrix x y)  \n            SET directions TO list of pairs negative one zero PLUS one zero ZERO negative one ZERO one ZERO zero  \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n  \n                    SET element at position nx of matrix element at position ny TO one MINUS element at position nx of matrix element at position ny  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION matrix_to_tuple(matrix)  \n            SET result TO empty list  \n            FOR each row IN matrix  \n                APPEND tuple converted from row TO result  \n            END FOR  \n            RETURN tuple converted from result  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF element at position zero of mat  \n        SET target TO tuple converted from list built by repeating tuple converted from list built by repeating zero for n times for m times  \n        SET initial_state TO matrix_to_tuple of mat  \n        SET queue TO list containing pair initial_state and zero  \n        SET visited TO empty set  \n        ADD initial_state TO visited  \n\n        WHILE queue is not empty  \n            REMOVE element at position zero FROM queue AND ASSIGN to current_state and steps  \n            IF current_state EQUALS target  \n                RETURN steps  \n            END IF  \n\n            SET current_matrix TO list built by converting each row in current_state to list  \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    SET next_matrix TO deep copy of current_matrix  \n                    CALL flip ON next_matrix with parameters i and j  \n                    SET next_state TO matrix_to_tuple of next_matrix  \n                    IF next_state NOT IN visited  \n                        ADD next_state TO visited  \n                        APPEND pair next_state and steps PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-path-in-a-grid-with-obstacles-elimination", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION shortestPath(grid parameter LIST OF LIST OF integer, k parameter integer) RETURNS integer  \n        IF grid IS empty OR element at position zero of grid IS empty  \n            RETURN negative one  \n        END IF  \n        \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF k GREATER THAN OR EQUAL TO m PLUS n MINUS two  \n            RETURN m PLUS n MINUS two  \n        END IF  \n        \n        SET directions TO list of pairs representing movement UP zero PLUS ONE RIGHT one PLUS ZERO DOWN zero MINUS ONE LEFT minus ONE PLUS ZERO  \n        \n        SET queue TO a new deque CONTAINING a tuple of zero zero k zero  \n        \n        SET visited TO a new set CONTAINING a tuple of zero zero k  \n        \n        WHILE the LENGTH OF queue GREATER THAN zero  \n            REMOVE and RETURN the leftmost element FROM queue ASSIGN TO variables x y remaining_k steps  \n            \n            IF x EQUALS m MINUS one AND y EQUALS n MINUS one  \n                RETURN steps  \n            END IF  \n            \n            FOR each pair dx dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                \n                IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n  \n                    SET new_k TO remaining_k MINUS element at position nx of grid AT position ny  \n                    IF new_k GREATER THAN OR EQUAL TO zero AND the tuple nx ny new_k IS NOT IN visited  \n                        ADD the tuple nx ny new_k TO visited  \n                        APPEND the tuple nx ny new_k steps PLUS one TO queue  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-insertion-steps-to-make-a-string-palindrome", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minInsertions(s)  \n        FUNCTION longest_palindromic_subsequence(s)  \n            SET n TO the LENGTH OF s  \n            CREATE dp AS a two dimensional array OF size n BY n FILLED WITH zero  \n            FOR i FROM zero TO n MINUS one  \n                SET element at position i AT position i OF dp TO one  \n            END FOR  \n            FOR cl FROM two TO n  \n                FOR i FROM zero TO n MINUS cl  \n                    SET j TO i PLUS cl MINUS one  \n                    IF element at position i OF s EQUALS element at position j OF s AND cl EQUALS two THEN  \n                        SET element at position i AT position j OF dp TO two  \n                    ELSE IF element at position i OF s EQUALS element at position j OF s THEN  \n                        SET element at position i AT position j OF dp TO element at position i PLUS one AT position j MINUS one OF dp PLUS two  \n                    ELSE  \n                        SET element at position i AT position j OF dp TO the GREATER VALUE BETWEEN element at position i AT position j MINUS one OF dp AND element at position i PLUS one AT position j OF dp  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN element at position zero AT position n MINUS one OF dp  \n        END FUNCTION  \n        RETURN the LENGTH OF s MINUS longest_palindromic_subsequence(s)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-echo-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION distinctEchoSubstrings(text)  \n        SET n TO the LENGTH OF text  \n        CREATE an empty SET called substrings  \n        FOR each length FROM one TO n DIVIDED BY two INCLUSIVE  \n            FOR each start FROM zero TO n MINUS two MULTIPLIED BY length INCLUSIVE  \n                SET a TO the SUBSTRING from position start TO position start PLUS length MINUS one OF text  \n                SET b TO the SUBSTRING from position start PLUS length TO position start PLUS two MULTIPLIED BY length MINUS one OF text  \n                IF a EQUALS b  \n                    ADD concatenation of a AND b TO the SET substrings  \n                END IF  \n            END FOR  \n        END FOR  \n        SET result TO the SIZE OF substrings  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-distance-to-type-a-word-using-two-fingers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDistance(word)  \n        FUNCTION distance(c1 c2)  \n            IF c1 EQUALS None  \n                RETURN zero  \n            END IF  \n            SET x1 TO the INTEGER DIVISION of the UNICODE CODE POINT of character c1 MINUS the UNICODE CODE POINT of uppercase letter A BY six  \n            SET y1 TO the REMAINDER of the UNICODE CODE POINT of character c1 MINUS the UNICODE CODE POINT of uppercase letter A DIVIDED BY six  \n            SET x2 TO the INTEGER DIVISION of the UNICODE CODE POINT of character c2 MINUS the UNICODE CODE POINT of uppercase letter A BY six  \n            SET y2 TO the REMAINDER of the UNICODE CODE POINT of character c2 MINUS the UNICODE CODE POINT of uppercase letter A DIVIDED BY six  \n            RETURN the ABSOLUTE VALUE of x1 MINUS x2 PLUS the ABSOLUTE VALUE of y1 MINUS y2  \n        END FUNCTION  \n        \n        FUNCTION dp(i f1 f2)  \n            IF i EQUALS the LENGTH OF word  \n                RETURN zero  \n            END IF  \n            SET c TO the element at position i of word  \n            SET d1 TO distance of f1 c PLUS dp of i PLUS one c f2  \n            SET d2 TO distance of f2 c PLUS dp of i PLUS one f1 c  \n            RETURN the MINIMUM of d1 AND d2  \n        END FUNCTION  \n        \n        RETURN dp of zero None None  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-subarray-to-maximize-array-value", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxValueAfterReverse(nums)  \n        SET n TO the LENGTH OF nums  \n        IF n EQUALS two  \n            RETURN the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element at position zero of nums AND the element at position one of nums  \n        END IF  \n\n        SET initial_value TO zero  \n        FOR i FROM one TO n MINUS one  \n            INCREMENT initial_value BY the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element at position i of nums AND the element at position i MINUS one of nums  \n        END FOR  \n\n        SET max_edge_gain TO zero  \n        FOR i FROM one TO n MINUS one  \n            SET current_gain TO the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element at position zero of nums AND the element at position i of nums MINUS the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element at position i of nums AND the element at position i MINUS one of nums  \n            IF current_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO current_gain  \n            END IF  \n        END FOR  \n\n        FOR i FROM zero TO n MINUS two  \n            SET current_gain TO the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element at position n MINUS one of nums AND the element at position i of nums MINUS the ABSOLUTE VALUE OF the DIFFERENCE BETWEEN the element at position i PLUS one of nums AND the element at position i of nums  \n            IF current_gain GREATER THAN max_edge_gain  \n                SET max_edge_gain TO current_gain  \n            END IF  \n        END FOR  \n\n        SET min_pair TO the MINIMUM OF the MAXIMUMS BETWEEN the element at position i of nums AND the element at position i PLUS one of nums FOR i FROM zero TO n MINUS two  \n        SET max_pair TO the MAXIMUM OF the MINIMUMS BETWEEN the element at position i of nums AND the element at position i PLUS one of nums FOR i FROM zero TO n MINUS two  \n\n        SET general_gain TO the MAXIMUM OF zero AND two MULTIPLIED BY the DIFFERENCE BETWEEN max_pair AND min_pair  \n\n        RETURN initial_value PLUS the MAXIMUM OF max_edge_gain AND general_gain  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-difficulty-of-a-job-schedule", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDifficulty(jobDifficulty, d)  \n        SET n TO the LENGTH OF jobDifficulty  \n        IF n LESS THAN d THEN  \n            RETURN the NEGATIVE of one  \n        END IF  \n        \n        FUNCTION dp(i, d)  \n            IF d EQUALS one THEN  \n                RETURN the MAXIMUM value IN the SUBLIST OF jobDifficulty STARTING AT position i TO the END  \n            END IF  \n            \n            SET min_difficulty TO positive infinity  \n            SET current_max TO zero  \n            FOR j FROM i TO n MINUS d  \n                SET current_max TO the GREATER BETWEEN current_max AND element at position j OF jobDifficulty  \n                SET candidate TO current_max PLUS dp(j PLUS one, d MINUS one)  \n                SET min_difficulty TO the SMALLER BETWEEN min_difficulty AND candidate  \n            END FOR  \n            \n            RETURN min_difficulty  \n        END FUNCTION  \n        \n        RETURN dp(zero, d)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game-v", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxJumps(arr parameter named arr OF TYPE List OF Integer, parameter named d OF TYPE Integer) RETURNS Integer  \n        FUNCTION dp(parameter named i OF TYPE Integer) RETURNS Integer  \n            SET max_jumps TO one  \n            FOR x FROM one TO d  \n                IF the value of i PLUS x LESS THAN the length of arr THEN  \n                    IF the element at position i PLUS x of arr GREATER THAN OR EQUAL TO the element at position i of arr THEN  \n                        BREAK the loop  \n                    END IF  \n                    IF the sum of one PLUS the result of dp with argument i PLUS x GREATER THAN max_jumps THEN  \n                        SET max_jumps TO the sum of one PLUS the result of dp with argument i PLUS x  \n                    END IF  \n                END IF  \n            END FOR  \n            FOR x FROM one TO d  \n                IF the value of i MINUS x GREATER THAN OR EQUAL TO zero THEN  \n                    IF the element at position i MINUS x of arr GREATER THAN OR EQUAL TO the element at position i of arr THEN  \n                        BREAK the loop  \n                    END IF  \n                    IF the sum of one PLUS the result of dp with argument i MINUS x GREATER THAN max_jumps THEN  \n                        SET max_jumps TO the sum of one PLUS the result of dp with argument i MINUS x  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN max_jumps  \n        END FUNCTION  \n        SET max_value TO zero  \n        FOR i FROM zero TO the length of arr MINUS one  \n            SET current TO dp with argument i  \n            IF current GREATER THAN max_value THEN  \n                SET max_value TO current  \n            END IF  \n        END FOR  \n        RETURN max_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "jump-game-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minJumps(arr)  \n        SET n TO the LENGTH OF arr  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n          \n        SET value_indices TO an empty mapping from values to list of positions  \n        FOR each position i AND element value IN arr  \n            APPEND position i TO the list corresponding to value in value_indices  \n        END FOR  \n          \n        SET queue TO an empty double ended queue  \n        APPEND a pair consisting of zero and zero TO queue  \n        SET visited TO a set containing zero  \n          \n        WHILE queue is not empty  \n            REMOVE the first element from queue and ASSIGN the first part TO current_index and the second part TO steps  \n              \n            IF current_index EQUALS n MINUS one  \n                RETURN steps  \n            END IF  \n              \n            SET next_indices TO an empty list  \n            APPEND the value current_index PLUS one TO next_indices  \n            APPEND the value current_index MINUS one TO next_indices  \n            APPEND the entire list mapped by the value at position current_index in arr FROM value_indices TO next_indices  \n              \n            FOR each next_index IN next_indices  \n                IF next_index IS GREATER THAN OR EQUAL TO zero AND next_index IS LESS THAN n AND next_index IS NOT IN visited  \n                    ADD next_index TO visited  \n                    APPEND a pair consisting of next_index and steps PLUS one TO queue  \n                END IF  \n            END FOR  \n              \n            SET the list mapped by the value at position current_index in arr FROM value_indices TO an empty list  \n        END WHILE  \n          \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-students-taking-exam", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxStudents(seats)  \n        SET m TO the LENGTH OF seats  \n        SET n TO the LENGTH OF element at position zero of seats  \n        \n        SET broken TO a list of zero values with the LENGTH OF m  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position j of element at position i of seats EQUALS the character hash  \n                    SET element at position i of broken TO element at position i of broken OR BITWISE LEFT SHIFT one BY j positions  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION is_valid(arrangement)  \n            RETURN the BITWISE AND of arrangement AND the BITWISE RIGHT SHIFT of arrangement BY one position EQUALS zero  \n        END FUNCTION  \n        \n        SET dp TO a list of empty dictionaries with the LENGTH OF m  \n        \n        FOR arrangement FROM zero TO BITWISE LEFT SHIFT one BY n positions MINUS one  \n            IF is_valid(arrangement) AND the BITWISE AND of arrangement AND element at position zero of broken EQUALS zero  \n                SET the dictionary at position zero of dp WITH key arrangement TO the COUNT OF ONES in the binary representation of arrangement  \n            END IF  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            FOR arrangement FROM zero TO BITWISE LEFT SHIFT one BY n positions MINUS one  \n                IF is_valid(arrangement) AND the BITWISE AND of arrangement AND element at position i of broken EQUALS zero  \n                    SET max_students TO zero  \n                    FOR each prev_arrangement IN keys of the dictionary at position i MINUS one of dp  \n                        IF the BITWISE AND of arrangement AND the BITWISE RIGHT SHIFT of prev_arrangement BY one position EQUALS zero AND the BITWISE AND of arrangement AND the BITWISE LEFT SHIFT of prev_arrangement BY one position EQUALS zero  \n                            IF the value associated with key prev_arrangement in the dictionary at position i MINUS one of dp GREATER THAN max_students  \n                                SET max_students TO the value associated with key prev_arrangement in the dictionary at position i MINUS one of dp  \n                            END IF  \n                        END IF  \n                    END FOR  \n                    SET the dictionary at position i of dp WITH key arrangement TO max_students PLUS the COUNT OF ONES in the binary representation of arrangement  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF the dictionary at the last position of dp IS NOT empty  \n            RETURN the MAXIMUM value among all values in the dictionary at the last position of dp  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-target-array-with-multiple-sums", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isPossible(target)  \n        SET max_heap TO empty list  \n        FOR each number IN target  \n            APPEND negative of number TO max_heap  \n        END FOR  \n        CALL heapify WITH max_heap  \n        \n        SET total_sum TO zero  \n        FOR each number IN target  \n            INCREMENT total_sum BY number  \n        END FOR  \n        \n        WHILE element at position zero of max_heap LESS THAN negative of one holds  \n            SET largest TO negative of result of heappop called with max_heap  \n            SET rest_sum TO total_sum MINUS largest  \n            \n            IF largest LESS THAN OR EQUAL TO rest_sum OR rest_sum EQUALS zero THEN  \n                RETURN False  \n            END IF  \n            \n            SET new_value TO largest MODULO rest_sum  \n            IF new_value EQUALS zero AND rest_sum NOT EQUAL TO one THEN  \n                RETURN False  \n            END IF  \n            \n            SET total_sum TO rest_sum PLUS new_value  \n            CALL heappush WITH max_heap AND negative of new_value  \n        END WHILE  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-all-valid-pickup-and-delivery-options", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countOrders(n)  \n        SET MOD TO one billion PLUS seven  \n        SET count TO one  \n        FOR i FROM two TO n  \n            SET count TO count MULTIPLIED BY i MULTIPLIED BY (two MULTIPLIED BY i MINUS one) MODULO MOD  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-multiple-of-three", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO a mapping of digits to their frequencies  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder when total_sum is divided by three  \n        IF remainder EQUALS one  \n            FOR each digit IN the list containing one four seven  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing two five eight  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit IN the list containing two five eight  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing one four seven  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        SET result TO an empty list  \n        FOR digit FROM nine DOWN TO zero  \n            APPEND the string form of digit repeated frequency of digit in count times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF final_number IS NOT empty AND the element at position one of final_number EQUALS zero  \n            RETURN zero as string  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO a list of elements each describing a pair of vertical AND horizontal movement increments as zero PLUS one zero MINUS one one zero MINUS one zero  \n        SET costs TO a list of m elements EACH BEING a list of n elements EACH SET TO positive infinity  \n        SET element at position zero of element at position zero of costs TO zero  \n        SET pq TO a list containing a single tuple consisting of zero zero zero representing the initial cost AND starting position  \n        SET visited TO an empty set  \n        \n        WHILE pq is not empty  \n            REMOVE the tuple with the smallest first element FROM pq AND UNPACK to cost i j  \n            \n            IF the pair consisting of i AND j is in visited  \n                CONTINUE to the next iteration  \n            END IF  \n            ADD the pair consisting of i AND j TO visited  \n            \n            IF i EQUALS m MINUS one AND j EQUALS n MINUS one  \n                RETURN cost  \n            END IF  \n            \n            FOR each pair of index k AND tuple of di dj IN the enumeration of directions  \n                SET ni TO i PLUS di  \n                SET nj TO j PLUS dj  \n                IF ni IS GREATER THAN OR EQUAL TO zero AND ni IS LESS THAN m AND nj IS GREATER THAN OR EQUAL TO zero AND nj IS LESS THAN n  \n                    IF k PLUS one NOT EQUALS element at position i of grid at position j  \n                        SET additional_cost TO one  \n                    ELSE  \n                        SET additional_cost TO zero  \n                    END IF  \n                    SET new_cost TO cost PLUS additional_cost  \n                    IF new_cost IS LESS THAN element at position ni of costs at position nj  \n                        SET element at position ni of costs at position nj TO new_cost  \n                        APPEND the tuple consisting of new_cost ni nj TO pq  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-position-after-t-seconds", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION frogPosition(n parameter, edges parameter, t parameter, target parameter)  \n        IF n parameter EQUALS one  \n            RETURN the number one point zero  \n        END IF  \n        SET graph TO a new mapping with default value as empty list  \n        FOR each pair u parameter and v parameter IN edges parameter  \n            APPEND v parameter TO element at position u parameter of graph  \n            APPEND u parameter TO element at position v parameter of graph  \n        END FOR  \n        SET queue TO a new double ended queue containing a tuple of the number one the number one point zero and the number zero  \n        SET visited TO a new set containing the number one  \n        WHILE queue is not empty  \n            REMOVE and ASSIGN first element of queue TO current_node parameter current_probability parameter current_time parameter  \n            IF current_time parameter EQUALS t parameter OR current_node parameter NOT EQUALS one AND THE LENGTH OF element at position current_node parameter of graph EQUALS one  \n                IF current_node parameter EQUALS target parameter  \n                    RETURN current_probability parameter  \n                ELSE  \n                    CONTINUE to the next iteration of the WHILE loop  \n                END IF  \n            END IF  \n            SET possible_moves TO THE LENGTH OF element at position current_node parameter of graph MINUS one IF current_node parameter NOT EQUALS one ELSE zero  \n            FOR each neighbor parameter IN element at position current_node parameter of graph  \n                IF neighbor parameter NOT IN visited  \n                    ADD neighbor parameter TO visited  \n                    APPEND a tuple of neighbor parameter current_probability parameter DIVIDED BY possible_moves current_time parameter PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the number zero point zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-performance-of-a-team", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxPerformance(n parameter, speed parameter, efficiency parameter, k parameter)  \n        SET engineers TO list of pairs each consisting of element at position index of efficiency parameter AND element at position index of speed parameter FOR each index IN range from zero TO n parameter MINUS one  \n        SORT engineers IN ORDER OF elements at position zero in each pair from HIGHEST TO LOWEST  \n        SET speed_heap TO empty list  \n        SET speed_sum TO zero  \n        SET max_performance TO zero  \n        FOR each pair consisting of eff variable and spd variable IN engineers  \n            ADD spd variable TO speed_heap USING heap push operation  \n            INCREMENT speed_sum BY spd variable  \n            IF the LENGTH OF speed_heap IS GREATER THAN k parameter  \n                SET smallest_speed TO the element REMOVED FROM speed_heap USING heap pop operation  \n                DECREMENT speed_sum BY smallest_speed  \n            END IF  \n            SET current_performance TO speed_sum MULTIPLIED BY eff variable  \n            IF current_performance IS GREATER THAN max_performance  \n                SET max_performance TO current_performance  \n            END IF  \n        END FOR  \n        RETURN max_performance MODULO one billion PLUS seven  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pizza-with-3n-slices", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSizeSlices(slices)  \n        SET n TO the LENGTH OF slices DIVIDED BY three  \n        \n        FUNCTION dp(start end k)  \n            IF k EQUALS zero OR start GREATER THAN end THEN  \n                RETURN zero  \n            END IF  \n            SET pick TO the element at position start of slices PLUS dp(start PLUS two end k MINUS one)  \n            SET skip TO dp(start PLUS one end k)  \n            RETURN the GREATER OF pick AND skip  \n        END FUNCTION  \n        \n        SET case1 TO dp(one the LENGTH OF slices MINUS one n)  \n        SET case2 TO dp(zero the LENGTH OF slices MINUS two n)  \n        \n        RETURN the GREATER OF case1 AND case2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-happy-prefix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPrefix WITH PARAMETER s  \n        SET n TO the LENGTH OF s  \n        SET lps TO a list of zero repeated n times  \n        SET j TO zero  \n        FOR i FROM one TO n MINUS one  \n            WHILE j GREATER THAN zero AND the element at position i of s NOT EQUALS the element at position j of s  \n                SET j TO the element at position j MINUS one of lps  \n            END WHILE  \n            IF the element at position i of s EQUALS the element at position j of s  \n                INCREMENT j BY one  \n                SET the element at position i of lps TO j  \n            END IF  \n        END FOR  \n        SET longest_happy_prefix_length TO the element at position n MINUS one of lps  \n        RETURN substring from position zero TO position longest_happy_prefix_length of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reducing-dishes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSatisfaction WITH PARAMETER satisfaction  \n        SORT satisfaction IN DESCENDING ORDER  \n        SET max_satisfaction TO zero  \n        SET current_satisfaction TO zero  \n        SET total_satisfaction TO zero  \n        FOR each element s IN satisfaction  \n            INCREMENT current_satisfaction BY s  \n            INCREMENT total_satisfaction BY current_satisfaction  \n            IF total_satisfaction GREATER THAN max_satisfaction  \n                SET max_satisfaction TO total_satisfaction  \n            END IF  \n        END FOR  \n        RETURN max_satisfaction  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGameIII(stoneValue)  \n        SET n TO the LENGTH OF stoneValue  \n        SET dp TO a list of zeroes with the LENGTH OF n PLUS one  \n        FOR i FROM n MINUS one TO zero BY MINUS one  \n            SET dp at position i TO the element at position i of stoneValue MINUS dp at position i PLUS one  \n            IF i PLUS two IS LESS THAN OR EQUAL TO n  \n                SET dp at position i TO the GREATER OF dp at position i AND the SUM OF the element at position i of stoneValue PLUS the element at position i PLUS one of stoneValue MINUS dp at position i PLUS two  \n            END IF  \n            IF i PLUS three IS LESS THAN OR EQUAL TO n  \n                SET dp at position i TO the GREATER OF dp at position i AND the SUM OF the element at position i of stoneValue PLUS the element at position i PLUS one of stoneValue PLUS the element at position i PLUS two of stoneValue MINUS dp at position i PLUS three  \n            END IF  \n        END FOR  \n        IF dp at position zero IS GREATER THAN zero  \n            RETURN the word Alice  \n        ELSE IF dp at position zero IS LESS THAN zero  \n            RETURN the word Bob  \n        ELSE  \n            RETURN the word Tie  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-paint-n-3-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numOfWays WITH PARAMETER n  \n        SET MOD TO one billion PLUS seven  \n        SET a TO six  \n        SET b TO six  \n        FOR each integer index FROM two TO n  \n            SET new_a TO three MULTIPLIED BY a PLUS two MULTIPLIED BY b  \n            SET new_b TO two MULTIPLIED BY a PLUS two MULTIPLIED BY b  \n            SET a TO new_a MODULO MOD  \n            SET b TO new_b MODULO MOD  \n        END FOR  \n        SET result TO a PLUS b  \n        SET result TO result MODULO MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-the-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArrays(s, k)  \n        SET MOD to one billion PLUS seven  \n        SET n to the LENGTH OF s  \n          \n        INITIALIZE dp AS a list of zero values of size n PLUS one  \n        SET element at position zero of dp TO one  \n          \n        FOR each i FROM one TO n inclusive  \n            FOR each j FROM zero TO i MINUS one inclusive  \n                IF element at position j of s NOT EQUALS character zero AND  \n                   the integer value represented by the substring of s from position j TO position i MINUS one IS GREATER THAN OR EQUAL TO one AND IS LESS THAN OR EQUAL TO k THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numOfArrays(n integer parameter m integer parameter k integer parameter) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE dp AS a three dimensional list of size n PLUS one by m PLUS one by k PLUS one filled with zero  \n        \n        FOR j FROM one TO m  \n            SET element at position j of list at position one of list dp TO one at position one  \n        END FOR  \n        \n        FOR i FROM two TO n  \n            FOR j FROM one TO m  \n                FOR p FROM one TO k  \n                    FOR x FROM one TO j MINUS one  \n                        SET element at position p of list at position j of list at position i of list dp TO the element at position p of list at position j of list at position i of list dp PLUS the element at position p MINUS one of list at position x of list at position i MINUS one of list dp MODULO MOD  \n                    END FOR  \n                    SET element at position p of list at position j of list at position i of list dp TO the element at position p of list at position j of list at position i of list dp PLUS the element at position p of list at position j of list at position i MINUS one of list dp MULTIPLIED BY j MODULO MOD  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        SET result TO zero  \n        FOR j FROM one TO m  \n            SET result TO result PLUS the element at position k of list at position j of list at position n of list dp MODULO MOD  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "constrained-subsequence-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION constrainedSubsetSum(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a list of zeros with LENGTH n  \n        SET element at position zero of dp TO element at position zero of nums  \n        SET max_sum TO element at position zero of nums  \n        INITIALIZE q AS a deque containing element zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position zero of q is a valid index AND element at position element at position zero of q of dp IS GREATER THAN zero  \n                SET value TO element at position element at position zero of q of dp  \n            ELSE  \n                SET value TO zero  \n            END IF  \n            SET element at position i of dp TO element at position i of nums PLUS value  \n            IF max_sum IS LESS THAN element at position i of dp  \n                SET max_sum TO element at position i of dp  \n            END IF  \n            WHILE the LENGTH OF q IS GREATER THAN zero AND element at position i of dp IS GREATER THAN OR EQUAL TO element at position element at position last of q of dp  \n                REMOVE element at position last from q  \n            END WHILE  \n            APPEND i TO q  \n            IF element at position zero of q EQUALS i MINUS k  \n                REMOVE element at position zero from q  \n            END IF  \n        END FOR  \n        RETURN max_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(mat parameter, k parameter)  \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF the element at position zero of mat  \n        SET initial_sum TO zero  \n        FOR each row IN mat  \n            INCREMENT initial_sum BY element at position zero of row  \n        END FOR  \n        SET initial_indices TO a sequence of zeros of length m  \n        SET min_heap TO a list containing a pair of initial_sum AND initial_indices converted to a tuple  \n        SET visited TO a set containing the tuple of initial_indices  \n\n        WHILE k GREATER THAN zero holds  \n            REMOVE and ASSIGN the pair current_sum AND indices FROM the smallest element of min_heap  \n            DECREMENT k BY one  \n\n            IF k EQUALS zero THEN  \n                RETURN current_sum  \n            END IF  \n\n            FOR i FROM zero TO m MINUS one  \n                IF element at position i of indices PLUS one LESS THAN n THEN  \n                    SET new_indices TO a copy of indices converted to a list  \n                    INCREMENT element at position i of new_indices BY one  \n                    SET new_indices_tuple TO new_indices converted to a tuple  \n                    SET new_sum TO current_sum MINUS element at position i AND element at position i of indices of mat PLUS element at position i AND element at position i of new_indices of mat  \n                    \n                    IF new_indices_tuple NOT IN visited THEN  \n                        ADD new_indices_tuple TO visited  \n                        ADD the pair new_sum AND new_indices_tuple TO min_heap maintaining heap property  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN the negative value of one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-dot-product-of-two-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxDotProduct(nums1, nums2)  \n        SET m TO the LENGTH OF nums1  \n        SET n TO the LENGTH OF nums2  \n        \n        SET dp TO a list of m PLUS one elements  \n        FOR index_i FROM zero TO m  \n            SET row TO a list of n PLUS one elements each initialized TO negative infinity  \n            ASSIGN row TO the element at position index_i of dp  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                SET current_product TO element at position i MINUS one of nums1 MULTIPLIED BY element at position j MINUS one of nums2  \n                \n                SET max_value TO the greatest value among current_product  \n                AND element at position i MINUS one of dp at position j  \n                AND element at position i of dp at position j MINUS one  \n                AND element at position i MINUS one of dp at position j MINUS one PLUS current_product  \n                \n                SET element at position i of dp at position j TO max_value  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m of dp at position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cherry-pickup-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dp(r c1 c2)  \n            IF c1 LESS THAN zero OR c1 GREATER THAN OR EQUAL TO cols OR c2 LESS THAN zero OR c2 GREATER THAN OR EQUAL TO cols  \n                RETURN zero  \n            END IF  \n            \n            IF c1 EQUALS c2  \n                SET cherries TO element at position r of grid AT position c1  \n            ELSE  \n                SET cherries TO element at position r of grid AT position c1 PLUS element at position r of grid AT position c2  \n            END IF  \n            \n            IF r EQUALS rows MINUS one  \n                RETURN cherries  \n            END IF  \n            \n            SET max_cherries TO zero  \n            FOR each dc1 IN the set of values minus one zero and one  \n                FOR each dc2 IN the set of values minus one zero and one  \n                    SET possible_cherries TO dp(r PLUS one c1 PLUS dc1 c2 PLUS dc2)  \n                    IF possible_cherries GREATER THAN max_cherries  \n                        SET max_cherries TO possible_cherries  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN cherries PLUS max_cherries  \n        END FUNCTION  \n        \n        RETURN dp(zero zero cols MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "paint-house-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost WITH PARAMETERS houses cost m n target  \n        FUNCTION dp WITH PARAMETERS i prev_color groups  \n            IF i EQUALS m  \n                IF groups EQUALS target  \n                    RETURN zero  \n                ELSE  \n                    RETURN positive infinity  \n                END IF  \n            END IF  \n            \n            IF element at position i of houses NOT EQUALS zero  \n                SET new_groups TO groups PLUS one IF element at position i of houses NOT EQUALS prev_color OTHERWISE groups  \n                RETURN dp WITH ARGUMENTS i PLUS one element at position i of houses new_groups  \n            END IF  \n            \n            SET min_cost TO positive infinity  \n            FOR color FROM one TO n  \n                SET new_groups TO groups PLUS one IF color NOT EQUALS prev_color OTHERWISE groups  \n                SET current_cost TO element at position i of cost at position color MINUS one PLUS dp WITH ARGUMENTS i PLUS one color new_groups  \n                IF current_cost LESS THAN min_cost  \n                    SET min_cost TO current_cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        SET result TO dp WITH ARGUMENTS zero zero zero  \n        IF result NOT EQUALS positive infinity  \n            RETURN result  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "allocate-mailboxes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(houses LIST OF INTEGERS k INTEGER)  \n        SORT houses IN ASCENDING ORDER  \n        SET n TO the LENGTH OF houses  \n        \n        INITIALIZE cost AS a TWO DIMENSIONAL LIST OF SIZE n BY n WITH all ELEMENTS SET TO zero  \n        FOR i FROM n MINUS one DOWNTO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET cost AT position i and position j TO cost AT position i PLUS one and position j MINUS one PLUS the ELEMENT AT position j OF houses MINUS the ELEMENT AT position i OF houses  \n            END FOR  \n        END FOR  \n        \n        INITIALIZE dp AS a TWO DIMENSIONAL LIST OF SIZE n PLUS one BY k PLUS one WITH all ELEMENTS SET TO positive infinity  \n        SET dp AT position zero and position zero TO zero  \n        \n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                FOR p FROM zero TO i MINUS one  \n                    SET dp AT position i and position j TO THE MINIMUM OF dp AT position i and position j AND dp AT position p and position j MINUS one PLUS cost AT position p and position i MINUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN dp AT position n and position k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parallel-courses-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minNumberOfSemesters(n, relations, k)  \n        SET graph TO a mapping with default value as empty list  \n        SET in_degree TO a list of zeros with the length equal to n PLUS one  \n        \n        FOR each previous course AND next course IN relations  \n            APPEND next course TO the list at key previous course IN graph  \n            INCREMENT the value at position next course IN in_degree BY one  \n        END FOR  \n        \n        SET queue TO an empty double ended queue  \n        FOR course FROM one TO n  \n            IF the value at position course IN in_degree EQUALS zero  \n                APPEND course TO queue  \n            END IF  \n        END FOR  \n        \n        SET semesters TO zero  \n        \n        WHILE queue is not empty  \n            SET limit TO the smaller value BETWEEN k AND the length of queue  \n            FOR iteration FROM one TO limit  \n                REMOVE AND RETURN the element from the front position of queue AND ASSIGN to current_course  \n                FOR each next_course IN the list at key current_course IN graph  \n                    DECREMENT the value at position next_course IN in_degree BY one  \n                    IF the value at position next_course IN in_degree EQUALS zero  \n                        APPEND next_course TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT semesters BY one  \n        END WHILE  \n        \n        RETURN semesters  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-value-of-equation", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxValueOfEquation(points, k)  \n        SET max_value TO negative infinity  \n        ASSIGN a new empty deque TO deque_  \n        \n        FOR each pair xj and yj IN points  \n            WHILE deque_ is not empty AND the value of xj MINUS the second element of the element at position zero of deque_ is GREATER THAN k  \n                REMOVE the element at position zero FROM deque_  \n            END WHILE  \n            \n            IF deque_ is not empty  \n                SET max_value TO the greater value BETWEEN max_value AND the sum of yj PLUS xj PLUS the first element of the element at position zero of deque_  \n            END IF  \n            \n            WHILE deque_ is not empty AND the difference between yj MINUS xj is GREATER THAN OR EQUAL TO the first element of the element at the last position of deque_  \n                REMOVE the element at the last position FROM deque_  \n            END WHILE  \n            \n            APPEND the pair of the difference between yj MINUS xj AND the value xj TO deque_  \n        END FOR  \n        \n        RETURN max_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION winnerSquareGame(n)  \n        SET dp TO a list of False values with length equal to n PLUS one  \n        FOR i FROM one TO n  \n            SET j TO one  \n            WHILE j MULTIPLIED BY j IS LESS THAN OR EQUAL TO i  \n                IF NOT the element at position i MINUS j MULTIPLIED BY j of dp EQUALS True  \n                    SET the element at position i of dp TO True  \n                    BREAK out of the WHILE loop  \n                END IF  \n                INCREMENT j BY one  \n            END WHILE  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-position-for-a-service-centre", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getMinDistSum(positions)  \n        SET n TO the LENGTH OF positions  \n        SET x TO zero  \n        SET y TO zero  \n        FOR each element consisting of x1 and y1 IN positions  \n            INCREMENT x BY x1  \n            INCREMENT y BY y1  \n        END FOR  \n        SET x TO x DIVIDED BY n  \n        SET y TO y DIVIDED BY n  \n        SET decay TO zero POINT nine nine nine  \n        SET eps TO a very small positive number one TIMES ten TO THE POWER OF MINUS six  \n        SET alpha TO zero POINT five  \n        WHILE TRUE  \n            SET grad_x TO zero  \n            SET grad_y TO zero  \n            SET dist TO zero  \n            FOR each element consisting of x1 and y1 IN positions  \n                SET a TO x MINUS x1  \n                SET b TO y MINUS y1  \n                SET c TO the square root of a MULTIPLIED BY a PLUS b MULTIPLIED BY b  \n                INCREMENT grad_x BY a DIVIDED BY c PLUS a very small positive number one TIMES ten TO THE POWER OF MINUS eight  \n                INCREMENT grad_y BY b DIVIDED BY c PLUS a very small positive number one TIMES ten TO THE POWER OF MINUS eight  \n                INCREMENT dist BY c  \n            END FOR  \n            SET dx TO grad_x MULTIPLIED BY alpha  \n            SET dy TO grad_y MULTIPLIED BY alpha  \n            DECREMENT x BY dx  \n            DECREMENT y BY dy  \n            MULTIPLY alpha BY decay AND ASSIGN TO alpha  \n            IF the absolute value of dx IS LESS THAN OR EQUAL TO eps AND the absolute value of dy IS LESS THAN OR EQUAL TO eps  \n                RETURN dist  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-non-overlapping-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxNumOfSubstrings(s)  \n        SET first TO an empty dictionary mapping characters to integer positions  \n        SET last TO an empty dictionary mapping characters to integer positions  \n        FOR each index and character in the enumeration of s  \n            IF character is not a key in first  \n                SET the value of first at key character TO index  \n            END IF  \n            SET the value of last at key character TO index  \n        END FOR  \n\n        SET intervals TO an empty list of pairs of integers  \n        FOR each character in the keys of first  \n            SET start TO the value of first at key character  \n            SET end TO the value of last at key character  \n            SET i TO start  \n            WHILE i is less than or equal to end  \n                IF the value of first at key element at position i of s is less than start  \n                    EXIT the WHILE loop  \n                END IF  \n                SET end TO the maximum of end and the value of last at key element at position i of s  \n                INCREMENT i BY one  \n            END WHILE  \n            IF the WHILE loop completed without exiting early  \n                APPEND the pair consisting of start and end TO intervals  \n            END IF  \n        END FOR  \n\n        SORT the list intervals in ascending order according to the second element of each pair  \n\n        SET result TO an empty list of substrings  \n        SET prev_end TO the integer value less than zero by one unit  \n        FOR each pair of start and end IN intervals  \n            IF start is greater than prev_end  \n                APPEND the substring of s from position start TO position end inclusive TO result  \n                SET prev_end TO end  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-a-value-of-a-mysterious-function-closest-to-target", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION closestToTarget(arr PARAMETERS arr PARAMETER target)  \n        SET seen TO an empty set of unique values  \n        SET min_diff TO infinity value  \n        FOR each num IN arr  \n            SET new_seen TO an empty set  \n            FOR each x IN seen  \n                ADD the bitwise AND of num AND x TO new_seen  \n            END FOR  \n            SET seen TO the union of new_seen AND the set containing num  \n            FOR each val IN seen  \n                SET diff TO the absolute value of val MINUS target  \n                IF diff LESS THAN min_diff THEN  \n                    SET min_diff TO diff  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-increments-on-subarrays-to-form-a-target-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minNumberOperations(target)  \n        SET operations TO zero  \n        SET previous TO zero  \n        FOR each current IN target  \n            IF current GREATER THAN previous  \n                INCREMENT operations BY current MINUS previous  \n            END IF  \n            SET previous TO current  \n        END FOR  \n        RETURN operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-compression-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getLengthOfOptimalCompression(s, k)  \n        FUNCTION dp(i, k, prev_char, prev_count)  \n            IF k LESS THAN zero  \n                RETURN infinity  \n            END IF  \n            IF i EQUALS the LENGTH OF s  \n                RETURN zero  \n            END IF  \n            IF element at position i of s EQUALS prev_char  \n                IF prev_count EQUALS one OR prev_count EQUALS nine OR prev_count EQUALS ninety-nine  \n                    SET increment TO one  \n                ELSE  \n                    SET increment TO zero  \n                END IF  \n                RETURN increment PLUS dp(i PLUS one, k, prev_char, prev_count PLUS one)  \n            ELSE  \n                SET keep TO one PLUS dp(i PLUS one, k, element at position i of s, one)  \n                SET delete TO dp(i PLUS one, k MINUS one, prev_char, prev_count)  \n                RETURN the minimum value between keep and delete  \n            END IF  \n        END FUNCTION  \n        RETURN dp(zero, k, an empty string, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "get-the-maximum-score", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxSum(nums1 nums1 LIST OF INTEGER nums2 nums2 LIST OF INTEGER) RETURNS INTEGER  \n        SET i TO zero  \n        SET j TO zero  \n        SET sum1 TO zero  \n        SET sum2 TO zero  \n        SET MOD TO ten RAISED TO THE POWER OF nine PLUS one  \n        \n        WHILE i LESS THAN THE LENGTH OF nums1 AND j LESS THAN THE LENGTH OF nums2  \n            IF element at position i of nums1 LESS THAN element at position j of nums2  \n                INCREMENT sum1 BY element at position i of nums1  \n                INCREMENT i BY one  \n            ELSE IF element at position i of nums1 GREATER THAN element at position j of nums2  \n                INCREMENT sum2 BY element at position j of nums2  \n                INCREMENT j BY one  \n            ELSE  \n                SET sum1 TO the GREATER VALUE BETWEEN sum1 AND sum2 PLUS element at position i of nums1  \n                SET sum2 TO sum1  \n                INCREMENT i BY one  \n                INCREMENT j BY one  \n            END IF  \n        END WHILE  \n        \n        WHILE i LESS THAN THE LENGTH OF nums1  \n            INCREMENT sum1 BY element at position i of nums1  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        WHILE j LESS THAN THE LENGTH OF nums2  \n            INCREMENT sum2 BY element at position j of nums2  \n            INCREMENT j BY one  \n        END WHILE  \n        \n        RETURN the GREATER VALUE BETWEEN sum1 AND sum2 MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-longest-awesome-substring", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestAwesome(s)  \n        SET prefix_map TO a map from zero to negative one  \n        SET prefix_xor TO zero  \n        SET max_length TO zero  \n        FOR each index i AND character char IN s with enumeration  \n            SET digit TO the integer value of character char  \n            SET prefix_xor TO prefix_xor XOR a value with one shifted left by digit times  \n            IF prefix_xor IS a key in prefix_map THEN  \n                SET max_length TO the larger of max_length AND the difference between i AND the element at position prefix_xor of prefix_map  \n            END IF  \n            FOR each index j FROM zero TO nine  \n                SET flipped TO prefix_xor XOR a value with one shifted left by j times  \n                IF flipped IS a key in prefix_map THEN  \n                    SET max_length TO the larger of max_length AND the difference between i AND the element at position flipped of prefix_map  \n                END IF  \n            END FOR  \n            IF prefix_xor IS NOT a key in prefix_map THEN  \n                SET the element at position prefix_xor of prefix_map TO i  \n            END IF  \n        END FOR  \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-cut-a-stick", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO the sorted result of appending zero and n to cuts  \n        \n        FUNCTION dp(left, right)  \n            IF the result of right MINUS left is LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing infinity  \n            FOR i FROM the result of left PLUS one TO the result of right MINUS one  \n                SET cost TO the element at position right of cuts MINUS the element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost IS LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the result of the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-most-similar-path-in-a-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION mostSimilar(n targetPath roads names)  \n        SET graph TO a new mapping with default empty list  \n        FOR each u v pair IN roads  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n        SET m TO the LENGTH OF targetPath  \n        FUNCTION dp(i j)  \n            IF i EQUALS zero THEN  \n                IF element at position j of names NOT EQUALS element at position i of targetPath THEN  \n                    RETURN one AND list containing j  \n                ELSE  \n                    RETURN zero AND list containing j  \n                END IF  \n            END IF  \n            SET min_cost TO positive infinity  \n            SET min_path TO empty list  \n            FOR each k IN element at position j of graph  \n                SET cost_path_pair TO dp(i MINUS one j)  \n                SET cost TO first element of cost_path_pair  \n                SET path TO second element of cost_path_pair  \n                IF cost LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                    SET min_path TO path  \n                END IF  \n            END FOR  \n            IF element at position j of names NOT EQUALS element at position i of targetPath THEN  \n                SET current_cost TO min_cost PLUS one  \n            ELSE  \n                SET current_cost TO min_cost  \n            END IF  \n            RETURN current_cost AND concatenation of min_path AND list containing j  \n        END FUNCTION  \n        SET min_cost TO positive infinity  \n        SET min_path TO empty list  \n        FOR each j FROM zero TO n MINUS one  \n            SET cost_path_pair TO dp(m MINUS one j)  \n            SET cost TO first element of cost_path_pair  \n            SET path TO second element of cost_path_pair  \n            IF cost LESS THAN min_cost THEN  \n                SET min_cost TO cost  \n                SET min_path TO path  \n            END IF  \n        END FOR  \n        RETURN min_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-days-to-eat-n-oranges", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDays(n)  \n        FUNCTION dp(remaining)  \n            IF remaining LESS THAN OR EQUAL TO one  \n                RETURN remaining  \n            END IF  \n            SET option_one TO the remainder of remaining DIVIDED BY two PLUS dp(the quotient of remaining DIVIDED BY two)  \n            SET option_two TO the remainder of remaining DIVIDED BY three PLUS dp(the quotient of remaining DIVIDED BY three)  \n            SET minimum_option TO the smaller value BETWEEN option_one AND option_two  \n            RETURN one PLUS minimum_option  \n        END FUNCTION  \n        RETURN dp(n)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-v", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGameV(stoneValue)  \n        SET prefix_sum TO a new list of zeros with the length equal to the length of stoneValue PLUS one  \n        FOR index i FROM zero TO the length of stoneValue MINUS one  \n            SET element at position i PLUS one of prefix_sum TO element at position i of prefix_sum PLUS element at position i of stoneValue  \n        END FOR  \n        \n        FUNCTION get_range_sum(left, right)  \n            RETURN element at position right PLUS one of prefix_sum MINUS element at position left of prefix_sum  \n        END FUNCTION  \n        \n        FUNCTION dp(left, right)  \n            IF left EQUALS right THEN  \n                RETURN zero  \n            END IF  \n            SET max_score TO zero  \n            FOR index i FROM left TO right MINUS one  \n                SET left_sum TO the result of get_range_sum with parameters left and i  \n                SET right_sum TO the result of get_range_sum with parameters i PLUS one and right  \n                IF left_sum LESS THAN right_sum THEN  \n                    SET max_score TO the maximum of max_score AND left_sum PLUS the result of dp with parameters left and i  \n                ELSE IF left_sum GREATER THAN right_sum THEN  \n                    SET max_score TO the maximum of max_score AND right_sum PLUS the result of dp with parameters i PLUS one and right  \n                ELSE  \n                    SET max_score TO the maximum among max_score AND left_sum PLUS the result of dp with parameters left and i AND right_sum PLUS the result of dp with parameters i PLUS one and right  \n                END IF  \n            END FOR  \n            RETURN max_score  \n        END FUNCTION  \n        \n        RETURN the result of dp with parameters zero and the length of stoneValue MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-days-to-disconnect-island", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minDays(grid)  \n        FUNCTION dfs(x, y, visited)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero of grid OR the tuple of x and y IS IN visited OR element at position x of grid at position y EQUALS zero  \n                RETURN  \n            END IF  \n            ADD the tuple of x and y TO visited  \n            FOR each pair dx and dy IN the collection of pairs negative one and zero PLUS one and zero PLUS zero and negative one PLUS zero and one  \n                CALL dfs WITH the SUM of x PLUS dx AND the SUM of y PLUS dy AND visited  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION is_connected()  \n            SET visited TO an empty set  \n            SET land_cells TO the collection of tuples i AND j FOR each i FROM zero TO the LENGTH OF grid MINUS one FOR each j FROM zero TO the LENGTH OF element at position zero of grid MINUS one WHERE element at position i of grid at position j EQUALS one  \n            IF the LENGTH OF land_cells EQUALS zero  \n                RETURN True  \n            END IF  \n            CALL dfs WITH the element at position zero of the tuple at position zero of land_cells AND the element at position one of the tuple at position zero of land_cells AND visited  \n            RETURN the LENGTH OF visited EQUALS the LENGTH OF land_cells  \n        END FUNCTION  \n\n        IF NOT the RESULT OF is_connected()  \n            RETURN zero  \n        END IF  \n\n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid at position j EQUALS one  \n                    SET element at position i of grid at position j TO zero  \n                    IF NOT the RESULT OF is_connected()  \n                        RETURN one  \n                    END IF  \n                    SET element at position i of grid at position j TO one  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-reorder-array-to-get-same-bst", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numOfWays(nums)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n  \n        FUNCTION count_ways(arr)  \n            IF the LENGTH OF arr LESS THAN OR EQUAL TO one THEN  \n                RETURN one  \n            END IF  \n  \n            SET root TO element at position one of arr  \n            SET left_subtree TO an empty list  \n            SET right_subtree TO an empty list  \n  \n            FOR each element x IN arr  \n                IF x LESS THAN root THEN  \n                    APPEND x TO left_subtree  \n                ELSE IF x GREATER THAN root THEN  \n                    APPEND x TO right_subtree  \n                END IF  \n            END FOR  \n  \n            SET ways_left TO count_ways(left_subtree)  \n            SET ways_right TO count_ways(right_subtree)  \n  \n            SET total_ways TO the combination of the sum of the LENGTH OF left_subtree PLUS the LENGTH OF right_subtree CHOOSE the LENGTH OF left_subtree  \n  \n            RETURN the product of ways_left MULTIPLIED BY ways_right MULTIPLIED BY total_ways MODULO MOD  \n        END FUNCTION  \n  \n        RETURN the difference of count_ways(nums) MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-all-possible-routes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countRoutes(locations ALL INTEGERS, start INTEGER, finish INTEGER, fuel INTEGER) RETURNS INTEGER  \n        SET MOD TO ten RAISED TO THE power OF nine PLUS one  \n        SET n TO the LENGTH OF locations  \n        \n        FUNCTION dp(city INTEGER, remaining_fuel INTEGER) RETURNS INTEGER  \n            IF remaining_fuel LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET routes TO zero  \n            IF city EQUALS finish  \n                SET routes TO one  \n            END IF  \n            FOR next_city FROM zero TO n MINUS one  \n                IF next_city NOT EQUALS city  \n                    SET fuel_cost TO the ABSOLUTE VALUE OF the element at position city of locations MINUS the element at position next_city of locations  \n                    IF remaining_fuel GREATER THAN OR EQUAL TO fuel_cost  \n                        SET routes TO routes PLUS the CALL OF dp WITH next_city AND remaining_fuel MINUS fuel_cost  \n                        SET routes TO routes MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN routes  \n        END FUNCTION  \n        \n        RETURN the CALL OF dp WITH start AND fuel  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self n)  \n        SET self.parent TO list of numbers from zero TO n INCLUSIVE  \n        SET self.rank TO list of zero repeated n PLUS one times  \n        SET self.count TO n  \n    END FUNCTION  \n  \n    FUNCTION find(self u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO result of self.find applied TO element at position u of self.parent  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n  \n    FUNCTION union(self u v)  \n        SET rootU TO result of self.find applied TO u  \n        SET rootV TO result of self.find applied TO v  \n        IF rootU NOT EQUALS rootV THEN  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank THEN  \n                SET element at position rootV of self.parent TO rootU  \n            ELSE IF element at position rootU of self.rank LESS THAN element at position rootV of self.rank THEN  \n                SET element at position rootU of self.parent TO rootV  \n            ELSE  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.rank BY one  \n            END IF  \n            DECREMENT self.count BY one  \n            RETURN True  \n        END IF  \n        RETURN False  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION maxNumEdgesToRemove(self n edges)  \n        SET uf_common TO new UnionFind initialized with n  \n        SET uf_alice TO new UnionFind initialized with n  \n        SET uf_bob TO new UnionFind initialized with n  \n  \n        SET used_edges TO zero  \n  \n        FOR each element consisting of t u v IN edges  \n            IF t EQUALS three THEN  \n                IF result of uf_common.union applied TO u v IS True THEN  \n                    CALL uf_alice.union WITH u v  \n                    CALL uf_bob.union WITH u v  \n                    INCREMENT used_edges BY one  \n                END IF  \n            END IF  \n        END FOR  \n  \n        FOR each element consisting of t u v IN edges  \n            IF t EQUALS one AND result of uf_alice.union applied TO u v IS True THEN  \n                INCREMENT used_edges BY one  \n            ELSE IF t EQUALS two AND result of uf_bob.union applied TO u v IS True THEN  \n                INCREMENT used_edges BY one  \n            END IF  \n        END FOR  \n  \n        IF uf_alice.count EQUALS one AND uf_bob.count EQUALS one THEN  \n            RETURN the LENGTH OF edges MINUS used_edges  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-string-is-transformable-with-substring-sort-operations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isTransformable WITH PARAMETERS s t  \n        CREATE a mapping from digits to empty lists called pos  \n        FOR each index i and character c IN the sequence s  \n            ADD the index i TO the heap list corresponding to the digit represented by the character c in pos  \n        END FOR  \n        FOR each index i and character c IN the sequence t  \n            SET digit TO the digit represented by the character c  \n            IF the list corresponding to digit in pos IS empty THEN  \n                RETURN false  \n            END IF  \n            FOR each number smaller FROM zero TO digit MINUS one  \n                IF the list corresponding to smaller in pos IS NOT empty AND the smallest element in that list IS LESS THAN the smallest element in the list for digit in pos THEN  \n                    RETURN false  \n                END IF  \n            END FOR  \n            REMOVE the smallest element FROM the list corresponding to digit in pos  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strange-printer-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION isPrintable(targetGrid)  \n        SET color_bounds TO a mapping with default value as a list of four elements where first element is positive infinity second element is positive infinity third element is negative infinity fourth element is negative infinity  \n        \n        FOR r FROM zero TO the LENGTH OF targetGrid MINUS one  \n            FOR c FROM zero TO the LENGTH OF element at position zero of targetGrid MINUS one  \n                SET color TO element at position r of targetGrid at position c  \n                SET element at position zero of color_bounds at position color TO the minimum value BETWEEN element at position zero of color_bounds at position color AND r  \n                SET element at position one of color_bounds at position color TO the minimum value BETWEEN element at position one of color_bounds at position color AND c  \n                SET element at position two of color_bounds at position color TO the maximum value BETWEEN element at position two of color_bounds at position color AND r  \n                SET element at position three of color_bounds at position color TO the maximum value BETWEEN element at position three of color_bounds at position color AND c  \n            END FOR  \n        END FOR  \n        \n        SET graph TO a mapping with default value as an empty list  \n        SET in_degree TO a mapping with default integer value zero  \n        \n        FOR each color AND bounding box composed of minr minc maxr maxc IN color_bounds  \n            FOR r FROM minr TO maxr  \n                FOR c FROM minc TO maxc  \n                    IF element at position r of targetGrid at position c NOT EQUALS color  \n                        SET other_color TO element at position r of targetGrid at position c  \n                        APPEND color TO element at position other_color of graph  \n                        INCREMENT element at position color of in_degree BY one  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        SET queue TO a double ended queue initialized with all colors from color_bounds for which element at position color of in_degree EQUALS zero  \n        SET visited_colors TO zero  \n        \n        WHILE queue is not empty  \n            REMOVE and RETURN the leftmost element from queue INTO variable color  \n            INCREMENT visited_colors BY one  \n            FOR each next_color IN element at position color of graph  \n                DECREMENT element at position next_color of in_degree BY one  \n                IF element at position next_color of in_degree EQUALS zero  \n                    APPEND next_color TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the boolean value of visited_colors EQUALS the LENGTH OF color_bounds  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-achievable-transfer-requests", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumRequests WITH PARAMETERS n requests  \n        SET max_requests TO zero  \n        SET num_requests TO the LENGTH OF requests  \n        FOR mask FROM zero TO the NUMBER OF TWO RAISED TO THE POWER OF num_requests MINUS one  \n            SET balance TO a LIST OF zero repeated n times  \n            SET count TO zero  \n            FOR i FROM zero TO num_requests MINUS one  \n                IF the BITWISE AND of mask AND the NUMBER OF TWO RAISED TO THE POWER OF i IS NOT EQUAL TO zero  \n                    SET from_building TO the ELEMENT AT POSITION i OF requests FIRST ELEMENT  \n                    SET to_building TO the ELEMENT AT POSITION i OF requests SECOND ELEMENT  \n                    DECREMENT the ELEMENT AT POSITION from_building OF balance BY one  \n                    INCREMENT the ELEMENT AT POSITION to_building OF balance BY one  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n            IF all ELEMENTS OF balance ARE EQUAL TO zero  \n                IF max_requests IS LESS THAN count  \n                    SET max_requests TO count  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_requests  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-visible-points", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION visiblePoints(points, angle, location)  \n        SET angles TO empty list  \n        SET extra_points TO zero  \n        \n        FOR each element COMPOSED OF x AND y IN points  \n            IF x EQUALS element at position zero of location AND y EQUALS element at position one of location  \n                INCREMENT extra_points BY one  \n                CONTINUE to next iteration  \n            END IF  \n            \n            SET angle_rad TO arctangent of the difference between y and element at position one of location OVER the difference between x and element at position zero of location  \n            SET angle_deg TO angle_rad converted to degrees  \n            APPEND angle_deg TO angles  \n        END FOR  \n        \n        SORT angles in ascending order  \n        \n        SET angles TO concatenation of angles AND each element in angles incremented by three hundred sixty  \n        \n        SET max_visible TO zero  \n        SET left TO zero  \n        \n        FOR right FROM zero TO the length of angles MINUS one  \n            WHILE difference between element at position right of angles AND element at position left of angles GREATER THAN angle  \n                INCREMENT left BY one  \n            END WHILE  \n            IF difference between right AND left PLUS one GREATER THAN max_visible  \n                SET max_visible TO difference between right AND left PLUS one  \n            END IF  \n        END FOR  \n        \n        RETURN sum of max_visible AND extra_points  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-one-bit-operations-to-make-integers-zero", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumOneBitOperations(n)  \n        IF n EQUALS zero  \n            RETURN zero  \n        END IF  \n        SET k TO zero  \n        WHILE two RAISED TO THE POWER OF k PLUS one LESS THAN OR EQUALS n  \n            INCREMENT k BY one  \n        END WHILE  \n        SET most_significant_bit TO two RAISED TO THE POWER OF k  \n        RETURN two RAISED TO THE POWER OF k PLUS one MINUS one MINUS self CALL minimumOneBitOperations WITH n EXCLUSIVE OR most_significant_bit  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-subtrees-with-max-distance-between-cities", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSubgraphsForEachDiameter(n, edges)  \n        SET graph TO an empty map from integer to list  \n        FOR each integer i FROM one TO n  \n            SET the element at key i of graph TO an empty list  \n        END FOR  \n        FOR each pair u AND v IN edges  \n            APPEND v TO the list at key u of graph  \n            APPEND u TO the list at key v of graph  \n        END FOR  \n        \n        FUNCTION bfs(subtree)  \n            SET start TO an arbitrary element of subtree  \n            SET queue TO a new double ended queue containing start  \n            SET visited TO a new set containing start  \n            SET distance TO zero  \n            SET farthest_node TO start  \n            \n            WHILE queue is not empty  \n                REMOVE the first element of queue AND ASSIGN it TO node  \n                FOR each neighbor IN the list at key node of graph  \n                    IF neighbor is in subtree AND neighbor is not in visited THEN  \n                        ADD neighbor TO visited  \n                        APPEND neighbor TO queue  \n                        SET farthest_node TO neighbor  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a new double ended queue containing farthest_node  \n            SET visited TO a new set containing farthest_node  \n            SET max_distance TO zero  \n            \n            WHILE queue is not empty  \n                SET size TO the number of elements in queue  \n                FOR each loop index from one TO size  \n                    REMOVE the first element of queue AND ASSIGN it TO node  \n                    FOR each neighbor IN the list at key node of graph  \n                        IF neighbor is in subtree AND neighbor is not in visited THEN  \n                            ADD neighbor TO visited  \n                            APPEND neighbor TO queue  \n                        END IF  \n                    END FOR  \n                END FOR  \n                IF queue is not empty THEN  \n                    INCREMENT max_distance BY one  \n                END IF  \n            END WHILE  \n            \n            RETURN max_distance  \n        END FUNCTION  \n        \n        SET result TO a list of zeros with length n MINUS one  \n        \n        FOR each integer size FROM two TO n  \n            FOR each subset IN the collection of combinations of the integers from one TO n chosen size at a time  \n                SET visited TO an empty set  \n                SET stack TO a list containing the first element of subset  \n                WHILE stack is not empty  \n                    REMOVE the last element of stack AND ASSIGN it TO node  \n                    IF node is not in visited THEN  \n                        ADD node TO visited  \n                        FOR each neighbor IN the list at key node of graph  \n                            IF neighbor is in subset AND neighbor is not in visited THEN  \n                                APPEND neighbor TO stack  \n                            END IF  \n                        END FOR  \n                    END IF  \n                END WHILE  \n                \n                IF visited equals the set of elements in subset THEN  \n                    SET diameter TO the result of bfs with the set converted from subset  \n                    IF diameter GREATER THAN zero THEN  \n                        INCREMENT the element at position diameter MINUS one of result BY one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rank-transform-of-a-matrix", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__ (self size)  \n        SET sequence FROM zero TO size MINUS one AS self.parent  \n    END FUNCTION  \n\n    FUNCTION find (self u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union (self u v)  \n        SET root_u TO self.find(u)  \n        SET root_v TO self.find(v)  \n        IF root_u NOT EQUALS root_v THEN  \n            SET element at position root_u of self.parent TO root_v  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION matrixRankTransform (self matrix)  \n        SET m TO LENGTH OF matrix  \n        SET n TO LENGTH OF element at position zero of matrix  \n        SET value_to_indices TO a default dictionary of list  \n        \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                APPEND pair consisting of r and c TO value_to_indices at key element at position r of matrix at position c  \n            END FOR  \n        END FOR  \n        \n        SET row_rank TO a list of zeros of length m  \n        SET col_rank TO a list of zeros of length n  \n        SET result TO a list of lists each of length n filled with zeros, total m lists  \n        \n        FOR each value IN keys of value_to_indices sorted in ascending order  \n            SET uf TO a new UnionFind object initialized with m PLUS n  \n            SET rank TO a default dictionary of integer  \n            \n            FOR each pair of r and c IN value_to_indices at key value  \n                CALL uf.union with r and c PLUS m  \n            END FOR  \n            \n            FOR each pair of r and c IN value_to_indices at key value  \n                SET root TO uf.find(r)  \n                SET current_max TO maximum of element at position r of row_rank AND element at position c of col_rank  \n                SET rank at key root TO maximum of current value at rank key root AND current_max PLUS one  \n            END FOR  \n            \n            FOR each pair of r and c IN value_to_indices at key value  \n                SET root TO uf.find(r)  \n                SET element at position r of result at position c TO rank at key root  \n                SET element at position r of row_rank TO rank at key root  \n                SET element at position c of col_rank TO rank at key root  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-form-a-target-string-given-a-dictionary", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numWays(words WITH TYPE List of strings, target WITH TYPE string) RETURNS integer  \n        SET MODULO_VALUE TO ten raised to the power of nine PLUS one  \n        SET number_of_positions TO the LENGTH OF the element at position zero of words  \n        SET target_length TO the LENGTH OF target  \n        \n        SET frequency_list TO a new list of size number_of_positions  \n        FOR index FROM zero TO number_of_positions MINUS one  \n            SET the element at position index of frequency_list TO an empty frequency dictionary mapping characters to integers  \n        END FOR  \n        \n        FOR each word IN words  \n            FOR character_index FROM zero TO the LENGTH OF word MINUS one  \n                SET character TO the element at position character_index of word  \n                INCREMENT the value at key character in the dictionary at position character_index of frequency_list BY one  \n            END FOR  \n        END FOR  \n        \n        SET dp_table TO a new two dimensional list with dimensions target_length PLUS one by number_of_positions PLUS one filled with zeros  \n        \n        FOR column_index FROM zero TO number_of_positions  \n            SET the element at row zero and column column_index of dp_table TO one  \n        END FOR  \n        \n        FOR target_index FROM one TO target_length  \n            FOR position_index FROM one TO number_of_positions  \n                SET the element at row target_index and column position_index of dp_table TO the element at row target_index and column position_index MINUS one of dp_table  \n                \n                SET current_target_character TO the element at position target_index MINUS one of target  \n                IF the value at key current_target_character in the dictionary at position position_index MINUS one of frequency_list GREATER THAN zero  \n                    INCREMENT the element at row target_index and column position_index of dp_table BY the element at row target_index MINUS one and column position_index MINUS one of dp_table MULTIPLIED BY the value at key current_target_character in the dictionary at position position_index MINUS one of frequency_list  \n                    SET the element at row target_index and column position_index of dp_table TO the element at row target_index and column position_index of dp_table MODULO MODULO_VALUE  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN the element at row target_length and column number_of_positions of dp_table  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-instructions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPath(destination PARAMETER row_and_column AS List OF Integer, k AS Integer) RETURNS String  \n        SET row TO element at position one of row_and_column  \n        SET col TO element at position two of row_and_column  \n        SET path TO empty list  \n        SET total_moves TO col PLUS row  \n        FOR index FROM zero TO total_moves MINUS one  \n            IF col GREATER THAN zero  \n                SET paths_with_H TO combination of row PLUS col MINUS one AND col MINUS one  \n                IF k LESS THAN OR EQUAL TO paths_with_H  \n                    APPEND letter H TO path  \n                    DECREMENT col BY one  \n                ELSE  \n                    APPEND letter V TO path  \n                    DECREMENT row BY one  \n                    DECREMENT k BY paths_with_H  \n                END IF  \n            ELSE  \n                APPEND letter V TO path  \n                DECREMENT row BY one  \n            END IF  \n        END FOR  \n        RETURN concatenation of all elements in path as a single string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "create-sorted-array-through-instructions", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION createSortedArray(instructions)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET MAX TO the maximum element of instructions PLUS one  \n        SET bit TO a list of zeros with the length MAX  \n\n        FUNCTION update(idx val)  \n            WHILE idx LESS THAN MAX  \n                INCREMENT element at position idx of bit BY val  \n                SET idx TO idx PLUS the bitwise AND of idx and the negative of idx  \n            END WHILE  \n        END FUNCTION  \n\n        FUNCTION query(idx)  \n            SET total TO zero  \n            WHILE idx GREATER THAN zero  \n                INCREMENT total BY element at position idx of bit  \n                SET idx TO idx MINUS the bitwise AND of idx and the negative of idx  \n            END WHILE  \n            RETURN total  \n        END FUNCTION  \n\n        SET total_cost TO zero  \n        FOR each i num IN the enumeration of instructions  \n            SET less_than TO the result of query at the position num MINUS one  \n            SET greater_than TO i MINUS the result of query at the position num  \n            IF less_than LESS THAN greater_than  \n                SET cost TO less_than  \n            ELSE  \n                SET cost TO greater_than  \n            END IF  \n            SET total_cost TO the remainder of total_cost PLUS cost DIVIDED BY MOD  \n            CALL update with the arguments num and one  \n        END FOR  \n\n        RETURN total_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distribute-repeating-integers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canDistribute(nums PARAMETER, quantity PARAMETER)  \n        SET count TO the list of the frequency of each unique element in nums  \n        SORT quantity IN descending order  \n        \n        FUNCTION can_satisfy(index PARAMETER)  \n            IF index EQUALS the LENGTH OF quantity THEN  \n                RETURN True  \n            END IF  \n            FOR each i FROM zero TO the LENGTH OF count MINUS one  \n                IF the element at position i of count GREATER THAN OR EQUAL TO the element at position index of quantity THEN  \n                    DECREMENT the element at position i of count BY the element at position index of quantity  \n                    IF can_satisfy the next index THEN  \n                        RETURN True  \n                    END IF  \n                    INCREMENT the element at position i of count BY the element at position index of quantity  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_satisfy zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-initial-energy-to-finish-tasks", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumEffort(tasks)  \n        SORT tasks IN ORDER THAT the element at position one of a task MINUS the element at position zero of a task IS GREATER THAN for each task IN tasks  \n        \n        SET current_energy TO zero  \n        SET required_initial_energy TO zero  \n        \n        FOR each task IN tasks  \n            SET actual TO the element at position zero of task  \n            SET minimum TO the element at position one of task  \n            \n            IF current_energy LESS THAN minimum  \n                INCREMENT required_initial_energy BY minimum MINUS current_energy  \n                SET current_energy TO minimum  \n            END IF  \n            \n            DECREMENT current_energy BY actual  \n        END FOR  \n        \n        RETURN required_initial_energy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-removals-to-make-mountain-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumMountainRemovals(nums)  \n        SET n TO the LENGTH OF nums  \n        SET lis TO a list of length n with all elements SET TO one  \n        FOR index i FROM zero TO n MINUS one  \n            FOR index j FROM zero TO i MINUS one  \n                IF element at position i of nums IS GREATER THAN element at position j of nums  \n                    SET lis at position i TO the GREATER OF lis at position i AND lis at position j PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET lds TO a list of length n with all elements SET TO one  \n        FOR index i FROM n MINUS one DOWN TO zero  \n            FOR index j FROM i PLUS one TO n MINUS one  \n                IF element at position i of nums IS GREATER THAN element at position j of nums  \n                    SET lds at position i TO the GREATER OF lds at position i AND lds at position j PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        SET max_mountain_length TO zero  \n        FOR index i FROM one TO n MINUS two  \n            IF lis at position i IS GREATER THAN one AND lds at position i IS GREATER THAN one  \n                SET max_mountain_length TO the GREATER OF max_mountain_length AND lis at position i PLUS lds at position i MINUS one  \n            END IF  \n        END FOR  \n        RETURN n MINUS max_mountain_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-deviation-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeviation(nums)  \n        SET max_heap TO empty list  \n        SET min_value TO positive infinity  \n        FOR each num IN nums  \n            IF remainder of num DIVIDED BY two EQUALS one  \n                SET num TO num MULTIPLIED BY two  \n            END IF  \n            IF min_value GREATER THAN num  \n                SET min_value TO num  \n            END IF  \n            PUSH negative num INTO max_heap as a heap element  \n        END FOR  \n        \n        SET min_deviation TO positive infinity  \n        \n        WHILE remainder of element at position zero of max_heap DIVIDED BY two EQUALS zero  \n            SET max_value TO negative value popped from max_heap as a heap element  \n            IF min_deviation GREATER THAN difference between max_value MINUS min_value  \n                SET min_deviation TO difference between max_value MINUS min_value  \n            END IF  \n            SET max_value TO max_value DIVIDED BY two using integer division  \n            IF min_value GREATER THAN max_value  \n                SET min_value TO max_value  \n            END IF  \n            PUSH negative max_value INTO max_heap as a heap element  \n        END WHILE  \n        \n        IF min_deviation GREATER THAN difference between negative element at position zero of max_heap MINUS min_value  \n            SET min_deviation TO difference between negative element at position zero of max_heap MINUS min_value  \n        END IF  \n        \n        RETURN min_deviation  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-incompatibility", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        \n        IF there EXISTS a count of any number in nums WHERE the count GREATER THAN k  \n            RETURN negative one  \n        END IF  \n        \n        SET subset_incompatibility TO an empty mapping  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF bit_count EQUALS subset_size  \n                SET elements TO an empty list  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BIT AT position i OF mask EQUALS one  \n                        APPEND the element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                \n                IF the NUMBER OF UNIQUE elements IN elements EQUALS subset_size  \n                    SET incompatibility TO the MAXIMUM OF elements MINUS the MINIMUM OF elements  \n                    ASSIGN incompatibility TO the ENTRY of mask IN subset_incompatibility  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET dp TO a list of LENGTH two RAISED TO THE POWER OF n FILLED WITH positive infinity  \n        SET the ELEMENT AT position zero OF dp TO zero  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF the REMAINDER of bit_count DIVIDED BY subset_size NOT EQUAL TO zero  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BINARY AND OF mask AND subset_mask EQUALS subset_mask  \n                    SET dp AT position mask TO the MINIMUM OF the CURRENT dp AT position mask AND the dp AT position of the BINARY XOR OF mask AND subset_mask PLUS the VALUE of subset_mask IN subset_incompatibility  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET full_mask TO two RAISED TO THE POWER OF n MINUS one  \n        IF the ELEMENT AT position full_mask OF dp NOT EQUAL TO positive infinity  \n            RETURN the ELEMENT AT position full_mask OF dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delivering-boxes-from-storage-to-ports", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION boxDelivering(boxes portsCount maxBoxes maxWeight)  \n        SET n TO the LENGTH OF boxes  \n        SET dp TO a list of size n PLUS one FILLED WITH infinity  \n        SET the element at position zero of dp TO zero  \n        \n        SET left TO zero  \n        SET current_weight TO zero  \n        SET extra_trips TO zero  \n        \n        FOR right FROM zero TO n MINUS one  \n            INCREMENT current_weight BY the element at position one of the element at position right of boxes  \n            IF right GREATER THAN zero AND the element at position zero of the element at position right of boxes NOT EQUALS the element at position zero of the element at position right MINUS one of boxes  \n                INCREMENT extra_trips BY one  \n            END IF  \n            \n            WHILE left LESS THAN OR EQUAL TO right AND (right MINUS left PLUS one GREATER THAN maxBoxes OR current_weight GREATER THAN maxWeight)  \n                DECREMENT current_weight BY the element at position one of the element at position left of boxes  \n                IF left GREATER THAN zero AND the element at position zero of the element at position left of boxes NOT EQUALS the element at position zero of the element at position left MINUS one of boxes  \n                    DECREMENT extra_trips BY one  \n                END IF  \n                INCREMENT left BY one  \n            END WHILE  \n            \n            SET the element at position right PLUS one of dp TO the element at position left of dp PLUS two PLUS extra_trips  \n        END FOR  \n        \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-height-by-stacking-cuboids", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxHeight WITH PARAMETER cuboids  \n        FOR each cuboid IN cuboids  \n            SORT dimensions of cuboid in ascending order  \n        END FOR  \n        SORT cuboids lexicographically based on their dimensions  \n        SET n TO the LENGTH OF cuboids  \n        SET dp TO a list of zeros with length n  \n        FOR i FROM zero TO n MINUS one  \n            SET dp at position i TO the element at position three of cuboids at position i  \n            FOR j FROM zero TO i MINUS one  \n                IF the element at position one of cuboids at position j LESS THAN OR EQUAL TO the element at position one of cuboids at position i AND the element at position two of cuboids at position j LESS THAN OR EQUAL TO the element at position two of cuboids at position i AND the element at position three of cuboids at position j LESS THAN OR EQUAL TO the element at position three of cuboids at position i THEN  \n                    IF dp at position j PLUS the element at position three of cuboids at position i GREATER THAN dp at position i THEN  \n                        SET dp at position i TO dp at position j PLUS the element at position three of cuboids at position i  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET result TO zero  \n        FOR each value IN dp  \n            IF value GREATER THAN result THEN  \n                SET result TO value  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-ways-to-distribute-candies", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION waysToDistribute(n, k)  \n        SET MOD TO one billion PLUS seven  \n        INITIALIZE dp AS a list containing elements each being a list of zeros with length equal to k PLUS one for each index FROM zero TO n INCLUSIVE  \n        SET element at position zero of dp TO a list where element at position zero is one and all other elements are zero  \n        FOR i FROM one TO n INCLUSIVE  \n            FOR j FROM one TO k INCLUSIVE  \n                SET element at position j of element at position i of dp TO the remainder after division by MOD of the sum of the product of j AND element at position j of element at position i MINUS one of dp AND element at position j MINUS one of element at position i MINUS one of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-adjacent-swaps-for-k-consecutive-ones", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minMoves(nums k)  \n        SET positions TO an empty list  \n        FOR each index num IN nums with index i starting from zero  \n            IF num EQUALS one  \n                APPEND i TO positions  \n            END IF  \n        END FOR  \n\n        FUNCTION calculate_cost(start end)  \n            SET mid TO start PLUS end DIVIDED BY two  \n            SET median TO element at position mid of positions  \n            SET cost TO zero  \n            FOR i FROM start TO end MINUS one  \n                INCREMENT cost BY the absolute value of element at position i of positions MINUS median PLUS mid MINUS i  \n            END FOR  \n            RETURN cost  \n        END FUNCTION  \n\n        SET min_cost TO infinity  \n        SET limit TO the length of positions MINUS k PLUS one  \n        FOR i FROM zero TO limit MINUS one  \n            SET current_cost TO calculate_cost(i i PLUS k)  \n            IF current_cost LESS THAN min_cost  \n                SET min_cost TO current_cost  \n            END IF  \n        END FOR  \n        RETURN min_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-xor-with-an-element-from-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximizeXor(nums, queries)  \n        SORT nums IN ASCENDING ORDER  \n        SET sorted_queries TO the list of pairs of index and query FROM enumerating queries SORTED BY the second element at position one of the query  \n        SET result TO a list of the LENGTH OF queries FILLED WITH the value MINUS one  \n        SET trie TO an empty dictionary  \n        SET num_index TO zero  \n        FOR each query_index and pair xi mi IN sorted_queries  \n            WHILE num_index LESS THAN the LENGTH OF nums AND element at position num_index of nums LESS THAN OR EQUAL TO mi  \n                SET num TO element at position num_index of nums  \n                SET node TO trie  \n                FOR i FROM thirty-one DOWN TO zero  \n                    SET bit TO the value of element at position i of the binary representation of num  \n                    IF bit NOT IN node  \n                        SET element at position bit of node TO an empty dictionary  \n                    END IF  \n                    SET node TO element at position bit of node  \n                END FOR  \n                INCREMENT num_index BY one  \n            END WHILE  \n            IF trie IS EMPTY  \n                CONTINUE TO next iteration of the FOR loop  \n            END IF  \n            SET node TO trie  \n            SET max_xor TO zero  \n            FOR i FROM thirty-one DOWN TO zero  \n                SET bit TO the value of element at position i of the binary representation of xi  \n                SET toggle_bit TO one MINUS bit  \n                IF toggle_bit IN node  \n                    SET max_xor TO max_xor PLUS the value of one MULTIPLIED BY the value of two RAISED TO THE POWER OF i  \n                    SET node TO element at position toggle_bit of node  \n                ELSE  \n                    SET node TO element at position bit of node  \n                END IF  \n            END FOR  \n            SET element at position query_index of result TO max_xor  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-operations-to-make-a-subsequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minOperations(target, arr)  \n        SET index_map TO empty mapping from element to position  \n        FOR index FROM zero TO the LENGTH OF target MINUS one  \n            SET the element at position index of target TO value  \n            SET element at position value of index_map TO index  \n        END FOR  \n        \n        SET transformed_arr TO empty list  \n        FOR each element value IN arr  \n            IF element value IN index_map  \n                APPEND element at position value of index_map TO transformed_arr  \n            END IF  \n        END FOR  \n        \n        SET lis TO empty list  \n        FOR each number num IN transformed_arr  \n            SET position pos TO the insertion position in lis where num can be placed to keep lis sorted in ascending order  \n            IF position pos EQUALS the LENGTH OF lis  \n                APPEND num TO lis  \n            ELSE  \n                SET element at position pos of lis TO num  \n            END IF  \n        END FOR  \n        \n        SET lcs_length TO the LENGTH OF lis  \n        SET minimum_operations TO the LENGTH OF target MINUS lcs_length  \n        RETURN minimum_operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-reconstruct-a-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkWays(pairs)  \n        SET graph TO a new mapping from element to a set of elements with default empty set  \n        FOR each pair IN pairs  \n            SET x TO the element at position one of pair  \n            SET y TO the element at position two of pair  \n            ADD y TO the set corresponding to key x in graph  \n            ADD x TO the set corresponding to key y in graph  \n        END FOR  \n        \n        SET max_degree TO the element in graph with the maximum size of the set corresponding to that element  \n        SET n TO the number of keys in graph  \n        \n        IF the size of the set corresponding to max_degree in graph NOT EQUALS n MINUS one  \n            RETURN zero  \n        END IF  \n        \n        FUNCTION can_be_parent(u, v)  \n            FOR each neighbor IN the set corresponding to v in graph  \n                IF neighbor NOT IN the set corresponding to u in graph AND neighbor NOT EQUALS u  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        SET ways TO one  \n        \n        FOR each u IN the keys of graph  \n            IF u EQUALS max_degree  \n                CONTINUE to next iteration  \n            END IF  \n            SET parent TO none  \n            FOR each v IN the set corresponding to u in graph  \n                IF v IN graph AND the size of the set corresponding to v in graph GREATER THAN OR EQUAL TO the size of the set corresponding to u in graph AND can_be_parent(v, u)  \n                    IF parent IS none OR the size of the set corresponding to v in graph LESS THAN the size of the set corresponding to parent in graph  \n                        SET parent TO v  \n                    END IF  \n                END IF  \n            END FOR  \n            IF parent IS none  \n                RETURN zero  \n            END IF  \n            IF the size of the set corresponding to parent in graph EQUALS the size of the set corresponding to u in graph  \n                SET ways TO two  \n            END IF  \n        END FOR  \n        \n        RETURN ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the sequence of negative one zero one zero negative one  \n        SET g_mouse TO a list containing m MULTIPLIED BY n empty lists  \n        SET g_cat TO a list containing m MULTIPLIED BY n empty lists  \n        FOR each pair of index i AND element row IN grid WITH enumeration  \n            FOR each pair of index j AND element c IN row WITH enumeration  \n                IF c EQUALS the character hash  \n                    CONTINUE to next iteration  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character F  \n                    SET food TO v  \n                END IF  \n                FOR each pair of consecutive elements a AND b IN dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the result of the FUNCTION calc WITH parameters g_mouse g_cat mouse_start cat_start food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            DECOMPOSE state INTO m c t  \n            SET pt TO t XOR one  \n            SET pre TO empty list  \n            IF pt EQUALS one  \n                FOR each pc IN the element at position c of g_cat  \n                    IF the element at position m THEN at position pc THEN at position one OF ans EQUALS zero  \n                        APPEND the tuple m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN the element at position m of g_mouse  \n                    IF the element at position pm THEN at position c THEN at position zero OF ans EQUALS zero  \n                        APPEND the tuple pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a three dimensional list of zeros with dimensions n by n by two  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET the element at position zero of the element at position j of the element at position i of degree TO the LENGTH OF the element at position i of g_mouse  \n                SET the element at position one of the element at position j of the element at position i of degree TO the LENGTH OF the element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a three dimensional list of zeros with dimensions n by n by two  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET the element at position one of the element at position i of the element at position hole of ans TO one  \n            SET the element at position zero of the element at position hole of the element at position i of ans TO two  \n            SET the element at position one of the element at position i of the element at position i of ans TO two  \n            SET the element at position zero of the element at position i of the element at position i of ans TO two  \n            APPEND the tuple hole i one TO q  \n            APPEND the tuple i hole zero TO q  \n            APPEND the tuple i i zero TO q  \n            APPEND the tuple i i one TO q  \n        END FOR  \n\n        WHILE q is not empty  \n            SET state TO the element removed from the left of q  \n            SET t TO the element at position two OF ans at dimension positions state at zero state at one state at two  \n            FOR each prev_state IN the result of calling get_prev_states WITH state  \n                DECOMPOSE prev_state INTO pm pc pt  \n                IF pt EQUALS t MINUS one  \n                    SET the element at position pt OF ans at dimension positions pm pc TO t  \n                    APPEND prev_state TO q  \n                ELSE  \n                    DECREMENT the element at position pt OF degree at dimension positions pm pc BY one  \n                    IF the element at position pt OF degree at dimension positions pm pc EQUALS zero  \n                        SET the element at position pt OF ans at dimension positions pm pc TO t  \n                        APPEND prev_state TO q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the element at position zero OF ans at dimension positions mouse_start cat_start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "building-boxes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumBoxes(n)  \n        FUNCTION triangular_pyramid(k)  \n            SET product_of_k_and_k_plus_one TO k MULTIPLIED BY k PLUS one  \n            SET product_of_all TO product_of_k_and_k_plus_one MULTIPLIED BY k PLUS two  \n            SET result TO product_of_all DIVIDED BY six  \n            RETURN result  \n        END FUNCTION  \n  \n        SET left TO zero  \n        SET right TO n  \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right PLUS one DIVIDED BY two  \n            IF triangular_pyramid(mid) LESS THAN OR EQUAL TO n  \n                SET left TO mid  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n  \n        SET boxes_used TO triangular_pyramid(left)  \n        SET remaining TO n MINUS boxes_used  \n        SET floor_boxes TO left MULTIPLIED BY left PLUS one DIVIDED BY two  \n  \n        SET additional_boxes TO zero  \n        WHILE remaining GREATER THAN zero  \n            INCREMENT additional_boxes BY one  \n            DECREMENT remaining BY additional_boxes  \n        END WHILE  \n  \n        RETURN floor_boxes PLUS additional_boxes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-iv", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION checkPartitioning(s)  \n        FUNCTION is_palindrome(sub)  \n            RETURN sub EQUALS reversed sub  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF s  \n        \n        SET is_pal TO a two dimensional list of Boolean FALSE values with dimensions n BY n  \n        \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM i TO n MINUS one  \n                IF element at position i of s EQUALS element at position j of s AND (j MINUS i LESS THAN OR EQUAL TO one OR element at position i PLUS one and position j MINUS one of is_pal IS TRUE)  \n                    SET element at position i and position j of is_pal TO TRUE  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR i FROM one TO n MINUS two  \n            IF element at position zero and position i MINUS one of is_pal IS TRUE  \n                FOR j FROM i TO n MINUS two  \n                    IF element at position i and position j of is_pal IS TRUE AND element at position j PLUS one and position n MINUS one of is_pal IS TRUE  \n                        RETURN TRUE  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN FALSE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-events-that-can-be-attended-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxValue(events parameter AS list of lists of integers, k parameter AS integer) RETURNS integer  \n        CALL events TO BE ORDERED BY the end day value of each event  \n        SET n TO the length of events  \n        SET dp TO a list of n PLUS one elements each containing a list of k PLUS one zeros  \n        FOR i FROM one TO n  \n            SET start TO the element at position one of the event at position i MINUS one of events  \n            SET end TO the element at position two of the event at position i MINUS one of events  \n            SET value TO the element at position three of the event at position i MINUS one of events  \n            SET j TO the position found by searching in events for the earliest event whose end day is GREATER THAN OR EQUAL TO start  \n            FOR l FROM one TO k  \n                SET dp at position i at position l TO the maximum of dp at position i MINUS one at position l AND dp at position j at position l MINUS one PLUS value  \n            END FOR  \n        END FOR  \n        RETURN the element at position n at position k of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-subsequence-sum", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minAbsDifference(nums goal)  \n        SET n TO the LENGTH OF nums  \n        SET mid TO n DIVIDED BY two  \n        \n        SET left_sums TO a LIST containing zero  \n        FOR each num IN the SUBLIST of nums from position zero TO position mid MINUS one  \n            SET new_sums TO an EMPTY LIST  \n            FOR each s IN left_sums  \n                APPEND s PLUS num TO new_sums  \n            END FOR  \n            EXTEND left_sums BY new_sums  \n        END FOR  \n        \n        SET right_sums TO a LIST containing zero  \n        FOR each num IN the SUBLIST of nums from position mid TO the END OF nums  \n            SET new_sums TO an EMPTY LIST  \n            FOR each s IN right_sums  \n                APPEND s PLUS num TO new_sums  \n            END FOR  \n            EXTEND right_sums BY new_sums  \n        END FOR  \n        \n        SORT right_sums IN ascending order  \n        \n        SET min_diff TO infinity  \n        \n        FOR each left_sum IN left_sums  \n            SET target TO goal MINUS left_sum  \n            SET pos TO the POSITION WHERE target CAN be INSERTED to MAINTAIN sorted ORDER in right_sums  \n            \n            IF pos IS LESS THAN the LENGTH OF right_sums  \n                SET candidate_diff TO the ABSOLUTE VALUE OF left_sum PLUS the ELEMENT AT POSITION pos OF right_sums MINUS goal  \n                IF candidate_diff IS LESS THAN min_diff  \n                    SET min_diff TO candidate_diff  \n                END IF  \n            END IF  \n            \n            IF pos IS GREATER THAN zero  \n                SET candidate_diff TO the ABSOLUTE VALUE OF left_sum PLUS the ELEMENT AT POSITION pos MINUS one OF right_sums MINUS goal  \n                IF candidate_diff IS LESS THAN min_diff  \n                    SET min_diff TO candidate_diff  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-from-performing-multiplication-operations", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(nums, multipliers)  \n        SET m TO the LENGTH OF multipliers  \n        SET n TO the LENGTH OF nums  \n        SET dp TO a list of zeroes WITH LENGTH m PLUS one  \n        FOR i FROM m MINUS one TO zero DECREMENTING BY one  \n            SET new_dp TO a list of zeroes WITH LENGTH m PLUS one  \n            FOR left FROM zero TO i INCLUSIVE  \n                SET right TO n MINUS one MINUS (i MINUS left)  \n                SET mul TO the element at position i of multipliers  \n                SET value_from_left TO mul MULTIPLIED BY the element at position left of nums PLUS the element at position left PLUS one of dp  \n                SET value_from_right TO mul MULTIPLIED BY the element at position right of nums PLUS the element at position left of dp  \n                SET the element at position left of new_dp TO the maximum BETWEEN value_from_left AND value_from_right  \n            END FOR  \n            SET dp TO new_dp  \n        END FOR  \n        RETURN the element at position zero of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-palindrome-length-from-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPalindrome(word1 word1 AS string word2 word2 AS string) RETURNS int  \n        SET s TO concatenation of word1 and word2  \n        SET n TO the LENGTH OF s  \n        SET dp TO a two dimensional list of zeroes with dimensions n by n  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of dp TO one  \n        END FOR  \n        \n        SET max_len TO zero  \n        FOR length FROM two TO n  \n            FOR i FROM zero TO n MINUS length  \n                SET j TO i PLUS length MINUS one  \n                IF element at position i of s EQUALS element at position j of s THEN  \n                    SET element at position i at position j of dp TO element at position i PLUS one at position j MINUS one of dp PLUS two  \n                    IF i LESS THAN the LENGTH OF word1 AND j GREATER THAN OR EQUAL TO the LENGTH OF word1 THEN  \n                        SET max_len TO the GREATER OF max_len AND element at position i at position j of dp  \n                    END IF  \n                ELSE  \n                    SET element at position i at position j of dp TO the GREATER OF element at position i PLUS one at position j of dp AND element at position i at position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_len  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "car-fleet-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getCollisionTimes(cars)  \n        SET n TO the LENGTH OF cars  \n        SET result TO a list of LENGTH n with each element SET TO negative one point zero  \n        SET stack TO an empty list  \n  \n        FOR i FROM n MINUS one DOWN TO zero  \n            SET pos TO element at position zero of element at position i of cars  \n            SET speed TO element at position one of element at position i of cars  \n  \n            WHILE the LENGTH OF stack IS GREATER THAN zero  \n                SET next_index TO element at the last position of stack  \n                SET next_pos TO element at position zero of element at position next_index of cars  \n                SET next_speed TO element at position one of element at position next_index of cars  \n  \n                IF speed IS LESS THAN OR EQUAL TO next_speed  \n                    REMOVE the last element FROM stack  \n                    CONTINUE  \n                END IF  \n  \n                SET collision_time TO next_pos MINUS pos DIVIDED BY speed MINUS next_speed  \n  \n                IF element at position next_index of result IS GREATER THAN zero AND collision_time IS GREATER THAN OR EQUAL TO element at position next_index of result  \n                    REMOVE the last element FROM stack  \n                    CONTINUE  \n                END IF  \n  \n                SET element at position i of result TO collision_time  \n                BREAK  \n            END WHILE  \n  \n            APPEND i TO stack  \n        END FOR  \n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-pairs-of-nodes", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(n, edges, queries)  \n        SET degree TO list of zeros with length n PLUS one  \n        FOR each u, v IN edges  \n            INCREMENT element at position u of degree BY one  \n            INCREMENT element at position v of degree BY one  \n        END FOR  \n        \n        SET shared TO empty mapping with default zero integer values  \n        FOR each u, v IN edges  \n            IF u GREATER THAN v  \n                SET temporary TO u  \n                SET u TO v  \n                SET v TO temporary  \n            END IF  \n            INCREMENT value at key tuple of u and v in shared BY one  \n        END FOR  \n        \n        SET sorted_degree TO the elements of degree arranged in ascending order  \n        \n        SET answers TO an empty list  \n        FOR each q IN queries  \n            SET count TO zero  \n            SET left TO one  \n            SET right TO n  \n            WHILE left LESS THAN right  \n                IF element at position left of sorted_degree PLUS element at position right of sorted_degree GREATER THAN q  \n                    INCREMENT count BY right MINUS left  \n                    DECREMENT right BY one  \n                ELSE  \n                    INCREMENT left BY one  \n                END IF  \n            END WHILE  \n            \n            FOR each key of pair u, v and value of count_uv IN shared  \n                SET degree_uv TO element at position u of degree PLUS element at position v of degree  \n                IF degree_uv GREATER THAN q AND degree_uv MINUS count_uv LESS THAN OR EQUAL TO q  \n                    DECREMENT count BY one  \n                END IF  \n            END FOR  \n            \n            APPEND count TO answers  \n        END FOR  \n        \n        RETURN answers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "make-the-xor-of-all-segments-equal-to-zero", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minChanges(nums parameter, k parameter)  \n        SET groups TO a new empty mapping from keys to empty lists  \n        FOR index FROM zero TO the LENGTH OF nums MINUS one  \n            SET remainder TO index MODULO k  \n            APPEND element at position index of nums TO the list stored at key remainder in groups  \n        END FOR  \n        \n        SET freq TO a list of k elements where each element is a new empty mapping from keys to zero  \n        SET min_size TO a list of k elements where each element is positive infinity  \n        \n        FOR index FROM zero TO k MINUS one  \n            FOR each number IN the list stored at key index in groups  \n                INCREMENT the mapping at key number in freq at position index BY one  \n            END FOR  \n            SET the element at position index in min_size TO the LENGTH OF the list stored at key index in groups  \n        END FOR  \n        \n        SET dp TO a list where each element is positive infinity and the number of elements is two RAISED TO THE POWER OF ten  \n        SET the element at position zero in dp TO zero  \n        \n        FOR index FROM zero TO k MINUS one  \n            SET new_dp TO a list where each element is positive infinity and the number of elements is two RAISED TO THE POWER OF ten  \n            SET min_dp TO the minimum value in dp  \n            \n            FOR j FROM zero TO two RAISED TO THE POWER OF ten MINUS one  \n                SET the element at position j in new_dp TO min_dp PLUS the element at position index in min_size  \n                \n                FOR each key value number AND its frequency count IN the mapping freq at position index  \n                    SET candidate TO the element at position j XOR number in dp PLUS the element at position index in min_size MINUS count  \n                    IF candidate LESS THAN the element at position j in new_dp  \n                        SET the element at position j in new_dp TO candidate  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            ASSIGN dp reference TO new_dp  \n        END FOR  \n        \n        RETURN the element at position zero in dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-the-beauty-of-the-garden", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers)  \n        SET indices TO a new dictionary that creates a new empty list for any new key  \n        SET prefix_sum TO a new list of zeros of the length of the number of elements in flowers PLUS one  \n        FOR each index i FROM zero TO the length of flowers MINUS one  \n            SET element_at_position i PLUS one of prefix_sum TO element_at_position i of prefix_sum PLUS the greater value between element_at_position i of flowers AND zero  \n            APPEND index i TO the list associated with element_at_position i of flowers in indices  \n        END FOR  \n        SET max_beauty TO the smallest possible number representable as negative infinity  \n        FOR each key beauty IN indices  \n            IF the length of the list associated with beauty in indices IS GREATER THAN OR EQUAL TO two  \n                SET first TO element at position zero of the list associated with beauty in indices  \n                SET last TO element at the last position of the list associated with beauty in indices  \n                SET current_beauty TO two MULTIPLIED BY beauty PLUS element at position last of prefix_sum MINUS element at position first PLUS one of prefix_sum  \n                IF current_beauty IS GREATER THAN max_beauty  \n                    SET max_beauty TO current_beauty  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-of-a-good-subarray", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(nums k)  \n        SET left TO k  \n        SET right TO k  \n        SET current_min TO element at position k of nums  \n        SET max_score TO current_min  \n        WHILE left GREATER THAN zero OR right LESS THAN the LENGTH OF nums MINUS one  \n            IF left EQUALS zero  \n                INCREMENT right BY one  \n            ELSE IF right EQUALS the LENGTH OF nums MINUS one  \n                DECREMENT left BY one  \n            ELSE IF element at position left MINUS one of nums GREATER THAN OR EQUAL TO element at position right PLUS one of nums  \n                DECREMENT left BY one  \n            ELSE  \n                INCREMENT right BY one  \n            END IF  \n            SET current_min TO the MINIMUM OF current_min AND element at position left of nums AND element at position right of nums  \n            SET score TO current_min MULTIPLIED BY the difference of right MINUS left PLUS one  \n            SET max_score TO the MAXIMUM OF max_score AND score  \n        END WHILE  \n        RETURN max_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-number-of-nice-divisors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxNiceDivisors(primeFactors)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        IF primeFactors LESS THAN OR EQUAL TO three  \n            RETURN primeFactors  \n        END IF  \n        SET num_threes TO primeFactors DIVIDED BY three  \n        SET remainder TO primeFactors MODULO three  \n        IF remainder EQUALS zero  \n            RETURN the result of three raised to the power of num_threes MODULO MOD  \n        ELSE IF remainder EQUALS one  \n            RETURN the result of three raised to the power of num_threes MINUS one MODULO MOD MULTIPLIED BY four MODULO MOD  \n        ELSE  \n            RETURN the result of three raised to the power of num_threes MODULO MOD MULTIPLIED BY two MODULO MOD  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-groups-getting-fresh-donuts", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxHappyGroups(batchSize, groups)  \n        IF batchSize EQUALS one  \n            RETURN the LENGTH OF groups  \n        END IF  \n        \n        SET remainder_count TO list of zeros with length batchSize  \n        FOR each group IN groups  \n            INCREMENT element at position of the remainder of group DIVIDED BY batchSize of remainder_count BY one  \n        END FOR  \n        \n        FUNCTION dp(remainder, variadic remainder_count)  \n            SET remainder_count TO a list converted from remainder_count tuple  \n            SET max_happy TO zero  \n            \n            FOR index FROM zero TO batchSize MINUS one  \n                IF element at position index of remainder_count EQUALS zero  \n                    CONTINUE to next iteration  \n                END IF  \n                \n                DECREMENT element at position index of remainder_count BY one  \n                SET new_remainder TO the remainder of remainder MINUS index DIVIDED BY batchSize using modulo operation  \n                \n                IF remainder EQUALS zero  \n                    SET happy_groups TO one PLUS CALL dp WITH new_remainder AND the unpacked remainder_count  \n                ELSE  \n                    SET happy_groups TO CALL dp WITH new_remainder AND the unpacked remainder_count  \n                END IF  \n                \n                IF happy_groups GREATER THAN max_happy  \n                    SET max_happy TO happy_groups  \n                END IF  \n                \n                INCREMENT element at position index of remainder_count BY one  \n            END FOR  \n            \n            RETURN max_happy  \n        END FUNCTION  \n        \n        RETURN CALL dp WITH zero AND the unpacked remainder_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-different-subsequences-gcds", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countDifferentSubsequenceGCDs(nums)  \n        SET max_num TO the maximum element IN nums  \n        SET num_set TO the set containing all elements of nums  \n        SET count TO zero  \n        FOR each g FROM one TO max_num INCLUSIVE  \n            SET gcd_val TO zero  \n            FOR each m FROM g TO max_num INCLUSIVE WITH STEP SIZE g  \n                IF m IS AN ELEMENT OF num_set THEN  \n                    SET gcd_val TO the greatest common divisor OF gcd_val AND m  \n                    IF gcd_val EQUALS g THEN  \n                        INCREMENT count BY one  \n                        BREAK the inner loop  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-xor-sum-of-all-pairs-bitwise-and", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION getXORSum(arr1 arr1_type AS List OF integers arr2 arr2_type AS List OF integers) RETURNS integer  \n        SET xor_sum_arr1 TO zero  \n        SET xor_sum_arr2 TO zero  \n        FOR each num IN arr1  \n            SET xor_sum_arr1 TO xor_sum_arr1 XOR num  \n        END FOR  \n        FOR each num IN arr2  \n            SET xor_sum_arr2 TO xor_sum_arr2 XOR num  \n        END FOR  \n        RETURN xor_sum_arr1 AND xor_sum_arr2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-building-height", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxBuilding(n, restrictions)  \n        APPEND a list consisting of one and zero TO restrictions  \n        SORT restrictions IN ascending order  \n        \n        FOR i FROM one TO the LENGTH OF restrictions MINUS one  \n            SET idx TO element at position i first element of restrictions  \n            SET height TO element at position i second element of restrictions  \n            SET prev_idx TO element at position i MINUS one first element of restrictions  \n            SET prev_height TO element at position i MINUS one second element of restrictions  \n            SET element at position i second element of restrictions TO the minimum BETWEEN height AND prev_height PLUS idx MINUS prev_idx  \n        END FOR  \n        \n        FOR i FROM the LENGTH OF restrictions MINUS two DOWN TO zero  \n            SET idx TO element at position i first element of restrictions  \n            SET height TO element at position i second element of restrictions  \n            SET next_idx TO element at position i PLUS one first element of restrictions  \n            SET next_height TO element at position i PLUS one second element of restrictions  \n            SET element at position i second element of restrictions TO the minimum BETWEEN height AND next_height PLUS next_idx MINUS idx  \n        END FOR  \n        \n        SET max_height TO zero  \n        SET prev_idx TO element at position zero first element of restrictions  \n        SET prev_height TO element at position zero second element of restrictions  \n        FOR i FROM one TO the LENGTH OF restrictions MINUS one  \n            SET idx TO element at position i first element of restrictions  \n            SET height TO element at position i second element of restrictions  \n            SET candidate_height TO idx MINUS prev_idx PLUS prev_height PLUS height DIVIDED BY two  \n            SET max_height TO the maximum BETWEEN max_height AND candidate_height  \n            SET prev_idx TO idx  \n            SET prev_height TO height  \n        END FOR  \n        \n        SET max_height TO the maximum BETWEEN max_height AND prev_height PLUS n MINUS prev_idx  \n        \n        RETURN max_height  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-palindrome-using-same-digits", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION nextPalindrome(num)  \n        SET n TO the LENGTH OF num  \n        SET half TO the SUBSTRING of num from the START TO the POSITION of n DIVIDED BY two MINUS one  \n        SET half_list TO the LIST of elements in half  \n        SET k TO negative one  \n        SET l TO negative one  \n        FOR i FROM the LENGTH OF half_list MINUS two DOWN TO zero  \n            IF element at position i of half_list LESS THAN element at position i PLUS one of half_list  \n                SET k TO i  \n                BREAK the loop  \n            END IF  \n        END FOR  \n        IF k EQUALS negative one  \n            RETURN the empty string  \n        END IF  \n        FOR i FROM the LENGTH OF half_list MINUS one DOWN TO k PLUS one  \n            IF element at position i of half_list GREATER THAN element at position k of half_list  \n                SET l TO i  \n                BREAK the loop  \n            END IF  \n        END FOR  \n        SET element at position k of half_list TO element at position l of half_list  \n        SET element at position l of half_list TO element at position k of half_list  \n        SET half_list TO the concatenation of the SUBLIST of half_list from the START TO k PLUS one WITH the SORTED SUBLIST of half_list from k PLUS one TO the END  \n        SET new_half TO the JOINED STRING of elements in half_list  \n        IF n MODULO two EQUALS zero  \n            RETURN the CONCATENATION of new_half WITH the REVERSED new_half  \n        ELSE  \n            RETURN the CONCATENATION of new_half WITH the element at position n DIVIDED BY two of num WITH the REVERSED new_half  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-color-value-in-a-directed-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestPathValue(colors, edges)  \n        SET n TO the LENGTH OF colors  \n        SET graph TO an empty mapping from keys to empty lists  \n        SET in_degree TO a list of zeros of LENGTH n  \n        \n        FOR each pair u AND v IN edges  \n            APPEND v TO the list at key u in graph  \n            INCREMENT the element at position v of in_degree BY one  \n        END FOR  \n        \n        SET queue TO a double-ended collection initialized with each index i FROM zero TO n MINUS one where the element at position i of in_degree EQUALS zero  \n        SET dp TO a list of lists each containing zeros of LENGTH twenty-six repeated n times  \n        SET visited TO zero  \n        SET max_color_value TO zero  \n        \n        WHILE queue is not empty  \n            REMOVE the first element from queue AND ASSIGN it TO node  \n            INCREMENT the element at position the alphabetical index of the character at position node in colors of dp at position node BY one  \n            SET max_color_value TO the larger value BETWEEN max_color_value AND the element at position the alphabetical index of the character at position node in colors of dp at position node  \n            INCREMENT visited BY one  \n            \n            FOR each neighbor IN the list at key node in graph  \n                FOR c FROM zero TO twenty-five  \n                    SET the element at position c of dp at position neighbor TO the larger value BETWEEN the element at position c of dp at position neighbor AND the element at position c of dp at position node  \n                END FOR  \n                DECREMENT the element at position neighbor of in_degree BY one  \n                IF the element at position neighbor of in_degree EQUALS zero  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        IF visited EQUALS n  \n            RETURN max_color_value  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-floored-pairs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO one billion PLUS seven  \n        SET max_num TO the maximum value IN nums  \n        SET count TO a mapping of each unique element IN nums TO its frequency  \n        SET prefix_sum TO a list of zeros WITH length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num IN count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the division of max_num BY num rounded down to nearest integer  \n                SET start TO num MULTIPLIED BY multiple  \n                SET end TO the smaller value BETWEEN num MULTIPLIED BY the sum of multiple PLUS one MINUS one AND max_num  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num IN count  \n                SET result TO the remainder of result DIVIDED BY MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stone-game-viii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION stoneGameVIII(stones)  \n        SET prefix_sum TO a list of zeros of the LENGTH OF stones  \n        SET element at position one of prefix_sum TO element at position one of stones  \n        FOR index FROM two TO the LENGTH OF stones  \n            SET element at position index of prefix_sum TO element at position index MINUS one of prefix_sum PLUS element at position index of stones  \n        END FOR  \n        SET dp TO element at the last position of prefix_sum  \n        FOR index FROM the LENGTH OF stones MINUS two DOWN TO two BY negative one  \n            IF dp GREATER THAN prefix_sum at position index MINUS dp  \n                CONTINUE TO the next iteration  \n            ELSE  \n                SET dp TO prefix_sum at position index MINUS dp  \n            END IF  \n        END FOR  \n        RETURN dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-xor-sum-of-two-arrays", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumXORSum(nums1 nums2)  \n        SET n TO the LENGTH OF nums1  \n        SET dp TO a list of size TWO RAISED TO THE POWER OF n with each element SET TO infinite  \n        SET the element at position zero of dp TO zero  \n        \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN THE BINARY REPRESENTATION OF mask  \n            FOR j FROM zero TO n MINUS one  \n                IF the element at position j of mask IS ONE  \n                    SET dp at position mask TO the MINIMUM OF dp at position mask AND dp at position mask MINUS TWO RAISED TO THE POWER OF j PLUS the BITWISE XOR of the element at position bit_count MINUS one of nums1 AND the element at position j of nums2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN the element at position TWO RAISED TO THE POWER OF n MINUS one of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-skips-to-arrive-at-meeting-on-time", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minSkips(dist speed hoursBefore)  \n        SET n TO the LENGTH OF dist  \n        SET dp TO a two dimensional list with n rows and n PLUS one columns where each element is INFINITY  \n        SET total_dist TO the SUM of all elements IN dist  \n        \n        IF total_dist DIVIDED BY speed GREATER THAN hoursBefore THEN  \n            RETURN the NEGATIVE of one  \n        END IF  \n        \n        SET element at position zero and position zero of dp TO element at position zero of dist  \n        FOR j FROM one TO n MINUS one  \n            SET element at position zero and position j of dp TO element at position zero of dist  \n        END FOR  \n        \n        FOR i FROM one TO n MINUS one  \n            FOR j FROM zero TO i  \n                IF j LESS THAN i THEN  \n                    SET element at position i and position j of dp TO the CEILING of element at position i MINUS one and position j of dp DIVIDED BY speed MULTIPLIED BY speed PLUS element at position i of dist  \n                END IF  \n                IF j GREATER THAN zero THEN  \n                    SET element at position i and position j of dp TO the MINIMUM of element at position i and position j of dp AND element at position i MINUS one and position j MINUS one of dp PLUS element at position i of dist  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FOR j FROM zero TO n MINUS one  \n            IF element at position n MINUS one and position j of dp LESS THAN OR EQUAL TO hoursBefore MULTIPLIED BY speed THEN  \n                RETURN j  \n            END IF  \n        END FOR  \n        \n        RETURN the NEGATIVE of one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-space-wasted-from-packaging", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minWastedSpace(packages, boxes)  \n        SET MOD TO one billion PLUS one  \n        SORT packages IN ascending order  \n        SET n TO the LENGTH OF packages  \n        \n        CREATE prefix_sum AS a list of zeros with LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix_sum TO element at position i of prefix_sum PLUS element at position i of packages  \n        END FOR  \n        \n        SET min_wasted_space TO infinity  \n        \n        FOR each box IN boxes  \n            SORT box IN ascending order  \n            IF element at last position of box LESS THAN element at last position of packages  \n                CONTINUE to next iteration of the loop  \n            END IF  \n            \n            SET total_wasted TO zero  \n            SET last_index TO zero  \n            \n            FOR each box_size IN box  \n                SET index TO last_index  \n                WHILE index LESS THAN n AND element at position index of packages LESS THAN OR EQUAL TO box_size  \n                    INCREMENT index BY one  \n                END WHILE  \n                \n                IF index GREATER THAN last_index  \n                    SET total_wasted TO total_wasted PLUS (index MINUS last_index) MULTIPLIED BY box_size MINUS (element at position index of prefix_sum MINUS element at position last_index of prefix_sum)  \n                    SET last_index TO index  \n                END IF  \n            END FOR  \n            \n            IF last_index EQUALS n  \n                IF total_wasted LESS THAN min_wasted_space  \n                    SET min_wasted_space TO total_wasted  \n                END IF  \n            END IF  \n        END FOR  \n        \n        IF min_wasted_space NOT EQUALS infinity  \n            RETURN min_wasted_space MODULO MOD  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS an opening parenthesis OR element e EQUALS an ampersand OR element e EQUALS a vertical bar  \n                APPEND a tuple containing element e AND zero TO stack  \n                CONTINUE to the next iteration  \n            ELSE IF element e EQUALS a closing parenthesis  \n                SET lastPair TO the result of removing and returning the last element from stack  \n                REMOVE and discard the last element from stack corresponding to an opening parenthesis  \n            ELSE  \n                SET lastPair TO a tuple containing element e AND one  \n            END IF  \n            IF the length of stack IS GREATER THAN zero AND the first item of the last tuple in stack IS EQUAL TO an ampersand OR a vertical bar  \n                SET op TO the first element of the result of removing and returning the last tuple from stack  \n                SET a AND costA TO the elements of the result of removing and returning the last tuple from stack  \n                SET b AND costB TO the elements of lastPair  \n                IF op EQUALS an ampersand  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one PLUS the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND the smaller of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND one PLUS the smaller of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last tuple in stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-ways-to-build-rooms-in-an-ant-colony", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION waysToBuildRooms(prevRoom)  \n        SET n TO the LENGTH OF prevRoom  \n        ASSIGN graph TO an empty mapping from keys to lists of values  \n        FOR room FROM one TO n MINUS one  \n            APPEND room TO the list at key element at position room of prevRoom in graph  \n        END FOR  \n  \n        FUNCTION dp(node)  \n            IF the list at key node in graph EQUALS empty  \n                RETURN one AND one  \n            END IF  \n  \n            SET total_ways TO one  \n            SET total_size TO one  \n  \n            ASSIGN child_results TO empty list  \n            FOR each child IN the list at key node in graph  \n                SET ways AND size TO dp(child)  \n                APPEND the pair of ways AND size TO child_results  \n                INCREMENT total_size BY size  \n            END FOR  \n  \n            SET current_size TO one  \n            FOR each ways AND size IN child_results  \n                SET total_ways TO total_ways MULTIPLIED BY the combination of current_size PLUS size MINUS one CHOOSE size MULTIPLIED BY ways  \n                APPLY modulo operation to total_ways with modulus equal to MOD  \n                INCREMENT current_size BY size  \n            END FOR  \n  \n            RETURN total_ways AND total_size  \n        END FUNCTION  \n  \n        RETURN the first element of dp applied to zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-common-subpath", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestCommonSubpath WITH PARAMETERS n AND paths  \n        FUNCTION hash_subpaths WITH PARAMETERS path AND length  \n            SET P TO one hundred thirteen  \n            SET MOD TO one billion plus seven  \n            SET hash_value TO zero  \n            SET power TO one  \n            FOR index FROM zero TO length MINUS one  \n                SET hash_value TO hash_value MULTIPLIED BY P PLUS element at position index of path  \n                SET hash_value TO remainder of hash_value DIVIDED BY MOD  \n                SET power TO power MULTIPLIED BY P  \n                SET power TO remainder of power DIVIDED BY MOD  \n            END FOR  \n            SET hashes TO a set containing hash_value  \n            FOR index FROM length TO length of path MINUS one  \n                SET hash_value TO hash_value MULTIPLIED BY P PLUS element at position index of path MINUS element at position index MINUS length of path MULTIPLIED BY power  \n                SET hash_value TO remainder of hash_value DIVIDED BY MOD  \n                ADD hash_value TO hashes  \n            END FOR  \n            RETURN hashes  \n        END FUNCTION  \n        FUNCTION check_common_subpath WITH PARAMETER length  \n            IF length EQUALS zero  \n                RETURN True  \n            END IF  \n            SET common_hashes TO the result of calling hash_subpaths WITH path as element at position zero of paths AND length  \n            FOR each path in paths starting from second element TO the last element  \n                SET current_hashes TO the result of calling hash_subpaths WITH path AND length  \n                SET common_hashes TO the intersection of common_hashes AND current_hashes  \n                IF common_hashes IS empty  \n                    RETURN False  \n                END IF  \n            END FOR  \n            RETURN True if common_hashes is NOT empty OTHERWISE False  \n        END FUNCTION  \n        SET left TO zero  \n        SET right TO the minimum length among lengths of all paths  \n        WHILE left LESS THAN right  \n            SET mid TO left PLUS right PLUS one DIVIDED BY two  \n            IF the result of check_common_subpath WITH mid IS True  \n                SET left TO mid  \n            ELSE  \n                SET right TO right MINUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "erect-the-fence-ii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION outerTrees(trees)  \n        FUNCTION dist_sq(p1, p2)  \n            SET first element of p1 MINUS first element of p2 TO difference_x  \n            SET second element of p1 MINUS second element of p2 TO difference_y  \n            RETURN difference_x MULTIPLIED BY difference_x PLUS difference_y MULTIPLIED BY difference_y  \n        END FUNCTION  \n\n        FUNCTION circumcenter(p1, p2, p3)  \n            SET first element of p1 TO ax  \n            SET second element of p1 TO ay  \n            SET first element of p2 TO bx  \n            SET second element of p2 TO by  \n            SET first element of p3 TO cx  \n            SET second element of p3 TO cy  \n            SET two MULTIPLIED BY (ax MULTIPLIED BY (by MINUS cy) PLUS bx MULTIPLIED BY (cy MINUS ay) PLUS cx MULTIPLIED BY (ay MINUS by)) TO d  \n            SET ((ax MULTIPLIED BY ax PLUS ay MULTIPLIED BY ay) MULTIPLIED BY (by MINUS cy) PLUS (bx MULTIPLIED BY bx PLUS by MULTIPLIED BY by) MULTIPLIED BY (cy MINUS ay) PLUS (cx MULTIPLIED BY cx PLUS cy MULTIPLIED BY cy) MULTIPLIED BY (ay MINUS by)) DIVIDED BY d TO ux  \n            SET ((ax MULTIPLIED BY ax PLUS ay MULTIPLIED BY ay) MULTIPLIED BY (cx MINUS bx) PLUS (bx MULTIPLIED BY bx PLUS by MULTIPLIED BY by) MULTIPLIED BY (ax MINUS cx) PLUS (cx MULTIPLIED BY cx PLUS cy MULTIPLIED BY cy) MULTIPLIED BY (bx MINUS ax)) DIVIDED BY d TO uy  \n            SET list of ux AND uy TO center_point  \n            SET square root of ((ux MINUS ax) MULTIPLIED BY (ux MINUS ax) PLUS (uy MINUS ay) MULTIPLIED BY (uy MINUS ay)) TO radius_length  \n            RETURN center_point AND radius_length  \n        END FUNCTION  \n\n        FUNCTION welzl(points, boundary, n)  \n            IF n EQUALS zero OR LENGTH OF boundary EQUALS three  \n                IF LENGTH OF boundary EQUALS zero  \n                    RETURN list of zero AND zero AND zero FOR radius  \n                ELSE IF LENGTH OF boundary EQUALS one  \n                    RETURN first element of boundary AND zero FOR radius  \n                ELSE IF LENGTH OF boundary EQUALS two  \n                    SET list of (first element of first element of boundary PLUS first element of second element of boundary) DIVIDED BY two AND (second element of first element of boundary PLUS second element of second element of boundary) DIVIDED BY two TO center  \n                    SET square root of dist_sq(first element of boundary, second element of boundary) DIVIDED BY two TO radius  \n                    RETURN center AND radius  \n                ELSE  \n                    RETURN result of circumcenter WITH unpacked boundary elements  \n                END IF  \n            END IF  \n            \n            SET element at position n MINUS one of points TO p  \n            SET result of welzl WITH points boundary AND n MINUS one TO center AND radius  \n            IF dist_sq(center, p) LESS THAN OR EQUAL TO radius MULTIPLIED BY radius  \n                RETURN center AND radius  \n            END IF  \n            \n            RETURN welzl WITH points boundary appended by p AND n MINUS one  \n        END FUNCTION  \n\n        RANDOMLY SHUFFLE trees  \n        SET result of welzl WITH trees EMPTY list AND LENGTH OF trees TO center AND radius  \n        RETURN list of first element of center AND second element of center AND radius  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "painting-a-grid-with-three-different-colors", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION colorTheGrid WITH PARAMETERS m n  \n        SET MOD TO one billion PLUS seven  \n        \n        FUNCTION generate_valid_columns WITH PARAMETER prev_col  \n            SET colors TO list containing one two three  \n            SET valid_cols TO empty list  \n            \n            FUNCTION backtrack WITH PARAMETERS col row  \n                IF row EQUALS m THEN  \n                    APPEND the tuple of col TO valid_cols  \n                    RETURN  \n                END IF  \n                FOR each color IN colors  \n                    IF col IS empty OR element at position the last index of col NOT EQUALS color THEN  \n                        IF prev_col IS NOT none AND element at position row of prev_col EQUALS color THEN  \n                            CONTINUE TO next iteration  \n                        END IF  \n                        APPEND color TO col  \n                        CALL backtrack WITH col AND row PLUS one  \n                        REMOVE the last element FROM col  \n                    END IF  \n                END FOR  \n            END FUNCTION  \n            \n            CALL backtrack WITH empty list AND zero  \n            RETURN valid_cols  \n        END FUNCTION  \n        \n        SET all_valid_cols TO CALL generate_valid_columns WITH argument none  \n        SET num_valid_cols TO the LENGTH OF all_valid_cols  \n        \n        SET compatible_cols TO empty dictionary WITH keys from zero TO num_valid_cols MINUS one each mapped to an empty list  \n        FOR i FROM zero TO num_valid_cols MINUS one  \n            FOR j FROM zero TO num_valid_cols MINUS one  \n                SET all_positions_different TO true  \n                FOR k FROM zero TO m MINUS one  \n                    IF element at position k of element at position i of all_valid_cols EQUALS element at position k of element at position j of all_valid_cols THEN  \n                        SET all_positions_different TO false  \n                        BREAK OUT OF inner loop  \n                    END IF  \n                END FOR  \n                IF all_positions_different THEN  \n                    APPEND j TO compatible_cols AT key i  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET dp TO list containing num_valid_cols elements each set to one  \n        \n        FOR each ignored_variable FROM one TO n MINUS one  \n            SET next_dp TO list containing num_valid_cols elements each set to zero  \n            FOR i FROM zero TO num_valid_cols MINUS one  \n                FOR each j IN compatible_cols AT key i  \n                    SET next_dp AT position j TO next_dp AT position j PLUS dp AT position i  \n                    SET next_dp AT position j TO next_dp AT position j MODULO MOD  \n                END FOR  \n            END FOR  \n            SET dp TO next_dp  \n        END FOR  \n        \n        SET total_ways TO zero  \n        FOR each count IN dp  \n            INCREMENT total_ways BY count  \n        END FOR  \n        RETURN total_ways MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-genetic-difference-query", "passing_rate": 1.0, "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__()  \n        SET children TO a mapping from keys to new TrieNode instances by default  \n        SET count TO zero  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION maxGeneticDifference(parents, queries)  \n        SET tree TO a mapping from keys to empty lists by default  \n        FOR index FROM zero TO LENGTH OF parents MINUS one  \n            SET parent TO element at position index of parents  \n            IF parent NOT EQUALS negative one THEN  \n                APPEND index TO the list at key parent in tree  \n            END IF  \n        END FOR  \n\n        SET node_queries TO a mapping from keys to empty lists by default  \n        FOR each pair consisting of node and val IN queries  \n            APPEND val TO the list at key node in node_queries  \n        END FOR  \n\n        SET root TO a new TrieNode instance  \n\n        SET result TO a list of zeros of LENGTH EQUAL TO LENGTH OF queries  \n\n        FUNCTION dfs(node)  \n            CALL insert WITH trie_root EQUAL TO root AND value EQUAL TO node  \n            FOR each val IN the list at key node in node_queries  \n                SET index TO the value at key pair node val in query_idx  \n                SET element at position index of result TO CALL max_xor WITH trie_root EQUAL TO root AND value EQUAL TO val  \n            END FOR  \n            FOR each child IN the list at key node in tree  \n                CALL dfs WITH child  \n            END FOR  \n            CALL erase WITH trie_root EQUAL TO root AND value EQUAL TO node  \n        END FUNCTION  \n\n        FUNCTION insert(trie_root, value)  \n            SET node TO trie_root  \n            FOR i FROM seventeen DOWN TO zero  \n                SET bit TO the value of the bit at position i of value where zero is least significant bit  \n                SET node TO the element at key bit in the children of node  \n                INCREMENT the count of node BY one  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION erase(trie_root, value)  \n            SET node TO trie_root  \n            FOR i FROM seventeen DOWN TO zero  \n                SET bit TO the value of the bit at position i of value where zero is least significant bit  \n                SET node TO the element at key bit in the children of node  \n                DECREMENT the count of node BY one  \n            END FOR  \n        END FUNCTION  \n\n        FUNCTION max_xor(trie_root, value)  \n            SET node TO trie_root  \n            SET max_xor_val TO zero  \n            FOR i FROM seventeen DOWN TO zero  \n                SET bit TO the value of the bit at position i of value where zero is least significant bit  \n                SET toggled_bit TO one MINUS bit  \n                IF toggled_bit IS A key IN the children of node AND the count of the child at toggled_bit IS GREATER THAN zero THEN  \n                    SET max_xor_val TO max_xor_val PLUS the value of one MULTIPLIED BY two RAISED TO THE power of i  \n                    SET node TO the child at toggled_bit in the children of node  \n                ELSE  \n                    SET node TO the child at bit in the children of node  \n                END IF  \n            END FOR  \n            RETURN max_xor_val  \n        END FUNCTION  \n\n        SET query_idx TO a mapping from pairs node val to their indices generated by enumerating queries  \n\n        FOR i FROM zero TO LENGTH OF parents MINUS one  \n            IF element at position i of parents EQUALS negative one THEN  \n                CALL dfs WITH i  \n                BREAK  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-duplicate-folders-in-system", "passing_rate": 1.0, "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        SET children TO a mapping from string TO TrieNode where missing keys create new TrieNode instances  \n        SET deleted TO logical false  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION deleteDuplicateFolder(self, paths)  \n        SET ans TO empty list  \n        SET root TO new instance of TrieNode  \n        SET subtreeToNodes TO a mapping from string TO list of TrieNode instances with default empty list  \n\n        FOR each path IN the list paths sorted in ascending order  \n            SET node TO root  \n            FOR each s IN path  \n                SET node TO the child of node corresponding TO s in children mapping  \n            END FOR  \n        END FOR  \n\n        FUNCTION buildSubtreeToRoots(node)  \n            SET subtree TO opening parenthesis concatenated WITH the concatenation OVER each s IN the children keys of node OF s concatenated WITH buildSubtreeToRoots for the child of node corresponding TO s concatenated WITH closing parenthesis  \n            IF subtree is NOT EQUALS TO an empty pair of parentheses  \n                APPEND node TO the list mapped by subtree in subtreeToNodes  \n            END IF  \n            RETURN subtree  \n        END FUNCTION  \n\n        CALL buildSubtreeToRoots with argument root  \n\n        FOR each nodes IN the values of subtreeToNodes  \n            IF the length of nodes is GREATER THAN one  \n                FOR each node IN nodes  \n                    SET the deleted field of node TO logical true  \n                END FOR  \n            END IF  \n        END FOR  \n\n        FUNCTION constructPath(node, path)  \n            FOR each s, child IN the pairs of keys and values in the children mapping of node  \n                IF the deleted field of child is logical false  \n                    CALL constructPath with arguments child and the concatenation of path with list containing s  \n                END IF  \n            END FOR  \n            IF path is NOT empty  \n                APPEND path TO ans  \n            END IF  \n        END FUNCTION  \n\n        CALL constructPath with arguments root and empty list  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-number-of-special-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSpecialSubsequences(nums)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO list of three elements each set to zero  \n        FOR each num IN nums  \n            IF num EQUALS zero  \n                SET element at position zero of dp TO element at position zero of dp MULTIPLIED BY two PLUS one MODULO MOD  \n            ELSE IF num EQUALS one  \n                SET element at position one of dp TO element at position one of dp MULTIPLIED BY two PLUS element at position zero of dp MODULO MOD  \n            ELSE IF num EQUALS two  \n                SET element at position two of dp TO element at position two of dp MULTIPLIED BY two PLUS element at position one of dp MODULO MOD  \n            END IF  \n        END FOR  \n        RETURN element at position two of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-the-length-of-two-palindromic-substrings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(s)  \n        SET n TO the LENGTH OF s  \n        SET max_len_end TO list of size n FILLED WITH value one  \n        SET max_len_start TO list of size n FILLED WITH value one  \n        \n        FUNCTION expand_around_center(left, right)  \n            WHILE left GREATER THAN OR EQUAL TO zero AND right LESS THAN n AND element at position left of s EQUALS element at position right of s  \n                SET length TO right MINUS left PLUS one  \n                SET max_len_end at position right TO the GREATER OF max_len_end at position right AND length  \n                SET max_len_start at position left TO the GREATER OF max_len_start at position left AND length  \n                DECREMENT left BY one  \n                INCREMENT right BY one  \n            END WHILE  \n        END FUNCTION  \n        \n        FOR i FROM zero TO n MINUS one  \n            CALL expand_around_center WITH arguments i AND i  \n        END FOR  \n        \n        SET prefix_max TO list of size n FILLED WITH value zero  \n        SET suffix_max TO list of size n FILLED WITH value zero  \n        \n        SET prefix_max at position zero TO max_len_end at position zero  \n        FOR i FROM one TO n MINUS one  \n            SET prefix_max at position i TO the GREATER OF prefix_max at position i MINUS one AND max_len_end at position i  \n        END FOR  \n        \n        SET suffix_max at position n MINUS one TO max_len_start at position n MINUS one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            SET suffix_max at position i TO the GREATER OF suffix_max at position i PLUS one AND max_len_start at position i  \n        END FOR  \n        \n        SET max_product TO zero  \n        FOR i FROM zero TO n MINUS two  \n            SET max_product TO the GREATER OF max_product AND prefix_max at position i MULTIPLIED BY suffix_max at position i PLUS one  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-longest-valid-obstacle-course-at-each-position", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestObstacleCourseAtEachPosition(obstacles)  \n        SET n TO the LENGTH OF obstacles  \n        SET ans TO an empty list  \n        SET increasing_subseq TO an empty list  \n        \n        FOR each obstacle IN obstacles  \n            SET idx TO the position where obstacle can be inserted in increasing_subseq such that all elements before that position are less than or equal to obstacle  \n            \n            IF idx EQUALS the LENGTH OF increasing_subseq  \n                APPEND obstacle TO increasing_subseq  \n            ELSE  \n                SET the element at position idx of increasing_subseq TO obstacle  \n            END IF  \n            \n            APPEND idx PLUS one TO ans  \n        END FOR  \n        \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "last-day-where-you-can-still-cross", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO list of integers from zero TO n MINUS one  \n        SET self.rank TO list of zero repeated n times  \n    END FUNCTION  \n  \n    FUNCTION find(self, x)  \n        IF element at position x of self.parent NOT EQUALS x THEN  \n            SET element at position x of self.parent TO the result of calling find on element at position x of self.parent  \n        END IF  \n        RETURN element at position x of self.parent  \n    END FUNCTION  \n  \n    FUNCTION union(self, x, y)  \n        SET rootX TO the result of calling find on x  \n        SET rootY TO the result of calling find on y  \n        IF rootX NOT EQUALS rootY THEN  \n            IF element at position rootX of self.rank GREATER THAN element at position rootY of self.rank THEN  \n                SET element at position rootY of self.parent TO rootX  \n            ELSE IF element at position rootX of self.rank LESS THAN element at position rootY of self.rank THEN  \n                SET element at position rootX of self.parent TO rootY  \n            ELSE  \n                SET element at position rootY of self.parent TO rootX  \n                INCREMENT element at position rootX of self.rank BY one  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION latestDayToCross(self, row, col, cells)  \n        SET grid TO a list consisting of row elements each of which is a list consisting of col elements each of which is one  \n        SET uf TO a new UnionFind object with parameter row MULTIPLIED BY col PLUS two  \n        SET TOP TO row MULTIPLIED BY col  \n        SET BOTTOM TO row MULTIPLIED BY col PLUS one  \n        SET directions TO a list of four pairs representing negative one and zero positive one and zero zero and negative one zero and positive one  \n        FOR day FROM the length of cells MINUS one DOWN TO zero  \n            SET r TO element at position day of cells at position zero  \n            SET c TO element at position day of cells at position one  \n            DECREMENT r BY one  \n            DECREMENT c BY one  \n            SET element at position r of grid at position c TO zero  \n            FOR each pair dr dc IN directions  \n                SET nr TO r PLUS dr  \n                SET nc TO c PLUS dc  \n                IF nr GREATER THAN OR EQUAL TO zero AND nr LESS THAN row AND nc GREATER THAN OR EQUAL TO zero AND nc LESS THAN col AND element at position nr of grid at position nc EQUALS zero THEN  \n                    CALL uf.union with parameters r MULTIPLIED BY col PLUS c AND nr MULTIPLIED BY col PLUS nc  \n                END IF  \n            END FOR  \n            IF r EQUALS zero THEN  \n                CALL uf.union with parameters r MULTIPLIED BY col PLUS c AND TOP  \n            END IF  \n            IF r EQUALS row MINUS one THEN  \n                CALL uf.union with parameters r MULTIPLIED BY col PLUS c AND BOTTOM  \n            END IF  \n            IF the result of calling uf.find on TOP EQUALS the result of calling uf.find on BOTTOM THEN  \n                RETURN day  \n            END IF  \n        END FOR  \n        RETURN zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-separate-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfCombinations(num)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET n TO the LENGTH OF num  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION dp(index, prev_len)  \n            IF index EQUALS n THEN  \n                RETURN one  \n            END IF  \n            IF the tuple of index AND prev_len EXISTS AS a key IN memo THEN  \n                RETURN the value in memo ASSOCIATED WITH the tuple of index AND prev_len  \n            END IF  \n            \n            SET count TO zero  \n            FOR length FROM one TO the LENGTH OF num MINUS index PLUS one  \n                IF the element at position index of num EQUALS the character zero THEN  \n                    BREAK the FOR loop  \n                END IF  \n                \n                SET current_num TO the substring from position index TO position index PLUS length MINUS one of num  \n                \n                IF prev_len EQUALS zero OR current_num IS GREATER THAN OR EQUAL TO the substring from position index MINUS prev_len TO position index MINUS one of num THEN  \n                    SET count TO the SUM of count AND the result of dp AT index PLUS length AND length MODULO MOD  \n                END IF  \n            END FOR  \n            \n            ASSIGN the value of count TO memo AT key tuple of index AND prev_len  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN dp AT zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-unique-good-subsequences", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfUniqueGoodSubsequences(binary)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET end_with_0 TO zero  \n        SET end_with_1 TO zero  \n        SET has_zero TO whether binary CONTAINS zero  \n        FOR each bit IN binary  \n            IF bit EQUALS one  \n                SET end_with_1 TO the sum of end_with_0 PLUS end_with_1 PLUS one DIVIDED BY MODULO MOD  \n            ELSE  \n                SET end_with_0 TO the sum of end_with_0 PLUS end_with_1 DIVIDED BY MODULO MOD  \n            END IF  \n        END FOR  \n        RETURN the sum of end_with_0 PLUS end_with_1 PLUS has_zero DIVIDED BY MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gcd-sort-of-an-array", "passing_rate": 1.0, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self parent TO a list of integers from zero TO size MINUS one  \n        SET self rank TO a list of size with all elements equal TO one  \n    END FUNCTION  \n\n    FUNCTION find(self, p)  \n        IF element at position p of self parent NOT EQUALS p THEN  \n            SET element at position p of self parent TO the result of calling self find WITH element at position p of self parent  \n        END IF  \n        RETURN element at position p of self parent  \n    END FUNCTION  \n\n    FUNCTION union(self, p, q)  \n        SET rootP TO the result of calling self find WITH p  \n        SET rootQ TO the result of calling self find WITH q  \n        IF rootP EQUALS rootQ THEN  \n            RETURN FALSE  \n        END IF  \n        IF element at position rootP of self rank GREATER THAN element at position rootQ of self rank THEN  \n            SET element at position rootQ of self parent TO rootP  \n        ELSE IF element at position rootP of self rank LESS THAN element at position rootQ of self rank THEN  \n            SET element at position rootP of self parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of self parent TO rootP  \n            INCREMENT element at position rootP of self rank BY one  \n        END IF  \n        RETURN TRUE  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION gcdSort(self, nums)  \n        SET sorted_nums TO nums sorted in ascending order  \n        SET max_val TO the maximum element in nums  \n        SET uf TO a new instance of UnionFind INITIALIZED with max_val PLUS one  \n        FOR each num IN nums  \n            FOR factor FROM two TO the integer part of the square root of num PLUS one  \n                IF num MODULO factor EQUALS zero THEN  \n                    CALL uf union WITH num AND factor  \n                    CALL uf union WITH num AND num DIVIDED BY factor  \n                END IF  \n            END FOR  \n        END FOR  \n        FOR i FROM zero TO the length of nums MINUS one  \n            IF calling uf find WITH element at position i of nums NOT EQUALS calling uf find WITH element at position i of sorted_nums THEN  \n                RETURN FALSE  \n            END IF  \n        END FOR  \n        RETURN TRUE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "subtree-removal-game-with-fibonacci-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findGameWinner(n)  \n        RETURN the remainder when n is divided by six NOT EQUALS to one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-operations-to-make-array-continuous", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minOperations(nums)  \n        SET n TO the LENGTH OF nums  \n        SET unique_nums TO the SORTED list OF all UNIQUE elements FROM nums  \n        SET min_operations TO n  \n        SET j TO zero  \n        FOR i FROM zero TO the LENGTH OF unique_nums MINUS one  \n            WHILE j LESS THAN the LENGTH OF unique_nums AND the element at position j of unique_nums LESS THAN the element at position i of unique_nums PLUS n  \n                INCREMENT j BY one  \n            END WHILE  \n            SET current_operations TO n MINUS the DIFFERENCE BETWEEN j AND i  \n            IF current_operations LESS THAN min_operations  \n                SET min_operations TO current_operations  \n            END IF  \n        END FOR  \n        RETURN min_operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-subsequence-repeated-k-times", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestSubsequenceRepeatedK WITH PARAMETERS s AND k  \n        IMPORT the data structure Counter from collections  \n  \n        SET freq TO Counter of sequence s  \n  \n        SET valid_chars TO an empty list  \n        FOR each character AND count IN the items of freq  \n            IF count GREATER THAN OR EQUAL TO k  \n                APPEND character TO valid_chars  \n            END IF  \n        END FOR  \n  \n        SORT valid_chars in descending lexicographical order  \n  \n        FUNCTION is_valid_subsequence WITH PARAMETER candidate  \n            SET count TO zero  \n            SET index TO zero  \n            FOR each character IN sequence s  \n                IF character EQUALS the element at position index of candidate  \n                    INCREMENT index BY one  \n                    IF index EQUALS the LENGTH OF candidate  \n                        INCREMENT count BY one  \n                        SET index TO zero  \n                        IF count EQUALS k  \n                            RETURN True  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n  \n        SET max_length TO the LENGTH OF valid_chars DIVIDED BY k  \n  \n        SET best_candidate TO an empty string  \n  \n        FUNCTION backtrack WITH PARAMETER candidate  \n            IF the LENGTH OF candidate GREATER THAN the LENGTH OF best_candidate  \n                SET best_candidate TO candidate  \n            END IF  \n            FOR each character IN valid_chars  \n                SET new_candidate TO candidate PLUS character  \n                IF is_valid_subsequence WITH new_candidate RETURNS True  \n                    CALL backtrack WITH new_candidate  \n                END IF  \n            END FOR  \n        END FUNCTION  \n  \n        CALL backtrack WITH an empty string  \n        RETURN best_candidate  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-score-of-students-solving-math-expression", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION scoreOfStudents(s, answers)  \n        FUNCTION evaluate_expression(expression)  \n            SET tokens TO empty list  \n            SET num TO zero  \n            FOR each character IN expression  \n                IF character is a digit THEN  \n                    SET num TO num MULTIPLIED BY ten PLUS the integer value of character  \n                ELSE  \n                    APPEND num TO tokens  \n                    APPEND character TO tokens  \n                    SET num TO zero  \n                END IF  \n            END FOR  \n            APPEND num TO tokens  \n            \n            SET i TO one  \n            WHILE i LESS THAN the LENGTH OF tokens DO  \n                IF element at position i of tokens EQUALS the character representing multiplication THEN  \n                    SET element at position i MINUS one of tokens TO element at position i MINUS one of tokens MULTIPLIED BY element at position i PLUS one of tokens  \n                    REMOVE elements at positions from i TO i PLUS two MINUS one FROM tokens  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n            \n            SET result TO element at position zero of tokens  \n            SET i TO one  \n            WHILE i LESS THAN the LENGTH OF tokens DO  \n                IF element at position i of tokens EQUALS the character representing addition THEN  \n                    SET result TO result PLUS element at position i PLUS one of tokens  \n                END IF  \n                INCREMENT i BY two  \n            END WHILE  \n            \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION get_possible_answers(expression)  \n            IF expression is composed only of digits THEN  \n                RETURN a set containing the integer value of expression  \n            END IF  \n            \n            SET results TO empty set  \n            FOR index i FROM one TO the LENGTH OF expression MINUS one MINUS one STEP two DO  \n                SET left_results TO get_possible_answers(substring from position zero TO position i MINUS one of expression)  \n                SET right_results TO get_possible_answers(substring from position i PLUS one TO the end of expression)  \n                FOR each left_element IN left_results DO  \n                    FOR each right_element IN right_results DO  \n                        IF element at position i of expression EQUALS the character representing addition THEN  \n                            SET result TO left_element PLUS right_element  \n                        ELSE  \n                            SET result TO left_element MULTIPLIED BY right_element  \n                        END IF  \n                        IF result LESS THAN OR EQUAL TO one thousand THEN  \n                            ADD result TO results  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END FOR  \n            RETURN results  \n        END FUNCTION  \n        \n        SET correct_answer TO evaluate_expression(s)  \n        SET possible_answers TO get_possible_answers(s)  \n        \n        SET points TO zero  \n        FOR each answer IN answers DO  \n            IF answer EQUALS correct_answer THEN  \n                INCREMENT points BY five  \n            ELSE IF answer IS IN possible_answers THEN  \n                INCREMENT points BY two  \n            END IF  \n        END FOR  \n        \n        RETURN points  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter the list of integers k parameter the integer) RETURNS integer  \n        SET total_sum TO the sum of all elements in nums  \n        SET n TO the length of nums  \n        CREATE an empty dictionary left_diff that returns zero for missing keys  \n        CREATE an empty dictionary right_diff that returns zero for missing keys  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value at key diff of right_diff BY one  \n        END FOR  \n        SET max_ways TO the value at key zero of right_diff  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff_change TO k MINUS the element at position i of nums  \n            SET new_ways TO the sum of the value at key the negative of diff_change of left_diff AND the value at key diff_change of right_diff  \n            IF max_ways LESS THAN new_ways THEN  \n                SET max_ways TO new_ways  \n            END IF  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value at key diff of right_diff BY one  \n            INCREMENT the value at key diff of left_diff BY one  \n        END FOR  \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-k-length-subsequence-with-occurrences-of-a-letter", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION smallestSubsequence(s STRING, k INTEGER, letter STRING, repetition INTEGER) RETURNS STRING  \n        SET letter_count TO the number of times letter OCCURS IN s  \n        SET stack TO empty list  \n        \n        FOR each index i AND character char IN s  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND character char IS LESS THAN element at the last position of stack AND the LENGTH OF s MINUS i PLUS the LENGTH OF stack MINUS one IS GREATER THAN OR EQUAL TO k  \n                IF element at the last position of stack EQUALS letter  \n                    IF letter_count IS GREATER THAN repetition  \n                        INCREMENT repetition BY one  \n                        REMOVE the last element FROM stack  \n                    ELSE  \n                        BREAK out of WHILE loop  \n                    END IF  \n                ELSE  \n                    REMOVE the last element FROM stack  \n                END IF  \n            END WHILE  \n            \n            IF the LENGTH OF stack IS LESS THAN k  \n                IF character char EQUALS letter  \n                    APPEND character char TO stack  \n                    DECREMENT repetition BY one  \n                ELSE IF the difference between k AND the LENGTH OF stack IS GREATER THAN repetition  \n                    APPEND character char TO stack  \n                END IF  \n                IF character char EQUALS letter  \n                    DECREMENT letter_count BY one  \n                END IF  \n            END IF  \n        END FOR  \n        \n        WHILE the LENGTH OF stack IS LESS THAN k  \n            APPEND letter TO stack  \n        END WHILE  \n        \n        RETURN the concatenation of all elements IN stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-array-into-two-arrays-to-minimize-sum-difference", "passing_rate": 1.0, "pseudocode": "CLASS Solution\n    FUNCTION minimumDifference(nums)\n        SET n TO the LENGTH OF nums DIVIDED BY two\n        SET total_sum TO the SUM OF all elements IN nums\n        SET target TO total_sum DIVIDED BY two\n        SET min_diff TO positive infinity\n        \n        SET left_half TO the elements from position one TO position n of nums\n        SET right_half TO the elements from position n PLUS one TO the end of nums\n        \n        SET left_sums TO a list of empty dictionaries with n PLUS one elements\n        SET right_sums TO a list of empty dictionaries with n PLUS one elements\n        \n        FOR i FROM zero TO n\n            FOR each combination combo of i elements selected FROM left_half\n                SET subset_sum TO the SUM OF elements IN combo\n                IF subset_sum NOT IN left_sums at position i\n                    SET left_sums at position i with key subset_sum TO zero\n                END IF\n                INCREMENT the value at left_sums at position i with key subset_sum BY one\n            END FOR\n            \n            FOR each combination combo of i elements selected FROM right_half\n                SET subset_sum TO the SUM OF elements IN combo\n                IF subset_sum NOT IN right_sums at position i\n                    SET right_sums at position i with key subset_sum TO zero\n                END IF\n                INCREMENT the value at right_sums at position i with key subset_sum BY one\n            END FOR\n        END FOR\n        \n        FOR i FROM zero TO n\n            SET left_values TO the sorted list of keys FROM left_sums at position i\n            SET right_values TO the sorted list of keys FROM right_sums at position n MINUS i\n            \n            SET j TO zero\n            SET k TO the LENGTH OF right_values MINUS one\n            WHILE j LESS THAN the LENGTH OF left_values AND k GREATER THAN OR EQUAL TO zero\n                SET current_sum TO the element at position j of left_values PLUS the element at position k of right_values\n                SET candidate_diff TO total_sum MINUS two MULTIPLIED BY current_sum\n                SET candidate_diff TO the absolute value of candidate_diff\n                IF candidate_diff LESS THAN min_diff\n                    SET min_diff TO candidate_diff\n                END IF\n                \n                IF current_sum LESS THAN target\n                    INCREMENT j BY one\n                ELSE IF current_sum GREATER THAN target\n                    DECREMENT k BY one\n                ELSE\n                    RETURN zero\n                END IF\n            END WHILE\n        END FOR\n        \n        RETURN min_diff\n    END FUNCTION\nEND CLASS"}
{"task_id": "second-minimum-time-to-reach-destination", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION secondMinimum(n INTEGER, edges LIST OF LIST OF INTEGER, time INTEGER, change INTEGER) RETURNS INTEGER  \n        SET graph TO an empty list containing n PLUS one empty lists  \n        FOR each pair u AND v IN edges  \n            APPEND v TO element at position u of graph  \n            APPEND u TO element at position v of graph  \n        END FOR  \n        \n        SET queue TO a double-ended queue containing a single tuple with element one current vertex AND element zero current time AND element zero count  \n        SET minTimes TO a list containing n PLUS one lists each containing two elements set to positive infinity  \n        SET element at position zero of element at position one of minTimes TO zero  \n        \n        WHILE queue is not empty  \n            REMOVE the first element FROM queue AND SET current TO the first item of this element AND SET currentTime TO the second item AND SET count TO the third item  \n            \n            IF current EQUALS n AND count EQUALS one  \n                RETURN currentTime  \n            END IF  \n            \n            IF the integer division of currentTime BY change MODULO two EQUALS zero  \n                SET nextTime TO currentTime PLUS time  \n            ELSE  \n                SET nextTime TO the product of the sum of the integer division of currentTime BY change PLUS one AND change PLUS time  \n            END IF  \n            \n            FOR each neighbor IN element at position current of graph  \n                IF element at position zero of element at position neighbor of minTimes GREATER THAN nextTime  \n                    SET element at position one of element at position neighbor of minTimes TO element at position zero of element at position neighbor of minTimes  \n                    SET element at position zero of element at position neighbor of minTimes TO nextTime  \n                    APPEND a tuple containing neighbor AND nextTime AND zero TO queue  \n                ELSE IF element at position zero of element at position neighbor of minTimes LESS THAN nextTime AND nextTime LESS THAN element at position one of element at position neighbor of minTimes  \n                    SET element at position one of element at position neighbor of minTimes TO nextTime  \n                    APPEND a tuple containing neighbor AND nextTime AND one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN the negative of one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parallel-courses-iii", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTime(n, relations, time)  \n        SET graph TO an empty mapping with default value as empty list  \n        FOR each pair OF prevCourse AND nextCourse IN relations  \n            APPEND prevCourse TO element at position nextCourse of graph  \n        END FOR  \n        \n        SET memo TO a list of size n PLUS one FILLED WITH minus one  \n        \n        FUNCTION dfs(course)  \n            IF element at position course of memo NOT EQUALS minus one THEN  \n                RETURN element at position course of memo  \n            END IF  \n            \n            SET max_prerequisite_time TO zero  \n            FOR each prevCourse IN element at position course of graph  \n                SET max_prerequisite_time TO the greater value BETWEEN max_prerequisite_time AND dfs(prevCourse)  \n            END FOR  \n            \n            SET element at position course of memo TO max_prerequisite_time PLUS element at position course MINUS one of time  \n            RETURN element at position course of memo  \n        END FUNCTION  \n        \n        SET total_minimum_time TO zero  \n        FOR course FROM one TO n  \n            SET total_minimum_time TO the greater value BETWEEN total_minimum_time AND dfs(course)  \n        END FOR  \n        \n        RETURN total_minimum_time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-valid-move-combinations-on-chessboard", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countCombinations(pieces PARAMETERS pieces AND positions PARAMETERS positions)  \n        SET directions TO a mapping from piece types TO lists of pairs of direction increments AS follows  \n            rook maps TO a list of pairs representing one step downward one step upward one step rightward one step leftward  \n            queen maps TO a list of pairs representing one step downward one step upward one step rightward one step leftward plus one step diagonal downward rightward one step diagonal upward rightward one step diagonal downward leftward one step diagonal upward leftward  \n            bishop maps TO a list of pairs representing one step diagonal downward rightward one step diagonal upward rightward one step diagonal downward leftward one step diagonal upward leftward  \n        SET positions TO the list constructed by subtracting one from the row and one from the column of each pair in the original positions list  \n        \n        FUNCTION get_destinations(start PARAMETERS start AND piece_type PARAMETERS piece_type)  \n            SET row TO the first element of start  \n            SET column TO the second element of start  \n            SET dests TO a list containing the start position  \n            FOR each pair of direction row increment and direction column increment IN the directions for the given piece_type  \n                SET next_row TO row PLUS direction row increment  \n                SET next_column TO column PLUS direction column increment  \n                WHILE next_row is greater than or equal to zero AND next_row is less than eight AND next_column is greater than or equal to zero AND next_column is less than eight  \n                    APPEND the pair of next_row and next_column TO dests  \n                    INCREMENT next_row BY direction row increment  \n                    INCREMENT next_column BY direction column increment  \n                END WHILE  \n            END FOR  \n            RETURN dests  \n        END FUNCTION  \n        \n        SET all_destinations TO the list constructed by applying get_destinations to each pair of corresponding elements of positions and pieces using pairing by position AND piece  \n        \n        FUNCTION is_valid_combination(combination PARAMETERS combination)  \n            SET current_positions TO a new list copying the positions list  \n            SET number_of_pieces TO the length of current_positions  \n            WHILE true  \n                IF the length of the set constructed from current_positions is less than number_of_pieces  \n                    RETURN false  \n                END IF  \n                SET all_reached TO true  \n                FOR index FROM zero TO number_of_pieces MINUS one  \n                    IF element at position index of current_positions EQUALS element at position index of combination  \n                        CONTINUE TO the next iteration of the loop  \n                    END IF  \n                    SET all_reached TO false  \n                    SET row TO element at position zero of element at position index of current_positions  \n                    SET column TO element at position one of element at position index of current_positions  \n                    SET target_row TO element at position zero of element at position index of combination  \n                    SET target_column TO element at position one of element at position index of combination  \n                    IF target_row GREATER THAN row  \n                        SET direction_row TO one  \n                    ELSE IF target_row LESS THAN row  \n                        SET direction_row TO negative one  \n                    ELSE  \n                        SET direction_row TO zero  \n                    END IF  \n                    IF target_column GREATER THAN column  \n                        SET direction_column TO one  \n                    ELSE IF target_column LESS THAN column  \n                        SET direction_column TO negative one  \n                    ELSE  \n                        SET direction_column TO zero  \n                    END IF  \n                    SET element at position index of current_positions TO the pair of row PLUS direction_row AND column PLUS direction_column  \n                END FOR  \n                IF all_reached IS true  \n                    RETURN true  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n        \n        SET valid_count TO zero  \n        FOR each combination IN the cartesian product of all_destinations unpacked  \n            IF is_valid_combination with combination as argument  \n                INCREMENT valid_count BY one  \n            END IF  \n        END FOR  \n        \n        RETURN valid_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-path-quality-of-a-graph", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximalPathQuality(values PARAMETER values OF TYPE List OF Integer, edges PARAMETER edges OF TYPE List OF List OF Integer, maxTime PARAMETER maxTime OF TYPE Integer) RETURNS Integer  \n        SET graph TO a new mapping from integer to list initialized with empty list for each key  \n        FOR each element comprised of u comma v comma time IN edges  \n            APPEND pair of element neighbor v and element time TO the list corresponding to element u in graph  \n            APPEND pair of element neighbor u and element time TO the list corresponding to element v in graph  \n        END FOR  \n        \n        SET visited TO a new empty set  \n        SET max_quality TO zero  \n        \n        FUNCTION dfs(node PARAMETER node OF TYPE Integer, current_time PARAMETER current_time OF TYPE Integer, current_quality PARAMETER current_quality OF TYPE Integer)  \n            NONLOCAL max_quality  \n            \n            IF node EQUALS zero THEN  \n                SET max_quality TO maximum of max_quality AND current_quality  \n            END IF  \n            \n            FOR each pair neighbor comma time IN the list corresponding to element node in graph  \n                IF time LESS THAN OR EQUAL TO current_time THEN  \n                    IF neighbor NOT IN visited THEN  \n                        ADD neighbor TO visited  \n                        CALL dfs WITH neighbor AND current_time MINUS time AND current_quality PLUS the element at position neighbor of values  \n                        REMOVE neighbor FROM visited  \n                    ELSE  \n                        CALL dfs WITH neighbor AND current_time MINUS time AND current_quality  \n                    END IF  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        ADD zero TO visited  \n        CALL dfs WITH zero AND maxTime AND the element at position zero of values  \n        \n        RETURN max_quality  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-tasks-you-can-assign", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxTaskAssign(tasks AS List of integers, workers AS List of integers, pills AS integer, strength AS integer) RETURNS integer  \n        SORT tasks IN ASCENDING ORDER  \n        SORT workers IN ASCENDING ORDER  \n        \n        FUNCTION canAssignTasks(k AS integer) RETURNS boolean  \n            SET available_workers TO last k elements of workers  \n            SET pills_used TO zero  \n            \n            FOR i FROM k MINUS one DOWN TO zero  \n                SET task TO element at position i of tasks  \n                SET worker_idx TO position of first element in available_workers GREATER THAN OR EQUAL TO task  \n                IF worker_idx IS LESS THAN the LENGTH OF available_workers THEN  \n                    REMOVE element at position worker_idx FROM available_workers  \n                ELSE IF pills_used IS LESS THAN pills THEN  \n                    SET worker_idx TO position of first element in available_workers GREATER THAN OR EQUAL TO task MINUS strength  \n                    IF worker_idx IS LESS THAN the LENGTH OF available_workers THEN  \n                        REMOVE element at position worker_idx FROM available_workers  \n                        INCREMENT pills_used BY one  \n                    ELSE  \n                        RETURN false  \n                    END IF  \n                ELSE  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO the smaller of the LENGTH OF tasks AND the LENGTH OF workers PLUS one  \n        WHILE left IS LESS THAN right  \n            SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n            IF canAssignTasks(mid) THEN  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        RETURN left MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-k-mirror-numbers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kMirror WITH PARAMETERS k n  \n        FUNCTION is_palindrome WITH PARAMETER s  \n            RETURN s EQUALS reverse of s  \n        END FUNCTION  \n        \n        FUNCTION to_base_k WITH PARAMETERS num k  \n            IF num EQUALS zero  \n                RETURN the string zero  \n            END IF  \n            SET digits TO an empty list  \n            WHILE num is greater than zero  \n                APPEND the remainder of num DIVIDED BY k converted to integer TO digits  \n                SET num TO the integer division of num BY k  \n            END WHILE  \n            RETURN concatenation of the string conversion of elements in the reverse order of digits  \n        END FUNCTION  \n        \n        FUNCTION generate_palindromes WITH PARAMETER length  \n            IF length EQUALS one  \n                FOR i FROM one TO nine  \n                    YIELD the string conversion of i  \n                END FOR  \n            ELSE  \n                SET start TO ten raised to the power of integer division of (length MINUS one) BY two  \n                SET end TO ten raised to the power of integer division of (length PLUS one) BY two  \n                FOR half FROM start TO one LESS THAN end  \n                    SET half_str TO the string conversion of half  \n                    IF length MODULO two EQUALS zero  \n                        SET full TO concatenation of half_str AND reverse of half_str  \n                    ELSE  \n                        SET full TO concatenation of half_str AND reverse of substring of half_str from the second last character TO the first character  \n                    END IF  \n                    YIELD full  \n                END FOR  \n            END IF  \n        END FUNCTION  \n        \n        SET k_mirror_numbers TO an empty list  \n        SET length TO one  \n        WHILE the LENGTH OF k_mirror_numbers LESS THAN n  \n            FOR each pal IN generate_palindromes with parameter length  \n                SET num TO the integer conversion of pal  \n                IF is_palindrome with the argument of to_base_k with parameters num AND k RETURNS true  \n                    APPEND num TO k_mirror_numbers  \n                    IF the LENGTH OF k_mirror_numbers EQUALS n  \n                        BREAK the inner loop  \n                    END IF  \n                END IF  \n            END FOR  \n            INCREMENT length BY one  \n        END WHILE  \n        \n        RETURN the sum of all elements in k_mirror_numbers  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-fertile-pyramids-in-a-land", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPyramids grid  \n        FUNCTION count_pyramids_from_top grid  \n            IF grid EQUALS empty OR the element at position zero of grid EQUALS empty  \n                RETURN zero  \n            END IF  \n            SET m TO the LENGTH OF grid  \n            SET n TO the LENGTH OF the element at position zero of grid  \n            SET dp TO a list of m elements each being a list of n elements each being zero  \n            SET count TO zero  \n            FOR index i FROM zero TO m MINUS one  \n                FOR index j FROM zero TO n MINUS one  \n                    IF element at position j of element at position i of grid EQUALS one  \n                        IF i EQUALS zero OR j EQUALS zero OR j EQUALS n MINUS one  \n                            SET element at position j of element at position i of dp TO one  \n                        ELSE  \n                            SET element at position j of element at position i of dp TO the MINIMUM OF element at position j MINUS one of element at position i MINUS one of dp AND element at position j of element at position i MINUS one of dp AND element at position j PLUS one of element at position i MINUS one of dp PLUS one  \n                        END IF  \n                        IF element at position j of element at position i of dp GREATER THAN one  \n                            INCREMENT count BY element at position j of element at position i of dp MINUS one  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        FUNCTION count_pyramids_from_bottom grid  \n            IF grid EQUALS empty OR the element at position zero of grid EQUALS empty  \n                RETURN zero  \n            END IF  \n            SET m TO the LENGTH OF grid  \n            SET n TO the LENGTH OF the element at position zero of grid  \n            SET dp TO a list of m elements each being a list of n elements each being zero  \n            SET count TO zero  \n            FOR index i FROM m MINUS one DOWN TO zero  \n                FOR index j FROM zero TO n MINUS one  \n                    IF element at position j of element at position i of grid EQUALS one  \n                        IF i EQUALS m MINUS one OR j EQUALS zero OR j EQUALS n MINUS one  \n                            SET element at position j of element at position i of dp TO one  \n                        ELSE  \n                            SET element at position j of element at position i of dp TO the MINIMUM OF element at position j MINUS one of element at position i PLUS one of dp AND element at position j of element at position i PLUS one of dp AND element at position j PLUS one of element at position i PLUS one of dp PLUS one  \n                        END IF  \n                        IF element at position j of element at position i of dp GREATER THAN one  \n                            INCREMENT count BY element at position j of element at position i of dp MINUS one  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN the RESULT OF count_pyramids_from_top WITH grid PLUS the RESULT OF count_pyramids_from_bottom WITH grid  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-all-people-with-secret", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION findAllPeople(n, meetings, firstPerson)  \n        SET know_secret TO the set containing zero and firstPerson  \n        SORT meetings IN ascending order ACCORDING TO the element at position three of each meeting  \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF meetings  \n            SET current_time TO the element at position three of the meeting at position i of meetings  \n            SET graph TO a new map FROM integers TO lists  \n            WHILE i LESS THAN the LENGTH OF meetings AND the element at position three of the meeting at position i of meetings EQUALS current_time  \n                SET x TO the element at position one of the meeting at position i of meetings  \n                SET y TO the element at position two of the meeting at position i of meetings  \n                APPEND y TO the list at key x in graph  \n                APPEND x TO the list at key y in graph  \n                INCREMENT i BY one  \n            END WHILE  \n            SET queue TO a new double-ended queue containing each person IN know_secret WHOSE value IS a key in graph  \n            SET visited TO an empty set  \n            WHILE the LENGTH OF queue IS GREATER THAN zero  \n                REMOVE the element at the front of queue AND ASSIGN it TO person  \n                IF person IS IN visited  \n                    CONTINUE TO the next iteration of the WHILE loop  \n                END IF  \n                ADD person TO visited  \n                ADD person TO know_secret  \n                FOR each neighbor IN the list at key person in graph  \n                    IF neighbor IS NOT IN visited  \n                        APPEND neighbor TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n        END WHILE  \n        RETURN a list containing all elements of know_secret  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-arrangement-of-pairs", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION validArrangement(pairs)  \n        SET graph TO a mapping from keys to empty lists  \n        SET out_degree TO a mapping counting occurrences of keys  \n        SET in_degree TO a mapping counting occurrences of keys  \n        \n        FOR each element u and element v IN pairs  \n            APPEND element v TO the list at key u in graph  \n            INCREMENT out_degree at key u BY one  \n            INCREMENT in_degree at key v BY one  \n        END FOR  \n        \n        SET start_node TO none  \n        FOR each node IN graph keys  \n            IF value of out_degree at node EQUALS value of in_degree at node PLUS one THEN  \n                SET start_node TO node  \n                BREAK  \n            END IF  \n        END FOR  \n        \n        IF start_node EQUALS none THEN  \n            SET start_node TO any element from the keys of graph  \n        END IF  \n        \n        SET path TO an empty list  \n        SET stack TO a list containing start_node  \n        \n        WHILE stack is not empty  \n            SET u TO the last element of stack  \n            IF the list at key u in graph is not empty THEN  \n                SET v TO the last element of the list at key u in graph  \n                REMOVE the last element from the list at key u in graph  \n                APPEND element v TO stack  \n            ELSE  \n                REMOVE the last element from stack and APPEND it TO path  \n            END IF  \n        END WHILE  \n        \n        REVERSE the order of elements in path  \n        \n        SET result TO an empty list  \n        FOR each index i FROM zero TO the length of path MINUS one  \n            APPEND a list containing element at position i of path and element at position i PLUS one of path TO result  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits, startPos, k)  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        FOR right FROM zero TO the LENGTH OF fruits MINUS one  \n            SET position TO the element at position right of fruits at position zero  \n            SET amount TO the element at position right of fruits at position one  \n            INCREMENT total_fruits BY amount  \n            WHILE left LESS THAN OR EQUAL TO right AND NOT (startPos MINUS k LESS THAN OR EQUAL TO the element at position left of fruits at position zero AND the element at position left of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND startPos MINUS k LESS THAN OR EQUAL TO the element at position right of fruits at position zero AND the element at position right of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND the MINIMUM OF the ABSOLUTE VALUE OF the element at position right of fruits at position zero MINUS startPos AND the ABSOLUTE VALUE OF the element at position left of fruits at position zero MINUS startPos PLUS the element at position right of fruits at position zero MINUS the element at position left of fruits at position zero LESS THAN OR EQUAL TO k)  \n                DECREMENT total_fruits BY the element at position left of fruits at position one  \n                INCREMENT left BY one  \n            END WHILE  \n            SET max_fruits TO the GREATER OF max_fruits AND total_fruits  \n        END FOR  \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-operations-to-make-the-array-k-increasing", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION kIncreasing(arr parameter k)  \n        FUNCTION longest_increasing_subsequence(subarr parameter)  \n            SET lis TO empty list  \n            FOR each num IN subarr  \n                IF lis EQUALS empty list OR num GREATER THAN OR EQUAL TO element at last position of lis  \n                    APPEND num TO lis  \n                ELSE  \n                    SET pos TO the position where num can be inserted to maintain sorted order in lis using bisect right logic  \n                    SET element at position pos of lis TO num  \n                END IF  \n            END FOR  \n            RETURN the LENGTH OF lis  \n        END FUNCTION  \n        \n        SET total_operations TO zero  \n        SET n TO the LENGTH OF arr  \n        \n        FOR start FROM zero TO k MINUS one  \n            SET subarr TO empty list  \n            FOR i FROM start TO n MINUS one STEP k  \n                APPEND element at position i of arr TO subarr  \n            END FOR  \n            SET lis_length TO CALL longest_increasing_subsequence WITH subarr  \n            INCREMENT total_operations BY the LENGTH OF subarr MINUS lis_length  \n        END FOR  \n        \n        RETURN total_operations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-operations-to-remove-adjacent-ones-in-matrix", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumOperations(grid)  \n        FUNCTION bfs()  \n            SET queue TO an empty double ended queue  \n            FOR u FROM zero TO n MINUS one  \n                IF element at position u of match EQUALS negative one  \n                    SET element at position u of dist TO zero  \n                    APPEND u TO queue  \n                ELSE  \n                    SET element at position u of dist TO infinity  \n                END IF  \n            END FOR  \n            SET element at position negative one of dist TO infinity  \n            WHILE queue is not empty  \n                SET u TO the element removed from the left side of queue  \n                IF element at position u of dist LESS THAN element at position negative one of dist  \n                    FOR each element v IN element at position u of graph  \n                        IF element at position element at position v of match of dist EQUALS infinity  \n                            SET element at position element at position v of match of dist TO element at position u of dist PLUS one  \n                            APPEND element at position element at position v of match TO queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END WHILE  \n            RETURN element at position negative one of dist LESS THAN infinity  \n        END FUNCTION  \n        \n        FUNCTION dfs(u)  \n            IF u NOT EQUALS negative one  \n                FOR each element v IN element at position u of graph  \n                    IF element at position element at position v of match of dist EQUALS element at position u of dist PLUS one  \n                        IF dfs(element at position v of match)  \n                            SET element at position v of match TO u  \n                            SET element at position u of match TO v  \n                            RETURN True  \n                        END IF  \n                    END IF  \n                END FOR  \n                SET element at position u of dist TO infinity  \n                RETURN False  \n            END IF  \n            RETURN True  \n        END FUNCTION  \n        \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        SET n TO rows MULTIPLIED BY cols  \n        SET graph TO a list of empty sets with the LENGTH OF n PLUS one  \n        SET match TO a list of negative ones with the LENGTH OF n PLUS one  \n        SET dist TO a list of zeros with the LENGTH OF n PLUS one  \n        \n        FOR r FROM zero TO rows MINUS one  \n            FOR c FROM zero TO cols MINUS one  \n                IF element at position r of grid at position c EQUALS one  \n                    SET u TO r MULTIPLIED BY cols PLUS c  \n                    FOR each pair dr dc IN the list containing negative one zero, one zero, zero negative one, zero one  \n                        SET nr TO r PLUS dr  \n                        SET nc TO c PLUS dc  \n                        IF zero LESS THAN OR EQUAL TO nr AND nr LESS THAN rows AND zero LESS THAN OR EQUAL TO nc AND nc LESS THAN cols AND element at position nr of grid at position nc EQUALS one  \n                            SET v TO nr MULTIPLIED BY cols PLUS nc  \n                            ADD v TO element at position u of graph  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET matching TO zero  \n        WHILE bfs()  \n            FOR u FROM zero TO n MINUS one  \n                IF element at position u of match EQUALS negative one AND dfs(u)  \n                    INCREMENT matching BY one  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN matching  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "stamping-the-grid", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION possibleToStamp(grid, stampHeight, stampWidth)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF the element at position zero of grid  \n        \n        FUNCTION prefix_sum(matrix)  \n            SET p TO a new matrix of zeros with dimensions m PLUS one BY n PLUS one  \n            FOR r FROM one TO m  \n                FOR c FROM one TO n  \n                    SET element_at_r_c_of_p TO element at position r MINUS one AND c MINUS one of matrix PLUS element at position r MINUS one AND c of p PLUS element at position r AND c MINUS one of p MINUS element at position r MINUS one AND c MINUS one of p  \n                END FOR  \n            END FOR  \n            RETURN p  \n        END FUNCTION  \n        \n        FUNCTION submatrix_sum(p, r1, c1, r2, c2)  \n            RETURN element at position r2 PLUS one AND c2 PLUS one of p MINUS element at position r2 PLUS one AND c1 of p MINUS element at position r1 AND c2 PLUS one of p PLUS element at position r1 AND c1 of p  \n        END FUNCTION  \n        \n        SET p_grid TO prefix_sum called with argument grid  \n        \n        SET p_stamps TO a new matrix of zeros with dimensions m PLUS one BY n PLUS one  \n        \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                IF element at position r AND c of grid EQUALS zero THEN  \n                    IF r PLUS stampHeight LESS THAN OR EQUAL TO m AND c PLUS stampWidth LESS THAN OR EQUAL TO n THEN  \n                        IF submatrix_sum called with arguments p_grid r c r PLUS stampHeight MINUS one c PLUS stampWidth MINUS one EQUALS zero THEN  \n                            INCREMENT element at position r AND c of p_stamps BY one  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET p_stamps TO prefix_sum called with argument p_stamps  \n        \n        FOR r FROM zero TO m MINUS one  \n            FOR c FROM zero TO n MINUS one  \n                IF element at position r AND c of grid EQUALS zero THEN  \n                    IF submatrix_sum called with arguments p_stamps the GREATER VALUE OF zero AND r MINUS stampHeight PLUS one the GREATER VALUE OF zero AND c MINUS stampWidth PLUS one r c EQUALS zero THEN  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "earliest-possible-day-of-full-bloom", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION earliestFullBloom(plantTime growTime)  \n        SET tasks TO list of pairs each containing element at position i of plantTime AND element at position i of growTime FOR index i FROM zero TO length of plantTime MINUS one  \n        SORT tasks BY second element of each pair IN descending order  \n        SET current_day TO zero  \n        SET earliest_bloom TO zero  \n        FOR each pair IN tasks  \n            DECOMPOSE pair INTO plant AND grow  \n            INCREMENT current_day BY plant  \n            SET bloom_day TO current_day PLUS grow  \n            IF bloom_day GREATER THAN earliest_bloom  \n                SET earliest_bloom TO bloom_day  \n            END IF  \n        END FOR  \n        RETURN earliest_bloom  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-running-time-of-n-computers", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxRunTime WITH parameters n batteries  \n        FUNCTION canRunFor WITH parameter time  \n            SET total TO zero  \n            FOR each battery IN batteries  \n                INCREMENT total BY the lesser VALUE BETWEEN battery AND time  \n            END FOR  \n            RETURN total GREATER THAN OR EQUAL TO time MULTIPLIED BY n  \n        END FUNCTION  \n        SET left TO zero  \n        SET right TO the SUM OF batteries DIVIDED BY n  \n        WHILE left LESS THAN right  \n            SET mid TO the INTEGER RESULT OF left PLUS right PLUS one DIVIDED BY two  \n            IF canRunFor WITH mid IS true  \n                SET left TO mid  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN left  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "choose-numbers-from-two-arrays-in-range", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countSubranges(nums1 PARAMETER, nums2 PARAMETER)  \n        SET n TO the LENGTH OF nums1  \n        SET count TO zero  \n        SET dp TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND to dp a new empty dictionary with default integer zero  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET the element at key element at position i of nums1 of dictionary at position i of dp TO the current value at that key PLUS one  \n            SET the element at key NEGATIVE element at position i of nums2 of dictionary at position i of dp TO the current value at that key PLUS one  \n            \n            IF i GREATER THAN zero THEN  \n                FOR each balance key AND freq value IN the items of dictionary at position i MINUS one of dp  \n                    SET the element at key balance PLUS element at position i of nums1 of dictionary at position i of dp TO the sum of the current value at that key AND freq value MODULO ten TO the power of nine PLUS seven  \n                    SET the element at key balance MINUS element at position i of nums2 of dictionary at position i of dp TO the sum of the current value at that key AND freq value MODULO ten TO the power of nine PLUS seven  \n                END FOR  \n            END IF  \n            \n            SET count TO the sum of count AND the value at key zero of dictionary at position i of dp MODULO ten TO the power of nine PLUS seven  \n        END FOR  \n        \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-good-people-based-on-statements", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE LEFT SHIFTED MINUS one BY n TIMES  \n            SET good TO a list of n elements each being false  \n            SET bad TO a list of n elements each being false  \n            FOR j FROM zero TO n MINUS one  \n                IF the result of i BITWISE AND the NUMBER ONE LEFT SHIFTED BY j TIMES IS NOT EQUAL TO zero  \n                    SET element at position j of good TO true  \n                ELSE  \n                    SET element at position j of bad TO true  \n                END IF  \n            END FOR  \n            SET valid TO true  \n            FOR j FROM zero TO n MINUS one  \n                IF element at position j of good IS true  \n                    FOR k FROM zero TO n MINUS one  \n                        IF (element at position k of element at position j of statements EQUALS zero AND element at position k of good IS true) OR (element at position k of element at position j of statements EQUALS one AND element at position k of bad IS true)  \n                            SET valid TO false  \n                            BREAK from the inner loop  \n                        END IF  \n                    END FOR  \n                    IF valid IS false  \n                        BREAK from the outer loop  \n                    END IF  \n                END IF  \n            END FOR  \n            IF valid IS true  \n                SET count_good TO zero  \n                FOR each value IN good  \n                    IF value IS true  \n                        INCREMENT count_good BY one  \n                    END IF  \n                END FOR  \n                IF count_good GREATER THAN max_good  \n                    SET max_good TO count_good  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-substring-with-given-hash-value", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION subStrHash(s power modulo k hashValue)  \n        FUNCTION val(c)  \n            RETURN the Unicode code point of character c MINUS the Unicode code point of lowercase letter a PLUS one  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF string s  \n        SET current_hash TO zero  \n        SET p_pow TO one  \n        \n        FOR index FROM n MINUS k TO n MINUS one  \n            SET current_hash TO the REMAINDER after division of current_hash PLUS the VALUE returned by val applied to element at position index of s MULTIPLIED BY p_pow BY modulo  \n            IF index LESS THAN n MINUS one  \n                SET p_pow TO the REMAINDER after division of p_pow MULTIPLIED BY power BY modulo  \n            END IF  \n        END FOR  \n        \n        SET start_index TO n MINUS k  \n        IF current_hash EQUALS hashValue  \n            RETURN the SUBSTRING of string s from position start_index TO position start_index PLUS k  \n        END IF  \n        \n        SET p_pow_k_minus_1 TO p_pow  \n        FOR index FROM n MINUS k MINUS one DOWN TO zero  \n            SET current_hash TO the REMAINDER after division of current_hash MINUS the VALUE returned by val applied to element at position index PLUS k of s MULTIPLIED BY p_pow_k_minus_1 BY modulo  \n            SET current_hash TO the REMAINDER after division of current_hash MULTIPLIED BY power PLUS the VALUE returned by val applied to element at position index of s BY modulo  \n            \n            IF current_hash EQUALS hashValue  \n                SET start_index TO index  \n            END IF  \n        END FOR  \n        \n        RETURN the SUBSTRING of string s from position start_index TO position start_index PLUS k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-remove-all-cars-containing-illegal-goods", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTime WITH PARAMETER s  \n        SET n TO the LENGTH OF s  \n        SET left_costs TO a LIST of zeroes with the LENGTH OF n  \n        SET right_costs TO a LIST of zeroes with the LENGTH OF n  \n        \n        IF element at position zero of s EQUALS the character one  \n            SET element at position zero of left_costs TO one  \n        ELSE  \n            SET element at position zero of left_costs TO zero  \n        END IF  \n        \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s EQUALS the character zero  \n                SET element at position i of left_costs TO element at position i MINUS one of left_costs  \n            ELSE  \n                SET element at position i of left_costs TO the SMALLER OF i PLUS one AND element at position i MINUS one of left_costs PLUS two  \n            END IF  \n        END FOR  \n        \n        IF element at position n MINUS one of s EQUALS the character one  \n            SET element at position n MINUS one of right_costs TO one  \n        ELSE  \n            SET element at position n MINUS one of right_costs TO zero  \n        END IF  \n        \n        FOR i FROM n MINUS two DOWN TO zero  \n            IF element at position i of s EQUALS the character zero  \n                SET element at position i of right_costs TO element at position i PLUS one of right_costs  \n            ELSE  \n                SET element at position i of right_costs TO the SMALLER OF n MINUS i AND element at position i PLUS one of right_costs PLUS two  \n            END IF  \n        END FOR  \n        \n        SET min_time TO the SMALLER OF element at position n MINUS one of left_costs AND element at position zero of right_costs  \n        \n        FOR i FROM zero TO n MINUS two  \n            SET min_time TO the SMALLER OF min_time AND element at position i of left_costs PLUS element at position i PLUS one of right_costs  \n        END FOR  \n        \n        RETURN min_time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-and-sum-of-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumANDSum(nums numSlots)  \n        FUNCTION dp(index slots)  \n            IF index EQUALS the LENGTH OF nums THEN  \n                RETURN zero  \n            END IF  \n            \n            SET max_and_sum TO zero  \n            SET slots_list TO a LIST containing the elements of slots  \n            \n            FOR i FROM zero TO numSlots MINUS one  \n                IF the element at position i of slots_list LESS THAN two THEN  \n                    INCREMENT the element at position i of slots_list BY one  \n                    SET and_sum TO the element at position index of nums AND the value i PLUS one PLUS the RESULT OF dp with arguments index PLUS one and the TUPLE of slots_list  \n                    SET max_and_sum TO the GREATER VALUE between max_and_sum AND and_sum  \n                    DECREMENT the element at position i of slots_list BY one  \n                END IF  \n            END FOR  \n            \n            RETURN max_and_sum  \n        END FUNCTION  \n        \n        SET initial_slots TO the TUPLE of zero REPEATED numSlots TIMES  \n        RETURN the RESULT OF dp with arguments zero AND initial_slots  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-good-triplets-in-an-array", "passing_rate": 1.0, "pseudocode": "CLASS BIT  \n    FUNCTION __init__(self, n)  \n        SET self.size TO n  \n        SET self.tree TO list of zeros with length n PLUS one  \n    END FUNCTION  \n\n    FUNCTION update(self, idx, delta)  \n        WHILE idx LESS THAN OR EQUAL TO self.size  \n            SET element at position idx of self.tree TO element at position idx of self.tree PLUS delta  \n            SET idx TO idx PLUS idx AND NEGATION OF idx  \n        END WHILE  \n    END FUNCTION  \n\n    FUNCTION query(self, idx)  \n        SET result TO zero  \n        WHILE idx GREATER THAN zero  \n            SET result TO result PLUS element at position idx of self.tree  \n            SET idx TO idx MINUS idx AND NEGATION OF idx  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION goodTriplets(self, nums1, nums2)  \n        SET n TO LENGTH OF nums1  \n        SET pos TO list of zeros with length n  \n        SET i TO zero  \n        FOR each num IN nums1  \n            SET element at position num of pos TO i  \n            INCREMENT i BY one  \n        END FOR  \n        SET compressed TO empty list  \n        FOR each num IN nums2  \n            APPEND element at position num of pos TO compressed  \n        END FOR  \n        SET bit TO new BIT instance with parameter n  \n        SET smaller_count TO list of zeros with length n  \n        SET larger_count TO list of zeros with length n  \n        SET i TO zero  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i of smaller_count TO bit query with parameter element at position i of compressed  \n            CALL bit update with parameters element at position i of compressed PLUS one and one  \n        END FOR  \n        SET bit TO new BIT instance with parameter n  \n        SET i TO n MINUS one  \n        WHILE i GREATER THAN OR EQUAL TO zero  \n            SET element at position i of larger_count TO bit query with parameter n MINUS bit query with parameter element at position i of compressed PLUS one  \n            CALL bit update with parameters element at position i of compressed PLUS one and one  \n            DECREMENT i BY one  \n        END WHILE  \n        SET good_triplets TO zero  \n        SET i TO zero  \n        FOR i FROM zero TO n MINUS one  \n            SET good_triplets TO good_triplets PLUS element at position i of smaller_count MULTIPLIED BY element at position i of larger_count  \n        END FOR  \n        RETURN good_triplets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-array-pairs-divisible-by-k", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION countPairs(nums k)  \n        SET gcd_count TO empty map with default integer zero  \n        \n        FOR each num IN nums  \n            SET current_gcd TO greatest common divisor of num AND k  \n            INCREMENT value at key current_gcd in gcd_count BY one  \n        END FOR  \n        \n        SET total_pairs TO zero  \n        SET gcd_values TO list of keys in gcd_count  \n        SET n TO length of gcd_values  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i TO n MINUS one  \n                SET gcd1 TO element at position i of gcd_values  \n                SET gcd2 TO element at position j of gcd_values  \n                SET product TO gcd1 MULTIPLIED BY gcd2  \n                SET remainder TO product MODULO k  \n                IF remainder EQUALS zero  \n                    IF i EQUALS j  \n                        SET count TO value at key gcd1 in gcd_count  \n                        SET pairs_for_this TO count MULTIPLIED BY count MINUS one DIVIDED BY two  \n                        INCREMENT total_pairs BY pairs_for_this  \n                    ELSE  \n                        SET count1 TO value at key gcd1 in gcd_count  \n                        SET count2 TO value at key gcd2 in gcd_count  \n                        INCREMENT total_pairs BY count1 MULTIPLIED BY count2  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_pairs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-to-finish-the-race", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumFinishTime(tires number list of list of numbers changeTime number numLaps number) RETURNS number  \n        SET min_times TO list of length fifteen filled with positive infinity  \n        FOR each pair f r IN tires  \n            SET total_time TO zero  \n            FOR index i FROM zero TO fourteen  \n                SET lap_time TO f MULTIPLIED BY r RAISED TO THE POWER OF i  \n                IF lap_time GREATER THAN changeTime PLUS f THEN  \n                    BREAK  \n                END IF  \n                INCREMENT total_time BY lap_time  \n                IF min_times at position i GREATER THAN total_time THEN  \n                    SET min_times at position i TO total_time  \n                END IF  \n            END FOR  \n        END FOR  \n        SET dp TO list of length numLaps PLUS one filled with positive infinity  \n        SET dp at position zero TO zero  \n        FOR index i FROM one TO numLaps  \n            FOR index j FROM zero TO the minimum between i MINUS one AND fourteen  \n                SET potential_time TO dp at position i MINUS j MINUS one PLUS min_times at position j PLUS changeTime  \n                IF dp at position i GREATER THAN potential_time THEN  \n                    SET dp at position i TO potential_time  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN dp at position numLaps MINUS changeTime  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "replace-non-coprime-numbers-in-array", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION replaceNonCoprimes nums  \n        SET stack TO an empty list  \n        FOR each num IN nums  \n            WHILE the LENGTH OF stack GREATER THAN zero  \n                SET g TO the greatest common divisor OF the element at the last position of stack AND num  \n                IF g EQUALS one  \n                    BREAK the WHILE loop  \n                END IF  \n                SET num TO the element at the last position of stack MULTIPLIED BY num DIVIDED BY g  \n                REMOVE the element at the last position FROM stack  \n            END WHILE  \n            APPEND num TO stack  \n        END FOR  \n        RETURN stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-weighted-subgraph-with-the-required-paths", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumWeight(n src1 src2 dest edges)  \n        FUNCTION dijkstra(graph start)  \n            SET distances TO a list of size n where each element is infinity  \n            SET element at position start of distances TO zero  \n            SET heap TO a list containing a tuple of zero and start  \n            \n            WHILE heap holds  \n                REMOVE and RETURN the smallest element from heap ASSIGNING to current_distance and current_node  \n                \n                IF current_distance GREATER THAN the element at position current_node of distances  \n                    CONTINUE to the next iteration  \n                END IF  \n                \n                FOR each neighbor and weight IN the elements at position current_node of graph  \n                    SET distance TO current_distance PLUS weight  \n                    \n                    IF distance LESS THAN the element at position neighbor of distances  \n                        SET the element at position neighbor of distances TO distance  \n                        ADD the tuple of distance and neighbor TO heap maintaining heap property  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN distances  \n        END FUNCTION  \n        \n        SET graph TO a list of n empty lists  \n        SET reverse_graph TO a list of n empty lists  \n        \n        FOR each u v w IN edges  \n            APPEND the tuple of v and w TO the element at position u of graph  \n            APPEND the tuple of u and w TO the element at position v of reverse_graph  \n        END FOR  \n        \n        SET dist_from_src1 TO the result of calling dijkstra with graph and src1  \n        SET dist_from_src2 TO the result of calling dijkstra with graph and src2  \n        SET dist_to_dest TO the result of calling dijkstra with reverse_graph and dest  \n        \n        SET min_weight TO infinity  \n        \n        FOR index i FROM zero TO n MINUS one  \n            IF the element at position i of dist_from_src1 NOT EQUALS infinity AND the element at position i of dist_from_src2 NOT EQUALS infinity AND the element at position i of dist_to_dest NOT EQUALS infinity  \n                SET min_weight TO the smaller value between min_weight and the sum of the element at position i of dist_from_src1 PLUS the element at position i of dist_from_src2 PLUS the element at position i of dist_to_dest  \n            END IF  \n        END FOR  \n        \n        IF min_weight EQUALS infinity  \n            RETURN negative one  \n        ELSE  \n            RETURN min_weight  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-white-tiles-after-covering-with-carpets", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumWhiteTiles(floor string, numCarpets integer, carpetLen integer) RETURNS integer  \n        SET n TO the LENGTH OF floor  \n        SET dp TO a list of lists with n PLUS one elements each containing numCarpets PLUS one zero elements  \n        \n        FOR i FROM one TO n  \n            SET dp element at position i sub element at position zero TO dp element at position i MINUS one sub element at position zero PLUS one IF element at position i MINUS one of floor EQUALS the character representing one OTHERWISE zero  \n        END FOR  \n        \n        FOR j FROM one TO numCarpets  \n            FOR i FROM one TO n  \n                SET dp element at position i sub element at position j TO dp element at position i MINUS one sub element at position j PLUS one IF element at position i MINUS one of floor EQUALS the character representing one OTHERWISE zero  \n                SET dp element at position i sub element at position j TO the MINIMUM OF dp element at position i sub element at position j AND dp element at position which is the GREATER OF zero AND i MINUS carpetLen sub element at position j MINUS one  \n            END FOR  \n        END FOR  \n        \n        RETURN dp element at position n sub element at position numCarpets  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-of-one-repeating-character", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestRepeating(s, queryCharacters, queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF element at position i of intervals at position two EQUALS element at position i plus one of intervals at position two  \n                    SET element at position i of intervals TO a tuple with first element as element at position i of intervals at position zero second element as element at position i plus one of intervals at position one third element as element at position i of intervals at position two  \n                    REMOVE element at position i plus one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n      \n        SET intervals TO empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple with first element start second element i MINUS one third element element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple with first element start second element n MINUS one third element element at position start of s TO intervals  \n      \n        SET results TO empty list  \n        SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n      \n        FOR each pair of char and idx in the parallel elements of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start TO element at position i of intervals at position zero  \n                SET end TO element at position i of intervals at position one  \n                SET c TO element at position i of intervals at position two  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK the loop  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n      \n            IF idx GREATER THAN start  \n                INSERT at position i a tuple with first element start second element idx MINUS one third element c INTO intervals  \n                SET element at position i plus one of intervals TO a tuple with first element idx second element end third element c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT at position i plus one a tuple with first element idx PLUS one second element end third element c INTO intervals  \n                SET element at position i of intervals TO a tuple with first element start second element idx third element c  \n            END IF  \n      \n            SET element at position i of intervals TO a tuple with first element element at position i of intervals at position zero second element element at position i of intervals at position one third element char  \n      \n            CALL merge_intervals()  \n      \n            SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n            APPEND longest TO results  \n        END FOR  \n      \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-value-of-k-coins-from-piles", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maxValueOfCoins(piles k)  \n        SET n TO the LENGTH OF piles  \n        SET dp TO a two dimensional list WITH n PLUS one ROWS AND k PLUS one COLUMNS INITIALIZED TO zero  \n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                SET current_pile TO element at position i MINUS one of piles  \n                SET current_value TO zero  \n                FOR l FROM zero TO the MINIMUM OF j AND the LENGTH OF current_pile  \n                    IF l GREATER THAN zero  \n                        SET current_value TO current_value PLUS element at position l MINUS one of current_pile  \n                    END IF  \n                    SET dp element at position i element at position j TO the GREATER VALUE BETWEEN dp element at position i element at position j AND dp element at position i MINUS one element at position j MINUS l PLUS current_value  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp element at position n element at position k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-scores-of-built-strings", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION sumScores WITH PARAMETER s  \n        SET n TO the LENGTH OF s  \n        SET lcp TO a LIST OF zeroes WITH THE LENGTH n  \n        SET l TO zero  \n        SET r TO zero  \n        \n        FOR i FROM one TO n MINUS one  \n            IF i LESS THAN OR EQUAL TO r  \n                SET lcp ELEMENT AT POSITION i TO THE MINIMUM OF r MINUS i PLUS one AND lcp ELEMENT AT POSITION i MINUS l  \n            END IF  \n            \n            WHILE i PLUS lcp ELEMENT AT POSITION i LESS THAN n AND ELEMENT AT POSITION lcp ELEMENT AT POSITION i OF s EQUALS ELEMENT AT POSITION i PLUS lcp ELEMENT AT POSITION i OF s  \n                INCREMENT lcp ELEMENT AT POSITION i BY one  \n            END WHILE  \n            \n            IF i PLUS lcp ELEMENT AT POSITION i MINUS one GREATER THAN r  \n                SET l TO i  \n                SET r TO i PLUS lcp ELEMENT AT POSITION i MINUS one  \n            END IF  \n        END FOR  \n        \n        RETURN THE SUM OF ELEMENTS OF lcp PLUS n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-total-beauty-of-the-gardens", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty WITH PARAMETERS flowers newFlowers target full partial  \n        CALL sort ON flowers  \n        SET n TO the LENGTH OF flowers  \n        SET max_beauty TO zero  \n        \n        CREATE prefix_sum AS list OF zero WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix_sum TO element at position i of prefix_sum PLUS element at position i of flowers  \n        END FOR  \n        \n        SET complete_gardens TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at position i of flowers GREATER THAN OR EQUAL TO target  \n                INCREMENT complete_gardens BY one  \n            ELSE  \n                BREAK  \n            END IF  \n        END FOR  \n        \n        SET remaining_flowers TO newFlowers  \n        SET max_incomplete_flowers TO zero  \n        \n        FOR i FROM complete_gardens TO n  \n            IF i GREATER THAN zero  \n                SET remaining_flowers TO remaining_flowers MINUS (target MINUS element at position n MINUS i of flowers)  \n                IF remaining_flowers LESS THAN zero  \n                    BREAK  \n                END IF  \n            END IF  \n            \n            SET left TO zero  \n            SET right TO n MINUS i MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO integer DIVISION OF left PLUS right BY two  \n                SET cost TO element at position mid of flowers MULTIPLIED BY (mid PLUS one) MINUS element at position mid PLUS one of prefix_sum  \n                IF cost GREATER THAN remaining_flowers  \n                    SET right TO mid MINUS one  \n                ELSE  \n                    SET left TO mid PLUS one  \n                END IF  \n            END WHILE  \n            \n            IF right GREATER THAN OR EQUAL TO zero  \n                SET numerator TO remaining_flowers MINUS (element at position right of flowers MULTIPLIED BY (right PLUS one) MINUS element at position right PLUS one of prefix_sum)  \n                SET max_incomplete_flowers TO element at position right of flowers PLUS numerator DIVIDED BY (right PLUS one)  \n            ELSE  \n                SET max_incomplete_flowers TO zero  \n            END IF  \n            \n            SET bounded_incomplete TO max_incomplete_flowers  \n            IF bounded_incomplete GREATER THAN target MINUS one  \n                SET bounded_incomplete TO target MINUS one  \n            END IF  \n            \n            SET total_beauty TO i MULTIPLIED BY full PLUS bounded_incomplete MULTIPLIED BY partial  \n            IF total_beauty GREATER THAN max_beauty  \n                SET max_beauty TO total_beauty  \n            END IF  \n        END FOR  \n        \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-of-a-node-sequence", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumScore(scores, edges)  \n        SET graph TO an empty mapping with default empty list  \n        FOR each pair u and v IN edges  \n            APPEND pair of element at position v of scores AND v TO the list at key u in graph  \n            APPEND pair of element at position u of scores AND u TO the list at key v in graph  \n        END FOR  \n        FOR each node IN the keys of graph  \n            ASSIGN to graph at key node the three elements with the largest first element from graph at key node  \n        END FOR  \n        SET max_score TO negative one  \n        FOR each pair u and v IN edges  \n            FOR each pair score1 and x IN graph at key u  \n                FOR each pair score2 and y IN graph at key v  \n                    IF the size of the set of elements x y u v EQUALS four  \n                        SET max_score TO the larger of max_score AND score1 PLUS score2 PLUS element at position u of scores PLUS element at position v of scores  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN max_score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-path-with-different-adjacent-characters", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION longestPath(parent, s)  \n        SET tree TO new mapping with default as empty list  \n        FOR index FROM zero TO the LENGTH OF parent MINUS one  \n            SET p TO element at position index of parent  \n            IF p NOT EQUALS negative one  \n                APPEND index TO element at key p of tree  \n            END IF  \n        END FOR  \n  \n        SET self.result TO one  \n  \n        FUNCTION dfs(node)  \n            SET max1 TO zero  \n            SET max2 TO zero  \n  \n            FOR each child IN element at key node of tree  \n                SET child_length TO CALL dfs WITH argument child  \n  \n                IF character at position child of s NOT EQUALS character at position node of s  \n                    IF child_length GREATER THAN max1  \n                        SET max2 TO max1  \n                        SET max1 TO child_length  \n                    ELSE IF child_length GREATER THAN max2  \n                        SET max2 TO child_length  \n                    END IF  \n                END IF  \n            END FOR  \n  \n            SET self.result TO the greater value between self.result AND max1 PLUS max2 PLUS one  \n            RETURN max1 PLUS one  \n        END FUNCTION  \n  \n        CALL dfs WITH argument zero  \n  \n        RETURN self.result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-cost-of-trip-with-k-highways", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumCost(n, highways, k)  \n        CREATE empty mapping graph WITH DEFAULT VALUE empty list  \n        FOR each city1 city2 toll IN highways  \n            APPEND tuple of city2 AND toll TO element at position city1 of graph  \n            APPEND tuple of city1 AND toll TO element at position city2 of graph  \n        END FOR  \n\n        FUNCTION dfs(city, visited, cost, highways_used)  \n            IF highways_used EQUALS k  \n                SET max_cost TO the GREATER VALUE BETWEEN max_cost AND cost  \n                RETURN  \n            END IF  \n            FOR each neighbor toll IN element at position city of graph  \n                IF neighbor NOT IN visited  \n                    ADD neighbor TO visited  \n                    CALL dfs WITH neighbor visited cost PLUS toll highways_used PLUS one  \n                    REMOVE neighbor FROM visited  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET max_cost TO negative one  \n        FOR start_city FROM zero TO n MINUS one  \n            CREATE new set visited WITH start_city AS THE ONLY ELEMENT  \n            CALL dfs WITH start_city visited zero zero  \n        END FOR  \n        RETURN max_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-flowers-in-full-bloom", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION fullBloomFlowers(flowers, people)  \n        SET start_times TO a sorted list of the first elements of each pair in flowers  \n        SET end_times TO a sorted list of the second elements of each pair in flowers  \n        SET result TO an empty list  \n        FOR each person IN people  \n            SET started TO the count of elements in start_times that are less than OR EQUAL TO person  \n            SET ended TO the count of elements in end_times that are strictly LESS THAN person  \n            SET bloom_count TO started MINUS ended  \n            APPEND bloom_count TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "escape-the-spreading-fire", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO a list containing the pairs of values one and zero MINUS one and zero zero and one and zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two dimensional list with m rows and n columns where each element is set TO positive infinity  \n            SET queue TO a new empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one THEN  \n                        APPEND the tuple consisting of i j and zero TO queue  \n                        SET element at row i column j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE and ASSIGN the first element of queue TO the triple x y t  \n                FOR each pair dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n AND element at position nx ny of grid EQUALS zero AND element at row nx column ny of fire_times EQUALS positive infinity THEN  \n                        SET element at row nx column ny of fire_times TO t PLUS one  \n                        APPEND the tuple consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a new double-ended queue containing the tuple zero zero and wait  \n            SET visited TO a new set containing the tuple zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE and ASSIGN the first element of queue TO the triple x y t  \n                FOR each pair dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n AND the tuple nx ny IS NOT IN visited AND element at position nx ny of grid EQUALS zero THEN  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one THEN  \n                            IF element at row nx column ny of fire_times IS GREATER THAN OR EQUAL TO t PLUS one THEN  \n                                RETURN True  \n                            ELSE  \n                                RETURN False  \n                            END IF  \n                        END IF  \n                        IF element at row nx column ny of fire_times IS GREATER THAN t PLUS one THEN  \n                            ADD the tuple nx ny TO visited  \n                            APPEND the tuple nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN False  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO negative one  \n        \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two ignoring any remainder  \n            IF can_escape(mid) THEN  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result IS NOT EQUAL TO m MULTIPLIED BY n THEN  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "total-appeal-of-a-string", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION appealSum WITH PARAMETER s  \n        SET last TO a list of twenty six elements each SET TO negative one  \n        SET total_appeal TO zero  \n        SET current_appeal TO zero  \n        FOR each pair of i and char FROM the enumeration of s  \n            SET index TO the numerical code of char MINUS the numerical code of the lowercase letter a  \n            SET current_appeal TO current_appeal PLUS i MINUS element at position index of last  \n            SET total_appeal TO total_appeal PLUS current_appeal  \n            SET element at position index of last TO i  \n        END FOR  \n        RETURN total_appeal  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-there-is-a-valid-parentheses-string-path", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF the sum of m PLUS n MINUS one MODULO two NOT EQUALS zero  \n            RETURN False  \n        END IF  \n        \n        SET dp TO a three dimensional list of False with dimensions m PLUS one by n PLUS one by m PLUS n PLUS one  \n        \n        SET element at position zero of element at position one of dp TO True  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                FOR k FROM zero TO m PLUS n  \n                    IF element at position i of element at position j PLUS one of dp OR element at position i PLUS one of element at position j of dp  \n                        IF element at position i of element at position j of grid EQUALS left parenthesis AND k PLUS one LESS THAN m PLUS n PLUS one  \n                            SET element at position i PLUS one of element at position j PLUS one of dp TO True  \n                        ELSE IF element at position i of element at position j of grid EQUALS right parenthesis AND k MINUS one GREATER THAN OR EQUAL TO zero  \n                            SET element at position i PLUS one of element at position j PLUS one of dp TO True  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m of element at position n of element at position zero of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "substring-with-largest-variance", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION largestVariance(s)  \n        FUNCTION calculate_variance(substring, char_a, char_b)  \n            SET max_variance TO zero  \n            SET count_a TO zero  \n            SET count_b TO zero  \n            SET has_b TO false  \n            SET first_b TO false  \n            \n            FOR each char IN substring  \n                IF char EQUALS char_a  \n                    INCREMENT count_a BY one  \n                ELSE IF char EQUALS char_b  \n                    INCREMENT count_b BY one  \n                    SET has_b TO true  \n                END IF  \n                \n                IF count_b GREATER THAN zero  \n                    SET max_variance TO the GREATER VALUE BETWEEN max_variance AND count_a MINUS count_b  \n                ELSE IF count_b EQUALS zero AND first_b IS true  \n                    SET max_variance TO the GREATER VALUE BETWEEN max_variance AND count_a MINUS one  \n                END IF  \n                \n                IF count_b GREATER THAN count_a  \n                    SET count_a TO zero  \n                    SET count_b TO zero  \n                    SET first_b TO has_b  \n                END IF  \n            END FOR  \n            \n            RETURN max_variance  \n        END FUNCTION  \n        \n        SET max_variance TO zero  \n        SET unique_chars TO the SET OF all UNIQUE ELEMENTS IN s  \n        \n        FOR each char_a, char_b IN all PERMUTATIONS of unique_chars TAKEN two AT A TIME  \n            IF char_a EQUALS char_b  \n                CONTINUE to next iteration  \n            END IF  \n            SET max_variance TO the GREATER VALUE BETWEEN max_variance AND calculate_variance WITH PARAMETERS s char_a char_b  \n        END FOR  \n        \n        RETURN max_variance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-node-to-path-in-tree", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION closestNode(n, edges, query)  \n        SET graph TO a new mapping with default empty list for each key  \n        FOR each element u and element v IN edges  \n            APPEND element v TO the list at key u in graph  \n            APPEND element u TO the list at key v in graph  \n        END FOR  \n      \n        FUNCTION find_path(start, end)  \n            SET queue TO a new double-ended queue containing a tuple consisting of start and a list containing start  \n            SET visited TO a new set containing start  \n          \n            WHILE the queue is not empty  \n                REMOVE and ASSIGN the first element of queue TO node and path respectively  \n                IF node EQUALS end  \n                    RETURN path  \n                END IF  \n                FOR each neighbor IN the list at key node in graph  \n                    IF neighbor NOT IN visited  \n                        ADD neighbor TO visited  \n                        APPEND a tuple consisting of neighbor and a new list formed by concatenating path and neighbor TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n        END FUNCTION  \n      \n        FUNCTION closest_node_on_path(path, node)  \n            SET min_distance TO positive infinity  \n            SET closest_node TO no value  \n            FOR each element p IN path  \n                SET distance TO the length of the result of find_path called with p and node MINUS one  \n                IF distance LESS THAN min_distance  \n                    SET min_distance TO distance  \n                    SET closest_node TO p  \n                END IF  \n            END FOR  \n            RETURN closest_node  \n        END FUNCTION  \n      \n        SET answer TO an empty list  \n        FOR each element start and element end and element node IN query  \n            SET path TO the result of find_path called with start and end  \n            APPEND the result of closest_node_on_path called with path and node TO answer  \n        END FOR  \n      \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-total-strength-of-wizards", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION totalStrength(strength)  \n        SET MOD TO the integer one billion PLUS seven  \n        SET n TO the LENGTH OF strength  \n        \n        INITIALIZE a list prefix with n PLUS one elements all set TO zero  \n        FOR index i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix TO the REMAINDER WHEN the SUM of element at position i of prefix AND element at position i of strength IS DIVIDED BY MOD  \n        END FOR  \n        \n        INITIALIZE a list prefix_prefix with n PLUS two elements all set TO zero  \n        FOR index i FROM zero TO n  \n            SET element at position i PLUS one of prefix_prefix TO the REMAINDER WHEN the SUM of element at position i of prefix_prefix AND element at position i of prefix IS DIVIDED BY MOD  \n        END FOR  \n        \n        INITIALIZE a list prev_smaller with n elements all set TO minus one  \n        INITIALIZE a list next_smaller_or_equal with n elements all set TO n  \n        \n        INITIALIZE an empty list stack  \n        FOR index i FROM zero TO n MINUS one  \n            WHILE stack IS NOT empty AND element at position at the last element of stack of strength IS GREATER THAN OR EQUAL TO element at position i of strength  \n                REMOVE the last element FROM stack  \n            END WHILE  \n            IF stack IS NOT empty  \n                SET element at position i of prev_smaller TO the last element of stack  \n            END IF  \n            APPEND i TO stack  \n        END FOR  \n        \n        CLEAR stack  \n        FOR index i FROM n MINUS one DOWN TO zero  \n            WHILE stack IS NOT empty AND element at position at the last element of stack of strength IS GREATER THAN element at position i of strength  \n                REMOVE the last element FROM stack  \n            END WHILE  \n            IF stack IS NOT empty  \n                SET element at position i of next_smaller_or_equal TO the last element of stack  \n            END IF  \n            APPEND i TO stack  \n        END FOR  \n        \n        SET total_strength TO zero  \n        FOR index i FROM zero TO n MINUS one  \n            SET left TO element at position i of prev_smaller PLUS one  \n            SET right TO element at position i of next_smaller_or_equal  \n            \n            SET sum_left TO the REMAINDER WHEN the PRODUCT of the QUANTITY of i MINUS left PLUS one AND the DIFFERENCE of element at position right PLUS one of prefix_prefix MINUS element at position i PLUS one of prefix_prefix IS DIVIDED BY MOD  \n            SET sum_right TO the REMAINDER WHEN the PRODUCT of the QUANTITY of right MINUS i AND the DIFFERENCE of element at position i PLUS one of prefix_prefix MINUS element at position left of prefix_prefix IS DIVIDED BY MOD  \n            \n            SET contribution TO the REMAINDER WHEN the PRODUCT of element at position i of strength AND the DIFFERENCE of sum_left MINUS sum_right IS DIVIDED BY MOD  \n            SET total_strength TO the REMAINDER WHEN the SUM of total_strength AND contribution IS DIVIDED BY MOD  \n        END FOR  \n        \n        RETURN total_strength  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-obstacle-removal-to-reach-corner", "passing_rate": 1.0, "pseudocode": "CLASS Solution  \n    FUNCTION minimumObstacles(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO a list containing the pairs of zero and one, one and zero, zero and negative one, negative one and zero  \n        SET min_heap TO a list containing a tuple of zero, zero and zero representing cost and coordinates  \n        SET visited TO a set containing tuple of zero and zero representing the starting coordinates  \n        \n        WHILE the min_heap is not empty  \n            REMOVE AND RETURN the element with the smallest cost from min_heap and ASSIGN the values to cost, x and y  \n            \n            IF the tuple of x and y EQUALS the tuple of m MINUS one and n MINUS one  \n                RETURN cost  \n            END IF  \n            \n            FOR each pair dx and dy IN directions  \n                SET nx TO x PLUS dx  \n                SET ny TO y PLUS dy  \n                \n                IF nx IS GREATER THAN OR EQUAL TO zero AND nx IS LESS THAN m AND ny IS GREATER THAN OR EQUAL TO zero AND ny IS LESS THAN n AND the tuple of nx and ny IS NOT IN visited  \n                    ADD the tuple of nx and ny TO visited  \n                    SET new_cost TO cost PLUS the element at position nx of grid AND the element at position ny of that row  \n                    INSERT the tuple of new_cost nx and ny INTO min_heap maintaining heap property  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
