{"task_id": "add-two-numbers", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values from position two TO the end  \n        SET node TO a new ListNode with val  \n        SET the element next to p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the evaluation of the element val at p1 EQUALS the element val at p2 AND is_same_list with the element next at p1 and the element next at p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION addTwoNumbers(l1 l2)  \n        SET dummy_head TO a new ListNode with zero  \n        SET current TO dummy_head  \n        SET carry TO zero  \n        \n        WHILE l1 IS NOT None OR l2 IS NOT None OR carry GREATER THAN zero  \n            IF l1 IS NOT None  \n                SET val1 TO the element val at l1  \n            ELSE  \n                SET val1 TO zero  \n            END IF  \n            IF l2 IS NOT None  \n                SET val2 TO the element val at l2  \n            ELSE  \n                SET val2 TO zero  \n            END IF  \n            SET total TO val1 PLUS val2 PLUS carry  \n            SET carry TO the integer division of total BY ten  \n            SET the element next to current TO a new ListNode with the remainder of total DIVIDED BY ten  \n            SET current TO the element next at current  \n            \n            IF l1 IS NOT None  \n                SET l1 TO the element next at l1  \n            END IF  \n            IF l2 IS NOT None  \n                SET l2 TO the element next at l2  \n            END IF  \n        END WHILE  \n        \n        RETURN the element next at dummy_head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-nth-node-from-end-of-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS none)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET head TO a new ListNode with value element at position one of values  \n    SET p TO head  \n    FOR val IN the elements of values starting from position two to the end  \n        SET node TO a new ListNode with value val  \n        SET the next element of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION\n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS none AND p2 EQUALS none  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS none OR p2 EQUALS none  \n        RETURN False  \n    END IF  \n    RETURN the condition that the value of p1 EQUALS the value of p2 AND the result of calling is_same_list with the next element of p1 and the next element of p2  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION removeNthFromEnd(self head n)  \n        SET dummy TO a new ListNode with value zero  \n        SET the next element of dummy TO head  \n        SET first TO dummy  \n        SET second TO dummy  \n        FOR i FROM zero TO n PLUS one  \n            SET first TO the next element of first  \n        END FOR  \n        WHILE first NOT EQUALS none  \n            SET first TO the next element of first  \n            SET second TO the next element of second  \n        END WHILE  \n        SET the next element of second TO the next element of the next element of second  \n        RETURN the next element of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "merge-k-sorted-lists", "passing_rate": 0.3333333333333333, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS none)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS nothing THEN  \n        RETURN nothing  \n    END IF  \n    SET head TO A new ListNode with value EQUALS element at position one of values  \n    SET p TO head  \n    FOR each val IN all elements of values starting from position two to the end  \n        SET node TO A new ListNode with value EQUALS val  \n        SET the next element of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS nothing AND p2 EQUALS nothing THEN  \n        RETURN true  \n    END IF  \n    IF p1 EQUALS nothing OR p2 EQUALS nothing THEN  \n        RETURN false  \n    END IF  \n    RETURN the value of p1 EQUALS the value of p2 AND RESULT OF is_same_list with parameters the next element of p1 AND the next element of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION mergeKLists(self lists)  \n        SET min_heap TO an empty list  \n        FOR each index i AND list lst IN lists with enumeration  \n            IF lst IS NOT nothing THEN  \n                ADD the tuple consisting of the value of lst AND i AND lst TO min_heap using heap push operation  \n            END IF  \n        END FOR  \n        SET dummy TO A new ListNode  \n        SET current TO dummy  \n        WHILE min_heap IS NOT empty DO  \n            REMOVE the smallest tuple of value val index i AND node FROM min_heap using heap pop operation  \n            SET the next element of current TO node  \n            SET current TO the next element of current  \n            IF the next element of node IS NOT nothing THEN  \n                ADD the tuple consisting of the value of the next element of node AND i AND the next element of node TO min_heap using heap push operation  \n            END IF  \n        END WHILE  \n        RETURN the next element of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swap-nodes-in-pairs", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val AND next  \n        SET the value attribute TO val  \n        SET the next attribute TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node with parameter values  \n    IF the collection values IS empty  \n        RETURN absence of any value  \n    END IF  \n    SET head TO a new ListNode with the element at position one of values  \n    SET pointer p TO head  \n    FOR each val IN the elements of values starting from position two TO the end  \n        SET node TO a new ListNode with val  \n        SET the next attribute of pointer p TO node  \n        SET pointer p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list with parameters p1 AND p2  \n    IF p1 IS absence of any value AND p2 IS absence of any value  \n        RETURN truth value true  \n    END IF  \n    IF p1 IS absence of any value OR p2 IS absence of any value  \n        RETURN truth value false  \n    END IF  \n    RETURN the logical AND of the equality of the value attribute of p1 WITH the value attribute of p2 AND the recursive call of is_same_list with the next attribute of p1 AND the next attribute of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION swapPairs with parameter head  \n        SET dummy TO a new ListNode with zero as the value  \n        SET the next attribute of dummy TO head  \n        SET current TO dummy  \n        \n        WHILE both the next attribute of current IS NOT absence of any value AND the next attribute of the next attribute of current IS NOT absence of any value  \n            SET first TO the next attribute of current  \n            SET second TO the next attribute of the next attribute of current  \n            \n            SET the next attribute of current TO second  \n            SET the next attribute of first TO the next attribute of second  \n            SET the next attribute of second TO first  \n            \n            SET current TO the next attribute of the next attribute of current  \n        END WHILE  \n        \n        RETURN the next attribute of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-nodes-in-k-group", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ WITH PARAMETERS self val EQUALS zero next EQUALS None  \n        SET the value attribute of self TO val  \n        SET the next attribute of self TO next  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION list_node WITH PARAMETERS values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode constructed with the first element in values  \n    SET p TO head  \n    FOR each val IN the elements of values from the second element TO the last element  \n        SET node TO a new ListNode constructed with val  \n        SET the next attribute of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION\n\nFUNCTION is_same_list WITH PARAMETERS p1 p2  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value attribute of p1 EQUALS the value attribute of p2 AND is_same_list called with the next attribute of p1 and the next attribute of p2  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION reverseKGroup WITH PARAMETERS self head k  \n        FUNCTION reverseLinkedList WITH PARAMETERS start end  \n            SET prev TO None  \n            SET curr TO start  \n            WHILE curr NOT EQUALS end  \n                SET next_node TO the next attribute of curr  \n                SET the next attribute of curr TO prev  \n                SET prev TO curr  \n                SET curr TO next_node  \n            END WHILE  \n            SET the next attribute of curr TO prev  \n            RETURN end AND start  \n        END FUNCTION\n\n        SET dummy TO a new ListNode constructed with zero  \n        SET the next attribute of dummy TO head  \n        SET prev_group_end TO dummy\n\n        WHILE True  \n            SET kth_node TO prev_group_end  \n            FOR each index FROM one TO k  \n                SET kth_node TO the next attribute of kth_node  \n                IF kth_node EQUALS None  \n                    RETURN the next attribute of dummy  \n                END IF  \n            END FOR  \n\n            SET next_group_start TO the next attribute of kth_node  \n            SET the next attribute of kth_node TO None  \n            CALL reverseLinkedList with the next attribute of prev_group_end and kth_node and SET the results TO new_group_start AND new_group_end  \n\n            SET the next attribute of prev_group_end TO new_group_start  \n            SET the next attribute of new_group_end TO next_group_start  \n\n            SET prev_group_end TO new_group_end  \n        END WHILE  \n\n        RETURN the next attribute of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val EQUALS zero, next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with value element at position one of values  \n    SET p TO head  \n    FOR each val IN elements from position two TO end of values  \n        SET node TO new ListNode with value val  \n        SET p.next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value of p1 EQUALS the value of p2 AND is_same_list applied to the next of p1 and the next of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION rotateRight(self, head, k)  \n        IF head EQUALS None OR the next of head EQUALS None OR k EQUALS zero  \n            RETURN head  \n        END IF  \n        SET length TO one  \n        SET tail TO head  \n        WHILE the next of tail is not None  \n            SET tail TO the next of tail  \n            INCREMENT length BY one  \n        END WHILE  \n        SET the next of tail TO head  \n        SET k TO k MODULO length  \n        SET steps_to_new_tail TO length MINUS k MINUS one  \n        SET new_tail TO head  \n        FOR each iterator FROM zero TO steps_to_new_tail MINUS one  \n            SET new_tail TO the next of new_tail  \n        END FOR  \n        SET new_head TO the next of new_tail  \n        SET the next of new_tail TO None  \n        RETURN new_head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicates-from-sorted-list-ii", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self dot val TO val  \n        SET self dot next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO NEW ListNode with element at position one of values  \n    SET p TO head  \n    FOR each val IN elements from position two TO the end of values  \n        SET node TO NEW ListNode with val  \n        SET next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the val of p1 EQUALS the val of p2 AND the result of is_same_list with the next of p1 and the next of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION deleteDuplicates(self head)  \n        SET dummy TO NEW ListNode with zero and head  \n        SET prev TO dummy  \n        WHILE head IS NOT None  \n            IF the next of head IS NOT None AND the val of head EQUALS the val of the next of head  \n                WHILE the next of head IS NOT None AND the val of head EQUALS the val of the next of head  \n                    SET head TO the next of head  \n                END WHILE  \n                SET the next of prev TO the next of head  \n            ELSE  \n                SET prev TO the next of prev  \n            END IF  \n            SET head TO the next of head  \n        END WHILE  \n        RETURN the next of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ WITH PARAMETERS val EQUALS zero AND next EQUALS none  \n        SET self dot val TO val  \n        SET self dot next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node WITH PARAMETER values  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET head TO new ListNode WITH PARAMETER element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values FROM position two TO the end  \n        SET node TO new ListNode WITH PARAMETER val  \n        SET p dot next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list WITH PARAMETERS p1 AND p2  \n    IF p1 EQUALS none AND p2 EQUALS none  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS none OR p2 EQUALS none  \n        RETURN False  \n    END IF  \n    RETURN the value at p1 dot val EQUALS the value at p2 dot val AND the result of is_same_list WITH PARAMETERS p1 dot next AND p2 dot next  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION partition WITH PARAMETERS head AND x  \n        SET less_head TO new ListNode WITH PARAMETER zero  \n        SET greater_head TO new ListNode WITH PARAMETER zero  \n        SET less TO less_head  \n        SET greater TO greater_head  \n        SET current TO head  \n        WHILE current IS NOT none  \n            IF the value at current dot val IS LESS THAN x  \n                SET less dot next TO current  \n                SET less TO less dot next  \n            ELSE  \n                SET greater dot next TO current  \n                SET greater TO greater dot next  \n            END IF  \n            SET current TO current dot next  \n        END WHILE  \n        SET less dot next TO greater_head dot next  \n        SET greater dot next TO none  \n        RETURN less_head dot next  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-linked-list-ii", "passing_rate": 0.1282051282051282, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val next  \n        SET the value property TO val  \n        SET the next property TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node with parameter values  \n    IF values IS NOT PRESENT  \n        RETURN NONE  \n    END IF  \n    SET head TO A new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements from position two TO the end of values  \n        SET node TO A new ListNode with val  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list with parameters p1 p2  \n    IF p1 IS NONE AND p2 IS NONE  \n        RETURN TRUE  \n    END IF  \n    IF p1 IS NOT PRESENT OR p2 IS NOT PRESENT  \n        RETURN FALSE  \n    END IF  \n    RETURN the value property of p1 EQUALS the value property of p2 AND is_same_list called with the next property of p1 AND the next property of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION reverseBetween with parameters head left right  \n        IF head IS NOT PRESENT OR left EQUALS right  \n            RETURN head  \n        END IF  \n        SET dummy TO A new ListNode with zero  \n        SET the next property of dummy TO head  \n        SET prev TO dummy  \n        FOR variable from zero TO left MINUS one MINUS one  \n            SET prev TO the next property of prev  \n        END FOR  \n        SET current TO the next property of prev  \n        FOR variable from zero TO right MINUS left MINUS one  \n            SET next_node TO the next property of current  \n            SET the next property of current TO the next property of next_node  \n            SET the next property of next_node TO the next property of prev  \n            SET the next property of prev TO next_node  \n        END FOR  \n        RETURN the next property of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "validate-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO A new TreeNode with the element at position one of values as val and left as None and right as None  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element taken from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.left TO A new TreeNode with the element at position i of values as val and left as None and right as None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.right TO A new TreeNode with the element at position i of values as val and left as None and right as None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree applied to the left attribute of p and the left attribute of q AND the result of is_same_tree applied to the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION isValidBST(self, root)  \n        FUNCTION validate(node, low, high)  \n            IF node EQUALS None THEN  \n                RETURN True  \n            END IF  \n            IF the val attribute of node LESS THAN OR EQUAL TO low OR the val attribute of node GREATER THAN OR EQUAL TO high THEN  \n                RETURN False  \n            END IF  \n            RETURN the result of validate applied to the left attribute of node low and the val attribute of node AND the result of validate applied to the right attribute of node the val attribute of node and high  \n        END FUNCTION  \n        RETURN validate applied to root the smallest possible number and the largest possible number  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "recover-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with value element at position one of values  \n    SET i TO one plus one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the element obtained by removing from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT no value  \n            SET node.left TO a new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT no value  \n            SET node.right TO a new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value  \n        RETURN True  \n    ELSE IF p IS no value OR q IS no value  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION recoverTree(self, root)  \n        SET first TO no value  \n        SET second TO no value  \n        SET prev TO no value  \n        SET curr TO root  \n        WHILE curr IS NOT no value  \n            IF curr.left IS no value  \n                IF prev IS NOT no value AND prev.val GREATER THAN curr.val  \n                    IF first IS no value  \n                        SET first TO prev  \n                    END IF  \n                    SET second TO curr  \n                END IF  \n                SET prev TO curr  \n                SET curr TO curr.right  \n            ELSE  \n                SET pred TO curr.left  \n                WHILE pred.right IS NOT no value AND pred.right NOT EQUALS curr  \n                    SET pred TO pred.right  \n                END WHILE  \n                IF pred.right IS no value  \n                    SET pred.right TO curr  \n                    SET curr TO curr.left  \n                ELSE  \n                    SET pred.right TO no value  \n                    IF prev IS NOT no value AND prev.val GREATER THAN curr.val  \n                        IF first IS no value  \n                            SET first TO prev  \n                        END IF  \n                        SET second TO curr  \n                    END IF  \n                    SET prev TO curr  \n                    SET curr TO curr.right  \n                END IF  \n            END IF  \n        END WHILE  \n        IF first IS NOT no value AND second IS NOT no value  \n            SET temporary TO first.val  \n            SET first.val TO second.val  \n            SET second.val TO temporary  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-level-order-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN none  \n    END IF  \n    SET root TO A new TreeNode INITIALIZED WITH the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the element REMOVED FROM the FRONT OF queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none THEN  \n            SET node.left TO A new TreeNode INITIALIZED WITH the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none THEN  \n            SET node.right TO A new TreeNode INITIALIZED WITH the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none THEN  \n        RETURN True  \n    ELSE IF p IS none OR q IS none THEN  \n        RETURN False  \n    ELSE IF p.val IS NOT EQUALS TO q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN the RESULT OF is_same_tree WITH p.left AND q.left AND is_same_tree WITH p.right AND q.right  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION levelOrder(self, root)  \n        IF root IS none THEN  \n            RETURN an empty list  \n        END IF  \n        SET result TO an empty list  \n        SET queue TO a double-ended queue INITIALIZED WITH root  \n        WHILE the LENGTH OF queue IS GREATER THAN zero  \n            SET level_size TO the LENGTH OF queue  \n            SET current_level TO an empty list  \n            FOR each element FROM one TO level_size  \n                SET node TO the element REMOVED FROM the FRONT OF queue  \n                APPEND node.val TO current_level  \n                IF node.left IS not none THEN  \n                    APPEND node.left TO queue  \n                END IF  \n                IF node.right IS not none THEN  \n                    APPEND node.right TO queue  \n                END IF  \n            END FOR  \n            APPEND current_level TO result  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-zigzag-level-order-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    ASSIGN root TO A NEW INSTANCE OF TreeNode WITH the element at position one of values AS val  \n    SET i TO one  \n    ASSIGN queue TO AN EMPTY DOUBLE ENDED QUEUE  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        REMOVE the FIRST element FROM queue AND ASSIGN it TO node  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            ASSIGN node.left TO A NEW INSTANCE OF TreeNode WITH the element at position i of values AS val  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            ASSIGN node.right TO A NEW INSTANCE OF TreeNode WITH the element at position i of values AS val  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN true  \n    ELSE IF p IS none OR q IS none  \n        RETURN false  \n    ELSE IF the val ATTRIBUTE OF p NOT EQUALS the val ATTRIBUTE OF q  \n        RETURN false  \n    ELSE  \n        RETURN the RESULT OF is_same_tree WITH p.left AND q.left AND AND the RESULT OF is_same_tree WITH p.right AND q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION zigzagLevelOrder(self, root)  \n        IF root IS none  \n            RETURN AN EMPTY LIST  \n        END IF  \n        ASSIGN result TO AN EMPTY LIST  \n        ASSIGN queue TO A DOUBLE ENDED QUEUE CONTAINING root  \n        SET left_to_right TO true  \n        WHILE the LENGTH OF queue GREATER THAN zero  \n            ASSIGN level_size TO the LENGTH OF queue  \n            ASSIGN current_level TO AN EMPTY DOUBLE ENDED QUEUE  \n            FOR counter FROM one TO level_size  \n                REMOVE the FIRST element FROM queue AND ASSIGN it TO node  \n                IF left_to_right IS true  \n                    APPEND the val ATTRIBUTE OF node TO current_level  \n                ELSE  \n                    INSERT the val ATTRIBUTE OF node AT THE BEGINNING OF current_level  \n                END IF  \n                IF the left ATTRIBUTE OF node IS NOT none  \n                    APPEND the left ATTRIBUTE OF node TO queue  \n                END IF  \n                IF the right ATTRIBUTE OF node IS NOT none  \n                    APPEND the right ATTRIBUTE OF node TO queue  \n                END IF  \n            END FOR  \n            APPEND A LIST CONVERTED FROM current_level TO result  \n            SET left_to_right TO NOT left_to_right  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double-ended collection  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is greater than zero  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.left TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.right TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF the value of p NOT EQUALS the value of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of calling is_same_tree with the left child of p and the left child of q AND the result of calling is_same_tree with the right child of p and the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION buildTree(self, preorder, inorder)  \n        IF the LENGTH OF preorder EQUALS zero OR the LENGTH OF inorder EQUALS zero THEN  \n            RETURN None  \n        END IF  \n        SET root_val TO the element at position zero of preorder  \n        SET root TO a new TreeNode initialized with root_val  \n        SET root_index_inorder TO the position of root_val within inorder  \n        SET root.left TO the result of calling self.buildTree with the subsequence of preorder from position one TO position root_index_inorder INCLUSIVE AND the subsequence of inorder from position zero TO position root_index_inorder MINUS one  \n        SET root.right TO the result of calling self.buildTree with the subsequence of preorder from position root_index_inorder PLUS one TO the end AND the subsequence of inorder from position root_index_inorder PLUS one TO the end  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with the element at position one of values  \n    SET i TO one  \n    INITIALIZE queue as an empty deque  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.right TO new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with p.left AND q.left AND the result of is_same_tree with p.right AND q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION buildTree(self, inorder, postorder)  \n        IF the LENGTH OF inorder EQUALS zero OR the LENGTH OF postorder EQUALS zero  \n            RETURN none  \n        END IF  \n        REMOVE the last element from postorder AND ASSIGN it TO root_val  \n        SET root TO new TreeNode with root_val  \n        SET root_index TO the position of root_val in inorder  \n        SET root.right TO the result of calling buildTree with the slice of inorder from root_index PLUS one TO the end AND postorder  \n        SET root.left TO the result of calling buildTree with the slice of inorder from the start TO root_index MINUS one AND postorder  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-level-order-traversal-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with value the element at position one of values and left None and right None  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the left side of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET node.left TO a new TreeNode with value the element at position i of values and left None and right None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET node.right TO a new TreeNode with value the element at position i of values and left None and right None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with parameters the left attribute of p and the left attribute of q AND the result of is_same_tree with parameters the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION levelOrderBottom(self, root)  \n        IF root IS None  \n            RETURN an empty list  \n        END IF  \n        SET result TO an empty list  \n        SET queue TO a double-ended queue initialized with root  \n        WHILE the LENGTH OF queue GREATER THAN zero  \n            SET level_size TO the LENGTH OF queue  \n            SET current_level TO an empty list  \n            FOR each element in the range from one TO level_size inclusive  \n                SET node TO the element removed from the left side of queue  \n                APPEND the val attribute of node TO current_level  \n                IF the left attribute of node IS NOT None  \n                    APPEND the left attribute of node TO queue  \n                END IF  \n                IF the right attribute of node IS NOT None  \n                    APPEND the right attribute of node TO queue  \n                END IF  \n            END FOR  \n            APPEND current_level TO result  \n        END WHILE  \n        RETURN result in reverse order  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "convert-sorted-list-to-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ (val EQUALS zero NEXT EQUALS none)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node (values)  \n    IF values IS NOT PRESENT  \n        RETURN none  \n    END IF  \n    SET head TO NEW ListNode WITH element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values FROM position two TO the last position  \n        SET node TO NEW ListNode WITH val  \n        SET the next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list (p1 p2)  \n    IF p1 IS none AND p2 IS none  \n        RETURN true  \n    END IF  \n    IF p1 IS NOT PRESENT OR p2 IS NOT PRESENT  \n        RETURN false  \n    END IF  \n    RETURN the val of p1 EQUALS the val of p2 AND is_same_list WITH the next of p1 AND the next of p2  \nEND FUNCTION  \n\nCLASS TreeNode  \n    FUNCTION __init__ (val EQUALS zero LEFT EQUALS none RIGHT EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node (values)  \n    IF values IS NOT PRESENT  \n        RETURN none  \n    END IF  \n    SET root TO NEW TreeNode WITH element at position one of values  \n    SET i TO one  \n    SET queue TO a new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN OR EQUAL TO the LENGTH OF values AND element at position i of values IS NOT none  \n            SET the left of node TO NEW TreeNode WITH element at position i of values  \n            APPEND the left of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN OR EQUAL TO the LENGTH OF values AND element at position i of values IS NOT none  \n            SET the right of node TO NEW TreeNode WITH element at position i of values  \n            APPEND the right of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree (p q)  \n    IF p IS NOT PRESENT AND q IS NOT PRESENT  \n        RETURN true  \n    ELSE IF p IS NOT PRESENT OR q IS NOT PRESENT  \n        RETURN false  \n    ELSE IF the val of p NOT EQUALS the val of q  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree WITH the left of p AND the left of q AND is_same_tree WITH the right of p AND the right of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION sortedListToBST (head)  \n        IF head IS NOT PRESENT  \n            RETURN none  \n        END IF  \n\n        FUNCTION findMiddle (left right)  \n            SET slow TO left  \n            SET fast TO left  \n            WHILE fast NOT EQUALS right AND the next of fast NOT EQUALS right  \n                SET slow TO the next of slow  \n                SET fast TO the next of the next of fast  \n            END WHILE  \n            RETURN slow  \n        END FUNCTION  \n\n        FUNCTION convertListToBST (left right)  \n            IF left EQUALS right  \n                RETURN none  \n            END IF  \n            SET mid TO findMiddle WITH left AND right  \n            SET node TO NEW TreeNode WITH the val of mid  \n            SET the left of node TO convertListToBST WITH left AND mid  \n            SET the right of node TO convertListToBST WITH the next of mid AND right  \n            RETURN node  \n        END FUNCTION  \n\n        RETURN convertListToBST WITH head AND none  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "path-sum-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET the value attribute TO val  \n        SET the left attribute TO left  \n        SET the right attribute TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF the list values is empty THEN  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values  \n    SET i TO one  \n    INITIALIZE an empty double ended queue named queue  \n    APPEND root TO queue  \n    WHILE the length of queue is greater than zero DO  \n        REMOVE the element at the front of queue and assign it TO node  \n        IF i is less than the length of values AND the element at position i of values is not none THEN  \n            SET the left attribute of node TO a new TreeNode with the element at position i of values  \n            APPEND the left attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is less than the length of values AND the element at position i of values is not none THEN  \n            SET the right attribute of node TO a new TreeNode with the element at position i of values  \n            APPEND the right attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p is none AND q is none THEN  \n        RETURN true  \n    ELSE IF p is none OR q is none THEN  \n        RETURN false  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q THEN  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(the left attribute of p, the left attribute of q) AND is_same_tree(the right attribute of p, the right attribute of q)  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION pathSum(self, root, targetSum)  \n        FUNCTION dfs(node, current_sum, path)  \n            IF node is none THEN  \n                RETURN  \n            END IF  \n            APPEND the value attribute of node TO path  \n            INCREMENT current_sum BY the value attribute of node  \n            IF the left attribute of node is none AND the right attribute of node is none AND current_sum EQUALS targetSum THEN  \n                APPEND a copy of path TO result  \n            END IF  \n            CALL dfs WITH the left attribute of node, current_sum, and path  \n            CALL dfs WITH the right attribute of node, current_sum, and path  \n            REMOVE the last element FROM path  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL dfs WITH root, zero, and an empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-maximum-path-sum", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with the element at position zero of values as val  \n    SET i TO one  \n    SET queue TO a new empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the left side of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None THEN  \n            SET node.left TO a new TreeNode with the element at position i of values as val  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None THEN  \n            SET node.right TO a new TreeNode with the element at position i of values as val  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None THEN  \n        RETURN True  \n    ELSE IF p IS None OR q IS None THEN  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with p.left and q.left AS arguments AND the result of is_same_tree with p.right and q.right AS arguments  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION maxPathSum(self, root)  \n        FUNCTION helper(node)  \n            IF node IS None THEN  \n                RETURN negative infinity, negative infinity  \n            END IF  \n            SET left_max, left_gain TO the result of helper with node.left AS argument  \n            SET right_max, right_gain TO the result of helper with node.right AS argument  \n            SET current_max TO the val attribute of node PLUS the greater of left_gain AND zero PLUS the greater of right_gain AND zero  \n            SET current_gain TO the val attribute of node PLUS the greatest of left_gain right_gain AND zero  \n            SET global_max TO the greatest of left_max right_max AND current_max  \n            RETURN global_max, current_gain  \n        END FUNCTION  \n        RETURN the first element of the result of helper with root AS argument  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-root-to-leaf-numbers", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN a null reference  \n    END IF  \n    SET root TO a new instance of TreeNode constructed with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero DO  \n        REMOVE the element from the front of queue and ASSIGN it TO node  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT a null reference THEN  \n            SET the left child of node TO a new instance of TreeNode constructed with the element at position i of values  \n            APPEND the left child of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT a null reference THEN  \n            SET the right child of node TO a new instance of TreeNode constructed with the element at position i of values  \n            APPEND the right child of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS a null reference AND q IS a null reference THEN  \n        RETURN True  \n    ELSE IF p IS a null reference OR q IS a null reference THEN  \n        RETURN False  \n    ELSE IF the value of p IS NOT EQUALS the value of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of the result of is_same_tree with the left child of p and the left child of q AND the result of is_same_tree with the right child of p and the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION sumNumbers(self, root)  \n        FUNCTION dfs(node, current_number)  \n            IF node IS a null reference THEN  \n                RETURN zero  \n            END IF  \n            SET current_number TO current_number MULTIPLIED BY ten PLUS the value of node  \n            IF the left child of node IS a null reference AND the right child of node IS a null reference THEN  \n                RETURN current_number  \n            END IF  \n            SET left_sum TO the result of dfs with the left child of node and current_number  \n            SET right_sum TO the result of dfs with the right child of node and current_number  \n            RETURN left_sum PLUS right_sum  \n        END FUNCTION  \n        RETURN the result of dfs with root and zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gas-station", "passing_rate": 0.6530612244897959, "pseudocode": "CLASS Solution  \n    FUNCTION canCompleteCircuit(gas, cost)  \n        IF the SUM OF elements in gas IS LESS THAN the SUM OF elements in cost  \n            RETURN the negative of one  \n        END IF  \n        SET start TO zero  \n        SET total_tank TO zero  \n        FOR index i FROM zero TO the LENGTH OF gas MINUS one  \n            SET total_tank TO total_tank PLUS element at position i of gas MINUS element at position i of cost  \n            IF total_tank IS LESS THAN zero  \n                SET start TO i PLUS one  \n                SET total_tank TO zero  \n            END IF  \n        END FOR  \n        RETURN start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reorder-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val DEFAULTING TO zero AND next DEFAULTING TO none  \n        SET the attribute val TO val  \n        SET the attribute next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node with parameter values  \n    IF the value of values EQUALS none OR the LENGTH OF values EQUALS zero THEN  \n        RETURN none  \n    END IF  \n    SET head TO a new ListNode initialized with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements starting from position two TO the end of values  \n        SET node TO a new ListNode initialized with val  \n        SET the attribute next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list with parameters p1 AND p2  \n    IF p1 EQUALS none AND p2 EQUALS none THEN  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS none OR p2 EQUALS none THEN  \n        RETURN False  \n    END IF  \n    RETURN the logical AND of the condition that the attribute val of p1 EQUALS the attribute val of p2 AND the result of calling is_same_list with parameters the attribute next of p1 AND the attribute next of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION reorderList with parameters self AND head  \n        IF head EQUALS none OR the attribute next of head EQUALS none THEN  \n            RETURN  \n        END IF  \n\n        SET slow TO head  \n        SET fast TO head  \n        WHILE fast NOT EQUALS none AND the attribute next of fast NOT EQUALS none  \n            SET slow TO the attribute next of slow  \n            SET fast TO the attribute next of the attribute next of fast  \n        END WHILE  \n\n        SET prev TO none  \n        SET curr TO slow  \n        WHILE curr NOT EQUALS none  \n            SET next_temp TO the attribute next of curr  \n            SET the attribute next of curr TO prev  \n            SET prev TO curr  \n            SET curr TO next_temp  \n        END WHILE  \n\n        SET first TO head  \n        SET second TO prev  \n        WHILE the attribute next of second NOT EQUALS none  \n            SET temp1 TO the attribute next of first  \n            SET temp2 TO the attribute next of second  \n            SET the attribute next of first TO second  \n            SET the attribute next of second TO temp1  \n            SET first TO temp1  \n            SET second TO temp2  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "insertion-sort-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val AND next  \n        SET the value of the instance property val TO val  \n        SET the value of the instance property next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node with parameter values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN values starting from position two TO the end  \n        SET node TO new ListNode with val  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list with parameters p1 AND p2  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value property of p1 EQUALS the value property of p2 AND is_same_list with parameters the next property of p1 AND the next property of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION insertionSortList with parameter head  \n        IF head EQUALS None OR the next property of head EQUALS None  \n            RETURN head  \n        END IF  \n        SET dummy TO new ListNode with a value of negative five thousand AND one  \n        SET the next property of dummy TO head  \n        SET current TO the next property of head  \n        SET the next property of head TO None  \n        WHILE current is not None  \n            SET next_node TO the next property of current  \n            SET prev TO dummy  \n            WHILE the next property of prev is not None AND the value property of the next property of prev LESS THAN the value property of current  \n                SET prev TO the next property of prev  \n            END WHILE  \n            SET the next property of current TO the next property of prev  \n            SET the next property of prev TO current  \n            SET current TO next_node  \n        END WHILE  \n        RETURN the next property of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val EQUALS zero, next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF the collection values IS empty  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode object initialized with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the collection values starting from position two to the end  \n        SET node TO a new ListNode object initialized with val  \n        SET the next element of the object referenced by p TO node  \n        ASSIGN p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF the object referenced by p1 IS None AND the object referenced by p2 IS None  \n        RETURN True  \n    END IF  \n    IF the object referenced by p1 IS None OR the object referenced by p2 IS None  \n        RETURN False  \n    END IF  \n    RETURN whether the value of the object referenced by p1 EQUALS the value of the object referenced by p2 AND the result of calling is_same_list with the next element of p1 AND the next element of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION sortList(self, head)  \n        IF the object referenced by head IS None OR the next element of the object referenced by head IS None  \n            RETURN head  \n        END IF  \n\n        FUNCTION split(head)  \n            SET slow TO head  \n            SET fast TO the next element of the object referenced by head  \n            WHILE the object referenced by fast IS NOT None AND the next element of the object referenced by fast IS NOT None  \n                SET slow TO the next element of the object referenced by slow  \n                SET fast TO the next element of the next element of the object referenced by fast  \n            END WHILE  \n            SET mid TO the next element of the object referenced by slow  \n            SET the next element of the object referenced by slow TO None  \n            RETURN head AND mid  \n        END FUNCTION  \n\n        FUNCTION merge(l1, l2)  \n            SET dummy TO a new ListNode object with default initialization  \n            SET current TO dummy  \n            WHILE the object referenced by l1 IS NOT None AND the object referenced by l2 IS NOT None  \n                IF the value of the object referenced by l1 IS LESS THAN the value of the object referenced by l2  \n                    SET the next element of the object referenced by current TO the object referenced by l1  \n                    SET l1 TO the next element of the object referenced by l1  \n                ELSE  \n                    SET the next element of the object referenced by current TO the object referenced by l2  \n                    SET l2 TO the next element of the object referenced by l2  \n                END IF  \n                SET current TO the next element of the object referenced by current  \n            END WHILE  \n            SET the next element of the object referenced by current TO the object referenced by l1 OR the object referenced by l2 whichever IS NOT None  \n            RETURN the next element of the object referenced by dummy  \n        END FUNCTION  \n\n        SET left AND right TO the result of calling split with head  \n        SET left TO the result of calling sortList on self with left  \n        SET right TO the result of calling sortList on self with right  \n\n        RETURN the result of calling merge with left AND right  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-upside-down", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value as element at position one of values and left as none and right as none  \n    SET i TO one  \n    SET queue TO new double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO first element removed from the left of queue  \n        IF i LESS THAN length of values AND element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with value as element at position i of values and left as none and right as none  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN length of values AND element at position i of values NOT EQUALS none  \n            SET node.right TO new TreeNode with value as element at position i of values and left as none and right as none  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree with parameters p.left and q.left AND is_same_tree with parameters p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION upsideDownBinaryTree(self, root)  \n        IF root EQUALS none OR root.left EQUALS none  \n            RETURN root  \n        END IF  \n        SET new_root TO self.upsideDownBinaryTree with parameter root.left  \n        SET root.left.left TO root.right  \n        SET root.left.right TO root  \n        SET root.left TO none  \n        SET root.right TO none  \n        RETURN new_root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-right-side-view", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self val SET TO zero left SET TO none right SET TO none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO A new TreeNode constructed WITH the element at position zero of values  \n    SET i TO one  \n    SET queue TO A new empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element REMOVED FROM the LEFT OF queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.left TO A new TreeNode constructed WITH the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.right TO A new TreeNode constructed WITH the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left q.left) AND is_same_tree(p.right q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION rightSideView(self root)  \n        IF root EQUALS none  \n            RETURN an empty list  \n        END IF  \n        SET right_side_view TO an empty list  \n        SET queue TO A new double ended queue initialized WITH root  \n        WHILE the LENGTH OF queue GREATER THAN zero  \n            SET level_length TO the LENGTH OF queue  \n            FOR i FROM zero TO level_length MINUS one  \n                SET node TO the element REMOVED FROM the LEFT OF queue  \n                IF i EQUALS level_length MINUS one  \n                    APPEND node.val TO right_side_view  \n                END IF  \n                IF node.left NOT EQUALS none  \n                    APPEND node.left TO queue  \n                END IF  \n                IF node.right NOT EQUALS none  \n                    APPEND node.right TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN right_side_view  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "basic-calculator", "passing_rate": 0.16981132075471697, "pseudocode": "CLASS Solution  \n    FUNCTION calculate WITH parameter s  \n        FUNCTION helper WITH parameter s  \n            SET stack TO empty list  \n            SET sign TO plus  \n            SET num TO zero  \n            \n            WHILE the LENGTH OF s GREATER THAN zero holds  \n                SET char TO element at position zero of s  \n                REMOVE element at position zero FROM s  \n                \n                IF char represents a digit  \n                    SET num TO num MULTIPLIED BY ten PLUS the integer value represented by char  \n                END IF  \n                \n                IF char EQUALS open parenthesis  \n                    SET num TO the result of calling helper WITH argument s  \n                END IF  \n                \n                IF the NEGATION of char represents a digit AND the NEGATION of char represents whitespace OR the LENGTH OF s EQUALS zero  \n                    IF sign EQUALS plus  \n                        APPEND num TO stack  \n                    ELSE IF sign EQUALS minus  \n                        APPEND the negative value of num TO stack  \n                    ELSE IF sign EQUALS multiplication symbol  \n                        SET the element at the last position of stack TO the element at the last position of stack MULTIPLIED BY num  \n                    ELSE IF sign EQUALS division symbol  \n                        SET the element at the last position of stack TO the integer result of the element at the last position of stack DIVIDED BY num  \n                    END IF  \n                    \n                    SET sign TO char  \n                    SET num TO zero  \n                END IF  \n                \n                IF char EQUALS close parenthesis  \n                    BREAK the WHILE loop  \n                END IF  \n            END WHILE  \n            \n            RETURN the sum of all elements in stack  \n        END FUNCTION  \n        \n        RETURN the result of calling helper WITH argument the list of characters in s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-element-in-a-bst", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode OBJECT WITH val EQUALS element at position one of values  \n    SET i TO one  \n    SET queue TO an empty deque collection  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the element REMOVED FROM THE FRONT OF queue  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.left TO a new TreeNode OBJECT WITH val EQUALS element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.right TO a new TreeNode OBJECT WITH val EQUALS element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION kthSmallest(self, root, k)  \n        SET stack TO an empty list  \n        SET current TO root  \n        SET count TO zero  \n        WHILE the LENGTH OF stack IS GREATER THAN zero OR current IS NOT None  \n            WHILE current IS NOT None  \n                APPEND current TO stack  \n                SET current TO current.left  \n            END WHILE  \n            SET current TO the element REMOVED FROM THE END OF stack  \n            INCREMENT count BY one  \n            IF count EQUALS k  \n                RETURN current.val  \n            END IF  \n            SET current TO current.right  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lowest-common-ancestor-of-a-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value element at position zero of values  \n    SET i TO one  \n    SET queue TO new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO first element removed from the left side of queue  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS none  \n            SET node.right TO new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF the value of p NOT EQUALS the value of q  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(the left child of p, the left child of q) AND is_same_tree(the right child of p, the right child of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION lowestCommonAncestor(self, root, p, q)  \n        IF root EQUALS none OR root EQUALS p OR root EQUALS q  \n            RETURN root  \n        END IF  \n        SET left TO the result of calling lowestCommonAncestor on self with the left child of root, p, q  \n        SET right TO the result of calling lowestCommonAncestor on self with the right child of root, p, q  \n        IF left NOT EQUALS none AND right NOT EQUALS none  \n            RETURN root  \n        END IF  \n        IF left NOT EQUALS none  \n            RETURN left  \n        ELSE  \n            RETURN right  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-univalue-subtrees", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val left right  \n        SET the value attribute TO val  \n        SET the left child attribute TO left  \n        SET the right child attribute TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node with parameter values  \n    IF the list values EQUALS empty  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with the element at position zero of values  \n    SET i TO one  \n    CREATE an empty double ended queue named queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        REMOVE and ASSIGN node TO the element removed from the left end of queue  \n        IF i LESS THAN the length of values AND the element at position i of values IS NOT no value  \n            SET the left child attribute of node TO a new TreeNode with the element at position i of values  \n            APPEND the left child attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND the element at position i of values IS NOT no value  \n            SET the right child attribute of node TO a new TreeNode with the element at position i of values  \n            APPEND the right child attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree with parameters p q  \n    IF p EQUALS no value AND q EQUALS no value  \n        RETURN True  \n    ELSE IF p EQUALS no value OR q EQUALS no value  \n        RETURN False  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with parameters the left child attribute of p and the left child attribute of q AND the result of is_same_tree with parameters the right child attribute of p and the right child attribute of q  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION countUnivalSubtrees with parameters root  \n        FUNCTION helper with parameters node  \n            IF node EQUALS no value  \n                RETURN True AND zero  \n            END IF  \n            SET is_left_unival AND left_count TO the result of helper with the left child attribute of node  \n            SET is_right_unival AND right_count TO the result of helper with the right child attribute of node  \n            IF is_left_unival AND is_right_unival  \n                IF the left child attribute of node EQUALS no value OR the value attribute of the left child attribute of node EQUALS the value attribute of node  \n                    AND the right child attribute of node EQUALS no value OR the value attribute of the right child attribute of node EQUALS the value attribute of node  \n                    RETURN True AND left_count PLUS right_count PLUS one  \n                END IF  \n            END IF  \n            RETURN False AND left_count PLUS right_count  \n        END FUNCTION  \n        SET discard AND count TO the result of helper with root  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-binary-search-tree-value-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS self val defaulted to zero left defaulted to none right defaulted to none  \n        SET the value attribute of self TO val  \n        SET the left attribute of self TO left  \n        SET the right attribute of self TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values  \n    IF values IS EMPTY  \n        RETURN none  \n    END IF  \n    SET root TO A new TreeNode CREATED WITH the element at position one of values  \n    SET i TO one  \n    CREATE an empty double ended queue named queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        REMOVE and ASSIGN the first element of queue TO node  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET the left attribute of node TO A new TreeNode CREATED WITH the element at position i of values  \n            APPEND the left attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET the right attribute of node TO A new TreeNode CREATED WITH the element at position i of values  \n            APPEND the right attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree WITH PARAMETERS p q  \n    IF p IS none AND q IS none  \n        RETURN true  \n    ELSE IF p IS none OR q IS none  \n        RETURN false  \n    ELSE IF the value attribute of p IS NOT EQUALS TO the value attribute of q  \n        RETURN false  \n    ELSE  \n        RETURN the logical AND of is_same_tree WITH PARAMETERS the left attribute of p and the left attribute of q AND is_same_tree WITH PARAMETERS the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION closestKValues WITH PARAMETERS self root target k  \n        FUNCTION inorder_traversal WITH PARAMETER node  \n            IF node IS none  \n                RETURN  \n            END IF  \n            CALL inorder_traversal WITH the left attribute of node  \n            IF the LENGTH OF result IS LESS THAN k  \n                APPEND the value attribute of node TO result  \n            ELSE  \n                IF the ABSOLUTE VALUE OF the value attribute of node MINUS target IS LESS THAN the ABSOLUTE VALUE OF the element at position one of result MINUS target  \n                    REMOVE the first element FROM result  \n                    APPEND the value attribute of node TO result  \n                ELSE  \n                    RETURN  \n                END IF  \n            END IF  \n            CALL inorder_traversal WITH the right attribute of node  \n        END FUNCTION  \n        CREATE an empty double ended queue named result  \n        CALL inorder_traversal WITH root  \n        RETURN the list CONVERTED FROM result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-longest-consecutive-sequence", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF values IS NOT present  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with value equal to element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO element removed from the left end of queue  \n        IF i LESS THAN the length of values AND element at position i of values IS NOT None  \n            SET node.left TO a new TreeNode with value equal to element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values IS NOT None  \n            SET node.right TO a new TreeNode with value equal to element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p IS NOT present AND q IS NOT present  \n        RETURN True  \n    ELSE IF p IS NOT present OR q IS NOT present  \n        RETURN False  \n    ELSE IF value of p IS NOT EQUALS value of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(left child of p, left child of q) AND is_same_tree(right child of p, right child of q)  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION longestConsecutive(self, root)  \n        IF root IS NOT present  \n            RETURN zero  \n        END IF  \n        \n        FUNCTION dfs(node, parent, current_length)  \n            IF node IS NOT present  \n                RETURN current_length  \n            END IF  \n            \n            IF parent IS present AND value of node EQUALS parent PLUS one  \n                SET current_length TO current_length PLUS one  \n            ELSE  \n                SET current_length TO one  \n            END IF  \n            \n            SET left_length TO dfs(left child of node, value of node, current_length)  \n            SET right_length TO dfs(right child of node, value of node, current_length)  \n            \n            RETURN the maximum value among current_length, left_length, and right_length  \n        END FUNCTION\n        \n        RETURN dfs(root, None, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-vertical-order-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty list THEN  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value equal to element at position one of values and left equal to None and right equal to None  \n    SET i TO one  \n    SET queue TO empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        REMOVE element from the left of queue and ASSIGN to node  \n        IF i IS LESS THAN LENGTH OF values AND element at position i of values IS NOT None THEN  \n            SET node.left TO new TreeNode with value equal to element at position i of values and left equal to None and right equal to None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN LENGTH OF values AND element at position i of values IS NOT None THEN  \n            SET node.right TO new TreeNode with value equal to element at position i of values and left equal to None and right equal to None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None THEN  \n        RETURN True  \n    ELSE IF p IS None OR q IS None THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree with arguments p.left and q.left AND is_same_tree with arguments p.right and q.right  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION verticalOrder(self, root)  \n        IF root IS None THEN  \n            RETURN empty list  \n        END IF  \n        SET column_table TO empty dictionary with default value empty list  \n        SET queue TO empty double ended queue  \n        APPEND tuple of root and zero TO queue  \n        SET min_column TO zero  \n        SET max_column TO zero  \n        WHILE queue is not empty  \n            REMOVE element from the left of queue and ASSIGN to node and column_index  \n            IF node IS NOT None THEN  \n                APPEND node.val TO list at key column_index in column_table  \n                IF column_index IS LESS THAN min_column THEN  \n                    SET min_column TO column_index  \n                END IF  \n                IF column_index IS GREATER THAN max_column THEN  \n                    SET max_column TO column_index  \n                END IF  \n                APPEND tuple of node.left and column_index MINUS one TO queue  \n                APPEND tuple of node.right and column_index PLUS one TO queue  \n            END IF  \n        END WHILE  \n        SET result TO empty list  \n        FOR x FROM min_column TO max_column  \n            APPEND element at key x in column_table TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "odd-even-linked-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ WITH PARAMETERS val AND next  \n        SET the val property TO val  \n        SET the next property TO next  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION list_node WITH PARAMETER values  \n    IF the list values IS empty  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode constructed WITH the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values starting from position two TO the end  \n        SET node TO a new ListNode constructed WITH val  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION\n\nFUNCTION is_same_list WITH PARAMETERS p1 AND p2  \n    IF p1 IS None AND p2 IS None  \n        RETURN True  \n    END IF  \n    IF p1 IS None OR p2 IS None  \n        RETURN False  \n    END IF  \n    RETURN the condition that the val property of p1 EQUALS the val property of p2 AND the recursive call to is_same_list WITH the next property of p1 AND the next property of p2  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION oddEvenList WITH PARAMETER head  \n        IF head IS None OR the next property of head IS None OR the next property of the next property of head IS None  \n            RETURN head  \n        END IF  \n        SET odd TO head  \n        SET even TO the next property of head  \n        SET even_head TO even  \n        WHILE even IS NOT None AND the next property of even IS NOT None  \n            SET the next property of odd TO the next property of even  \n            SET odd TO the next property of odd  \n            SET the next property of even TO the next property of odd  \n            SET even TO the next property of even  \n        END WHILE  \n        SET the next property of odd TO even_head  \n        RETURN head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-bst-subtree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS none OR the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO A NEW TreeNode WITH the element at position one of values  \n    SET i TO one  \n    SET queue TO A NEW deque COLLECTION  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the element REMOVED FROM the FRONT OF queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node.left TO A NEW TreeNode WITH the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node.right TO A NEW TreeNode WITH the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION largestBSTSubtree(self, root)  \n        FUNCTION dfs(node)  \n            IF node EQUALS none  \n                RETURN positive infinity, negative infinity, zero  \n            END IF  \n            SET left_min, left_max, left_size TO dfs(node.left)  \n            SET right_min, right_max, right_size TO dfs(node.right)  \n            IF left_max LESS THAN node.val AND node.val LESS THAN right_min  \n                RETURN the smaller VALUE BETWEEN node.val AND left_min, the greater VALUE BETWEEN node.val AND right_max, left_size PLUS right_size PLUS one  \n            END IF  \n            RETURN negative infinity, positive infinity, THE GREATER VALUE BETWEEN left_size AND right_size  \n        END FUNCTION  \n        RETURN the element at position three of dfs(root)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-pairs", "passing_rate": 0.6346153846153846, "pseudocode": "CLASS Solution  \n    FUNCTION palindromePairs(words)  \n        FUNCTION is_palindrome(s)  \n            RETURN s EQUALS the string formed by the elements of s in reverse order  \n        END FUNCTION  \n        \n        SET word_dict TO an empty mapping from string to integer  \n        FOR each index i FROM zero TO the length of words MINUS one  \n            SET word_dict at the element at position i of words TO i  \n        END FOR  \n        \n        SET result TO an empty list  \n        \n        FOR each index i FROM zero TO the length of words MINUS one  \n            SET word TO the element at position i of words  \n            \n            IF word EQUALS the empty string THEN  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            \n            IF the empty string is a key in word_dict AND is_palindrome applied to word returns true THEN  \n                APPEND the list containing i and the value at the empty string key in word_dict TO result  \n                APPEND the list containing the value at the empty string key in word_dict and i TO result  \n            END IF  \n            \n            SET reversed_word TO the string formed by the elements of word in reverse order  \n            IF reversed_word is a key in word_dict AND the value at key reversed_word in word_dict NOT EQUALS i THEN  \n                APPEND the list containing i and the value at reversed_word key in word_dict TO result  \n            END IF  \n            \n            FOR each index j FROM one TO the length of word MINUS one  \n                SET prefix TO the substring of word from position zero TO position j MINUS one  \n                SET suffix TO the substring of word from position j TO the last position in word  \n                SET reversed_prefix TO the string formed by the elements of prefix in reverse order  \n                SET reversed_suffix TO the string formed by the elements of suffix in reverse order  \n                \n                IF is_palindrome applied to suffix returns true AND reversed_prefix is a key in word_dict THEN  \n                    APPEND the list containing i and the value at reversed_prefix key in word_dict TO result  \n                END IF  \n                \n                IF is_palindrome applied to prefix returns true AND reversed_suffix is a key in word_dict THEN  \n                    APPEND the list containing the value at reversed_suffix key in word_dict and i TO result  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "house-robber-iii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with value equal to the element at position one of values and no left nor right  \n    SET i TO one  \n    SET queue TO an empty deque collection  \n    APPEND root TO queue  \n    WHILE the queue IS NOT empty  \n        SET node TO the element REMOVED FROM the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value  \n            SET node.left TO a new TreeNode with value equal to the element at position i of values and no left nor right  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value  \n            SET node.right TO a new TreeNode with value equal to the element at position i of values and no left nor right  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value  \n        RETURN true  \n    ELSE IF p IS no value OR q IS no value  \n        RETURN false  \n    ELSE IF the value of p NOT EQUALS the value of q  \n        RETURN false  \n    ELSE  \n        RETURN the boolean result of is_same_tree with parameters the left child of p and the left child of q AND is_same_tree with parameters the right child of p and the right child of q  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION rob(self, root)  \n        FUNCTION rob_from_node(node)  \n            IF node IS no value  \n                RETURN zero, zero  \n            END IF  \n            SET left_robbed, left_not_robbed TO the two values returned by rob_from_node with the left child of node  \n            SET right_robbed, right_not_robbed TO the two values returned by rob_from_node with the right child of node  \n            SET rob_this_node TO the value of node PLUS left_not_robbed PLUS right_not_robbed  \n            SET not_rob_this_node TO the maximum value BETWEEN left_robbed AND left_not_robbed PLUS the maximum value BETWEEN right_robbed AND right_not_robbed  \n            RETURN rob_this_node, not_rob_this_node  \n        END FUNCTION  \n        RETURN the maximum value RETURNED BY rob_from_node with root as parameter  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-leaves-of-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val left right  \n        SET val TO val  \n        SET left TO left  \n        SET right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF values EQUALS an empty list  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode constructed with the element at position one of values  \n    SET i TO one  \n    SET queue TO a new empty deque  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the first element REMOVED from queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT NONE  \n            SET node.left TO a new TreeNode constructed with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT NONE  \n            SET node.right TO a new TreeNode constructed with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p q  \n    IF p IS NONE AND q IS NONE  \n        RETURN true  \n    ELSE IF p IS NONE OR q IS NONE  \n        RETURN false  \n    ELSE IF the val attribute of p IS NOT EQUALS TO the val attribute of q  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree with arguments the left attribute of p AND the left attribute of q AND the result of is_same_tree with arguments the right attribute of p AND the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findLeaves with parameters root  \n        FUNCTION collectLeaves with parameter node  \n            IF node IS NONE  \n                RETURN minus one  \n            END IF  \n            SET left_height TO the result of collectLeaves with argument the left attribute of node  \n            SET right_height TO the result of collectLeaves with argument the right attribute of node  \n            SET current_height TO the maximum of left_height AND right_height PLUS one  \n            IF current_height IS GREATER THAN OR EQUAL TO the LENGTH OF result  \n                APPEND an empty list TO result  \n            END IF  \n            APPEND the val attribute of node TO the element at position current_height of result  \n            RETURN current_height  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL collectLeaves with argument root  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-divisible-subset", "passing_rate": 0.03571428571428571, "pseudocode": "CLASS Solution  \n    FUNCTION largestDivisibleSubset(nums)  \n        SORT nums IN ASCENDING ORDER  \n        SET n TO the LENGTH OF nums  \n        SET f TO a list OF value one REPEATED n times  \n        SET k TO zero  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF the element at position i of nums MODULO the element at position j of nums EQUALS zero THEN  \n                    SET f at position i TO the GREATER VALUE BETWEEN f at position i AND f at position j PLUS one  \n                END IF  \n            END FOR  \n            IF f at position k LESS THAN f at position i THEN  \n                SET k TO i  \n            END IF  \n        END FOR  \n        SET m TO f at position k  \n        SET i TO k  \n        SET ans TO an empty list  \n        WHILE m GREATER THAN zero  \n            IF the element at position k of nums MODULO the element at position i of nums EQUALS zero AND f at position i EQUALS m THEN  \n                APPEND the element at position i of nums TO ans  \n                SET k TO i  \n                DECREMENT m BY one  \n            END IF  \n            DECREMENT i BY one  \n        END WHILE  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "plus-one-linked-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val EQUALS zero, next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements from position two TO the end of values  \n        SET node TO a new ListNode with val  \n        SET the next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value of p1 EQUALS the value of p2 AND is_same_list of the next of p1 AND the next of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION plusOne(self, head)  \n        FUNCTION reverseList(node)  \n            SET prev TO None  \n            WHILE node IS NOT None  \n                SET next_node TO the next of node  \n                SET the next of node TO prev  \n                SET prev TO node  \n                SET node TO next_node  \n            END WHILE  \n            RETURN prev  \n        END FUNCTION  \n        \n        SET reversed_head TO reverseList of head  \n        SET carry TO one  \n        SET current TO reversed_head  \n        \n        WHILE current IS NOT None AND carry EQUALS one  \n            SET the value of current TO the value of current PLUS carry  \n            SET carry TO the value of current DIVIDED BY ten  \n            SET the value of current TO the value of current MODULO ten  \n            \n            IF the next of current EQUALS None AND carry EQUALS one  \n                SET the next of current TO a new ListNode with carry  \n                SET carry TO zero  \n            END IF  \n            \n            SET prev TO current  \n            SET current TO the next of current  \n        END WHILE  \n        \n        RETURN reverseList of reversed_head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "evaluate-division", "passing_rate": 0.34782608695652173, "pseudocode": "CLASS Solution  \n    FUNCTION calcEquation(equations, values, queries)  \n        SET graph TO a new mapping with default type as mapping  \n        FOR each pair of variables a and b AND each corresponding value IN equations and values  \n            SET element at key b of element at key a of graph TO value  \n            SET element at key a of element at key b of graph TO one DIVIDED BY value  \n        END FOR  \n        \n        FUNCTION dfs(start, end, visited)  \n            IF start NOT IN graph OR end NOT IN graph THEN  \n                RETURN negative one  \n            END IF  \n            IF start EQUALS end THEN  \n                RETURN one  \n            END IF  \n            ADD start TO visited  \n            FOR each neighbor AND weight IN elements of element at key start of graph  \n                IF neighbor NOT IN visited THEN  \n                    SET result TO dfs(neighbor, end, visited)  \n                    IF result NOT EQUALS negative one THEN  \n                        RETURN weight MULTIPLIED BY result  \n                    END IF  \n                END IF  \n            END FOR  \n            REMOVE start FROM visited  \n            RETURN negative one  \n        END FUNCTION  \n        \n        SET results TO empty list  \n        FOR each query IN queries  \n            SET start TO element at position one of query  \n            SET end TO element at position two of query  \n            SET visited TO empty set  \n            SET result TO dfs(start, end, visited)  \n            APPEND result TO results  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pacific-atlantic-water-flow", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION pacificAtlantic(heights)  \n        FUNCTION bfs(q vis)  \n            WHILE the LENGTH OF q is greater than zero  \n                FOR underscore FROM zero TO the LENGTH OF q MINUS one  \n                    SET i TO the first element of the tuple at the front of q removed from the left  \n                    SET j TO the second element of the tuple at the front of q removed from the left  \n                    FOR each pair a b IN the list containing the pairs zero MINUS one zero one one zero MINUS one zero  \n                        SET x TO i PLUS a  \n                        SET y TO j PLUS b  \n                        IF x IS GREATER THAN OR EQUAL TO zero AND x IS LESS THAN m AND y IS GREATER THAN OR EQUAL TO zero AND y IS LESS THAN n AND the tuple x y IS NOT IN vis AND the element at position x of heights AND at position y OF THAT element IS GREATER THAN OR EQUAL TO the element at position i of heights AND at position j OF THAT element  \n                            ADD the tuple x y TO vis  \n                            APPEND the tuple x y TO the right end of q  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END WHILE  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF heights  \n        SET n TO the LENGTH OF the first element of heights  \n        SET vis1 TO an empty set  \n        SET vis2 TO an empty set  \n        SET q1 TO an empty double ended queue  \n        SET q2 TO an empty double ended queue  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF i EQUALS zero OR j EQUALS zero  \n                    ADD the tuple i j TO vis1  \n                    APPEND the tuple i j TO the right end of q1  \n                END IF  \n                IF i EQUALS m MINUS one OR j EQUALS n MINUS one  \n                    ADD the tuple i j TO vis2  \n                    APPEND the tuple i j TO the right end of q2  \n                END IF  \n            END FOR  \n        END FOR  \n        CALL bfs WITH q1 AND vis1  \n        CALL bfs WITH q2 AND vis2  \n        SET result TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the tuple i j IS IN vis1 AND the tuple i j IS IN vis2  \n                    APPEND the tuple i j TO result  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "path-sum-iii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value being element at position zero of values  \n    SET i TO one  \n    SET queue TO new deque collection  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS None THEN  \n            SET node.left TO new TreeNode with value being element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS None THEN  \n            SET node.right TO new TreeNode with value being element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree with parameters p.left and q.left AND is_same_tree with parameters p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION pathSum(self, root, targetSum)  \n        FUNCTION helper(node, current_sum, prefix_sums)  \n            IF node EQUALS None THEN  \n                RETURN zero  \n            END IF  \n            SET current_sum TO current_sum PLUS node.val  \n            SET paths_to_here TO the value associated with key current_sum MINUS targetSum in prefix_sums IF EXISTS OTHERWISE zero  \n            SET prefix_sums at key current_sum TO the value associated with key current_sum in prefix_sums IF EXISTS OTHERWISE zero PLUS one  \n            SET paths_in_left TO the result of calling helper with parameters node.left, current_sum, prefix_sums  \n            SET paths_in_right TO the result of calling helper with parameters node.right, current_sum, prefix_sums  \n            DECREMENT the value associated with key current_sum in prefix_sums BY one  \n            RETURN paths_to_here PLUS paths_in_left PLUS paths_in_right  \n        END FUNCTION  \n        SET prefix_sums TO a new mapping with key zero associated with value one  \n        RETURN the result of calling helper with parameters root, zero, prefix_sums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "add-two-numbers-ii", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ WITH PARAMETERS val NEXT  \n        SET the property val TO val  \n        SET the property next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node WITH PARAMETERS values  \n    IF the list values EQUALS empty  \n        RETURN nothing  \n    END IF  \n    SET head TO a new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values FROM position two TO the end  \n        SET node TO a new ListNode with val  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list WITH PARAMETERS p1 p2  \n    IF p1 EQUALS nothing AND p2 EQUALS nothing  \n        RETURN true  \n    END IF  \n    IF p1 EQUALS nothing OR p2 EQUALS nothing  \n        RETURN false  \n    END IF  \n    RETURN the val property of p1 EQUALS the val property of p2 AND is_same_list WITH PARAMETERS the next property of p1 AND the next property of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION addTwoNumbers WITH PARAMETERS l1 l2  \n        FUNCTION pushIntoStack WITH PARAMETER node  \n            SET stack TO an empty list  \n            WHILE node is not nothing  \n                APPEND the val property of node TO stack  \n                SET node TO the next property of node  \n            END WHILE  \n            RETURN stack  \n        END FUNCTION  \n\n        SET stack1 TO pushIntoStack WITH PARAMETER l1  \n        SET stack2 TO pushIntoStack WITH PARAMETER l2  \n\n        SET carry TO zero  \n        SET result TO nothing  \n\n        WHILE the LENGTH OF stack1 IS GREATER THAN zero OR the LENGTH OF stack2 IS GREATER THAN zero OR carry IS GREATER THAN zero  \n            IF the LENGTH OF stack1 IS GREATER THAN zero  \n                SET val1 TO the last element of stack1 and REMOVE that element FROM stack1  \n            ELSE  \n                SET val1 TO zero  \n            END IF  \n            IF the LENGTH OF stack2 IS GREATER THAN zero  \n                SET val2 TO the last element of stack2 and REMOVE that element FROM stack2  \n            ELSE  \n                SET val2 TO zero  \n            END IF  \n\n            SET total TO val1 PLUS val2 PLUS carry  \n            SET carry TO total DIVIDED BY ten  \n            SET digit TO total MODULO ten  \n\n            SET new_node TO a new ListNode with digit  \n            SET the next property of new_node TO result  \n            SET result TO new_node  \n        END WHILE  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-node-in-a-bst", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters self val left right  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with element at position one of values  \n    SET i TO one  \n    INITIALIZE queue AS an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the first element removed from the left of queue  \n        IF i LESS THAN LENGTH OF values AND element at position i of values NOT EQUALS None  \n            SET node.left TO new TreeNode with element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN LENGTH OF values AND element at position i of values NOT EQUALS None  \n            SET node.right TO new TreeNode with element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p q  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with p.left and q.left AND the result of is_same_tree with p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION deleteNode with parameters self root key  \n        IF root EQUALS None  \n            RETURN None  \n        END IF  \n        IF root.val GREATER THAN key  \n            SET root.left TO the result of calling deleteNode on self with root.left and key  \n            RETURN root  \n        END IF  \n        IF root.val LESS THAN key  \n            SET root.right TO the result of calling deleteNode on self with root.right and key  \n            RETURN root  \n        END IF  \n        IF root.left EQUALS None  \n            RETURN root.right  \n        END IF  \n        IF root.right EQUALS None  \n            RETURN root.left  \n        END IF  \n        SET node TO root.right  \n        WHILE node.left NOT EQUAL TO None  \n            SET node TO node.left  \n        END WHILE  \n        SET node.left TO root.left  \n        SET root TO root.right  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-the-repetitions", "passing_rate": 0.5, "pseudocode": "CLASS Solution  \n    FUNCTION getMaxRepetitions(s1 s1 AS string, n1 n1 AS integer, s2 s2 AS string, n2 n2 AS integer) RETURNS integer  \n        IF n1 EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n\n        SET s2_count TO a list of zeros with length equal to the length of s2 PLUS one  \n        SET index_map TO a list of zeros with length equal to the length of s2 PLUS one  \n\n        SET current_index_s2 TO zero  \n        SET s1_count TO zero  \n\n        WHILE s1_count LESS THAN n1  \n            INCREMENT s1_count BY one  \n\n            FOR each char IN s1  \n                IF char EQUALS the element at position current_index_s2 of s2 THEN  \n                    INCREMENT current_index_s2 BY one  \n                    IF current_index_s2 EQUALS the length of s2 THEN  \n                        SET the element at position s1_count of s2_count TO the element at position s1_count MINUS one of s2_count PLUS one  \n                        SET current_index_s2 TO zero  \n                    END IF  \n                END IF  \n                SET the element at position s1_count of index_map TO current_index_s2  \n            END FOR  \n\n            IF current_index_s2 IS contained in the elements of index_map from position one TO position s1_count MINUS one THEN  \n                SET start TO the position of current_index_s2 in index_map  \n                SET cycle_length TO s1_count MINUS start  \n                SET cycles_fit TO the integer division of n1 MINUS start BY cycle_length  \n                SET remainder TO the remainder of the integer division of n1 MINUS start BY cycle_length  \n\n                SET total_s2_count TO the element at position start of s2_count PLUS cycles_fit MULTIPLIED BY the difference between the element at position start PLUS cycle_length of s2_count AND the element at position start of s2_count PLUS the difference between the element at position start PLUS remainder of s2_count AND the element at position start of s2_count  \n\n                RETURN the integer division of total_s2_count BY n2  \n            END IF  \n        END WHILE  \n\n        RETURN the integer division of the element at position s1_count of s2_count BY n2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-palindrome-product", "passing_rate": 0.75, "pseudocode": "CLASS Solution  \n    FUNCTION largestPalindrome WITH PARAMETER n  \n        IF n EQUALS one  \n            RETURN nine  \n        END IF  \n\n        SET upper_limit TO ten MULTIPLIED BY ten MULTIPLIED BY ... (repeated n times) MINUS one  \n        SET lower_limit TO ten MULTIPLIED BY ten MULTIPLIED BY ... (repeated n MINUS one times)  \n\n        SET max_palindrome TO zero  \n\n        FOR i FROM upper_limit TO lower_limit MINUS one DECREMENTING BY one  \n            FOR j FROM i TO lower_limit MINUS one DECREMENTING BY one  \n                SET product TO i MULTIPLIED BY j  \n                IF product LESS THAN OR EQUAL TO max_palindrome  \n                    BREAK  \n                END IF  \n                SET str_product TO the string representation of product  \n                IF str_product EQUALS str_product reversed in order  \n                    SET max_palindrome TO product  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN remainder of max_palindrome DIVIDED BY one thousand three hundred thirty seven  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-consecutive-ones-ii", "passing_rate": 0.2972972972972973, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxConsecutiveOnes(nums)  \n        SET max_count TO zero  \n        SET current_count TO zero  \n        SET zero_count TO zero  \n        SET left TO zero  \n        \n        FOR right FROM zero TO the LENGTH OF nums MINUS one  \n            IF element at position right of nums EQUALS one  \n                INCREMENT current_count BY one  \n            ELSE IF zero_count LESS THAN one  \n                INCREMENT zero_count BY one  \n                INCREMENT current_count BY one  \n            ELSE  \n                SET max_count TO the GREATER OF max_count AND current_count  \n                WHILE zero_count EQUALS one  \n                    IF element at position left of nums EQUALS zero  \n                        DECREMENT zero_count BY one  \n                    END IF  \n                    DECREMENT current_count BY one  \n                    INCREMENT left BY one  \n                END WHILE  \n                INCREMENT current_count BY one  \n            END IF  \n        END FOR  \n        \n        SET max_count TO the GREATER OF max_count AND current_count  \n        RETURN max_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "most-frequent-subtree-sum", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN nothing  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position one of values  \n    SET i TO one  \n    SET queue TO a new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the length of values AND the element at position i of values is not nothing  \n            SET node.left TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND the element at position i of values is not nothing  \n            SET node.right TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS nothing AND q EQUALS nothing  \n        RETURN True  \n    ELSE IF p EQUALS nothing OR q EQUALS nothing  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(the left attribute of p, the left attribute of q) AND is_same_tree(the right attribute of p, the right attribute of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findFrequentTreeSum(self, root)  \n        FUNCTION subtree_sum(node)  \n            IF node EQUALS nothing  \n                RETURN zero  \n            END IF  \n            SET current_sum TO the val attribute of node PLUS subtree_sum(the left attribute of node) PLUS subtree_sum(the right attribute of node)  \n            INCREMENT the element at key current_sum in count BY one  \n            RETURN current_sum  \n        END FUNCTION  \n        \n        SET count TO an empty mapping with integer default values  \n        CALL subtree_sum with root  \n        SET max_freq TO the maximum value among all values in count or zero if count is empty  \n        SET result TO an empty list  \n        FOR each key and frequency IN count  \n            IF frequency EQUALS max_freq  \n                APPEND key TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-bottom-left-tree-value", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the collection values DOES NOT EXIST OR the LENGTH OF values EQUALS zero  \n        RETURN nothing  \n    END IF  \n    SET root TO a new instance of TreeNode WITH the element at position one of values AS val  \n    SET i TO one  \n    CREATE an empty double ended queue named queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        REMOVE the first element FROM queue AND ASSIGN it TO node  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values EXISTS AND the element at position i of values IS NOT nothing  \n            SET node.left TO a new instance of TreeNode WITH the element at position i of values AS val  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values EXISTS AND the element at position i of values IS NOT nothing  \n            SET node.right TO a new instance of TreeNode WITH the element at position i of values AS val  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p DOES NOT EXIST AND q DOES NOT EXIST  \n        RETURN True  \n    ELSE IF p DOES NOT EXIST OR q DOES NOT EXIST  \n        RETURN False  \n    ELSE IF the value attribute of p IS NOT EQUAL TO the value attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(the left attribute of p, the left attribute of q) AND is_same_tree(the right attribute of p, the right attribute of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findBottomLeftValue(self, root)  \n        CREATE a double ended queue named queue WITH root AS its only element  \n        SET leftmost_value TO nothing  \n        WHILE the LENGTH OF queue IS GREATER THAN zero  \n            SET level_size TO the LENGTH OF queue  \n            FOR i FROM zero TO level_size MINUS one  \n                REMOVE the first element FROM queue AND ASSIGN it TO node  \n                IF i EQUALS zero  \n                    SET leftmost_value TO the value attribute of node  \n                END IF  \n                IF the left attribute of node EXISTS  \n                    APPEND the left attribute of node TO queue  \n                END IF  \n                IF the right attribute of node EXISTS  \n                    APPEND the right attribute of node TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN leftmost_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-largest-value-in-each-tree-row", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self val SET TO zero left SET TO None right SET TO None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with value AS element at position one of values  \n    SET i TO one  \n    CREATE an empty double-ended queue named queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero DO  \n        REMOVE and RETURN the element from the left of queue AND ASSIGN TO node  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT None THEN  \n            SET node.left TO a new TreeNode with value AS element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT None THEN  \n            SET node.right TO a new TreeNode with value AS element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p q)  \n    IF p IS None AND q IS None THEN  \n        RETURN True  \n    ELSE IF p IS None OR q IS None THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(the left child of p THE left child of q) AND is_same_tree(the right child of p THE right child of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION largestValues(self root)  \n        IF root IS None THEN  \n            RETURN an empty list  \n        END IF  \n        CREATE an empty double-ended queue named queue initialized with root as its only element  \n        CREATE an empty list named largest_values  \n        WHILE the LENGTH OF queue IS GREATER THAN zero DO  \n            SET level_size TO the LENGTH OF queue  \n            SET max_value TO negative infinity  \n            FOR index FROM one TO level_size DO  \n                REMOVE and RETURN the element from the left of queue AND ASSIGN TO node  \n                IF max_value IS LESS THAN the value of node THEN  \n                    SET max_value TO the value of node  \n                END IF  \n                IF the left child of node IS NOT None THEN  \n                    APPEND the left child of node TO queue  \n                END IF  \n                IF the right child of node IS NOT None THEN  \n                    APPEND the right child of node TO queue  \n                END IF  \n            END FOR  \n            APPEND max_value TO largest_values  \n        END WHILE  \n        RETURN largest_values  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-abbreviation", "passing_rate": 0.6666666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION wordsAbbreviation(words)  \n        FUNCTION abbreviate(word prefix_length)  \n            IF the LENGTH OF word MINUS prefix_length LESS THAN OR EQUAL TO two  \n                RETURN word  \n            END IF  \n            RETURN the SUBSTRING of word from the FIRST POSITION TO the POSITION prefix_length PLUS the STRING REPRESENTATION OF the LENGTH OF word MINUS prefix_length MINUS one PLUS the LAST CHARACTER of word  \n        END FUNCTION  \n\n        FUNCTION get_unique_abbreviations(words_with_indices prefix_length)  \n            SET abbs TO a new empty mapping from keys to lists  \n            FOR each index and word IN words_with_indices  \n                APPEND the TUPLE of index and word TO the LIST at the KEY given by abbreviate(word prefix_length) IN abbs  \n            END FOR  \n            RETURN abbs  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF words  \n        SET ans TO a LIST of EMPTY STRINGS with LENGTH n  \n        SET words_with_indices TO the LIST of TUPLES of each INTEGER index and corresponding word in words enumerated by index  \n        \n        SET abbs TO get_unique_abbreviations(words_with_indices the NUMBER one)  \n        \n        FOR each abb and group IN the ITEMS OF abbs  \n            IF the LENGTH OF group EQUALS one  \n                SET index and word TO the FIRST ELEMENT of group  \n                SET the ELEMENT at position index of ans TO abb  \n            ELSE  \n                SET new_group TO an EMPTY LIST  \n                FOR each index and word IN group  \n                    APPEND the TUPLE of index and word TO new_group  \n                END FOR  \n                SET prefix_length TO the NUMBER two  \n                WHILE the LENGTH OF new_group GREATER THAN zero  \n                    SET new_abbs TO get_unique_abbreviations(new_group prefix_length)  \n                    SET new_group TO an EMPTY LIST  \n                    FOR each new_abb and new_group_items IN the ITEMS OF new_abbs  \n                        IF the LENGTH OF new_group_items EQUALS one  \n                            SET index and word TO the FIRST ELEMENT of new_group_items  \n                            SET the ELEMENT at position index of ans TO new_abb  \n                        ELSE  \n                            FOR each element IN new_group_items  \n                                APPEND element TO new_group  \n                            END FOR  \n                        END IF  \n                    END FOR  \n                    INCREMENT prefix_length BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-binary-tree-from-string", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val EQUALS zero, next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with value being element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values from position two TO the last element  \n        SET node TO new ListNode with value val  \n        SET p.next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the comparison of p1.val EQUALS p2.val AND is_same_list with parameters p1.next AND p2.next  \nEND FUNCTION  \n\nCLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value being element at position one of values  \n    SET i TO one  \n    SET queue TO new empty deque  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the length of values AND the element at position i of values NOT EQUALS None  \n            SET node.left TO new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND the element at position i of values NOT EQUALS None  \n            SET node.right TO new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree with parameters p.left AND q.left AND is_same_tree with parameters p.right AND q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION str2tree(self, s)  \n        FUNCTION parse_tree(index)  \n            IF index GREATER THAN OR EQUAL TO the length of s  \n                RETURN None AND index  \n            END IF  \n            SET start TO index  \n            WHILE index LESS THAN the length of s AND (the element at position index of s IS a digit OR the element at position index of s EQUALS the minus character)  \n                INCREMENT index BY one  \n            END WHILE  \n            SET node TO new TreeNode with value the integer parsed from the substring of s from position start TO position index MINUS one  \n            IF index LESS THAN the length of s AND the element at position index of s EQUALS the opening parenthesis character  \n                SET node.left AND index TO the values returned by parse_tree with parameter index PLUS one  \n            END IF  \n            IF index LESS THAN the length of s AND the element at position index of s EQUALS the opening parenthesis character  \n                SET node.right AND index TO the values returned by parse_tree with parameter index PLUS one  \n            END IF  \n            IF index LESS THAN the length of s AND the element at position index of s EQUALS the closing parenthesis character  \n                INCREMENT index BY one  \n            END IF  \n            RETURN node AND index  \n        END FUNCTION  \n        SET root AND _ TO parse_tree with parameter zero  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "convert-bst-to-greater-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS self val left right  \n        SET self dot val TO val  \n        SET self dot left TO left  \n        SET self dot right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values  \n    IF values EQUALS nothing  \n        RETURN nothing  \n    END IF  \n    SET root TO new instance of TreeNode WITH PARAMETER element at position one of values  \n    SET i TO one  \n    SET queue TO new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO remove and return the first element of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS nothing  \n            SET node dot left TO new instance of TreeNode WITH PARAMETER element at position i of values  \n            APPEND node dot left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS nothing  \n            SET node dot right TO new instance of TreeNode WITH PARAMETER element at position i of values  \n            APPEND node dot right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree WITH PARAMETERS p q  \n    IF p EQUALS nothing AND q EQUALS nothing  \n        RETURN True  \n    ELSE IF p EQUALS nothing OR q EQUALS nothing  \n        RETURN False  \n    ELSE IF p dot val NOT EQUALS q dot val  \n        RETURN False  \n    ELSE  \n        RETURN RESULT OF is_same_tree WITH PARAMETERS p dot left q dot left AND RESULT OF is_same_tree WITH PARAMETERS p dot right q dot right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION convertBST WITH PARAMETERS self root  \n        SET self dot sum TO zero  \n        FUNCTION traverse WITH PARAMETER node  \n            IF node EQUALS nothing  \n                RETURN  \n            END IF  \n            CALL traverse WITH PARAMETER node dot right  \n            INCREMENT self dot sum BY node dot val  \n            SET node dot val TO self dot sum  \n            CALL traverse WITH PARAMETER node dot left  \n        END FUNCTION  \n        CALL traverse WITH PARAMETER root  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "boundary-of-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val left right  \n        SET the property val TO val  \n        SET the property left TO left  \n        SET the property right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF the collection values IS EMPTY  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode object initialized with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty deque collection  \n    APPEND root TO queue  \n    WHILE the collection queue IS NOT EMPTY  \n        SET node TO the element obtained by removing the first element of queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value  \n            SET the property left of node TO a new TreeNode object initialized with the element at position i of values  \n            APPEND the property left of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value  \n            SET the property right of node TO a new TreeNode object initialized with the element at position i of values  \n            APPEND the property right of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p q  \n    IF p IS no value AND q IS no value  \n        RETURN True  \n    ELSE IF p IS no value OR q IS no value  \n        RETURN False  \n    ELSE IF the property val of p IS NOT EQUALS TO the property val of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree called with the property left of p and the property left of q AND the result of is_same_tree called with the property right of p and the property right of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION boundaryOfBinaryTree with parameter root  \n        IF root IS no value  \n            RETURN an empty list  \n        END IF  \n\n        FUNCTION is_leaf with parameter node  \n            RETURN node IS no value IS False AND the property left of node IS no value AND the property right of node IS no value  \n        END FUNCTION  \n\n        SET left_boundary TO an empty list  \n        SET current TO the property left of root  \n        WHILE current IS NOT no value  \n            IF the result of is_leaf called with current IS False  \n                APPEND the property val of current TO left_boundary  \n            END IF  \n            IF the property left of current IS NOT no value  \n                SET current TO the property left of current  \n            ELSE  \n                SET current TO the property right of current  \n            END IF  \n        END WHILE  \n\n        SET right_boundary TO an empty list  \n        SET current TO the property right of root  \n        WHILE current IS NOT no value  \n            IF the result of is_leaf called with current IS False  \n                APPEND the property val of current TO right_boundary  \n            END IF  \n            IF the property right of current IS NOT no value  \n                SET current TO the property right of current  \n            ELSE  \n                SET current TO the property left of current  \n            END IF  \n        END WHILE  \n\n        SET leaves TO an empty list  \n\n        FUNCTION collect_leaves with parameter node  \n            IF node IS no value  \n                RETURN  \n            END IF  \n            IF the result of is_leaf called with node  \n                APPEND the property val of node TO leaves  \n            END IF  \n            CALL collect_leaves with the property left of node  \n            CALL collect_leaves with the property right of node  \n        END FUNCTION  \n\n        CALL collect_leaves with root  \n\n        IF the result of is_leaf called with root  \n            SET leaves TO an empty list  \n        END IF  \n\n        RETURN a new list formed by concatenating a list containing the property val of root followed by left_boundary followed by leaves followed by the reverse of right_boundary  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-longest-consecutive-sequence-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS self val LEFT right  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETERS values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO NEW TreeNode WITH PARAMETER element at position zero of values  \n    SET i TO one  \n    SET queue TO new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO first element removed FROM queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.left TO new TreeNode WITH PARAMETER element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.right TO new TreeNode WITH PARAMETER element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree WITH PARAMETERS p q  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree WITH PARAMETERS p.left q.left AND is_same_tree WITH PARAMETERS p.right q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION longestConsecutive WITH PARAMETERS self root  \n        FUNCTION dfs WITH PARAMETERS node  \n            IF node EQUALS None  \n                RETURN zero AND zero  \n            END IF  \n            SET inc_len TO one  \n            SET dec_len TO one  \n            SET left_inc AND left_dec TO dfs WITH PARAMETERS node.left  \n            SET right_inc AND right_dec TO dfs WITH PARAMETERS node.right  \n            IF node.left NOT EQUALS None  \n                IF node.val EQUALS node.left.val PLUS one  \n                    SET dec_len TO left_dec PLUS one  \n                ELSE IF node.val EQUALS node.left.val MINUS one  \n                    SET inc_len TO left_inc PLUS one  \n                END IF  \n            END IF  \n            IF node.right NOT EQUALS None  \n                IF node.val EQUALS node.right.val PLUS one  \n                    SET dec_len TO the GREATER OF dec_len AND right_dec PLUS one  \n                ELSE IF node.val EQUALS node.right.val MINUS one  \n                    SET inc_len TO the GREATER OF inc_len AND right_inc PLUS one  \n                END IF  \n            END IF  \n            SET max_len TO the GREATER OF max_len AND inc_len PLUS dec_len MINUS one  \n            RETURN inc_len AND dec_len  \n        END FUNCTION  \n        SET max_len TO zero  \n        CALL dfs WITH PARAMETER root  \n        RETURN max_len  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kill-process", "passing_rate": 0.7380952380952381, "pseudocode": "CLASS Solution  \n    FUNCTION killProcess(pid AS list of integers ppid AS list of integers kill AS integer) RETURNS list of integers  \n        SET tree TO a mapping from integer keys to list of integers with default empty list  \n        FOR each pair of child and parent IN the parallel elements of pid and ppid  \n            APPEND child TO the list corresponding to parent in tree  \n        END FOR  \n        SET queue TO a list containing only the integer kill  \n        SET killed_processes TO an empty list  \n        WHILE the list queue is not empty  \n            SET current TO the element at the first position of queue  \n            REMOVE the element at the first position from queue  \n            APPEND current TO killed_processes  \n            FOR each child IN the list corresponding to current key in tree  \n                APPEND child TO queue  \n            END FOR  \n        END WHILE  \n        RETURN killed_processes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "fraction-addition-and-subtraction", "passing_rate": 0.7735849056603774, "pseudocode": "CLASS Solution  \n    FUNCTION fractionAddition(expression)  \n        SET list_of_fractions TO the result of replacing every occurrence of the minus sign in expression WITH the plus sign followed BY the minus sign THEN splitting the resulting string by the plus sign  \n        SET sum_of_fractions TO the sum of converting each non empty element in list_of_fractions INTO a fraction using the fraction conversion operation  \n        SET result_string TO the concatenation of the numerator of sum_of_fractions FOLLOWED BY the forward slash FOLLOWED BY the denominator of sum_of_fractions  \n        RETURN result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-negative-integers-without-consecutive-ones", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION findIntegers WITH PARAMETER n  \n        SET binary_representation TO the binary representation of n starting from the element after the first character  \n        SET length TO the LENGTH OF binary_representation  \n        INITIALIZE dp AS a list of zeros with the size EQUAL TO length PLUS one  \n        SET the element at position zero of dp TO one  \n        SET the element at position one of dp TO two  \n        FOR i FROM two TO length  \n            SET the element at position i of dp TO the element at position i MINUS one of dp PLUS the element at position i MINUS two of dp  \n        END FOR  \n        SET result TO zero  \n        SET previous_bit TO zero  \n        FOR i FROM zero TO length MINUS one  \n            IF the element at position i of binary_representation EQUALS one  \n                SET result TO result PLUS the element at position length MINUS i MINUS one of dp  \n                IF previous_bit EQUALS one  \n                    SET result TO result MINUS one  \n                    BREAK the loop  \n                END IF  \n            END IF  \n            IF the element at position i of binary_representation EQUALS one  \n                SET previous_bit TO one  \n            ELSE  \n                SET previous_bit TO zero  \n            END IF  \n        END FOR  \n        RETURN result PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-string-from-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode WITH the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the element removed from the left end of queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node.left TO a new TreeNode WITH the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node.right TO a new TreeNode WITH the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN True  \n    ELSE IF p IS none OR q IS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree WITH p.left AND q.left AND the result of is_same_tree WITH p.right AND q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION tree2str(self, root)  \n        FUNCTION helper(node)  \n            IF node IS none  \n                RETURN an empty string  \n            END IF  \n            SET result TO the string representation of node.val  \n            IF node.left IS NOT none OR node.right IS NOT none  \n                SET result TO result PLUS an open parenthesis PLUS the result of helper WITH node.left PLUS a close parenthesis  \n            END IF  \n            IF node.right IS NOT none  \n                SET result TO result PLUS an open parenthesis PLUS the result of helper WITH node.right PLUS a close parenthesis  \n            END IF  \n            RETURN result  \n        END FUNCTION  \n        RETURN the result of helper WITH root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "task-scheduler", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION leastInterval(tasks task_list OF STRING n cooldown_interval OF INTEGER) RETURNS INTEGER  \n        SET task_counts TO a collection mapping each unique element IN task_list TO the number of times it appears  \n        SET max_heap TO an empty list  \n        FOR each count IN the collection of values OF task_counts  \n            APPEND the negative of count TO max_heap  \n        END FOR  \n        CONVERT max_heap INTO a heap structure with smallest element at top  \n        \n        SET time TO zero  \n        SET queue TO an empty list  \n        \n        WHILE max_heap is not empty OR queue is not empty  \n            WHILE queue is not empty AND the first element in queue has a first value EQUALS time  \n                REMOVE the first element of queue AND SET it TO a tuple with first part ignored and second part count_value  \n                IF count_value IS LESS THAN zero  \n                    ADD count_value TO the heap max_heap  \n                END IF  \n            END WHILE  \n            \n            IF max_heap is not empty  \n                REMOVE the smallest element from heap max_heap AND SET it TO count_value  \n                SET count_value TO count_value PLUS one  \n                IF count_value IS LESS THAN zero  \n                    APPEND a tuple consisting of time PLUS cooldown_interval PLUS one AND count_value TO queue  \n                END IF  \n            END IF  \n            \n            INCREMENT time BY one  \n        END WHILE  \n        \n        RETURN time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "add-one-row-to-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS EMPTY  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value as element at position one of values  \n    SET i TO one  \n    SET queue TO new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO remove first element from queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.left TO new TreeNode with value as element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.right TO new TreeNode with value as element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN True  \n    ELSE IF p IS none OR q IS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION addOneRow(self, root, val, depth)  \n        IF depth EQUALS one  \n            RETURN new TreeNode with value val and left subtree root  \n        END IF  \n        SET queue TO new empty double ended queue with element as tuple of root and one  \n        WHILE queue IS NOT EMPTY  \n            SET node and level TO remove first element from queue  \n            IF level EQUALS depth MINUS one  \n                SET node.left TO new TreeNode with value val and left subtree node.left  \n                SET node.right TO new TreeNode with value val and right subtree node.right  \n            ELSE IF level LESS THAN depth MINUS one  \n                IF node.left IS NOT none  \n                    APPEND tuple of node.left and level PLUS one TO queue  \n                END IF  \n                IF node.right IS NOT none  \n                    APPEND tuple of node.right and level PLUS one TO queue  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-derangement-of-an-array", "passing_rate": 0.09090909090909091, "pseudocode": "CLASS Solution  \n    FUNCTION findDerangement WITH PARAMETER n  \n        SET MOD TO one billion PLUS seven  \n        \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        IF n EQUALS two  \n            RETURN one  \n        END IF  \n        \n        SET prev2 TO one  \n        SET prev1 TO zero  \n        \n        FOR i FROM three TO n  \n            SET current TO the product of the quantity of i MINUS one AND the sum of prev1 AND prev2 MODULO MOD  \n            SET prev2 TO prev1  \n            SET prev1 TO current  \n        END FOR  \n        \n        RETURN prev1  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val equals zero, left equals none, right equals none)  \n        SET self dot val TO val  \n        SET self dot left TO left  \n        SET self dot right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the first element removed from the left of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET the left property of node TO a new TreeNode initialized with the element at position i of values  \n            APPEND the left property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET the right property of node TO a new TreeNode initialized with the element at position i of values  \n            APPEND the right property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF the val property of p NOT EQUALS the val property of q  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of the result of calling is_same_tree with the left property of p and the left property of q AND the result of calling is_same_tree with the right property of p and the right property of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION constructMaximumBinaryTree(self, nums)  \n        IF the LENGTH OF nums EQUALS zero  \n            RETURN none  \n        END IF  \n        SET max_val TO the maximum element in nums  \n        SET max_index TO the index of max_val in nums  \n        SET root TO a new TreeNode initialized with max_val  \n        SET the left property of root TO the result of calling constructMaximumBinaryTree on the sublist of nums from the first element up to the element before max_index  \n        SET the right property of root TO the result of calling constructMaximumBinaryTree on the sublist of nums from the element after max_index to the last element  \n        RETURN root  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "print-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with the element at position zero of values  \n    SET i TO one  \n    CREATE an empty queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the first element removed from the queue  \n        IF i LESS THAN the length of values AND the element at position i of values NOT EQUALS none  \n            SET node.left TO a new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND the element at position i of values NOT EQUALS none  \n            SET node.right TO a new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF the value of p NOT EQUALS the value of q  \n        RETURN false  \n    ELSE  \n        RETURN the logical AND of is_same_tree with the left child of p and the left child of q AND is_same_tree with the right child of p and the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION printTree(self, root)  \n        FUNCTION getHeight(node)  \n            IF node EQUALS none  \n                RETURN zero  \n            END IF  \n            RETURN one PLUS the maximum of getHeight with the left child of node AND getHeight with the right child of node  \n        END FUNCTION  \n        SET height TO getHeight of root  \n        SET width TO two RAISED TO THE POWER OF height MINUS one  \n        SET res TO a list containing height elements EACH being a list containing width elements EACH being an empty string  \n        FUNCTION placeNode(node, row, left, right)  \n            IF node EQUALS none  \n                RETURN  \n            END IF  \n            SET mid TO the integer division of the sum of left and right BY two  \n            SET the element at position mid of the list at position row of res TO the string representation of the value of node  \n            CALL placeNode with the left child of node, row PLUS one, left, mid  \n            CALL placeNode with the right child of node, row PLUS one, mid, right  \n        END FUNCTION  \n        CALL placeNode with root, zero, zero, width  \n        RETURN res  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-width-of-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with value element at position one of values  \n    SET i TO one  \n    SET queue TO an empty deque  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the length of values AND element at position i of values is not none  \n            SET node.left TO a new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values is not none  \n            SET node.right TO a new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p is none AND q is none  \n        RETURN true  \n    ELSE IF p is none OR q is none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION widthOfBinaryTree(self, root)  \n        IF root is none  \n            RETURN zero  \n        END IF  \n        SET queue TO a deque containing the tuple of root and zero  \n        SET max_width TO zero  \n        WHILE queue is not empty  \n            SET level_length TO the length of queue  \n            SET first_index TO the second element of the first tuple in queue  \n            FOR counter FROM one TO level_length  \n                SET node, index TO the first tuple removed from queue  \n                IF counter EQUALS level_length  \n                    IF index MINUS first_index PLUS one GREATER THAN max_width  \n                        SET max_width TO index MINUS first_index PLUS one  \n                    END IF  \n                END IF  \n                IF node.left is not none  \n                    APPEND the tuple of node.left and two MULTIPLIED BY index TO queue  \n                END IF  \n                IF node.right is not none  \n                    APPEND the tuple of node.right and two MULTIPLIED BY index PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN max_width  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-tree-partition", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value at position one of values AND left None AND right None  \n    SET i TO one  \n    INITIALIZE queue AS new deque  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        REMOVE first element FROM queue AND ASSIGN TO node  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS None  \n            SET node.left TO new TreeNode with value at position i of values AND left None AND right None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS None  \n            SET node.right TO new TreeNode with value at position i of values AND left None AND right None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(left attribute of p, left attribute of q) AND is_same_tree(right attribute of p, right attribute of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION checkEqualTree(self, root)  \n        FUNCTION subtree_sum(node)  \n            IF node EQUALS None  \n                RETURN zero  \n            END IF  \n            RETURN value at attribute val of node PLUS subtree_sum(left attribute of node) PLUS subtree_sum(right attribute of node)  \n        END FUNCTION  \n        \n        SET total_sum TO subtree_sum(root)  \n        \n        IF total_sum MODULO two NOT EQUALS zero  \n            RETURN False  \n        END IF  \n        \n        SET target TO total_sum DIVIDED BY two  \n        SET found TO list containing a single element False  \n        \n        FUNCTION can_split(node)  \n            IF node EQUALS None  \n                RETURN zero  \n            END IF  \n            SET current_sum TO value at attribute val of node PLUS can_split(left attribute of node) PLUS can_split(right attribute of node)  \n            IF current_sum EQUALS target AND node NOT EQUALS root  \n                SET element at position zero of found TO True  \n            END IF  \n            RETURN current_sum  \n        END FUNCTION  \n        \n        CALL can_split(root)  \n        RETURN element at position zero of found  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "beautiful-arrangement-ii", "passing_rate": 0.2647058823529412, "pseudocode": "CLASS Solution  \n    FUNCTION constructArray(n k)  \n        SET result TO empty list  \n        FOR each number FROM one TO n MINUS k MINUS one  \n            APPEND number TO result  \n        END FOR  \n        SET left TO n MINUS k  \n        SET right TO n  \n        WHILE left LESS THAN OR EQUAL TO right  \n            IF left EQUALS right  \n                APPEND left TO result  \n            ELSE  \n                APPEND left TO result  \n                APPEND right TO result  \n            END IF  \n            INCREMENT left BY one  \n            DECREMENT right BY one  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "trim-a-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO A NEW TreeNode WITH the element at position one of values AS val  \n    SET i TO one  \n    SET queue TO A NEW empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the element REMOVED FROM THE LEFT OF queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None THEN  \n            SET node.left TO A NEW TreeNode WITH the element at position i of values AS val  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None THEN  \n            SET node.right TO A NEW TreeNode WITH the element at position i of values AS val  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None THEN  \n        RETURN True  \n    ELSE IF p IS None OR q IS None THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION trimBST(self, root, low, high)  \n        IF root IS None THEN  \n            RETURN None  \n        END IF  \n        IF root.val IS LESS THAN low THEN  \n            RETURN self.trimBST(root.right, low, high)  \n        END IF  \n        IF root.val IS GREATER THAN high THEN  \n            RETURN self.trimBST(root.left, low, high)  \n        END IF  \n        SET root.left TO self.trimBST(root.left, low, high)  \n        SET root.right TO self.trimBST(root.right, low, high)  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "redundant-connection-ii", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRedundantDirectedConnection(edges)  \n        FUNCTION find(parent, i)  \n            IF element at position i of parent NOT EQUALS i  \n                SET element at position i of parent TO find(parent, element at position i of parent)  \n            END IF  \n            RETURN element at position i of parent  \n        END FUNCTION  \n        \n        FUNCTION union(parent, rank, x, y)  \n            SET rootX TO find(parent, x)  \n            SET rootY TO find(parent, y)  \n            IF rootX NOT EQUALS rootY  \n                IF element at position rootX of rank GREATER THAN element at position rootY of rank  \n                    SET element at position rootY of parent TO rootX  \n                ELSE IF element at position rootX of rank LESS THAN element at position rootY of rank  \n                    SET element at position rootX of parent TO rootY  \n                ELSE  \n                    SET element at position rootY of parent TO rootX  \n                    INCREMENT element at position rootX of rank BY one  \n                END IF  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF edges  \n        SET parent TO a list of integers from zero TO n inclusive  \n        SET rank TO a list of zeros with length n PLUS one  \n        \n        SET candidate1 TO None  \n        SET candidate2 TO None  \n        SET last TO None  \n        \n        FOR each pair of variables u and v IN edges  \n            IF element at position v of parent NOT EQUALS v  \n                SET candidate1 TO a list containing element at position v of parent AND v  \n                SET candidate2 TO a list containing u AND v  \n            ELSE  \n                IF union(parent, rank, u, v) EQUALS False  \n                    SET last TO a list containing u AND v  \n                END IF  \n            END IF  \n        END FOR  \n        \n        IF candidate1 EQUALS None  \n            RETURN last  \n        END IF  \n        \n        IF last NOT EQUALS None  \n            RETURN candidate1  \n        END IF  \n        \n        RETURN candidate2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-univalue-path", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS self val SET TO zero left SET TO none right SET TO none  \n        SET self val TO val  \n        SET self left TO left  \n        SET self right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values  \n    IF the collection values IS EMPTY  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode CREATED WITH the element at position zero of values  \n    SET i TO one  \n    SET queue TO a new double-ended queue  \n    APPEND root TO queue  \n    WHILE the collection queue IS NOT EMPTY  \n        SET node TO the element REMOVED FROM THE LEFT of queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node left TO a new TreeNode CREATED WITH the element at position i of values  \n            APPEND node left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node right TO a new TreeNode CREATED WITH the element at position i of values  \n            APPEND node right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree WITH PARAMETERS p q  \n    IF p IS none AND q IS none  \n        RETURN true  \n    ELSE IF p IS none OR q IS none  \n        RETURN false  \n    ELSE IF the value of p IS NOT EQUALS TO the value of q  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree WITH PARAMETERS the left child of p AND the left child of q  \n        AND the result of is_same_tree WITH PARAMETERS the right child of p AND the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION longestUnivaluePath WITH PARAMETERS self root  \n        FUNCTION dfs WITH PARAMETER node  \n            IF node IS none  \n                RETURN zero AND zero  \n            END IF  \n            SET left_length AND left_value TO the result of dfs WITH THE left child of node  \n            SET right_length AND right_value TO the result of dfs WITH THE right child of node  \n            SET left_arrow TO zero  \n            SET right_arrow TO zero  \n            IF node left EXISTS AND the value of node left EQUALS the value of node  \n                SET left_arrow TO left_length PLUS one  \n            END IF  \n            IF node right EXISTS AND the value of node right EQUALS the value of node  \n                SET right_arrow TO right_length PLUS one  \n            END IF  \n            SET self max_length TO the GREATER OF self max_length AND left_arrow PLUS right_arrow  \n            RETURN the GREATER OF left_arrow AND right_arrow AND the value of node  \n        END FUNCTION  \n        SET self max_length TO zero  \n        CALL dfs WITH PARAMETER root  \n        RETURN self max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "insert-into-a-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with value being the element at position one of values and left and right being None  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None THEN  \n            SET node.left TO a new TreeNode with value being the element at position i of values and left and right being None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None THEN  \n            SET node.right TO a new TreeNode with value being the element at position i of values and left and right being None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None THEN  \n        RETURN True  \n    ELSE IF p IS None OR q IS None THEN  \n        RETURN False  \n    ELSE IF the value of p NOT EQUALS the value of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with parameters being the left child of p and the left child of q  \n        AND the result of is_same_tree with parameters being the right child of p and the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION insertIntoBST(self, root, val)  \n        FUNCTION dfs(root)  \n            IF root IS None THEN  \n                RETURN a new TreeNode with value val and left and right being None  \n            END IF  \n            IF the value of root LESS THAN val THEN  \n                SET root.right TO the result of dfs called with the right child of root  \n            ELSE  \n                SET root.left TO the result of dfs called with the left child of root  \n            END IF  \n            RETURN root  \n        END FUNCTION  \n        RETURN dfs called with root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cherry-pickup", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET n TO the LENGTH OF grid  \n        IF element at position zero of element at position zero of grid EQUALS minus one OR element at position n MINUS one of element at position n MINUS one of grid EQUALS minus one  \n            RETURN zero  \n        END IF  \n\n        INITIALIZE dp AS a three dimensional collection of dimensions n by n by n with all elements SET TO minus one  \n        SET element at position zero of element at position zero of element at position zero of dp TO element at position zero of element at position zero of grid  \n\n        SET directions TO the collection containing the pair of zero and one AND the pair of one and zero  \n\n        FOR t FROM one TO two MULTIPLIED BY n MINUS one  \n            FOR i1 FROM the MAXIMUM of zero AND t MINUS (n MINUS one) TO the MINIMUM of n AND t PLUS one  \n                FOR i2 FROM the MAXIMUM of zero AND t MINUS (n MINUS one) TO the MINIMUM of n AND t PLUS one  \n                    SET j1 TO t MINUS i1  \n                    SET j2 TO t MINUS i2  \n\n                    IF element at position i1 of element at position j1 of grid EQUALS minus one OR element at position i2 of element at position j2 of grid EQUALS minus one  \n                        CONTINUE to the next iteration  \n                    END IF  \n\n                    SET prev_max TO minus one  \n\n                    FOR each pair di1 dj1 IN directions  \n                        FOR each pair di2 dj2 IN directions  \n                            SET pi1 TO i1 MINUS di1  \n                            SET pj1 TO j1 MINUS dj1  \n                            SET pi2 TO i2 MINUS di2  \n                            SET pj2 TO j2 MINUS dj2  \n\n                            IF pi1 GREATER THAN OR EQUAL TO zero AND pi1 LESS THAN n AND pj1 GREATER THAN OR EQUAL TO zero AND pj1 LESS THAN n AND pi2 GREATER THAN OR EQUAL TO zero AND pi2 LESS THAN n AND pj2 GREATER THAN OR EQUAL TO zero AND pj2 LESS THAN n  \n                                SET prev_max TO the MAXIMUM of prev_max AND element at position pi1 of element at position pi2 of element at position pj1 of dp  \n                            END IF  \n                        END FOR  \n                    END FOR  \n\n                    IF prev_max GREATER THAN OR EQUAL TO zero  \n                        IF i1 EQUALS i2  \n                            SET cherries TO element at position i1 of element at position j1 of grid  \n                        ELSE  \n                            SET cherries TO element at position i1 of element at position j1 of grid PLUS element at position i2 of element at position j2 of grid  \n                        END IF  \n\n                        SET element at position i1 of element at position i2 of element at position j1 of dp TO prev_max PLUS cherries  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n\n        SET result TO the MAXIMUM of zero AND element at position n MINUS one of element at position n MINUS one of element at position n MINUS one of dp  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-leaf-in-a-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS empty  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with value as element at position one of values  \n    SET i TO one  \n    CREATE an empty double-ended queue named queue  \n    APPEND root TO queue  \n    WHILE there exists any element in queue  \n        REMOVE and ASSIGN node TO the element from the front of queue  \n        IF i is LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET left child of node TO a new TreeNode with value as element at position i of values  \n            APPEND left child of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET right child of node TO a new TreeNode with value as element at position i of values  \n            APPEND right child of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value  \n        RETURN True  \n    ELSE IF p IS no value OR q IS no value  \n        RETURN False  \n    ELSE IF value of p IS NOT EQUALS value of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with parameters left child of p AND left child of q AND is_same_tree with parameters right child of p AND right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findClosestLeaf(self, root, k)  \n        IF left child of root IS no value AND right child of root IS no value  \n            RETURN value of root  \n        END IF  \n        CREATE an empty default dictionary named graph with lists as default values  \n        FUNCTION dfs(node, parent)  \n            IF parent IS NOT no value  \n                APPEND value of parent TO the list in graph under key of value of node  \n                APPEND value of node TO the list in graph under key of value of parent  \n            END IF  \n            IF left child of node IS NOT no value  \n                CALL dfs with parameters left child of node AND node  \n            END IF  \n            IF right child of node IS NOT no value  \n                CALL dfs with parameters right child of node AND node  \n            END IF  \n        END FUNCTION  \n        CALL dfs with parameters root AND no value  \n        CREATE a double-ended queue named queue containing element k  \n        CREATE an empty set named visited  \n        WHILE there exists any element in queue  \n            REMOVE and ASSIGN current TO the element from the front of queue  \n            ADD current TO visited  \n            IF the LENGTH OF the list in graph under key current IS EQUALS one AND current IS NOT EQUALS value of root  \n                RETURN current  \n            END IF  \n            FOR each neighbor IN the list in graph under key current  \n                IF neighbor IS NOT IN visited  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN minus one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reorganize-string", "passing_rate": 0.2222222222222222, "pseudocode": "CLASS Solution  \n    FUNCTION reorganizeString(s)  \n        SET count TO frequency count of each character in s  \n        SET max_heap TO empty list  \n        FOR each character and frequency IN count  \n            APPEND pair of frequency MINUS frequency and character TO max_heap  \n        END FOR  \n        TRANSFORM max_heap into a heap structure based on the first element of each pair  \n        \n        SET prev_char TO no value  \n        SET prev_freq TO zero  \n        SET result TO empty list  \n        \n        WHILE the max_heap is not empty OR prev_freq LESS THAN zero holds  \n            IF the max_heap is empty AND prev_freq LESS THAN zero holds  \n                RETURN empty string  \n            END IF  \n            \n            SET freq and char TO element extracted from the top of max_heap heap  \n            APPEND char TO result  \n            \n            INCREMENT freq BY one  \n            \n            IF prev_freq LESS THAN zero holds  \n                INSERT pair of prev_freq and prev_char INTO max_heap heap  \n            END IF  \n            \n            SET prev_char TO char  \n            SET prev_freq TO freq  \n        END WHILE  \n        \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swim-in-rising-water", "passing_rate": 0.37037037037037035, "pseudocode": "CLASS Solution  \n    FUNCTION swimInWater(grid)  \n        SET n TO the LENGTH OF grid  \n        SET visited TO a new empty set  \n        SET min_heap TO a list containing a tuple of the element at position zero zero of grid the number zero the number zero  \n        ADD the tuple of the number zero the number zero TO visited  \n        SET directions TO a list containing tuples of the number zero and the number one the number one and the number zero the number zero and the negative number one the negative number one and the number zero  \n        WHILE min_heap is not empty  \n            REMOVE and RETURN the smallest element from min_heap and ASSIGN to variables t i j  \n            IF i EQUALS n MINUS one AND j EQUALS n MINUS one  \n                RETURN t  \n            END IF  \n            FOR each tuple di dj IN directions  \n                SET ni TO i PLUS di  \n                SET nj TO j PLUS dj  \n                IF ni GREATER THAN OR EQUAL TO zero AND ni LESS THAN n AND nj GREATER THAN OR EQUAL TO zero AND nj LESS THAN n AND the tuple ni nj NOT IN visited  \n                    ADD the tuple ni nj TO visited  \n                    ADD to min_heap a tuple of the GREATER OF t AND the element at position ni nj of grid the value ni the value nj  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the negative number one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "letter-case-permutation", "passing_rate": 0.24242424242424243, "pseudocode": "CLASS Solution  \n    FUNCTION letterCasePermutation(s)  \n        FUNCTION dfs(i)  \n            IF i GREATER THAN OR EQUAL TO the LENGTH OF t THEN  \n                APPEND the CONCATENATION OF all elements of t TO ans  \n                RETURN  \n            END IF  \n            CALL dfs WITH i PLUS one  \n            IF element at position i of t IS an alphabetic letter THEN  \n                SET element at position i of t TO the character obtained by toggling the case of element at position i of t  \n                CALL dfs WITH i PLUS one  \n            END IF  \n        END FUNCTION  \n        SET t TO the list of individual characters of s  \n        SET ans TO an empty list  \n        CALL dfs WITH zero  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-pruning", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self val SET TO zero left SET TO none right SET TO none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value of element at position one of values  \n    SET i TO one  \n    SET queue TO new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty DO  \n        SET node TO element removed from the left of queue  \n        IF i LESS THAN LENGTH OF values AND element at position i of values IS NOT none THEN  \n            SET node.left TO new TreeNode with value of element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN LENGTH OF values AND element at position i of values IS NOT none THEN  \n            SET node.right TO new TreeNode with value of element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p q)  \n    IF p EQUALS none AND q EQUALS none THEN  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left q.left) AND is_same_tree(p.right q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION pruneTree(self root)  \n        IF root EQUALS none THEN  \n            RETURN none  \n        END IF  \n        SET root.left TO self.pruneTree(root.left)  \n        SET root.right TO self.pruneTree(root.right)  \n        IF root.val EQUALS zero AND root.left EQUALS none AND root.right EQUALS none THEN  \n            RETURN none  \n        END IF  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-unique-characters-of-all-substrings-of-a-given-string", "passing_rate": 0.6666666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION uniqueLetterString(s)  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        \n        SET last TO a list of negative one REPEATED twenty six TIMES  \n        SET last2 TO a list of negative one REPEATED twenty six TIMES  \n        \n        SET result TO zero  \n        \n        FOR each index i AND character char IN s  \n            SET idx TO the position of char in the uppercase alphabet starting FROM zero  \n            \n            SET contribution TO the difference of i MINUS the element at position idx of last  \n            MULTIPLIED BY the difference of the element at position idx of last MINUS the element at position idx of last2  \n            SET result TO the sum of result PLUS contribution  \n            SET result TO the remainder of result DIVIDED BY MOD  \n            \n            SET the element at position idx of last2 TO the element at position idx of last  \n            SET the element at position idx of last TO i  \n        END FOR  \n        \n        FOR each index i FROM zero TO twenty five  \n            SET contribution TO the difference of n MINUS the element at position i of last  \n            MULTIPLIED BY the difference of the element at position i of last MINUS the element at position i of last2  \n            SET result TO the sum of result PLUS contribution  \n            SET result TO the remainder of result DIVIDED BY MOD  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "similar-string-groups", "passing_rate": 0.6190476190476191, "pseudocode": "CLASS Solution  \n    FUNCTION numSimilarGroups(strs)  \n        FUNCTION are_similar(s1, s2)  \n            SET diff TO empty list  \n            FOR index FROM zero TO LENGTH OF s1 MINUS one  \n                IF element at position index of s1 NOT EQUALS element at position index of s2  \n                    APPEND index TO diff  \n                END IF  \n            END FOR  \n            RETURN LENGTH OF diff EQUALS zero OR (LENGTH OF diff EQUALS two AND element at position element at position zero of diff of s1 EQUALS element at position element at position one of diff of s2 AND element at position element at position one of diff of s1 EQUALS element at position element at position zero of diff of s2)  \n        END FUNCTION  \n\n        FUNCTION dfs(node, visited)  \n            ADD node TO visited  \n            FOR each neighbor IN element at position node of graph  \n                IF neighbor NOT IN visited  \n                    CALL dfs(neighbor, visited)  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET n TO LENGTH OF strs  \n        SET graph TO map from each integer index FROM zero TO n MINUS one TO empty list  \n\n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i PLUS one TO n MINUS one  \n                IF CALL are_similar(element at position i of strs, element at position j of strs)  \n                    APPEND j TO element at position i of graph  \n                    APPEND i TO element at position j of graph  \n                END IF  \n            END FOR  \n        END FOR  \n\n        SET visited TO empty set  \n        SET num_groups TO zero  \n\n        FOR i FROM zero TO n MINUS one  \n            IF i NOT IN visited  \n                CALL dfs(i, visited)  \n                INCREMENT num_groups BY one  \n            END IF  \n        END FOR  \n\n        RETURN num_groups  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-subtree-with-all-the-deepest-nodes", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ WITH parameters self val left right  \n        SET the value property of self TO val  \n        SET the left property of self TO left  \n        SET the right property of self TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH parameter values  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with the first element of values as val  \n    SET i TO one  \n    CREATE an empty double ended queue named queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the length of values AND the element at position i of values is not none  \n            SET the left property of node TO a new TreeNode with the element at position i of values as val  \n            APPEND the left property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND the element at position i of values is not none  \n            SET the right property of node TO a new TreeNode with the element at position i of values as val  \n            APPEND the right property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree WITH parameters p q  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF the value property of p NOT EQUALS the value property of q  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree with the left property of p and the left property of q AND the result of is_same_tree with the right property of p and the right property of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION subtreeWithAllDeepest WITH parameters self root  \n        FUNCTION dfs WITH parameter node  \n            IF node EQUALS none  \n                RETURN node AND zero  \n            END IF  \n            SET left_node AND left_depth TO the result of dfs with the left property of node  \n            SET right_node AND right_depth TO the result of dfs with the right property of node  \n            IF left_depth GREATER THAN right_depth  \n                RETURN left_node AND left_depth PLUS one  \n            ELSE IF right_depth GREATER THAN left_depth  \n                RETURN right_node AND right_depth PLUS one  \n            ELSE  \n                RETURN node AND left_depth PLUS one  \n            END IF  \n        END FUNCTION  \n        RETURN the first element of the result of dfs with root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "prime-palindrome", "passing_rate": 0.5925925925925926, "pseudocode": "CLASS Solution  \n    FUNCTION primePalindrome(n)  \n        FUNCTION is_prime(num)  \n            IF num LESS THAN two  \n                RETURN False  \n            END IF  \n            IF num EQUALS two OR num EQUALS three  \n                RETURN True  \n            END IF  \n            IF num MODULO two EQUALS zero OR num MODULO three EQUALS zero  \n                RETURN False  \n            END IF  \n            SET i TO five  \n            WHILE i MULTIPLIED BY i LESS THAN OR EQUAL TO num  \n                IF num MODULO i EQUALS zero OR num MODULO i PLUS two EQUALS zero  \n                    RETURN False  \n                END IF  \n                INCREMENT i BY six  \n            END WHILE  \n            RETURN True  \n        END FUNCTION  \n  \n        FUNCTION is_palindrome(num)  \n            RETURN the string representation of num EQUALS the reverse of the string representation of num  \n        END FUNCTION  \n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN two  \n        END IF  \n  \n        IF n GREATER THAN OR EQUAL TO ten AND n LESS THAN OR EQUAL TO eleven  \n            RETURN eleven  \n        END IF  \n  \n        WHILE True  \n            IF n MODULO two EQUALS zero  \n                INCREMENT n BY one  \n                CONTINUE  \n            END IF  \n            IF is_palindrome(n) AND is_prime(n)  \n                RETURN n  \n            END IF  \n            IF the length of the string representation of n MODULO two EQUALS zero  \n                SET n TO ten RAISED TO the power of the length of the string representation of n PLUS one  \n            ELSE  \n                INCREMENT n BY two  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-malware-spread-ii", "passing_rate": 0.6, "pseudocode": "CLASS Solution  \n    FUNCTION minMalwareSpread(graph, initial)  \n        SET n TO the LENGTH OF graph  \n        SET adj_list TO a DEFAULT DICTIONARY with default empty list  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i PLUS one TO n MINUS one  \n                IF element at position i of graph AT position j EQUALS one THEN  \n                    APPEND j TO the list at key i in adj_list  \n                    APPEND i TO the list at key j in adj_list  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION dfs(node, visited)  \n            IF node IS IN visited THEN  \n                RETURN zero  \n            END IF  \n            ADD node TO visited  \n            SET size TO one  \n            FOR each neighbor IN the list at key node in adj_list  \n                INCREMENT size BY the RESULT OF dfs(neighbor, visited)  \n            END FOR  \n            RETURN size  \n        END FUNCTION  \n        \n        SET infected TO a SET containing all elements of initial  \n        \n        SET component_sizes TO an empty list  \n        SET visited TO an empty set  \n        SET component_index TO an empty dictionary  \n        \n        FOR node FROM zero TO n MINUS one  \n            IF node IS NOT IN visited AND node IS NOT IN infected THEN  \n                SET size TO the RESULT OF dfs(node, visited)  \n                APPEND size TO component_sizes  \n                \n                FOR i FROM the LENGTH OF component_sizes MINUS one DOWN TO zero STEP minus one  \n                    IF element at position i of component_sizes EQUALS size THEN  \n                        BREAK out of the loop  \n                    END IF  \n                END FOR  \n                \n                FOR each neighbor IN the list at key node in adj_list  \n                    SET the value at key neighbor in component_index TO i  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        SET infected_in_component TO a DEFAULT DICTIONARY with default zero  \n        \n        FOR each node IN infected  \n            IF node IS IN component_index THEN  \n                INCREMENT the value at key component_index[node] in infected_in_component BY one  \n            END IF  \n        END FOR  \n        \n        SET max_size TO zero  \n        SET node_to_remove TO the MINIMUM element in initial  \n        \n        FOR each node IN infected  \n            IF node IS IN component_index THEN  \n                SET comp_idx TO the value at key node in component_index  \n                IF the value at key comp_idx in infected_in_component EQUALS one THEN  \n                    IF element at position comp_idx of component_sizes IS GREATER THAN max_size THEN  \n                        SET max_size TO element at position comp_idx of component_sizes  \n                        SET node_to_remove TO node  \n                    ELSE IF element at position comp_idx of component_sizes EQUALS max_size THEN  \n                        SET node_to_remove TO the MINIMUM of node_to_remove AND node  \n                    END IF  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN node_to_remove  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-cameras", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with value equal to the element at position one of values and left and right equal to no value  \n    SET i TO one  \n    CREATE an empty double ended queue named queue  \n    APPEND root TO queue  \n    WHILE queue is not empty DO  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not no value THEN  \n            SET node.left TO a new TreeNode with value equal to the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not no value THEN  \n            SET node.right TO a new TreeNode with value equal to the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p is no value AND q is no value THEN  \n        RETURN true  \n    ELSE IF p is no value OR q is no value THEN  \n        RETURN false  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q THEN  \n        RETURN false  \n    ELSE  \n        RETURN the logical AND of is_same_tree called with the left attribute of p and the left attribute of q AND is_same_tree called with the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION minCameraCover(self, root)  \n        FUNCTION dfs(node)  \n            IF node is no value THEN  \n                RETURN zero as no camera status, zero as monitored status, and infinite value as camera status  \n            END IF  \n            SET left_no_camera, left_monitored, left_camera TO the three values returned by dfs called with the left attribute of node  \n            SET right_no_camera, right_monitored, right_camera TO the three values returned by dfs called with the right attribute of node  \n            SET no_camera TO the sum of left_monitored PLUS right_monitored  \n            SET monitored TO the minimum among the following three values:  \n                left_camera PLUS the minimum of right_monitored AND right_camera  \n                right_camera PLUS the minimum of left_monitored AND left_camera  \n                left_camera PLUS right_camera  \n            SET camera TO one PLUS the minimum among left_no_camera, left_monitored, left_camera PLUS the minimum among right_no_camera, right_monitored, right_camera  \n            RETURN no_camera, monitored, camera  \n        END FUNCTION  \n        SET root_no_camera, root_monitored, root_camera TO the three values returned by dfs called with root  \n        RETURN the minimum of root_monitored AND root_camera  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "vertical-order-traversal-of-a-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO A TreeNode OBJECT INITIALIZED WITH the element at position one of values  \n    SET i TO one  \n    INITIALIZE queue AS an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue HOLDS elements  \n        SET node TO the element REMOVED FROM the LEFT SIDE of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None  \n            SET node.left TO A TreeNode OBJECT INITIALIZED WITH the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None  \n            SET node.right TO A TreeNode OBJECT INITIALIZED WITH the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION verticalTraversal(self, root)  \n        IF root EQUALS None  \n            RETURN an empty list  \n        END IF  \n        INITIALIZE node_dict AS a dictionary defaulting to empty list  \n        SET min_col TO zero  \n        SET max_col TO zero  \n\n        FUNCTION dfs(node, row, col)  \n            IF node EQUALS None  \n                RETURN  \n            END IF  \n            APPEND the pair consisting of row and node.val TO the list at key col in node_dict  \n            IF col LESS THAN min_col  \n                SET min_col TO col  \n            END IF  \n            IF col GREATER THAN max_col  \n                SET max_col TO col  \n            END IF  \n            CALL dfs ON node.left WITH row PLUS one AND col MINUS one  \n            CALL dfs ON node.right WITH row PLUS one AND col PLUS one  \n        END FUNCTION  \n\n        CALL dfs ON root WITH zero FOR row AND zero FOR col  \n\n        INITIALIZE result AS an empty list  \n        FOR col FROM min_col TO max_col  \n            SORT the list at key col in node_dict BY the first element of each pair THEN BY the second element of each pair IN ascending order  \n            EXTRACT the second elements from each pair in the sorted list  \n            APPEND this extracted list TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-common-supersequence", "passing_rate": 0.2608695652173913, "pseudocode": "CLASS Solution  \n    FUNCTION shortestCommonSupersequence(str1 parameter str2 parameter) RETURNS string  \n        SET m TO the LENGTH OF str1  \n        SET n TO the LENGTH OF str2  \n        \n        SET dp TO a two dimensional list of zeroes with m PLUS one rows and n PLUS one columns  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF the element at position i MINUS one of str1 EQUALS the element at position j MINUS one of str2 THEN  \n                    SET the element at position i and position j of dp TO the element at position i MINUS one and position j MINUS one of dp PLUS one  \n                ELSE  \n                    IF the element at position i MINUS one and position j of dp GREATER THAN the element at position i and position j MINUS one of dp THEN  \n                        SET the element at position i and position j of dp TO the element at position i MINUS one and position j of dp  \n                    ELSE  \n                        SET the element at position i and position j of dp TO the element at position i and position j MINUS one of dp  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET i TO m  \n        SET j TO n  \n        SET scs TO an empty list  \n        \n        WHILE i GREATER THAN zero AND j GREATER THAN zero  \n            IF the element at position i MINUS one of str1 EQUALS the element at position j MINUS one of str2 THEN  \n                APPEND the element at position i MINUS one of str1 TO scs  \n                DECREMENT i BY one  \n                DECREMENT j BY one  \n            ELSE IF the element at position i MINUS one and position j of dp GREATER THAN the element at position i and position j MINUS one of dp THEN  \n                APPEND the element at position i MINUS one of str1 TO scs  \n                DECREMENT i BY one  \n            ELSE  \n                APPEND the element at position j MINUS one of str2 TO scs  \n                DECREMENT j BY one  \n            END IF  \n        END WHILE  \n        \n        WHILE i GREATER THAN zero  \n            APPEND the element at position i MINUS one of str1 TO scs  \n            DECREMENT i BY one  \n        END WHILE  \n        \n        WHILE j GREATER THAN zero  \n            APPEND the element at position j MINUS one of str2 TO scs  \n            DECREMENT j BY one  \n        END WHILE  \n        \n        REVERSE the order of elements in scs  \n        \n        SET result_string TO the concatenation of elements in scs in order  \n        \n        RETURN result_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parsing-a-boolean-expression", "passing_rate": 0.7777777777777778, "pseudocode": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO an empty list  \n        FOR each character c IN expression  \n            IF character c EQUALS one of the characters true OR false OR exclamation mark OR ampersand OR vertical bar  \n                APPEND character c TO stk  \n            ELSE IF character c EQUALS closing parenthesis  \n                SET count_t TO zero  \n                SET count_f TO zero  \n                WHILE element at last position of stk EQUALS true OR element at last position of stk EQUALS false  \n                    INCREMENT count_t BY one IF element at last position of stk EQUALS true  \n                    INCREMENT count_f BY one IF element at last position of stk EQUALS false  \n                    REMOVE element at last position FROM stk  \n                END WHILE  \n                SET operator TO element at last position of stk  \n                REMOVE element at last position FROM stk  \n                IF operator EQUALS exclamation mark  \n                    SET c TO true IF count_f GREATER THAN zero IS false ELSE false  \n                ELSE IF operator EQUALS ampersand  \n                    SET c TO false IF count_f GREATER THAN zero ELSE true  \n                ELSE IF operator EQUALS vertical bar  \n                    SET c TO true IF count_t GREATER THAN zero ELSE false  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN element at position zero of stk EQUALS true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "optimize-water-distribution-in-a-village", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION minCostToSupplyWater(n wells pipes)  \n        FOR index FROM zero TO n MINUS one  \n            APPEND a list containing zero PLUS element at position index of wells PLUS one PLUS element at position index of wells TO pipes  \n        END FOR  \n        \n        SORT pipes BY the value of element at position three of each element in pipes IN ascending order  \n        \n        SET parent TO a list representing the sequence of integers FROM zero TO n  \n        \n        FUNCTION find(x)  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO find(element at position x of parent)  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n        \n        FUNCTION union(x y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootX of parent TO rootY  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n        \n        SET min_cost TO zero  \n        FOR each element IN pipes  \n            SET house1 TO element at position one of element  \n            SET house2 TO element at position two of element  \n            SET cost TO element at position three of element  \n            IF union(house1 house2)  \n                INCREMENT min_cost BY cost  \n            END IF  \n        END FOR  \n        \n        RETURN min_cost  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-valid-words-for-each-puzzle", "passing_rate": 0.4594594594594595, "pseudocode": "CLASS Solution  \n    FUNCTION findNumOfValidWords(words LIST OF strings, puzzles LIST OF strings) RETURNS LIST OF integers  \n        FUNCTION to_mask(s STRING) RETURNS INTEGER  \n            SET mask TO zero  \n            FOR each character IN s  \n                SET character_position TO the Unicode code point of character MINUS the Unicode code point of the lowercase letter a  \n                SET mask TO mask OR one SHIFTED LEFT BY character_position  \n            END FOR  \n            RETURN mask  \n        END FUNCTION  \n        \n        SET word_count TO an empty default dictionary with integer default value  \n        \n        FOR each word IN words  \n            SET mask TO the result of calling to_mask with word  \n            IF the number of set bits in mask IS LESS THAN OR EQUAL TO seven THEN  \n                INCREMENT the count in word_count associated with mask BY one  \n            END IF  \n        END FOR  \n        \n        SET result TO an empty list  \n        \n        FOR each puzzle IN puzzles  \n            SET first_character_position TO the Unicode code point of the element at position zero of puzzle MINUS the Unicode code point of the lowercase letter a  \n            SET first_char_mask TO one SHIFTED LEFT BY first_character_position  \n            SET puzzle_mask TO the result of calling to_mask with the substring from position one TO the end of puzzle  \n            SET count TO the value in word_count associated with first_char_mask  \n            \n            SET subset TO puzzle_mask  \n            WHILE subset IS NOT zero  \n                SET combined_mask TO subset OR first_char_mask  \n                INCREMENT count BY the value in word_count associated with combined_mask  \n                SET subset TO the bitwise AND of subset MINUS one AND puzzle_mask  \n            END WHILE  \n            \n            APPEND count TO result  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-vowels-permutation", "passing_rate": 0.3181818181818182, "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n\n        FOR each number FROM two TO n  \n            SET a_next TO e PLUS i PLUS u  \n            SET e_next TO a PLUS i  \n            SET i_next TO e PLUS o  \n            SET o_next TO i  \n            SET u_next TO i PLUS o  \n\n            SET a TO a_next MODULO MOD  \n            SET e TO e_next MODULO MOD  \n            SET i TO i_next MODULO MOD  \n            SET o TO o_next MODULO MOD  \n            SET u TO u_next MODULO MOD  \n        END FOR  \n\n        SET result TO a PLUS e PLUS i PLUS o PLUS u  \n        SET result TO result MODULO MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-profit-in-job-scheduling", "passing_rate": 0.2222222222222222, "pseudocode": "CLASS Solution  \n    FUNCTION jobScheduling(startTime, endTime, profit)  \n        SET jobs TO the collection of tuples combining each element at the same position of startTime endTime profit sorted by the second element of each tuple in ascending order  \n        SET end_times TO the collection of the second element of each tuple in jobs in order  \n        SET dp TO a list of zeros with the length being the length of jobs PLUS one  \n        FOR i FROM one TO the length of jobs  \n            SET j TO the position returned by the binary search for the position to insert the first element of the tuple at position i MINUS one of jobs into end_times using right insertion method  \n            IF the element at position i MINUS one of dp is GREATER THAN OR EQUAL TO the element at position j of dp PLUS the third element of the tuple at position i MINUS one of jobs THEN  \n                SET the element at position i of dp TO the element at position i MINUS one of dp  \n            ELSE  \n                SET the element at position i of dp TO the element at position j of dp PLUS the third element of the tuple at position i MINUS one of jobs  \n            END IF  \n        END FOR  \n        RETURN the last element of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-paths-with-max-score", "passing_rate": 0.3488372093023256, "pseudocode": "CLASS Solution  \n    FUNCTION pathsWithMaxScore(board)  \n        SET MOD TO ten POWERED BY nine PLUS one  \n        SET n TO the LENGTH OF board  \n        SET dp TO a three dimensional list of size n by n where each element is a list containing negative infinity and zero  \n        SET the element at position n MINUS one and n MINUS one of dp TO a list containing zero and one  \n        FOR i FROM n MINUS one DOWN TO zero INCLUSIVE  \n            FOR j FROM n MINUS one DOWN TO zero INCLUSIVE  \n                IF the element at position i of board at position j of board EQUALS the character representing a barrier OR the element at position i of board at position j of board EQUALS the character representing the start point  \n                    CONTINUE to the next iteration of the inner loop  \n                END IF  \n                IF the element at position i of board at position j of board EQUALS the character representing the end point  \n                    SET value TO zero  \n                ELSE  \n                    SET value TO the integer representation of the element at position i of board at position j of board  \n                END IF  \n                FOR each pair consisting of x and y IN the list containing the pairs one and zero, zero and one, one and one  \n                    SET ni TO i PLUS x  \n                    SET nj TO j PLUS y  \n                    IF ni IS GREATER THAN OR EQUAL TO zero AND ni IS LESS THAN n AND nj IS GREATER THAN OR EQUAL TO zero AND nj IS LESS THAN n  \n                        IF the first element of dp at position ni and nj IS GREATER THAN the first element of dp at position i and j  \n                            SET dp at position i and j TO a list containing the first element of dp at position ni and nj PLUS value AND the second element of dp at position ni and nj  \n                        ELSE IF the first element of dp at position ni and nj EQUALS the first element of dp at position i and j  \n                            SET the second element of dp at position i and j TO the sum of the second element of dp at position i and j AND the second element of dp at position ni and nj MODULO MOD  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        IF the first element of dp at position zero and zero EQUALS negative infinity  \n            RETURN a list containing zero AND zero  \n        END IF  \n        RETURN a list containing the first element of dp at position zero and zero AND the second element of dp at position zero and zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-sum-bst-in-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val SET TO zero, left SET TO none, right SET TO none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the collection values EQUALS empty THEN  \n        RETURN none  \n    END IF  \n    SET root TO a new instance of TreeNode with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty DO  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none THEN  \n            SET node.left TO a new instance of TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none THEN  \n            SET node.right TO a new instance of TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none THEN  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none THEN  \n        RETURN False  \n    ELSE IF the value of p NOT EQUALS the value of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of the result of calling is_same_tree with the left child of p and the left child of q AND the result of calling is_same_tree with the right child of p and the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION maxSumBST(self, root)  \n        SET self.max_sum TO zero  \n        \n        FUNCTION helper(node)  \n            IF node EQUALS none THEN  \n                RETURN True AND zero AND positive infinity AND negative infinity  \n            END IF  \n            SET left_is_bst, left_sum, left_min, left_max TO the result of calling helper with the left child of node  \n            SET right_is_bst, right_sum, right_min, right_max TO the result of calling helper with the right child of node  \n            IF left_is_bst AND right_is_bst AND left_max LESS THAN the value of node AND the value of node LESS THAN right_min THEN  \n                SET current_sum TO left_sum PLUS right_sum PLUS the value of node  \n                SET current_min TO the smaller value BETWEEN the value of node AND left_min  \n                SET current_max TO the larger value BETWEEN the value of node AND right_max  \n                SET self.max_sum TO the larger value BETWEEN self.max_sum AND current_sum  \n                RETURN True AND current_sum AND current_min AND current_max  \n            END IF  \n            RETURN False AND zero AND positive infinity AND negative infinity  \n        END FUNCTION  \n        \n        CALL helper with root  \n        RETURN self.max_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-number-of-darts-inside-of-a-circular-dartboard", "passing_rate": 0.6857142857142857, "pseudocode": "CLASS Solution  \n    FUNCTION numPoints(darts, r)  \n        FUNCTION distance(p1, p2)  \n            SET difference_of_first_coordinates TO element at position zero of p1 MINUS element at position zero of p2  \n            SET difference_of_second_coordinates TO element at position one of p1 MINUS element at position one of p2  \n            SET square_of_difference_first TO difference_of_first_coordinates MULTIPLIED BY difference_of_first_coordinates  \n            SET square_of_difference_second TO difference_of_second_coordinates MULTIPLIED BY difference_of_second_coordinates  \n            SET sum_of_squares TO square_of_difference_first PLUS square_of_difference_second  \n            SET result TO square root of sum_of_squares  \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION circle_center(p1, p2, r)  \n            SET d TO distance of p1 AND p2  \n            IF d GREATER THAN two MULTIPLIED BY r  \n                RETURN None  \n            END IF  \n            SET a TO square root of r MULTIPLIED BY r MINUS d DIVIDED BY two MULTIPLIED BY d DIVIDED BY two  \n            SET midpoint_first_coordinate TO element at position zero of p1 PLUS element at position zero of p2 DIVIDED BY two  \n            SET midpoint_second_coordinate TO element at position one of p1 PLUS element at position one of p2 DIVIDED BY two  \n            SET h TO list of midpoint_first_coordinate AND midpoint_second_coordinate  \n            SET dx TO element at position one of p2 MINUS element at position one of p1 MULTIPLIED BY a DIVIDED BY d  \n            SET dy TO element at position zero of p2 MINUS element at position zero of p1 MULTIPLIED BY a DIVIDED BY d  \n            SET first_center_first_coordinate TO element at position zero of h MINUS dx  \n            SET first_center_second_coordinate TO element at position one of h PLUS dy  \n            SET second_center_first_coordinate TO element at position zero of h PLUS dx  \n            SET second_center_second_coordinate TO element at position one of h MINUS dy  \n            SET centers TO list containing list of first_center_first_coordinate AND first_center_second_coordinate AND list of second_center_first_coordinate AND second_center_second_coordinate  \n            RETURN centers  \n        END FUNCTION  \n        \n        FUNCTION is_inside(circle, point, r)  \n            SET dist TO distance of circle AND point  \n            IF dist LESS THAN OR EQUAL TO r  \n                RETURN True  \n            ELSE  \n                RETURN False  \n            END IF  \n        END FUNCTION  \n        \n        SET n TO length of darts  \n        IF n EQUALS one  \n            RETURN one  \n        END IF  \n        \n        SET max_count TO one  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET centers TO circle_center of element at position i of darts AND element at position j of darts AND r  \n                IF centers IS NOT None  \n                    FOR each center IN centers  \n                        SET count TO zero  \n                        FOR each dart IN darts  \n                            IF is_inside of center AND dart AND r  \n                                INCREMENT count BY one  \n                            END IF  \n                        END FOR  \n                        IF count GREATER THAN max_count  \n                            SET max_count TO count  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "passing_rate": 0.03225806451612903, "pseudocode": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(i j diff)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i of balls INCLUSIVE  \n                IF x EQUALS element at position i of balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO negative one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                INCREMENT ans BY dfs(i PLUS one j MINUS x diff PLUS y) MULTIPLIED BY combination of element at position i of balls CHOOSE x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n\n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO length of balls  \n        RETURN dfs(zero n zero) DIVIDED BY combination of n MULTIPLIED BY two CHOOSE n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tree-of-coprimes", "passing_rate": 0.6052631578947368, "pseudocode": "CLASS Solution  \n    FUNCTION getCoprimes(nums, edges)  \n        SET n TO the LENGTH OF nums  \n        SET tree TO a DEFAULT DICTIONARY mapping to LISTS  \n        FOR each pair u AND v IN edges  \n            APPEND v TO the LIST at key u IN tree  \n            APPEND u TO the LIST at key v IN tree  \n        END FOR  \n  \n        SET coprime TO a two dimensional collection of size fifty BY fifty FILLED with False values  \n        FOR i FROM one TO fifty  \n            FOR j FROM one TO fifty  \n                SET the element at row i AND column j OF coprime TO the RESULT OF the greatest common divisor of i AND j EQUALS one  \n            END FOR  \n        END FOR  \n  \n        SET result TO a LIST of size n FILLED with negative one  \n        SET ancestor_stack TO a LIST of size fifty FILLED with None values  \n  \n        FUNCTION dfs(node, parent, depth)  \n            SET closest_ancestor TO negative one  \n            SET max_depth TO negative one  \n            FOR value FROM one TO fifty  \n                IF the element at row nums at position node AND column value OF coprime EQUALS True AND the element at position value OF ancestor_stack IS NOT None  \n                    SET anc_node AND anc_depth TO the values unpacked FROM the element at position value OF ancestor_stack  \n                    IF anc_depth IS GREATER THAN max_depth  \n                        SET max_depth TO anc_depth  \n                        SET closest_ancestor TO anc_node  \n                    END IF  \n                END IF  \n            END FOR  \n            SET the element at position node OF result TO closest_ancestor  \n  \n            SET original_ancestor TO the element at position nums at position node OF ancestor_stack  \n            SET the element at position nums at position node OF ancestor_stack TO a TUPLE containing node AND depth  \n  \n            FOR each child IN the LIST at key node OF tree  \n                IF child NOT EQUALS parent  \n                    CALL dfs WITH child AND node AND depth PLUS one  \n                END IF  \n            END FOR  \n  \n            SET the element at position nums at position node OF ancestor_stack TO original_ancestor  \n        END FUNCTION  \n  \n        CALL dfs WITH zero AND negative one AND zero  \n  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-interval-to-include-each-query", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION minInterval(intervals AS list of list of integers query_list AS list of integers) RETURNS list of integers  \n        CALL sort THE list intervals IN ascending order BY element at position zero of each element  \n        SET sorted_queries TO an empty list  \n        FOR each element WITH position index IN query_list  \n            APPEND a pair consisting of element AND position index TO sorted_queries  \n        END FOR  \n        CALL sort THE list sorted_queries IN ascending order BY first element of each pair  \n        \n        SET min_heap TO an empty priority collection  \n        SET result TO a list of the same length AS query_list FILLED WITH minus one  \n        \n        SET interval_index TO zero  \n        FOR each pair query AND original_index IN sorted_queries  \n            WHILE interval_index LESS THAN the LENGTH OF intervals AND element at position zero of element at position interval_index of intervals LESS THAN OR EQUAL TO query  \n                SET start TO element at position zero of element at position interval_index of intervals  \n                SET end TO element at position one of element at position interval_index of intervals  \n                SET interval_size TO end MINUS start PLUS one  \n                ADD the pair of interval_size AND end TO min_heap MAINTAINING min_heap property  \n                INCREMENT interval_index BY one  \n            END WHILE  \n            \n            WHILE min_heap IS NOT empty AND the second element of the smallest element in min_heap LESS THAN query  \n                REMOVE the smallest element from min_heap  \n            END WHILE  \n            \n            IF min_heap IS NOT empty  \n                SET element at position original_index of result TO the first element of the smallest element in min_heap  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible", "passing_rate": 0.21212121212121213, "pseudocode": "CLASS Solution  \n    FUNCTION rearrangeSticks(n integer, k integer) RETURNS integer  \n        SET MODULO TO ten raised to the power of nine PLUS one  \n        SET dp TO a two-dimensional list of zeros with dimensions n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                SET element at position i of element at position j of dp TO  \n                    the remainder of the sum of element at position i MINUS one of element at position j MINUS one of dp PLUS the product of i MINUS one and element at position i MINUS one of element at position j of dp DIVIDED BY MODULO  \n            END FOR  \n        END FOR  \n        RETURN element at position n of element at position k of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-number-of-good-subsets", "passing_rate": 0.6304347826086957, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfGoodSubsets(nums)  \n        SET count TO the frequency count of elements in nums  \n        SET dp TO a list of zeroes with length two EXPONENTIATED BY ten  \n        SET element at position zero of dp TO one  \n        \n        FOR each num IN the keys of count  \n            IF num EQUALS one  \n                SET element at position zero of dp TO the element at position zero of dp MULTIPLIED BY two EXPONENTIATED BY the element at position one in count  \n                CONTINUE to the next iteration  \n            END IF  \n            IF num NOT IN prime_factors  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            SET factors TO the value in prime_factors associated with num  \n            SET mask TO zero  \n            FOR each prime IN factors  \n                SET mask TO mask PLUS two EXPONENTIATED BY the quantity of prime MINUS one  \n            END FOR  \n            \n            FOR m FROM two EXPONENTIATED BY ten MINUS one DOWNTO zero  \n                IF the bitwise AND of m AND mask EQUALS zero  \n                    SET element at position bitwise OR of m AND mask of dp TO the element at position bitwise OR of m AND mask of dp PLUS the element at position m of dp MULTIPLIED BY the element in count associated with num  \n                    SET element at position bitwise OR of m AND mask of dp TO element at position bitwise OR of m AND mask of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET result TO the summation of elements of dp from position one to the end  \n        SET result TO result MODULO MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-product-of-two-sorted-arrays", "passing_rate": 0.7692307692307693, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)  \n        FUNCTION count(p PARAMETER)  \n            SET cnt TO zero  \n            SET n TO the LENGTH OF nums2  \n            FOR each element x IN nums1  \n                IF x GREATER THAN zero  \n                    INCREMENT cnt BY the POSITION TO THE RIGHT OF p DIVIDED BY x IN nums2  \n                ELSE IF x LESS THAN zero  \n                    INCREMENT cnt BY n MINUS the POSITION TO THE LEFT OF p DIVIDED BY x IN nums2  \n                ELSE  \n                    INCREMENT cnt BY n MULTIPLIED BY the INDICATOR THAT p GREATER THAN OR EQUAL TO zero  \n                END IF  \n            END FOR  \n            RETURN cnt  \n        END FUNCTION  \n\n        SET mx TO the MAXIMUM OF the ABSOLUTE VALUE OF the FIRST ELEMENT OF nums1 AND the ABSOLUTE VALUE OF the LAST ELEMENT OF nums1 MULTIPLIED BY the MAXIMUM OF the ABSOLUTE VALUE OF the FIRST ELEMENT OF nums2 AND the ABSOLUTE VALUE OF the LAST ELEMENT OF nums2  \n        RETURN the POSITION TO THE LEFT OF k IN the RANGE FROM NEGATIVE mx TO mx PLUS ONE WITH count AS THE KEY MINUS mx  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-employees-to-be-invited-to-a-meeting", "passing_rate": 0.5, "pseudocode": "CLASS Solution\n    FUNCTION maximumInvitations(favorite)\n        SET n TO the LENGTH OF favorite\n        SET graph TO a DEFAULT DICTIONARY of LISTS\n        SET in_degree TO a LIST of zeros OF SIZE n\n\n        FOR i FROM zero TO n MINUS one\n            APPEND i TO the LIST in graph AT element at position i of favorite\n            INCREMENT element at position i of in_degree BY one\n        END FOR\n\n        SET mutual_chains TO zero\n        SET visited TO a LIST of FALSE OF SIZE n\n\n        FOR i FROM zero TO n MINUS one\n            IF element at position element at position i of favorite of favorite EQUALS i AND i LESS THAN element at position i of favorite\n                SET a TO i\n                SET b TO element at position i of favorite\n                SET chain_a TO the RESULT OF the CALL TO self FIND_CHAIN_LENGTH WITH a graph visited\n                SET chain_b TO the RESULT OF the CALL TO self FIND_CHAIN_LENGTH WITH b graph visited\n                INCREMENT mutual_chains BY chain_a PLUS chain_b\n            END IF\n        END FOR\n\n        SET longest_cycle TO zero\n        SET visited TO a LIST of FALSE OF SIZE n\n\n        FOR i FROM zero TO n MINUS one\n            IF NOT element at position i of visited\n                SET cycle_length TO the RESULT OF the CALL TO self FIND_CYCLE_LENGTH WITH i graph visited favorite\n                SET longest_cycle TO the GREATER OF longest_cycle AND cycle_length\n            END IF\n        END FOR\n\n        RETURN the GREATER OF mutual_chains AND longest_cycle\n    END FUNCTION\n\n    FUNCTION find_chain_length(start graph visited)\n        SET length TO zero\n        SET queue TO a double ended queue INITIALIZED WITH start\n        SET element at position start of visited TO TRUE\n\n        WHILE queue IS NOT empty\n            SET current TO the FIRST element REMOVED FROM queue\n            FOR each neighbor IN graph at element current\n                IF NOT element at position neighbor of visited\n                    SET element at position neighbor of visited TO TRUE\n                    ADD neighbor TO the END OF queue\n                    INCREMENT length BY one\n                END IF\n            END FOR\n        END WHILE\n\n        RETURN length\n    END FUNCTION\n\n    FUNCTION find_cycle_length(start graph visited favorite)\n        IF element at position start of visited\n            RETURN zero\n        END IF\n\n        SET stack TO an empty LIST\n        SET current TO start\n\n        WHILE NOT element at position current of visited\n            SET element at position current of visited TO TRUE\n            APPEND current TO stack\n            SET current TO element at position current of favorite\n        END WHILE\n\n        IF current IS NOT IN stack\n            RETURN zero\n        END IF\n\n        SET cycle_start_index TO the POSITION OF current IN stack\n        SET cycle_length TO the LENGTH OF stack MINUS cycle_start_index\n\n        RETURN cycle_length\n    END FUNCTION\nEND CLASS"}
{"task_id": "number-of-ways-to-divide-a-long-corridor", "passing_rate": 0.5657894736842105, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfWays WITH PARAMETER corridor  \n        SET MOD TO ten RAISED TO the power OF nine PLUS one  \n        SET seats TO empty list  \n        FOR each position_and_character IN corridor WITH index position  \n            IF character AT position EQUALS seat character  \n                APPEND position TO seats  \n            END IF  \n        END FOR  \n        IF the LENGTH OF seats MODULO two NOT EQUALS zero OR the LENGTH OF seats LESS THAN two  \n            RETURN zero  \n        END IF  \n        SET ways TO one  \n        FOR index FROM three TO the LENGTH OF seats WITH STEP two  \n            SET difference TO the element AT position index OF seats MINUS the element AT position index MINUS one OF seats  \n            SET ways TO ways MULTIPLIED BY difference MODULO MOD  \n        END FOR  \n        RETURN ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-difference-in-sums-after-removal-of-elements", "passing_rate": 0.7708333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDifference(nums)  \n        SET n TO the LENGTH OF nums DIVIDED BY three  \n        \n        SET min_heap TO empty list  \n        SET min_sums TO a list OF zeros WITH LENGTH equal TO two MULTIPLIED BY n PLUS one  \n        \n        FOR i FROM zero TO two MULTIPLIED BY n MINUS one  \n            PUSH negative of element at position i of nums ONTO min_heap  \n            IF the LENGTH OF min_heap GREATER THAN n THEN  \n                REMOVE the smallest element FROM min_heap  \n            END IF  \n            IF the LENGTH OF min_heap EQUALS n THEN  \n                SET element at position i of min_sums TO negative of the SUM OF elements IN min_heap  \n            END IF  \n        END FOR  \n        \n        SET max_heap TO empty list  \n        SET max_sums TO a list OF zeros WITH LENGTH equal TO two MULTIPLIED BY n PLUS one  \n        \n        FOR i FROM the value of three MULTIPLIED BY n MINUS one DOWN TO n  \n            PUSH element at position i of nums ONTO max_heap  \n            IF the LENGTH OF max_heap GREATER THAN n THEN  \n                REMOVE the smallest element FROM max_heap  \n            END IF  \n            IF the LENGTH OF max_heap EQUALS n THEN  \n                SET element at position i of max_sums TO the SUM OF elements IN max_heap  \n            END IF  \n        END FOR  \n        \n        SET min_diff TO positive infinity  \n        \n        FOR i FROM n MINUS one TO two MULTIPLIED BY n MINUS one  \n            SET min_diff TO the smaller value BETWEEN min_diff AND element at position i of min_sums MINUS element at position i PLUS one of max_sums  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-moves-to-make-palindrome", "passing_rate": 0.6756756756756757, "pseudocode": "CLASS Solution  \n    FUNCTION minMovesToMakePalindrome WITH PARAMETER s AS string  \n        SET s TO list of characters from s  \n        SET n TO the LENGTH OF s  \n        SET moves TO zero  \n        WHILE the LENGTH OF s GREATER THAN one  \n            FOR i FROM the LENGTH OF s MINUS one DOWN TO one DECREMENT BY one  \n                IF the element at position i of s EQUALS the element at position zero of s  \n                    FOR j FROM i TO the LENGTH OF s MINUS two  \n                        SWAP the element at position j of s WITH the element at position j PLUS one of s  \n                        INCREMENT moves BY one  \n                    END FOR  \n                    REMOVE the element at position zero FROM s  \n                    REMOVE the element at the last position FROM s  \n                    BREAK the FOR loop  \n                END IF  \n            END FOR  \n            IF no matching character was found in the FOR loop  \n                REMOVE the element at position zero FROM s  \n            END IF  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
