{"task_id": "add-two-numbers", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values IS EMPTY  \n        RETURN None  \n    END IF  \n    SET head TO ListNode element at position one of values  \n    SET p TO head  \n    FOR each val IN values from position two TO the end  \n        SET node TO ListNode val  \n        SET p.next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 IS None AND p2 IS None  \n        RETURN True  \n    END IF  \n    IF p1 IS None OR p2 IS None  \n        RETURN False  \n    END IF  \n    RETURN self.val EQUALS p2.val AND is_same_list p1.next p2.next  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION addTwoNumbers(l1 l2)  \n        SET dummy_head TO ListNode zero  \n        SET current TO dummy_head  \n        SET carry TO zero  \n        WHILE l1 IS NOT None OR l2 IS NOT None OR carry DOES NOT EQUAL zero  \n            IF l1 IS NOT None  \n                SET val1 TO l1.val  \n            ELSE  \n                SET val1 TO zero  \n            END IF  \n            IF l2 IS NOT None  \n                SET val2 TO l2.val  \n            ELSE  \n                SET val2 TO zero  \n            END IF  \n            SET total TO val1 PLUS val2 PLUS carry  \n            SET carry TO total DIVIDED BY ten  \n            SET current.next TO ListNode total MODULO ten  \n            SET current TO current.next  \n            IF l1 IS NOT None  \n                SET l1 TO l1.next  \n            END IF  \n            IF l2 IS NOT None  \n                SET l2 TO l2.next  \n            END IF  \n        END WHILE  \n        RETURN dummy_head.next  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-nth-node-from-end-of-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ WITH PARAMETERS val AND next  \n        SET the value attribute TO val  \n        SET the next attribute TO next  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION list_node WITH PARAMETER values  \n    IF the values list EQUALS empty list  \n        RETURN None  \n    END IF  \n    SET head TO a new instance of ListNode initialized with the element at position zero of values  \n    SET p TO head  \n    FOR each val IN the elements of values from position one TO the end  \n        SET node TO a new instance of ListNode initialized with val  \n        SET the next attribute of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION\n\nFUNCTION is_same_list WITH PARAMETERS p1 AND p2  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the logical AND of the equality of the value attribute of p1 AND the value attribute of p2 AND the result of calling is_same_list with the next attribute of p1 AND the next attribute of p2  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION removeNthFromEnd WITH PARAMETERS head AND n  \n        SET dummy TO a new instance of ListNode initialized with zero  \n        SET the next attribute of dummy TO head  \n        SET first TO dummy  \n        SET second TO dummy  \n        FOR i FROM zero TO n PLUS one  \n            SET first TO the next attribute of first  \n        END FOR  \n        WHILE first NOT EQUALS None  \n            SET first TO the next attribute of first  \n            SET second TO the next attribute of second  \n        END WHILE  \n        SET the next attribute of second TO the next attribute of the next attribute of second  \n        RETURN the next attribute of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "merge-k-sorted-lists", "passing_rate": 0.3333333333333333, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val SET TO zero next SET TO None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values from position two TO the last position  \n        SET node TO a new ListNode with val  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None THEN  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None THEN  \n        RETURN False  \n    END IF  \n    RETURN the element val of p1 EQUALS the element val of p2 AND is_same_list(the element next of p1 the element next of p2)  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION mergeKLists(self lists)  \n        SET min_heap TO an empty list  \n        SET i TO one  \n        FOR each lst IN lists WITH INDEX i FROM one TO the LENGTH OF lists  \n            IF lst NOT EQUALS None THEN  \n                ADD the triple of the element val of lst AND i AND lst TO min_heap using heap push operation  \n            END IF  \n            INCREMENT i BY one  \n        END FOR  \n        SET dummy TO a new ListNode with default values  \n        SET current TO dummy  \n        WHILE min_heap is NOT empty DO  \n            REMOVE the triple with the smallest first element from min_heap using heap pop operation and SET it TO val i node  \n            SET the next property of current TO node  \n            SET current TO the next property of current  \n            IF the element next of node NOT EQUALS None THEN  \n                ADD the triple of the element val of the element next of node AND i AND the element next of node TO min_heap using heap push operation  \n            END IF  \n        END WHILE  \n        RETURN the next property of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swap-nodes-in-pairs", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val SET TO zero next SET TO None)  \n        SET self dot val TO val  \n        SET self dot next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with value as element at position one of values  \n    SET p TO head  \n    FOR each val IN elements of values starting from position two to the end  \n        SET node TO new ListNode with value as val  \n        SET p dot next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value of element p1 dot val EQUALS the value of element p2 dot val AND the result of is_same_list with arguments p1 dot next AND p2 dot next  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION swapPairs(self head)  \n        SET dummy TO new ListNode with value SET TO zero  \n        SET dummy dot next TO head  \n        SET current TO dummy  \n        \n        WHILE current dot next NOT EQUALS None AND current dot next dot next NOT EQUALS None  \n            SET first TO current dot next  \n            SET second TO current dot next dot next  \n            \n            SET current dot next TO second  \n            SET first dot next TO second dot next  \n            SET second dot next TO first  \n            \n            SET current TO current dot next dot next  \n        END WHILE  \n        \n        RETURN dummy dot next  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-nodes-in-k-group", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val, next)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty list  \n        RETURN none  \n    END IF  \n    SET head TO new ListNode object with value as element at position one of values and next as none  \n    SET p TO head  \n    FOR each val IN elements of values starting from position two to the end  \n        SET node TO new ListNode object with value as val and next as none  \n        SET next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF p1 EQUALS none AND p2 EQUALS none  \n        RETURN true  \n    END IF  \n    IF p1 EQUALS none OR p2 EQUALS none  \n        RETURN false  \n    END IF  \n    RETURN the expression that element val at p1 EQUALS element val at p2 AND function call is_same_list with arguments element next at p1 and element next at p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION reverseKGroup(head, k)  \n        FUNCTION reverseLinkedList(start, end)  \n            SET prev TO none  \n            SET curr TO start  \n            WHILE curr NOT EQUALS end  \n                SET next_node TO element next at curr  \n                SET next of curr TO prev  \n                SET prev TO curr  \n                SET curr TO next_node  \n            END WHILE  \n            SET next of curr TO prev  \n            RETURN end AND start  \n        END FUNCTION  \n\n        SET dummy TO new ListNode object with value zero and next as none  \n        SET next of dummy TO head  \n        SET prev_group_end TO dummy  \n\n        WHILE true holds  \n            SET kth_node TO prev_group_end  \n            FOR index FROM one TO k  \n                SET kth_node TO element next at kth_node  \n                IF kth_node EQUALS none  \n                    RETURN element next at dummy  \n                END IF  \n            END FOR  \n\n            SET next_group_start TO element next at kth_node  \n            SET next of kth_node TO none  \n            CALL reverseLinkedList with arguments element next at prev_group_end and kth_node and ASSIGN results TO new_group_start AND new_group_end  \n\n            SET next of prev_group_end TO new_group_start  \n            SET next of new_group_end TO next_group_start  \n            SET prev_group_end TO new_group_end  \n        END WHILE  \n\n        RETURN element next at dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rotate-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val DEFAULT zero next DEFAULT none)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET head TO A NEW ListNode WITH the element at position zero of values  \n    SET p TO head  \n    FOR each val IN the elements from position one TO the last position of values  \n        SET node TO A NEW ListNode WITH val  \n        SET p.next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS none AND p2 EQUALS none  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS none OR p2 EQUALS none  \n        RETURN False  \n    END IF  \n    RETURN the condition that the val attribute of p1 EQUALS the val attribute of p2 AND is_same_list called with the next attribute of p1 AND the next attribute of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION rotateRight(head k)  \n        IF head EQUALS none OR the next attribute of head EQUALS none OR k EQUALS zero  \n            RETURN head  \n        END IF  \n        SET length TO one  \n        SET tail TO head  \n        WHILE the next attribute of tail IS NOT none  \n            SET tail TO the next attribute of tail  \n            INCREMENT length BY one  \n        END WHILE  \n        SET the next attribute of tail TO head  \n        SET k TO k MODULO length  \n        SET steps_to_new_tail TO length MINUS k MINUS one  \n        SET new_tail TO head  \n        FOR each index FROM zero TO steps_to_new_tail MINUS one  \n            SET new_tail TO the next attribute of new_tail  \n        END FOR  \n        SET new_head TO the next attribute of new_tail  \n        SET the next attribute of new_tail TO none  \n        RETURN new_head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "remove-duplicates-from-sorted-list-ii", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val AND next  \n        SET the value property TO val  \n        SET the next property TO next  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION list_node with parameter values  \n    IF the values collection IS EMPTY  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode with the element at position one of the values collection  \n    SET p TO head  \n    FOR each val IN the values collection from position two TO the last position  \n        SET node TO a new ListNode with val as the value  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION\n\nFUNCTION is_same_list with parameters p1 AND p2  \n    IF p1 IS None AND p2 IS None  \n        RETURN True  \n    END IF  \n    IF p1 IS None OR p2 IS None  \n        RETURN False  \n    END IF  \n    RETURN the logical AND of the condition that the value property of p1 EQUALS the value property of p2 AND the result of is_same_list invoked with the next property of p1 AND the next property of p2  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION deleteDuplicates with parameters self AND head  \n        SET dummy TO a new ListNode with zero as the value AND head as the next property  \n        SET prev TO dummy  \n        WHILE head IS NOT None  \n            IF the next property of head IS NOT None AND the value property of head EQUALS the value property of the next property of head  \n                WHILE the next property of head IS NOT None AND the value property of head EQUALS the value property of the next property of head  \n                    SET head TO the next property of head  \n                END WHILE  \n                SET the next property of prev TO the next property of head  \n            ELSE  \n                SET prev TO the next property of prev  \n            END IF  \n            SET head TO the next property of head  \n        END WHILE  \n        RETURN the next property of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "partition-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self val TO val  \n        SET self next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO NEW ListNode WITH element at position one of values  \n    SET p TO head  \n    FOR each val IN elements from position two TO the end of values  \n        SET node TO NEW ListNode WITH val  \n        SET next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value of p1 EQUALS the value of p2 AND is_same_list(next of p1 next of p2)  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION partition(self head x)  \n        SET less_head TO NEW ListNode WITH zero  \n        SET greater_head TO NEW ListNode WITH zero  \n        SET less TO less_head  \n        SET greater TO greater_head  \n        SET current TO head  \n        WHILE current NOT EQUALS None  \n            IF the value of current LESS THAN x  \n                SET next of less TO current  \n                SET less TO next of less  \n            ELSE  \n                SET next of greater TO current  \n                SET greater TO next of greater  \n            END IF  \n            SET current TO next of current  \n        END WHILE  \n        SET next of less TO next of greater_head  \n        SET next of greater TO None  \n        RETURN next of less_head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-linked-list-ii", "passing_rate": 0.1282051282051282, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self , val , next)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN none  \n    END IF  \n    SET head TO A new ListNode with value as element at position one of values and next as none  \n    SET p TO head  \n    FOR each val IN the elements of values starting from position two to the end  \n        SET node TO A new ListNode with value as val and next as none  \n        SET the next element of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 , p2)  \n    IF p1 EQUALS none AND p2 EQUALS none THEN  \n        RETURN true  \n    END IF  \n    IF p1 EQUALS none OR p2 EQUALS none THEN  \n        RETURN false  \n    END IF  \n    RETURN the value of p1 EQUALS the value of p2 AND the result of is_same_list with the next element of p1 AND the next element of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION reverseBetween(self , head , left , right)  \n        IF head EQUALS none OR left EQUALS right THEN  \n            RETURN head  \n        END IF  \n        SET dummy TO A new ListNode with value as zero and next as none  \n        SET the next element of dummy TO head  \n        SET prev TO dummy  \n        FOR an iteration variable starting from one TO left MINUS one  \n            SET prev TO the next element of prev  \n        END FOR  \n        SET current TO the next element of prev  \n        FOR an iteration variable starting from one TO right MINUS left  \n            SET next_node TO the next element of current  \n            SET the next element of current TO the next element of next_node  \n            SET the next element of next_node TO the next element of prev  \n            SET the next element of prev TO next_node  \n        END FOR  \n        RETURN the next element of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "validate-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val defaulted to zero AND left defaulted to none AND right defaulted to none  \n        SET the val property TO val  \n        SET the left property TO left  \n        SET the right property TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF the values collection is empty THEN  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode object initialized with the element at position one of values  \n    SET i TO one  \n    SET queue TO a new empty double ended queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty DO  \n        SET node TO the element obtained by removing the leftmost element of queue  \n        IF i is less than the length of values AND the element at position i of values is not none THEN  \n            SET the left property of node TO a new TreeNode object initialized with the element at position i of values  \n            APPEND the left property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is less than the length of values AND the element at position i of values is not none THEN  \n            SET the right property of node TO a new TreeNode object initialized with the element at position i of values  \n            APPEND the right property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p AND q  \n    IF p is none AND q is none THEN  \n        RETURN true  \n    ELSE IF p is none OR q is none THEN  \n        RETURN false  \n    ELSE IF the val property of p NOT EQUALS the val property of q THEN  \n        RETURN false  \n    ELSE  \n        RETURN the logical AND of the result of calling is_same_tree with the left property of p AND the left property of q AND the result of calling is_same_tree with the right property of p AND the right property of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION isValidBST with parameter root  \n        FUNCTION validate with parameters node AND low defaulted to negative infinity AND high defaulted to positive infinity  \n            IF node is none THEN  \n                RETURN true  \n            END IF  \n            IF the val property of node is LESS THAN OR EQUAL TO low OR the val property of node is GREATER THAN OR EQUAL TO high THEN  \n                RETURN false  \n            END IF  \n            RETURN the logical AND of the result of calling validate with the left property of node AND low AND the val property of node AND the result of calling validate with the right property of node AND the val property of node AND high  \n        END FUNCTION  \n        RETURN the result of calling validate with root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "recover-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val DEFAULT zero left DEFAULT None right DEFAULT None  \n        SET the value attribute TO val  \n        SET the left attribute TO left  \n        SET the right attribute TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values as list  \n    IF the values collection EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value as element at position one of values  \n    SET i TO one  \n    SET queue TO empty double ended queue  \n    APPEND root TO queue  \n    WHILE the queue collection is not empty  \n        SET node TO element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values is not None  \n            SET the left attribute of node TO new TreeNode with value as element at position i of values  \n            APPEND the left attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values is not None  \n            SET the right attribute of node TO new TreeNode with value as element at position i of values  \n            APPEND the right attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p and q  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with parameters the left attribute of p and the left attribute of q AND the result of is_same_tree with parameters the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION recoverTree with parameter root as optional TreeNode  \n        SET first TO None  \n        SET second TO None  \n        SET prev TO None  \n        SET curr TO root  \n        WHILE curr NOT EQUALS None  \n            IF the left attribute of curr EQUALS None  \n                IF prev NOT EQUALS None AND the value attribute of prev GREATER THAN the value attribute of curr  \n                    IF first EQUALS None  \n                        SET first TO prev  \n                    END IF  \n                    SET second TO curr  \n                END IF  \n                SET prev TO curr  \n                SET curr TO the right attribute of curr  \n            ELSE  \n                SET pred TO the left attribute of curr  \n                WHILE the right attribute of pred NOT EQUALS None AND the right attribute of pred NOT EQUALS curr  \n                    SET pred TO the right attribute of pred  \n                END WHILE  \n                IF the right attribute of pred EQUALS None  \n                    SET the right attribute of pred TO curr  \n                    SET curr TO the left attribute of curr  \n                ELSE  \n                    SET the right attribute of pred TO None  \n                    IF prev NOT EQUALS None AND the value attribute of prev GREATER THAN the value attribute of curr  \n                        IF first EQUALS None  \n                            SET first TO prev  \n                        END IF  \n                        SET second TO curr  \n                    END IF  \n                    SET prev TO curr  \n                    SET curr TO the right attribute of curr  \n                END IF  \n            END IF  \n        END WHILE  \n        IF first NOT EQUALS None AND second NOT EQUALS None  \n            SET temporary variable temp TO the value attribute of first  \n            SET the value attribute of first TO the value attribute of second  \n            SET the value attribute of second TO temp  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-level-order-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with value equal to the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is greater than zero  \n        SET node TO the first element removed from the left side of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value THEN  \n            SET node.left TO a new TreeNode with value equal to the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value THEN  \n            SET node.right TO a new TreeNode with value equal to the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value THEN  \n        RETURN true  \n    ELSE IF p IS no value OR q IS no value THEN  \n        RETURN false  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q THEN  \n        RETURN false  \n    ELSE  \n        RETURN the logical AND of the result of calling is_same_tree with the left attribute of p and the left attribute of q AND the result of calling is_same_tree with the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION levelOrder(self, root)  \n        IF root IS no value THEN  \n            RETURN an empty list  \n        END IF  \n        SET result TO an empty list  \n        SET queue TO a double-ended queue initialized with root as its only element  \n        WHILE the LENGTH OF queue is greater than zero  \n            SET level_size TO the LENGTH OF queue  \n            SET current_level TO an empty list  \n            FOR each index FROM zero TO level_size MINUS one  \n                SET node TO the first element removed from the left side of queue  \n                APPEND the value attribute of node TO current_level  \n                IF the left attribute of node IS NOT no value THEN  \n                    APPEND the left attribute of node TO queue  \n                END IF  \n                IF the right attribute of node IS NOT no value THEN  \n                    APPEND the right attribute of node TO queue  \n                END IF  \n            END FOR  \n            APPEND current_level TO result  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-zigzag-level-order-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS EMPTY  \n        RETURN None  \n    END IF  \n    SET root TO A NEW TreeNode WITH value ELEMENT at position zero OF values AND left None AND right None  \n    SET i TO one  \n    SET queue TO AN EMPTY DOUBLE ENDED QUEUE  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO THE FIRST ELEMENT REMOVED FROM queue  \n        IF i IS LESS THAN THE LENGTH OF values AND ELEMENT at position i OF values IS NOT None  \n            SET node.left TO A NEW TreeNode WITH value ELEMENT at position i OF values AND left None AND right None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN THE LENGTH OF values AND ELEMENT at position i OF values IS NOT None  \n            SET node.right TO A NEW TreeNode WITH value ELEMENT at position i OF values AND left None AND right None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION zigzagLevelOrder(self, root)  \n        IF root IS None  \n            RETURN AN EMPTY LIST  \n        END IF  \n        SET result TO AN EMPTY LIST  \n        SET queue TO A DOUBLE ENDED QUEUE INITIALIZED WITH root  \n        SET left_to_right TO True  \n        WHILE queue IS NOT EMPTY  \n            SET level_size TO THE LENGTH OF queue  \n            SET current_level TO AN EMPTY DOUBLE ENDED QUEUE  \n            FOR iterator FROM zero TO level_size MINUS one  \n                SET node TO THE FIRST ELEMENT REMOVED FROM queue  \n                IF left_to_right IS True  \n                    APPEND node.val TO current_level  \n                ELSE  \n                    INSERT node.val AT THE BEGINNING OF current_level  \n                END IF  \n                IF node.left IS NOT None  \n                    APPEND node.left TO queue  \n                END IF  \n                IF node.right IS NOT None  \n                    APPEND node.right TO queue  \n                END IF  \n            END FOR  \n            APPEND A LIST CONVERTED FROM current_level TO result  \n            SET left_to_right TO NOT left_to_right  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN no value  \n    END IF  \n    SET root TO new TreeNode with value equal to element at position one of values and no left and right  \n    SET i TO one  \n    CREATE empty queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT no value  \n            SET node.left TO new TreeNode with value equal to element at position i of values and no left and right  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT no value  \n            SET node.right TO new TreeNode with value equal to element at position i of values and no left and right  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value  \n        RETURN true  \n    ELSE IF p IS no value OR q IS no value  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree with p.left and q.left AND the result of is_same_tree with p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION buildTree(self, preorder, inorder)  \n        IF the LENGTH OF preorder EQUALS zero OR the LENGTH OF inorder EQUALS zero  \n            RETURN no value  \n        END IF  \n        SET root_val TO element at position one of preorder  \n        SET root TO new TreeNode with value equal to root_val and no left and right  \n        SET root_index_inorder TO the position of root_val in inorder  \n        SET root.left TO the result of calling buildTree of self with the sublist of preorder from position two TO the position root_index_inorder PLUS one and the sublist of inorder from position one TO the position root_index_inorder  \n        SET root.right TO the result of calling buildTree of self with the sublist of preorder from the position root_index_inorder PLUS two TO the end and the sublist of inorder from the position root_index_inorder PLUS two TO the end  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the collection values IS EMPTY  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode CREATED WITH the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty deque  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO the element REMOVED FROM the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET node.left TO a new TreeNode CREATED WITH the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET node.right TO a new TreeNode CREATED WITH the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree WITH the left attribute of p AND the left attribute of q  \n            AND the result of is_same_tree WITH the right attribute of p AND the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION buildTree(self, inorder, postorder)  \n        IF inorder IS EMPTY OR postorder IS EMPTY  \n            RETURN None  \n        END IF  \n        SET root_val TO the element REMOVED FROM the end of postorder  \n        SET root TO a new TreeNode CREATED WITH root_val  \n        SET root_index TO the position of root_val IN inorder  \n        SET root.right TO the result of calling buildTree ON the sublist of inorder FROM position root_index PLUS one TO the end  \n            AND the current postorder  \n        SET root.left TO the result of calling buildTree ON the sublist of inorder FROM the start TO position root_index MINUS one  \n            AND the current postorder  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-level-order-traversal-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ WITH PARAMETERS self val left right  \n        SET self dot val TO val  \n        SET self dot left TO left  \n        SET self dot right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node WITH PARAMETER values  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode CREATED WITH the element at position one of values  \n    SET i TO one  \n    SET queue TO a new double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        SET node TO the FIRST element REMOVED FROM queue  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET the left child of node TO a new TreeNode CREATED WITH the element at position i of values  \n            APPEND the left child of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET the right child of node TO a new TreeNode CREATED WITH the element at position i of values  \n            APPEND the right child of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree WITH PARAMETERS p q  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF the val attribute of p IS NOT EQUALS TO the val attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the AND of the result of is_same_tree CALLED WITH the left child of p AND the left child of q AND the result of is_same_tree CALLED WITH the right child of p AND the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION levelOrderBottom WITH PARAMETERS self root  \n        IF root IS None  \n            RETURN an empty list  \n        END IF  \n        SET result TO an empty list  \n        SET queue TO a new double-ended queue CONTAINING root  \n        WHILE the LENGTH OF queue IS GREATER THAN zero  \n            SET level_size TO the LENGTH OF queue  \n            SET current_level TO an empty list  \n            FOR counter FROM zero TO level_size MINUS one  \n                SET node TO the FIRST element REMOVED FROM queue  \n                APPEND the val attribute of node TO current_level  \n                IF the left child of node IS NOT None  \n                    APPEND the left child of node TO queue  \n                END IF  \n                IF the right child of node IS NOT None  \n                    APPEND the right child of node TO queue  \n                END IF  \n            END FOR  \n            APPEND current_level TO result  \n        END WHILE  \n        RETURN result IN THE ORDER FROM LAST ELEMENT TO FIRST ELEMENT  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "convert-sorted-list-to-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val AND next  \n        SET property val TO parameter val  \n        SET property next TO parameter next  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION list_node with parameter values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with element at position one of values  \n    SET p TO head  \n    FOR each val IN elements of values FROM position two TO the end  \n        SET node TO new ListNode with val  \n        SET the next property of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION\n\nFUNCTION is_same_list with parameters p1 AND p2  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the val property of p1 EQUALS the val property of p2 AND is_same_list with parameters the next property of p1 AND the next property of p2  \nEND FUNCTION\n\nCLASS TreeNode  \n    FUNCTION __init__ with parameters val AND left AND right  \n        SET property val TO parameter val  \n        SET property left TO parameter left  \n        SET property right TO parameter right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node with parameter values  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with element at position one of values  \n    SET i TO one  \n    SET queue TO a new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS None  \n            SET the left property of node TO new TreeNode with element at position i of values  \n            APPEND the left property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS None  \n            SET the right property of node TO new TreeNode with element at position i of values  \n            APPEND the right property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree with parameters p AND q  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF the val property of p NOT EQUALS the val property of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree with parameters the left property of p AND the left property of q AND is_same_tree with parameters the right property of p AND the right property of q  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION sortedListToBST with parameter head  \n        IF head EQUALS None  \n            RETURN None  \n        END IF  \n\n        FUNCTION findMiddle with parameters left AND right  \n            SET slow TO left  \n            SET fast TO left  \n            WHILE fast NOT EQUALS right AND the next property of fast NOT EQUALS right  \n                SET slow TO the next property of slow  \n                SET fast TO the next property of the next property of fast  \n            END WHILE  \n            RETURN slow  \n        END FUNCTION  \n\n        FUNCTION convertListToBST with parameters left AND right  \n            IF left EQUALS right  \n                RETURN None  \n            END IF  \n            SET mid TO findMiddle with parameters left AND right  \n            SET node TO new TreeNode with the val property of mid  \n            SET the left property of node TO convertListToBST with parameters left AND mid  \n            SET the right property of node TO convertListToBST with parameters the next property of mid AND right  \n            RETURN node  \n        END FUNCTION  \n\n        RETURN convertListToBST with parameters head AND None  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "path-sum-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val SET TO zero, left SET TO None, right SET TO None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value as element at position zero of values  \n    SET i TO one  \n    INITIALIZE queue as empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.left TO new TreeNode with value as element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.right TO new TreeNode with value as element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree of p.left and q.left AND is_same_tree of p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION pathSum(self, root, targetSum)  \n        FUNCTION dfs(node, current_sum, path)  \n            IF node IS None  \n                RETURN  \n            END IF  \n            APPEND node.val TO path  \n            SET current_sum TO current_sum PLUS node.val  \n            IF node.left IS None AND node.right IS None AND current_sum EQUALS targetSum  \n                APPEND a copy of path TO result  \n            END IF  \n            CALL dfs with node.left, current_sum, path  \n            CALL dfs with node.right, current_sum, path  \n            REMOVE last element FROM path  \n        END FUNCTION  \n        INITIALIZE result AS empty list  \n        CALL dfs with root, zero, empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flatten-binary-tree-to-linked-list", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS none OR the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.right TO new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree applied to p.left and q.left AND the result of is_same_tree applied to p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION flatten(self, root)  \n        IF root EQUALS none  \n            RETURN  \n        END IF  \n        SET stack TO a list containing root  \n        WHILE the LENGTH OF stack GREATER THAN zero  \n            SET node TO the element removed from the end of stack  \n            IF node.right NOT EQUALS none  \n                APPEND node.right TO stack  \n            END IF  \n            IF node.left NOT EQUALS none  \n                APPEND node.left TO stack  \n            END IF  \n            SET node.left TO none  \n            IF the LENGTH OF stack GREATER THAN zero  \n                SET node.right TO the element at the last position of stack  \n            ELSE  \n                SET node.right TO none  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-maximum-path-sum", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with value equal to the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is greater THAN zero  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None  \n            SET node.left TO a new TreeNode with value equal to the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None  \n            SET node.right TO a new TreeNode with value equal to the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF the value of p NOT EQUALS the value of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(the left child of p, the left child of q) AND is_same_tree(the right child of p, the right child of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION maxPathSum(self, root)  \n        FUNCTION helper(node)  \n            IF node EQUALS None  \n                RETURN negative infinity, negative infinity  \n            END IF  \n            SET left_max, left_gain TO helper(the left child of node)  \n            SET right_max, right_gain TO helper(the right child of node)  \n            SET current_max TO the value of node PLUS the maximum of left_gain AND zero PLUS the maximum of right_gain AND zero  \n            SET current_gain TO the value of node PLUS the maximum of left_gain, right_gain, AND zero  \n            SET global_max TO the maximum of left_max, right_max, AND current_max  \n            RETURN global_max, current_gain  \n        END FUNCTION  \n        RETURN the first element of helper(root)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-root-to-leaf-numbers", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val left right  \n        SET the value attribute TO val  \n        SET the left attribute TO left  \n        SET the right attribute TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF the values collection is empty  \n        RETURN nothing  \n    END IF  \n    SET root TO a new TreeNode initialized with element at position one of values  \n    SET i TO one  \n    CREATE an empty double ended queue called queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the element removed from the front of queue  \n        IF i is less than the length of values AND element at position i of values is not nothing  \n            SET the left attribute of node TO a new TreeNode initialized with element at position i of values  \n            APPEND the left attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is less than the length of values AND element at position i of values is not nothing  \n            SET the right attribute of node TO a new TreeNode initialized with element at position i of values  \n            APPEND the right attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p q  \n    IF p is nothing AND q is nothing  \n        RETURN True  \n    ELSE IF p is nothing OR q is nothing  \n        RETURN False  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of is_same_tree with the left attribute of p and the left attribute of q AND is_same_tree with the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION sumNumbers with parameters root  \n        FUNCTION dfs with parameters node current_number  \n            IF node is nothing  \n                RETURN zero  \n            END IF  \n            SET current_number TO current_number MULTIPLIED BY ten PLUS the value attribute of node  \n            IF the left attribute of node is nothing AND the right attribute of node is nothing  \n                RETURN current_number  \n            END IF  \n            SET left_sum TO dfs with the left attribute of node and current_number  \n            SET right_sum TO dfs with the right attribute of node and current_number  \n            RETURN left_sum PLUS right_sum  \n        END FUNCTION  \n        RETURN dfs with root and zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gas-station", "passing_rate": 0.6530612244897959, "pseudocode": "CLASS Solution  \n    FUNCTION canCompleteCircuit(gas, cost)  \n        IF the SUM of gas LESS THAN the SUM of cost  \n            RETURN negative one  \n        END IF  \n        SET start TO zero  \n        SET total_tank TO zero  \n        FOR i FROM zero TO the LENGTH OF gas MINUS one  \n            INCREMENT total_tank BY the element at position i of gas MINUS the element at position i of cost  \n            IF total_tank LESS THAN zero  \n                SET start TO i PLUS one  \n                SET total_tank TO zero  \n            END IF  \n        END FOR  \n        RETURN start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reorder-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self dot val TO val  \n        SET self dot next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty list  \n        RETURN None  \n    END IF  \n    SET head TO A new ListNode WITH element at position one of values  \n    SET p TO head  \n    FOR each val IN elements from position two TO the end of values  \n        SET node TO A new ListNode WITH val  \n        SET p dot next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN element val of p1 EQUALS element val of p2 AND is_same_list(element next of p1 element next of p2)  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION reorderList(head)  \n        IF head EQUALS None OR element next of head EQUALS None  \n            RETURN  \n        END IF  \n        SET slow TO head  \n        SET fast TO head  \n        WHILE fast IS NOT None AND element next of fast IS NOT None  \n            SET slow TO element next of slow  \n            SET fast TO element next of element next of fast  \n        END WHILE  \n        SET prev TO None  \n        SET curr TO slow  \n        WHILE curr IS NOT None  \n            SET next_temp TO element next of curr  \n            SET element next of curr TO prev  \n            SET prev TO curr  \n            SET curr TO next_temp  \n        END WHILE  \n        SET first TO head  \n        SET second TO prev  \n        WHILE element next of second IS NOT None  \n            SET temp1 TO element next of first  \n            SET temp2 TO element next of second  \n            SET element next of first TO second  \n            SET element next of second TO temp1  \n            SET first TO temp1  \n            SET second TO temp2  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "insertion-sort-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values IS EMPTY THEN  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode constructed with element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements of values from position two TO the last position  \n        SET node TO a new ListNode constructed with val  \n        SET the next element of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 IS None AND p2 IS None THEN  \n        RETURN True  \n    END IF  \n    IF p1 IS None OR p2 IS None THEN  \n        RETURN False  \n    END IF  \n    RETURN the value of p1 EQUALS the value of p2 AND is_same_list(the next element of p1 the next element of p2)  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION insertionSortList(self head)  \n        IF head IS None OR the next element of head IS None THEN  \n            RETURN head  \n        END IF  \n        SET dummy TO a new ListNode constructed with the value negative five thousand and one  \n        SET the next element of dummy TO head  \n        SET current TO the next element of head  \n        SET the next element of head TO None  \n        WHILE current IS NOT None  \n            SET next_node TO the next element of current  \n            SET prev TO dummy  \n            WHILE the next element of prev IS NOT None AND the value of the next element of prev IS LESS THAN the value of current  \n                SET prev TO the next element of prev  \n            END WHILE  \n            SET the next element of current TO the next element of prev  \n            SET the next element of prev TO current  \n            SET current TO next_node  \n        END WHILE  \n        RETURN the next element of dummy  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val, next)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with val equal to element at position one of values and next equal to None  \n    SET p TO head  \n    FOR each val IN elements of values starting from position two TO the last position  \n        SET node TO new ListNode with val equal to val and next equal to None  \n        SET the element next of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF p1 EQUALS None AND p2 EQUALS None THEN  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None THEN  \n        RETURN False  \n    END IF  \n    RETURN the element val of p1 EQUALS the element val of p2 AND is_same_list(the element next of p1, the element next of p2)  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION sortList(self, head)  \n        IF head EQUALS None OR the element next of head EQUALS None THEN  \n            RETURN head  \n        END IF  \n        \n        FUNCTION split(head)  \n            SET slow TO head  \n            SET fast TO the element next of head  \n            WHILE fast NOT EQUALS None AND the element next of fast NOT EQUALS None  \n                SET slow TO the element next of slow  \n                SET fast TO the element next of the element next of fast  \n            END WHILE  \n            SET mid TO the element next of slow  \n            SET the element next of slow TO None  \n            RETURN head, mid  \n        END FUNCTION  \n        \n        FUNCTION merge(l1, l2)  \n            SET dummy TO new ListNode with val equal to zero and next equal to None  \n            SET current TO dummy  \n            WHILE l1 NOT EQUALS None AND l2 NOT EQUALS None  \n                IF the element val of l1 LESS THAN the element val of l2 THEN  \n                    SET the element next of current TO l1  \n                    SET l1 TO the element next of l1  \n                ELSE  \n                    SET the element next of current TO l2  \n                    SET l2 TO the element next of l2  \n                END IF  \n                SET current TO the element next of current  \n            END WHILE  \n            IF l1 NOT EQUALS None THEN  \n                SET the element next of current TO l1  \n            ELSE  \n                SET the element next of current TO l2  \n            END IF  \n            RETURN the element next of dummy  \n        END FUNCTION  \n        \n        SET left, right TO split(head)  \n        SET left TO self.sortList(left)  \n        SET right TO self.sortList(right)  \n        \n        RETURN merge(left, right)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-upside-down", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode constructed with element at position one of values  \n    SET i TO one  \n    CREATE an empty deque named queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS None  \n            SET node.left TO a new TreeNode constructed with element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS None  \n            SET node.right TO a new TreeNode constructed with element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the AND of the result of is_same_tree with parameters p.left and q.left and the result of is_same_tree with parameters p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION upsideDownBinaryTree(self, root)  \n        IF root EQUALS None OR root.left EQUALS None  \n            RETURN root  \n        END IF  \n        SET new_root TO the result of self.upsideDownBinaryTree with parameter root.left  \n        SET the left child of the left child of root TO the right child of root  \n        SET the right child of the left child of root TO root  \n        SET the left child of root TO None  \n        SET the right child of root TO None  \n        RETURN new_root  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "binary-tree-right-side-view", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN nothing  \n    END IF  \n    SET root TO a new TreeNode with the element at position zero of values as value and nothing as left and right  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS nothing  \n            SET node.left TO a new TreeNode with the element at position i of values as value and nothing as left and right  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS nothing  \n            SET node.right TO a new TreeNode with the element at position i of values as value and nothing as left and right  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS nothing AND q EQUALS nothing  \n        RETURN true  \n    ELSE IF p EQUALS nothing OR q EQUALS nothing  \n        RETURN false  \n    ELSE IF the value property of p NOT EQUALS the value property of q  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree called with the left property of p and the left property of q AND the result of is_same_tree called with the right property of p and the right property of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION rightSideView(self, root)  \n        IF root EQUALS nothing  \n            RETURN an empty list  \n        END IF  \n        SET right_side_view TO an empty list  \n        SET queue TO a double ended queue initialized with root as the single element  \n        WHILE the LENGTH OF queue GREATER THAN zero  \n            SET level_length TO the LENGTH OF queue  \n            FOR i FROM zero TO level_length MINUS one  \n                SET node TO the element removed from the front of queue  \n                IF i EQUALS level_length MINUS one  \n                    APPEND the value property of node TO right_side_view  \n                END IF  \n                IF the left property of node NOT EQUALS nothing  \n                    APPEND the left property of node TO queue  \n                END IF  \n                IF the right property of node NOT EQUALS nothing  \n                    APPEND the right property of node TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN right_side_view  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "basic-calculator", "passing_rate": 0.16981132075471697, "pseudocode": "CLASS Solution  \n    FUNCTION calculate(s)  \n        FUNCTION helper(s)  \n            SET stack TO empty list  \n            SET sign TO plus symbol  \n            SET num TO zero  \n            WHILE the LENGTH OF s IS GREATER THAN zero  \n                SET char TO element at position zero of s  \n                REMOVE element at position zero FROM s  \n                IF char IS a digit character  \n                    SET num TO num MULTIPLIED BY ten PLUS the integer value of char  \n                END IF  \n                IF char EQUALS opening parenthesis symbol  \n                    SET num TO the result of calling helper with s  \n                END IF  \n                IF the character char IS NOT a digit character AND the character char IS NOT a whitespace character OR the LENGTH OF s EQUALS zero  \n                    IF sign EQUALS plus symbol  \n                        APPEND num TO stack  \n                    ELSE IF sign EQUALS minus symbol  \n                        APPEND the negative value of num TO stack  \n                    ELSE IF sign EQUALS multiplication symbol  \n                        SET the element at the last position of stack TO the element at the last position of stack MULTIPLIED BY num  \n                    ELSE IF sign EQUALS division symbol  \n                        SET the element at the last position of stack TO the integer part of the element at the last position of stack DIVIDED BY num  \n                    END IF  \n                    SET sign TO char  \n                    SET num TO zero  \n                END IF  \n                IF char EQUALS closing parenthesis symbol  \n                    BREAK the WHILE loop  \n                END IF  \n            END WHILE  \n            RETURN the sum of all elements in stack  \n        END FUNCTION  \n        RETURN the result of calling helper with the list of characters of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-element-in-a-bst", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        ASSIGN reference TO self.left AS left  \n        ASSIGN reference TO self.right AS right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values as val and no left or right  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is greater than zero  \n        REMOVE the element at the front of queue AND ASSIGN TO node  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none THEN  \n            ASSIGN reference TO node.left AS a new TreeNode with the element at position i of values as val and no left or right  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none THEN  \n            ASSIGN reference TO node.right AS a new TreeNode with the element at position i of values as val and no left or right  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none THEN  \n        RETURN true  \n    ELSE IF p IS none OR q IS none THEN  \n        RETURN false  \n    ELSE IF the value stored in p.val NOT EQUALS the value stored in q.val THEN  \n        RETURN false  \n    ELSE  \n        RETURN the result of calling is_same_tree with p.left and q.left AND the result of calling is_same_tree with p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION kthSmallest(self, root, k)  \n        SET stack TO an empty list  \n        ASSIGN reference TO current AS root  \n        SET count TO zero  \n        WHILE the LENGTH OF stack GREATER THAN zero OR current IS NOT none  \n            WHILE current IS NOT none  \n                APPEND current TO stack  \n                ASSIGN reference TO current AS the left child of current  \n            END WHILE  \n            REMOVE the last element FROM stack AND ASSIGN TO current  \n            INCREMENT count BY one  \n            IF count EQUALS k THEN  \n                RETURN the value stored in current.val  \n            END IF  \n            ASSIGN reference TO current AS the right child of current  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "lowest-common-ancestor-of-a-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self val SET TO zero left SET TO none right SET TO none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with value element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the first element REMOVED FROM queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS none  \n            SET node.left TO a new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS none  \n            SET node.right TO a new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with arguments p.left and q.left AND the result of is_same_tree with arguments p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION lowestCommonAncestor(self root p q)  \n        IF root EQUALS none OR root EQUALS p OR root EQUALS q  \n            RETURN root  \n        END IF  \n        SET left TO the result of self.lowestCommonAncestor called with root.left and p and q  \n        SET right TO the result of self.lowestCommonAncestor called with root.right and p and q  \n        IF left NOT EQUALS none AND right NOT EQUALS none  \n            RETURN root  \n        END IF  \n        IF left NOT EQUALS none  \n            RETURN left  \n        ELSE  \n            RETURN right  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-univalue-subtrees", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values IS EMPTY  \n        RETURN None  \n    END IF  \n    SET root TO A NEW TreeNode WITH value EQUALS element at position one of values AND left EQUALS None AND right EQUALS None  \n    SET i TO one  \n    SET queue TO AN EMPTY double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO FIRST ELEMENT OF queue REMOVED  \n        IF i IS LESS THAN THE LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.left TO A NEW TreeNode WITH value EQUALS element at position i of values AND left EQUALS None AND right EQUALS None  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN THE LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.right TO A NEW TreeNode WITH value EQUALS element at position i of values AND left EQUALS None AND right EQUALS None  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION countUnivalSubtrees(self, root)  \n        FUNCTION helper(node)  \n            IF node IS None  \n                RETURN True AND zero  \n            END IF  \n            SET is_left_unival AND left_count TO helper(node.left)  \n            SET is_right_unival AND right_count TO helper(node.right)  \n            IF is_left_unival IS True AND is_right_unival IS True  \n                IF (node.left IS None OR element at position val of node.left EQUALS element at position val of node) AND (node.right IS None OR element at position val of node.right EQUALS element at position val of node)  \n                    RETURN True AND left_count PLUS right_count PLUS one  \n                END IF  \n            END IF  \n            RETURN False AND left_count PLUS right_count  \n        END FUNCTION  \n        SET dummy TO helper(root) AND SET count TO the second RETURNED value OF dummy  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-binary-search-tree-value-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value element at position one of values AND left none AND right none  \n    SET i TO one  \n    SET queue TO empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO remove element from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.left TO new TreeNode with value element at position i of values AND left none AND right none  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.right TO new TreeNode with value element at position i of values AND left none AND right none  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree with arguments p.left AND q.left AND is_same_tree with arguments p.right AND q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION closestKValues(self, root, target, k)  \n        FUNCTION inorder_traversal(node)  \n            IF node EQUALS none  \n                RETURN  \n            END IF  \n            CALL inorder_traversal with argument node.left  \n            IF LENGTH OF result LESS THAN k  \n                APPEND node.val TO result  \n            ELSE  \n                IF absolute value of node.val MINUS target LESS THAN absolute value of element at position one of result MINUS target  \n                    REMOVE element from the front of result  \n                    APPEND node.val TO result  \n                ELSE  \n                    RETURN  \n                END IF  \n            END IF  \n            CALL inorder_traversal with argument node.right  \n        END FUNCTION  \n        SET result TO empty double ended queue  \n        CALL inorder_traversal with argument root  \n        RETURN list constructed from elements of result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-longest-consecutive-sequence", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position zero of values  \n    SET i TO one  \n    INITIALIZE queue as an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node.left TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT none  \n            SET node.right TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN true  \n    ELSE IF p IS none OR q IS none  \n        RETURN false  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree with the left attribute of p AND the left attribute of q  \n        AND the result of is_same_tree with the right attribute of p AND the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION longestConsecutive(self, root)  \n        IF root IS none  \n            RETURN zero  \n        END IF  \n        FUNCTION dfs(node, parent, current_length)  \n            IF node IS none  \n                RETURN current_length  \n            END IF  \n            IF parent IS NOT none AND the val attribute of node EQUALS parent PLUS one  \n                INCREMENT current_length BY one  \n            ELSE  \n                SET current_length TO one  \n            END IF  \n            SET left_length TO the result of dfs with the left attribute of node, the val attribute of node, and current_length  \n            SET right_length TO the result of dfs with the right attribute of node, the val attribute of node, and current_length  \n            RETURN the maximum value among current_length, left_length, and right_length  \n        END FUNCTION  \n        RETURN dfs with root, none, and zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-vertical-order-traversal", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode created with the element at position zero of values  \n    SET i TO one  \n    CREATE an empty deque named queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue IS GREATER THAN zero  \n        REMOVE and ASSIGN the element from the left end of queue TO node  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET node.left TO a new TreeNode created with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND the element at position i of values IS NOT None  \n            SET node.right TO a new TreeNode created with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree called with p.left and q.left AND the result of is_same_tree called with p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION verticalOrder(self, root)  \n        IF root EQUALS None  \n            RETURN an empty list  \n        END IF  \n        CREATE a default dictionary named column_table which maps keys to empty lists  \n        CREATE a deque named queue containing the tuple of root and zero  \n        SET min_column TO zero  \n        SET max_column TO zero  \n        WHILE the LENGTH OF queue IS GREATER THAN zero  \n            REMOVE and ASSIGN the element from the left end of queue TO the tuple of node and column_index  \n            IF node IS NOT None  \n                APPEND node.val TO the list associated with column_index in column_table  \n                IF column_index IS LESS THAN min_column  \n                    SET min_column TO column_index  \n                END IF  \n                IF column_index IS GREATER THAN max_column  \n                    SET max_column TO column_index  \n                END IF  \n                APPEND the tuple of node.left and column_index MINUS one TO queue  \n                APPEND the tuple of node.right and column_index PLUS one TO queue  \n            END IF  \n        END WHILE  \n        CREATE an empty list named results  \n        FOR each integer x FROM min_column TO max_column  \n            APPEND the list associated with x in column_table TO results  \n        END FOR  \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "odd-even-linked-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val EQUALS zero next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode with value equal to element at position zero of values  \n    SET p TO head  \n    FOR each val IN elements of values from position one TO the last position  \n        SET node TO new ListNode with value equal to val  \n        SET the next element of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None THEN  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None THEN  \n        RETURN False  \n    END IF  \n    RETURN the value element of p1 EQUALS the value element of p2 AND is_same_list(the next element of p1 the next element of p2)  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION oddEvenList(self head)  \n        IF head EQUALS None OR the next element of head EQUALS None OR the next element of the next element of head EQUALS None THEN  \n            RETURN head  \n        END IF  \n        SET odd TO head  \n        SET even TO the next element of head  \n        SET even_head TO even  \n        WHILE even IS NOT None AND the next element of even IS NOT None  \n            SET the next element of odd TO the next element of even  \n            SET odd TO the next element of odd  \n            SET the next element of even TO the next element of odd  \n            SET even TO the next element of even  \n        END WHILE  \n        SET the next element of odd TO even_head  \n        RETURN head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-bst-subtree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode with value element at position one of values, left no value, right no value  \n    SET i TO one  \n    SET queue TO a new empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the left end of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT no value THEN  \n            SET node.left TO a new TreeNode with value element at position i of values, left no value, right no value  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT no value THEN  \n            SET node.right TO a new TreeNode with value element at position i of values, left no value, right no value  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value THEN  \n        RETURN true  \n    ELSE IF p IS no value OR q IS no value THEN  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree with arguments p.left and q.left AND the result of is_same_tree with arguments p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION largestBSTSubtree(self, root)  \n        FUNCTION dfs(node)  \n            IF node IS no value THEN  \n                RETURN positive infinity, negative infinity, zero  \n            END IF  \n            SET left_min, left_max, left_size TO the result of dfs with argument node.left  \n            SET right_min, right_max, right_size TO the result of dfs with argument node.right  \n            IF left_max LESS THAN node.val AND node.val LESS THAN right_min THEN  \n                RETURN the minimum of node.val and left_min, the maximum of node.val and right_max, left_size PLUS right_size PLUS one  \n            END IF  \n            RETURN negative infinity, positive infinity, the maximum of left_size and right_size  \n        END FUNCTION  \n        RETURN the third element of the result of dfs with argument root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-pairs", "passing_rate": 0.6346153846153846, "pseudocode": "CLASS Solution  \n    FUNCTION palindromePairs(words)  \n        FUNCTION is_palindrome(s)  \n            RETURN s EQUALS the REVERSED sequence of characters in s  \n        END FUNCTION  \n        \n        SET word_dict TO an empty dictionary mapping each word in words TO its position index  \n        SET result TO an empty list  \n        \n        FOR each position i AND corresponding word IN words  \n            IF word EQUALS an empty string THEN  \n                CONTINUE to next iteration of the loop  \n            END IF  \n            \n            IF word_dict CONTAINS an empty string AND is_palindrome(word) holds THEN  \n                APPEND a list containing i AND the position index of the empty string TO result  \n                APPEND a list containing the position index of the empty string AND i TO result  \n            END IF  \n            \n            SET reversed_word TO the sequence of characters in word in reverse order  \n            IF word_dict CONTAINS reversed_word AND the position index of reversed_word IS NOT EQUAL TO i THEN  \n                APPEND a list containing i AND the position index of reversed_word TO result  \n            END IF  \n            \n            FOR variable j FROM one TO the LENGTH OF word MINUS one  \n                SET prefix TO the substring from the first character up to position j of word  \n                SET suffix TO the substring from position j TO the end of word  \n                SET reversed_prefix TO the sequence of characters in prefix in reverse order  \n                SET reversed_suffix TO the sequence of characters in suffix in reverse order  \n                \n                IF is_palindrome(suffix) holds AND word_dict CONTAINS reversed_prefix THEN  \n                    APPEND a list containing i AND the position index of reversed_prefix TO result  \n                END IF  \n                \n                IF is_palindrome(prefix) holds AND word_dict CONTAINS reversed_suffix THEN  \n                    APPEND a list containing the position index of reversed_suffix AND i TO result  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "house-robber-iii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty list THEN  \n        RETURN nothing  \n    END IF  \n    SET root TO a new TreeNode with value element at position one of values WITH left set to nothing AND right set to nothing  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty DO  \n        SET node TO the element removed from the left side of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS nothing THEN  \n            SET node.left TO a new TreeNode with value element at position i of values WITH left set to nothing AND right set to nothing  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS nothing THEN  \n            SET node.right TO a new TreeNode with value element at position i of values WITH left set to nothing AND right set to nothing  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS nothing AND q EQUALS nothing THEN  \n        RETURN True  \n    ELSE IF p EQUALS nothing OR q EQUALS nothing THEN  \n        RETURN False  \n    ELSE IF the value of p NOT EQUALS the value of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(the left child of p, the left child of q) AND is_same_tree(the right child of p, the right child of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION rob(self, root)  \n        FUNCTION rob_from_node(node)  \n            IF node EQUALS nothing THEN  \n                RETURN zero, zero  \n            END IF  \n            SET left_robbed, left_not_robbed TO rob_from_node(the left child of node)  \n            SET right_robbed, right_not_robbed TO rob_from_node(the right child of node)  \n            SET rob_this_node TO the value of node PLUS left_not_robbed PLUS right_not_robbed  \n            SET not_rob_this_node TO the maximum of left_robbed AND left_not_robbed PLUS the maximum of right_robbed AND right_not_robbed  \n            RETURN rob_this_node, not_rob_this_node  \n        END FUNCTION  \n        RETURN the maximum of rob_from_node(root)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-leaves-of-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self dot val TO val  \n        SET self dot left TO left  \n        SET self dot right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS none OR the LENGTH OF values EQUALS zero THEN  \n        RETURN none  \n    END IF  \n    SET root TO new instance of TreeNode initialized with the element at position one of values  \n    SET i TO one  \n    INITIALIZE queue as an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the queue is not empty DO  \n        SET node TO the element removed from the left of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none THEN  \n            SET node dot left TO new instance of TreeNode initialized with the element at position i of values  \n            APPEND node dot left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none THEN  \n            SET node dot right TO new instance of TreeNode initialized with the element at position i of values  \n            APPEND node dot right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none THEN  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none THEN  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of calling is_same_tree with the left attribute of p AND the left attribute of q AND calling is_same_tree with the right attribute of p AND the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findLeaves(self, root)  \n        FUNCTION collectLeaves(node)  \n            IF node EQUALS none THEN  \n                RETURN minus one  \n            END IF  \n            SET left_height TO the result of calling collectLeaves with the left attribute of node  \n            SET right_height TO the result of calling collectLeaves with the right attribute of node  \n            SET current_height TO the greater value between left_height AND right_height PLUS one  \n            IF current_height GREATER THAN OR EQUAL TO the LENGTH OF result THEN  \n                APPEND an empty list TO result  \n            END IF  \n            APPEND the val attribute of node TO the element at position current_height of result  \n            RETURN current_height  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL collectLeaves with root  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-divisible-subset", "passing_rate": 0.03571428571428571, "pseudocode": "CLASS Solution  \n    FUNCTION largestDivisibleSubset(nums)  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET f TO a list of length n with all elements equal TO one  \n        SET k TO zero  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO i MINUS one  \n                IF the element at position i of nums MODULO the element at position j of nums EQUALS zero THEN  \n                    SET f at position i TO the GREATER OF the value at position i of f AND the value at position j of f PLUS one  \n                END IF  \n            END FOR  \n            IF the value at position k of f IS LESS THAN the value at position i of f THEN  \n                SET k TO i  \n            END IF  \n        END FOR  \n        SET m TO the value at position k of f  \n        SET i TO k  \n        SET ans TO an empty list  \n        WHILE m IS GREATER THAN zero  \n            IF the element at position k of nums MODULO the element at position i of nums EQUALS zero AND the value at position i of f EQUALS m THEN  \n                APPEND the element at position i of nums TO ans  \n                SET k TO i  \n                DECREMENT m BY one  \n            END IF  \n            DECREMENT i BY one  \n        END WHILE  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "plus-one-linked-list", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self val SET TO zero next SET TO None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET head TO new ListNode element at position one of values  \n    SET p TO head  \n    FOR each val IN elements of values starting from position two to the end  \n        SET node TO new ListNode val  \n        SET p.next TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1 p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN p1.val EQUALS p2.val AND is_same_list p1.next p2.next  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION plusOne(head)  \n        FUNCTION reverseList(node)  \n            SET prev TO None  \n            WHILE node NOT EQUAL None  \n                SET next_node TO node.next  \n                SET node.next TO prev  \n                SET prev TO node  \n                SET node TO next_node  \n            END WHILE  \n            RETURN prev  \n        END FUNCTION  \n\n        SET reversed_head TO reverseList head  \n        SET carry TO one  \n        SET current TO reversed_head  \n\n        WHILE current NOT EQUAL None AND carry EQUALS one  \n            SET current.val TO current.val PLUS carry  \n            SET carry TO current.val DIVIDED BY ten  \n            SET current.val TO current.val MODULO ten  \n\n            IF current.next EQUALS None AND carry EQUALS one  \n                SET current.next TO new ListNode carry  \n                SET carry TO zero  \n            END IF  \n\n            SET prev TO current  \n            SET current TO current.next  \n        END WHILE  \n\n        RETURN reverseList reversed_head  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "evaluate-division", "passing_rate": 0.34782608695652173, "pseudocode": "CLASS Solution  \n    FUNCTION calcEquation(equations, values, queries)  \n        SET graph TO a mapping from element to a mapping from element to number with default empty mapping  \n        FOR each pair of elements a and b AND each corresponding value in equations and values IN PARALLEL  \n            SET the element at position b of the mapping at position a of graph TO value  \n            SET the element at position a of the mapping at position b of graph TO one DIVIDED BY value  \n        END FOR  \n\n        FUNCTION dfs(start, end, visited)  \n            IF start NOT IN graph OR end NOT IN graph  \n                RETURN negative one  \n            END IF  \n            IF start EQUALS end  \n                RETURN one  \n            END IF  \n            ADD start TO visited  \n            FOR each neighbor AND corresponding weight IN the mapping at position start of graph  \n                IF neighbor NOT IN visited  \n                    SET result TO dfs(neighbor, end, visited)  \n                    IF result NOT EQUALS negative one  \n                        RETURN weight MULTIPLIED BY result  \n                    END IF  \n                END IF  \n            END FOR  \n            REMOVE start FROM visited  \n            RETURN negative one  \n        END FUNCTION  \n\n        SET results TO an empty list  \n        FOR each query IN queries  \n            SET start TO the element at position zero of query  \n            SET end TO the element at position one of query  \n            SET visited TO an empty set  \n            SET result TO dfs(start, end, visited)  \n            APPEND result TO results  \n        END FOR  \n\n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pacific-atlantic-water-flow", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION pacificAtlantic(heights)  \n        FUNCTION bfs(queue, visited)  \n            WHILE the LENGTH OF queue is GREATER THAN zero  \n                FOR each element FROM zero TO the LENGTH OF queue MINUS one  \n                    SET i TO the first component OF the element REMOVED FROM the FRONT OF queue  \n                    SET j TO the second component OF the element REMOVED FROM the FRONT OF queue  \n                    FOR each pair a b IN the list of pairs zero MINUS one zero one one zero MINUS one zero  \n                        SET x TO i PLUS a  \n                        SET y TO j PLUS b  \n                        IF x IS GREATER THAN OR EQUAL TO zero AND x IS LESS THAN m AND y IS GREATER THAN OR EQUAL TO zero AND y IS LESS THAN n AND the pair x y IS NOT IN visited AND the element at position x y OF heights IS GREATER THAN OR EQUAL TO the element at position i j OF heights  \n                            ADD the pair x y TO visited  \n                            APPEND the pair x y TO queue  \n                        END IF  \n                    END FOR  \n                END FOR  \n            END WHILE  \n        END FUNCTION  \n\n        SET m TO the LENGTH OF heights  \n        SET n TO the LENGTH OF the element at position zero OF heights  \n        SET visited_one TO an empty set  \n        SET visited_two TO an empty set  \n        SET queue_one TO an empty double ended queue  \n        SET queue_two TO an empty double ended queue  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF i EQUALS zero OR j EQUALS zero  \n                    ADD the pair i j TO visited_one  \n                    APPEND the pair i j TO queue_one  \n                END IF  \n                IF i EQUALS m MINUS one OR j EQUALS n MINUS one  \n                    ADD the pair i j TO visited_two  \n                    APPEND the pair i j TO queue_two  \n                END IF  \n            END FOR  \n        END FOR  \n        CALL bfs WITH queue_one AND visited_one  \n        CALL bfs WITH queue_two AND visited_two  \n        SET result TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                IF the pair i j IS IN visited_one AND the pair i j IS IN visited_two  \n                    APPEND the pair i j TO result  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "path-sum-iii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO A new TreeNode with value EQUALS the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero DO  \n        SET node TO the element obtained by removing from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.left TO A new TreeNode with value EQUALS the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.right TO A new TreeNode with value EQUALS the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with parameters p.left and q.left ANDed WITH the result of is_same_tree with parameters p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION pathSum(self, root, targetSum)  \n        FUNCTION helper(node, current_sum, prefix_sums)  \n            IF node EQUALS None THEN  \n                RETURN zero  \n            END IF  \n            SET current_sum TO current_sum PLUS node.val  \n            SET paths_to_here TO the value from prefix_sums accessed by the key current_sum MINUS targetSum OR zero if key not found  \n            SET the value for key current_sum in prefix_sums TO the value from prefix_sums accessed by key current_sum OR zero if key not found PLUS one  \n            SET paths_in_left TO the result of helper called with parameters node.left, current_sum, prefix_sums  \n            SET paths_in_right TO the result of helper called with parameters node.right, current_sum, prefix_sums  \n            DECREMENT the value for key current_sum in prefix_sums BY one  \n            RETURN paths_to_here PLUS paths_in_left PLUS paths_in_right  \n        END FUNCTION  \n        SET prefix_sums TO a dictionary with the key zero assigned value one  \n        RETURN the result of helper called with parameters root, zero, prefix_sums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "add-two-numbers-ii", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__(self, val EQUALS zero, next EQUALS None)  \n        SET self.val TO val  \n        SET self.next TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode with the element at position one of values  \n    SET p TO head  \n    FOR each val IN the elements from position two TO the end of values  \n        SET node TO a new ListNode with val  \n        SET the next element of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list(p1, p2)  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the value of the element p1 EQUALS the value of the element p2 AND is_same_list of the next element of p1 WITH the next element of p2  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION addTwoNumbers(self, l1, l2)  \n        FUNCTION pushIntoStack(node)  \n            SET stack TO an empty list  \n            WHILE node DOES NOT EQUAL None  \n                APPEND the value of the element node TO stack  \n                SET node TO the next element of node  \n            END WHILE  \n            RETURN stack  \n        END FUNCTION  \n\n        SET stack1 TO pushIntoStack with l1  \n        SET stack2 TO pushIntoStack with l2  \n\n        SET carry TO zero  \n        SET result TO None  \n\n        WHILE the LENGTH OF stack1 GREATER THAN zero OR the LENGTH OF stack2 GREATER THAN zero OR carry NOT EQUALS zero  \n            IF the LENGTH OF stack1 GREATER THAN zero  \n                SET val1 TO the last element of stack1  \n                REMOVE the last element FROM stack1  \n            ELSE  \n                SET val1 TO zero  \n            END IF  \n\n            IF the LENGTH OF stack2 GREATER THAN zero  \n                SET val2 TO the last element of stack2  \n                REMOVE the last element FROM stack2  \n            ELSE  \n                SET val2 TO zero  \n            END IF  \n\n            SET total TO val1 PLUS val2 PLUS carry  \n            SET carry TO the result of total DIVIDED BY ten rounded down to the nearest integer  \n            SET digit TO the remainder of total MODULO ten  \n\n            SET new_node TO a new ListNode with digit  \n            SET the next element of new_node TO result  \n            SET result TO new_node  \n        END WHILE  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "delete-node-in-a-bst", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val left right  \n        SET the value property TO val  \n        SET the left property TO left  \n        SET the right property TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF the list values does not have any elements  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode created with the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue has elements  \n        SET node TO the first element removed from the left of queue  \n        IF i is less than the length of values AND the element at position i of values is not no value  \n            SET the left property of node TO a new TreeNode created with the element at position i of values  \n            APPEND the left property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is less than the length of values AND the element at position i of values is not no value  \n            SET the right property of node TO a new TreeNode created with the element at position i of values  \n            APPEND the right property of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p q  \n    IF p does not exist AND q does not exist  \n        RETURN true  \n    END IF  \n    IF p does not exist OR q does not exist  \n        RETURN false  \n    END IF  \n    IF the value property of p NOT EQUALS the value property of q  \n        RETURN false  \n    END IF  \n    RETURN the result of is_same_tree called with the left property of p and the left property of q AND the result of is_same_tree called with the right property of p and the right property of q  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION deleteNode with parameters root key  \n        IF root does not exist  \n            RETURN no value  \n        END IF  \n        IF the value property of root GREATER THAN key  \n            SET the left property of root TO the result of calling deleteNode with the left property of root and key  \n            RETURN root  \n        END IF  \n        IF the value property of root LESS THAN key  \n            SET the right property of root TO the result of calling deleteNode with the right property of root and key  \n            RETURN root  \n        END IF  \n        IF the left property of root does not exist  \n            RETURN the right property of root  \n        END IF  \n        IF the right property of root does not exist  \n            RETURN the left property of root  \n        END IF  \n        SET node TO the right property of root  \n        WHILE the left property of node exists  \n            SET node TO the left property of node  \n        END WHILE  \n        SET the left property of node TO the left property of root  \n        SET root TO the right property of root  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-the-repetitions", "passing_rate": 0.5, "pseudocode": "CLASS Solution  \n    FUNCTION getMaxRepetitions(s1 s one, n1 n one, s2 s two, n2 n two)  \n        IF n one EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n\n        SET s two count TO a list of zeros with the length EQUAL TO the LENGTH OF s two PLUS one  \n        SET index map TO a list of zeros with the length EQUAL TO the LENGTH OF s two PLUS one  \n\n        SET current index s two TO zero  \n        SET s one count TO zero  \n\n        WHILE s one count LESS THAN n one  \n            INCREMENT s one count BY one  \n            FOR each character IN s1  \n                IF character EQUALS element at position current index s two of s two THEN  \n                    INCREMENT current index s two BY one  \n                    IF current index s two EQUALS the LENGTH OF s two THEN  \n                        SET element at position s one count of s two count TO element at position s one count MINUS one of s two count PLUS one  \n                        SET current index s two TO zero  \n                    END IF  \n                END IF  \n                SET element at position s one count of index map TO current index s two  \n            END FOR  \n\n            IF current index s two IS IN elements from position one TO position s one count MINUS one of index map THEN  \n                SET start TO the POSITION OF current index s two IN index map  \n                SET cycle length TO s one count MINUS start  \n                SET cycles fit TO (n one MINUS start) DIVIDED BY cycle length  \n                SET remainder TO (n one MINUS start) MODULO cycle length  \n                SET total s two count TO element at position start of s two count PLUS cycles fit MULTIPLIED BY (element at position start PLUS cycle length of s two count MINUS element at position start of s two count) PLUS element at position start PLUS remainder of s two count MINUS element at position start of s two count  \n                RETURN total s two count DIVIDED BY n two  \n            END IF  \n        END WHILE  \n\n        RETURN element at position s one count of s two count DIVIDED BY n two  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-palindrome-product", "passing_rate": 0.75, "pseudocode": "CLASS Solution  \n    FUNCTION largestPalindrome(n)  \n        IF n EQUALS one  \n            RETURN nine  \n        END IF  \n        \n        SET upper_limit TO ten RAISED TO THE POWER OF n MINUS one  \n        SET lower_limit TO ten RAISED TO THE POWER OF n MINUS one  \n        \n        SET max_palindrome TO zero  \n        \n        FOR i FROM upper_limit TO lower_limit DECREMENT BY one  \n            FOR j FROM i TO lower_limit DECREMENT BY one  \n                SET product TO i MULTIPLIED BY j  \n                IF product LESS THAN OR EQUAL TO max_palindrome  \n                    BREAK  \n                END IF  \n                \n                SET str_product TO the string representation of product  \n                IF str_product EQUALS the reversal of str_product  \n                    SET max_palindrome TO product  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_palindrome MODULO one thousand three hundred thirty seven  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-good-base", "passing_rate": 0.6808510638297872, "pseudocode": "CLASS Solution  \n    FUNCTION smallestGoodBase(n)  \n        SET n TO the integer conversion of n  \n        SET max_length TO the integer part of the logarithm base two of n PLUS one  \n        FOR m FROM max_length DOWN TO two  \n            SET k TO the integer part of the nth root of n where the root degree is m MINUS one  \n            IF k LESS THAN two  \n                CONTINUE to the next iteration of the loop  \n            END IF  \n            SET num TO the integer division of k raised to the power m MINUS one BY k MINUS one  \n            IF num EQUALS n  \n                RETURN the string conversion of k  \n            END IF  \n        END FOR  \n        RETURN the string conversion of n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-consecutive-ones-ii", "passing_rate": 0.2972972972972973, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxConsecutiveOnes(nums)  \n        SET max_count TO zero  \n        SET current_count TO zero  \n        SET zero_count TO zero  \n        SET left TO zero  \n        \n        FOR right FROM zero TO the LENGTH OF nums MINUS one  \n            IF the element at position right of nums EQUALS one  \n                INCREMENT current_count BY one  \n            ELSE IF zero_count LESS THAN one  \n                INCREMENT zero_count BY one  \n                INCREMENT current_count BY one  \n            ELSE  \n                SET max_count TO the greater value BETWEEN max_count AND current_count  \n                WHILE zero_count EQUALS one  \n                    IF the element at position left of nums EQUALS zero  \n                        DECREMENT zero_count BY one  \n                    END IF  \n                    DECREMENT current_count BY one  \n                    INCREMENT left BY one  \n                END WHILE  \n                INCREMENT current_count BY one  \n            END IF  \n        END FOR  \n        \n        SET max_count TO the greater value BETWEEN max_count AND current_count  \n        RETURN max_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-subsequences", "passing_rate": 0.10526315789473684, "pseudocode": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(u, last, t)  \n            IF u EQUALS the LENGTH OF nums  \n                IF the LENGTH OF t GREATER THAN one  \n                    APPEND a COPY OF t TO ans  \n                END IF  \n                RETURN  \n            END IF  \n            IF element at position u of nums GREATER THAN OR EQUAL TO last  \n                APPEND element at position u of nums TO t  \n                CALL dfs WITH u INCREMENTED BY one AND element at position u of nums AS last AND t  \n                REMOVE the LAST element FROM t  \n            END IF  \n            IF element at position u of nums NOT EQUALS last  \n                CALL dfs WITH u INCREMENTED BY one AND last AND t  \n            END IF  \n        END FUNCTION  \n        SET ans TO an EMPTY list  \n        CALL dfs WITH zero AS u AND minus one thousand AS last AND an EMPTY list AS t  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "most-frequent-subtree-sum", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values  \n    SET i TO one  \n    INITIALIZE queue as an empty double-ended collection  \n    APPEND root TO queue  \n    WHILE the queue is not empty  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not None THEN  \n            SET node.left TO a new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not None THEN  \n            SET node.right TO a new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None THEN  \n        RETURN True  \n    ELSE IF p IS None OR q IS None THEN  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with p.left and q.left AND the result of is_same_tree with p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findFrequentTreeSum(self, root)  \n        FUNCTION subtree_sum(node)  \n            IF node IS None THEN  \n                RETURN zero  \n            END IF  \n            SET current_sum TO node.val PLUS subtree_sum with node.left PLUS subtree_sum with node.right  \n            INCREMENT the value at key current_sum in count BY one  \n            RETURN current_sum  \n        END FUNCTION  \n        \n        INITIALIZE count as a default dictionary with integer default value  \n        CALL subtree_sum with root  \n        \n        SET max_freq TO the maximum value among all values in count with a default of zero  \n        \n        SET result TO a list of keys from count where the corresponding value EQUALS max_freq  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-bottom-left-tree-value", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the input list values IS EMPTY  \n        RETURN null  \n    END IF  \n    SET root TO a new TreeNode with value equal to element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT EMPTY  \n        SET node TO the element removed from the front of queue  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT null  \n            SET node.left TO a new TreeNode with value equal to element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i IS LESS THAN the LENGTH OF values AND element at position i of values IS NOT null  \n            SET node.right TO a new TreeNode with value equal to element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS null AND q IS null  \n        RETURN True  \n    ELSE IF p IS null OR q IS null  \n        RETURN False  \n    ELSE IF the value of p DOES NOT EQUAL the value of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of calling is_same_tree with p.left and q.left AND the result of calling is_same_tree with p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findBottomLeftValue(self, root)  \n        SET queue TO a double ended queue containing root  \n        SET leftmost_value TO null  \n        WHILE queue IS NOT EMPTY  \n            SET level_size TO the LENGTH OF queue  \n            FOR i FROM zero TO level_size MINUS one  \n                SET node TO the element removed from the front of queue  \n                IF i EQUALS zero  \n                    SET leftmost_value TO the value of node  \n                END IF  \n                IF the left child of node EXISTS  \n                    APPEND the left child of node TO queue  \n                END IF  \n                IF the right child of node EXISTS  \n                    APPEND the right child of node TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN leftmost_value  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-largest-value-in-each-tree-row", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value element at position zero of values  \n    SET i TO one  \n    SET queue TO a new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the first element removed from the left side of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.left TO a new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.right TO a new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN true  \n    ELSE IF p IS none OR q IS none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN the result of is_same_tree with arguments p.left and q.left AND the result of is_same_tree with arguments p.right and q.right  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION largestValues(self, root)  \n        IF root IS none  \n            RETURN an empty list  \n        END IF  \n        SET queue TO a new double ended queue containing root  \n        SET largest_values TO an empty list  \n        WHILE queue is not empty  \n            SET level_size TO the LENGTH OF queue  \n            SET max_value TO negative infinity  \n            FOR index FROM zero TO level_size MINUS one  \n                SET node TO the first element removed from the left side of queue  \n                IF max_value LESS THAN node.val  \n                    SET max_value TO node.val  \n                END IF  \n                IF node.left IS NOT none  \n                    APPEND node.left TO queue  \n                END IF  \n                IF node.right IS NOT none  \n                    APPEND node.right TO queue  \n                END IF  \n            END FOR  \n            APPEND max_value TO largest_values  \n        END WHILE  \n        RETURN largest_values  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-abbreviation", "passing_rate": 0.6666666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION wordsAbbreviation(words)  \n        FUNCTION abbreviate(word prefix_length)  \n            IF the LENGTH OF word MINUS prefix_length IS LESS THAN OR EQUAL TO two  \n                RETURN word  \n            END IF  \n            RETURN the SUBSTRING of word FROM position one TO position prefix_length PLUS the STRING REPRESENTATION OF the LENGTH OF word MINUS prefix_length MINUS one PLUS the ELEMENT at position the LENGTH OF word OF word  \n        END FUNCTION  \n\n        FUNCTION get_unique_abbreviations(words_with_indices prefix_length)  \n            SET abbs TO an empty mapping from abbreviations TO list of pairs  \n            FOR each pair index word IN words_with_indices  \n                APPEND the pair index word TO the list at the KEY abbreviate of word AND prefix_length IN abbs  \n            END FOR  \n            RETURN abbs  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF words  \n        SET ans TO a LIST of empty strings OF LENGTH n  \n        SET words_with_indices TO an empty list  \n        FOR each index i FROM one TO n  \n            APPEND the pair i AND the ELEMENT at position i OF words TO words_with_indices  \n        END FOR  \n\n        SET abbs TO get_unique_abbreviations WITH words_with_indices AND prefix_length one  \n\n        FOR each pair abb group IN the ITEMS OF abbs  \n            IF the LENGTH OF group EQUALS one  \n                SET index TO the FIRST ELEMENT of the FIRST PAIR in group  \n                SET word TO the SECOND ELEMENT of the FIRST PAIR in group  \n                SET the ELEMENT at position index OF ans TO abb  \n            ELSE  \n                SET new_group TO an empty list  \n                FOR each pair index word IN group  \n                    APPEND the pair index word TO new_group  \n                END FOR  \n                SET prefix_length TO two  \n                WHILE the LENGTH OF new_group IS GREATER THAN zero  \n                    SET new_abbs TO get_unique_abbreviations WITH new_group AND prefix_length  \n                    SET new_group TO an empty list  \n                    FOR each pair new_abb new_group_items IN the ITEMS OF new_abbs  \n                        IF the LENGTH OF new_group_items EQUALS one  \n                            SET index TO the FIRST ELEMENT of the FIRST PAIR in new_group_items  \n                            SET word TO the SECOND ELEMENT of the FIRST PAIR in new_group_items  \n                            SET the ELEMENT at position index OF ans TO new_abb  \n                        ELSE  \n                            FOR each item IN new_group_items  \n                                APPEND item TO new_group  \n                            END FOR  \n                        END IF  \n                    END FOR  \n                    INCREMENT prefix_length BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n\n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-binary-tree-from-string", "passing_rate": 0.0, "pseudocode": "CLASS ListNode  \n    FUNCTION __init__ with parameters val AND next  \n        SET the val attribute TO val  \n        SET the next attribute TO next  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION list_node with parameter values  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET head TO a new ListNode with the element at position zero of values  \n    SET p TO head  \n    FOR each val IN the elements of values starting from the position one to the end  \n        SET node TO a new ListNode with val  \n        SET the next attribute of p TO node  \n        SET p TO node  \n    END FOR  \n    RETURN head  \nEND FUNCTION  \n\nFUNCTION is_same_list with parameters p1 AND p2  \n    IF p1 EQUALS None AND p2 EQUALS None  \n        RETURN True  \n    END IF  \n    IF p1 EQUALS None OR p2 EQUALS None  \n        RETURN False  \n    END IF  \n    RETURN the condition that the val attribute of p1 EQUALS the val attribute of p2 AND the recursive call to is_same_list with the next attribute of p1 AND the next attribute of p2  \nEND FUNCTION  \n\nCLASS TreeNode  \n    FUNCTION __init__ with parameters val AND left AND right  \n        SET the val attribute TO val  \n        SET the left attribute TO left  \n        SET the right attribute TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    CALL the append method of queue with root  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the result of calling the method that removes and returns the element from the left of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values DOES NOT EQUAL None  \n            SET the left attribute of node TO a new TreeNode with the element at position i of values  \n            CALL the append method of queue with the left attribute of node  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values DOES NOT EQUAL None  \n            SET the right attribute of node TO a new TreeNode with the element at position i of values  \n            CALL the append method of queue with the right attribute of node  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p AND q  \n    IF p EQUALS None AND q EQUALS None  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN the result of the logical AND of the recursive call to is_same_tree with the left attribute of p AND the left attribute of q AND the recursive call to is_same_tree with the right attribute of p AND the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION str2tree with parameter s  \n        FUNCTION parse_tree with parameter index  \n            IF index GREATER THAN OR EQUAL TO the LENGTH OF s  \n                RETURN None AND index  \n            END IF  \n            SET start TO index  \n            WHILE index LESS THAN the LENGTH OF s AND the element at position index of s IS A DIGIT OR the element at position index of s EQUALS the character indicating negative sign  \n                INCREMENT index BY one  \n            END WHILE  \n            SET node TO a new TreeNode created with the integer value represented by the substring of s from position start TO position index MINUS one  \n            IF index LESS THAN the LENGTH OF s AND the element at position index of s EQUALS the character indicating an open parenthesis  \n                SET the left attribute of node AND index TO the result of calling parse_tree with index PLUS one  \n            END IF  \n            IF index LESS THAN the LENGTH OF s AND the element at position index of s EQUALS the character indicating an open parenthesis  \n                SET the right attribute of node AND index TO the result of calling parse_tree with index PLUS one  \n            END IF  \n            IF index LESS THAN the LENGTH OF s AND the element at position index of s EQUALS the character indicating a close parenthesis  \n                INCREMENT index BY one  \n            END IF  \n            RETURN node AND index  \n        END FUNCTION  \n        SET root AND discard TO the result of calling parse_tree with zero  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "convert-bst-to-greater-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with val EQUALS element at position one of values AND left EQUALS none AND right EQUALS none  \n    SET i TO one  \n    SET queue TO a new empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO element removed from the front of queue  \n        IF i LESS THAN the length of values AND element at position i of values DOES NOT EQUAL none  \n            SET node.left TO new TreeNode with val EQUALS element at position i of values AND left EQUALS none AND right EQUALS none  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values DOES NOT EQUAL none  \n            SET node.right TO new TreeNode with val EQUALS element at position i of values AND left EQUALS none AND right EQUALS none  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION convertBST(self, root)  \n        SET self.sum TO zero  \n        \n        FUNCTION traverse(node)  \n            IF node EQUALS none  \n                RETURN  \n            END IF  \n            traverse(node.right)  \n            SET self.sum TO self.sum PLUS node.val  \n            SET node.val TO self.sum  \n            traverse(node.left)  \n        END FUNCTION  \n        \n        CALL traverse with root  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "boundary-of-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value element at position zero of values  \n    SET i TO one  \n    SET queue TO new empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue holds elements  \n        SET node TO remove the first element from queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with value element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS none  \n            SET node.right TO new TreeNode with value element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF value of p NOT EQUALS value of q  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(left child of p, left child of q) AND is_same_tree(right child of p, right child of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION boundaryOfBinaryTree(self, root)  \n        IF root EQUALS none  \n            RETURN empty list  \n        END IF  \n        \n        FUNCTION is_leaf(node)  \n            RETURN left child of node EQUALS none AND right child of node EQUALS none  \n        END FUNCTION  \n        \n        SET left_boundary TO empty list  \n        SET current TO left child of root  \n        WHILE current holds value  \n            IF NOT is_leaf(current)  \n                APPEND value of current TO left_boundary  \n            END IF  \n            IF left child of current holds value  \n                SET current TO left child of current  \n            ELSE  \n                SET current TO right child of current  \n            END IF  \n        END WHILE  \n        \n        SET right_boundary TO empty list  \n        SET current TO right child of root  \n        WHILE current holds value  \n            IF NOT is_leaf(current)  \n                APPEND value of current TO right_boundary  \n            END IF  \n            IF right child of current holds value  \n                SET current TO right child of current  \n            ELSE  \n                SET current TO left child of current  \n            END IF  \n        END WHILE  \n        \n        SET leaves TO empty list  \n        FUNCTION collect_leaves(node)  \n            IF node EQUALS none  \n                RETURN  \n            END IF  \n            IF is_leaf(node)  \n                APPEND value of node TO leaves  \n            END IF  \n            CALL collect_leaves(left child of node)  \n            CALL collect_leaves(right child of node)  \n        END FUNCTION  \n        \n        CALL collect_leaves(root)  \n        \n        IF is_leaf(root)  \n            SET leaves TO empty list  \n        END IF  \n        \n        RETURN list created by concatenating value of root WITH left_boundary WITH leaves WITH elements of right_boundary in reverse order  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-longest-consecutive-sequence-ii", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS\n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN no value  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty DO  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value THEN  \n            SET node.left TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values IS NOT no value THEN  \n            SET node.right TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION\n\nFUNCTION is_same_tree(p, q)  \n    IF p IS no value AND q IS no value THEN  \n        RETURN TRUE  \n    ELSE IF p IS no value OR q IS no value THEN  \n        RETURN FALSE  \n    ELSE IF the value of p IS NOT EQUAL TO the value of q THEN  \n        RETURN FALSE  \n    ELSE  \n        RETURN the logical AND of the call to is_same_tree with p.left and q.left AND the call to is_same_tree with p.right and q.right  \n    END IF  \nEND FUNCTION\n\nCLASS Solution  \n    FUNCTION longestConsecutive(self, root)  \n        FUNCTION dfs(node)  \n            IF node IS no value THEN  \n                RETURN zero, zero  \n            END IF  \n            SET inc_len TO one  \n            SET dec_len TO one  \n            SET left_inc, left_dec TO the result of dfs called with node.left  \n            SET right_inc, right_dec TO the result of dfs called with node.right  \n            IF node.left IS NOT no value THEN  \n                IF the value of node EQUALS the value of node.left PLUS one THEN  \n                    SET dec_len TO left_dec PLUS one  \n                ELSE IF the value of node EQUALS the value of node.left MINUS one THEN  \n                    SET inc_len TO left_inc PLUS one  \n                END IF  \n            END IF  \n            IF node.right IS NOT no value THEN  \n                IF the value of node EQUALS the value of node.right PLUS one THEN  \n                    SET dec_len TO the maximum of dec_len AND right_dec PLUS one  \n                ELSE IF the value of node EQUALS the value of node.right MINUS one THEN  \n                    SET inc_len TO the maximum of inc_len AND right_inc PLUS one  \n                END IF  \n            END IF  \n            SET max_len TO the maximum of max_len AND inc_len PLUS dec_len MINUS one  \n            RETURN inc_len, dec_len  \n        END FUNCTION  \n        SET max_len TO zero  \n        CALL dfs with root  \n        RETURN max_len  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "optimal-division", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION optimalDivision(nums)  \n        IF the LENGTH OF nums EQUALS one  \n            RETURN the STRING REPRESENTATION OF the ELEMENT at position one of nums  \n        END IF  \n        IF the LENGTH OF nums EQUALS two  \n            RETURN the STRING REPRESENTATION OF the ELEMENT at position one of nums FOLLOWED BY the WORD division FOLLOWED BY the STRING REPRESENTATION OF the ELEMENT at position two of nums  \n        END IF  \n        RETURN the STRING REPRESENTATION OF the ELEMENT at position one of nums FOLLOWED BY the WORD division FOLLOWED BY an OPENING PARENTHESIS FOLLOWED BY the STRING REPRESENTATIONS OF the ELEMENTS from position two TO the END OF nums JOINED BY the WORD division FOLLOWED BY a CLOSING PARENTHESIS  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kill-process", "passing_rate": 0.7380952380952381, "pseudocode": "CLASS Solution  \n    FUNCTION killProcess(pid parameter as list of integers ppid parameter as list of integers kill parameter as integer) RETURNS list of integers  \n        SET tree TO a mapping from integer to list of integers with default empty list  \n        FOR each pair child and parent IN the combination of pid and ppid  \n            APPEND child TO the list at key parent in tree  \n        END FOR  \n        SET queue TO a list containing kill  \n        SET killed_processes TO an empty list  \n        WHILE the LENGTH OF queue is GREATER THAN zero  \n            REMOVE the element at position zero from queue and ASSIGN it TO current  \n            APPEND current TO killed_processes  \n            APPEND all elements from the list at key current in tree TO queue  \n        END WHILE  \n        RETURN killed_processes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "fraction-addition-and-subtraction", "passing_rate": 0.7735849056603774, "pseudocode": "CLASS Solution  \n    FUNCTION fractionAddition(expression)  \n        SET transformed_expression TO expression WITH every occurrence of MINUS REPLACED BY PLUS MINUS  \n        SET list_of_fractions TO the result of SPLITTING transformed_expression BY PLUS  \n        SET sum_of_fractions TO the result of SUMMING a fraction object CREATED FROM each item IN list_of_fractions WHEN the item IS NOT empty  \n        SET numerator_of_result TO the numerator PART of sum_of_fractions  \n        SET denominator_of_result TO the denominator PART of sum_of_fractions  \n        SET final_result TO the concatenation OF numerator_of_result AS string PLUS a forward slash PLUS denominator_of_result AS string  \n        RETURN final_result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "construct-string-from-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode constructed with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is greater than zero  \n        REMOVE the first element FROM queue and ASSIGN IT TO node  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.left TO a new TreeNode constructed with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.right TO a new TreeNode constructed with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF the value field of p NOT EQUALS the value field of q  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(the left field of p, the left field of q) AND is_same_tree(the right field of p, the right field of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION tree2str(root)  \n        FUNCTION helper(node)  \n            IF node EQUALS none  \n                RETURN empty string  \n            END IF  \n            SET result TO the string conversion of the value field of node  \n            IF the left field of node EXISTS OR (the left field of node DOES NOT EXIST AND the right field of node EXISTS)  \n                SET result TO result PLUS an opening parenthesis PLUS helper(the left field of node) PLUS a closing parenthesis  \n            END IF  \n            IF the right field of node EXISTS  \n                SET result TO result PLUS an opening parenthesis PLUS helper(the right field of node) PLUS a closing parenthesis  \n            END IF  \n            RETURN result  \n        END FUNCTION  \n        RETURN helper(root)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "add-one-row-to-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the element removed from the left end of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.left TO a new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS none  \n            SET node.right TO a new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF the val property of p NOT EQUALS the val property of q  \n        RETURN false  \n    ELSE  \n        RETURN the Boolean AND of the result of is_same_tree invoked with the left property of p and the left property of q AND the result of is_same_tree invoked with the right property of p and the right property of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION addOneRow(self, root, val, depth)  \n        IF depth EQUALS one  \n            RETURN a new TreeNode with val as the val argument AND root as the left argument AND none as the right argument  \n        END IF  \n        SET queue TO a double ended queue containing a single pair consisting of root AND one  \n        WHILE queue is not empty  \n            SET node AND level TO the pair removed from the left end of queue  \n            IF level EQUALS depth MINUS one  \n                SET node.left TO a new TreeNode with val as the val argument AND the original left property of node as the left argument AND none as the right argument  \n                SET node.right TO a new TreeNode with val as the val argument AND none as the left argument AND the original right property of node as the right argument  \n            ELSE IF level LESS THAN depth MINUS one  \n                IF the left property of node is not none  \n                    APPEND a pair consisting of the left property of node AND level PLUS one TO queue  \n                END IF  \n                IF the right property of node is not none  \n                    APPEND a pair consisting of the right property of node AND level PLUS one TO queue  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-derangement-of-an-array", "passing_rate": 0.09090909090909091, "pseudocode": "CLASS Solution  \n    FUNCTION findDerangement(n)  \n        SET MOD TO one billion PLUS seven  \n        \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        IF n EQUALS two  \n            RETURN one  \n        END IF  \n        \n        SET prev2 TO one  \n        SET prev1 TO zero  \n        \n        FOR i FROM three TO n  \n            SET current TO the product of i MINUS one AND the sum of prev1 AND prev2  \n            SET current TO current MODULO MOD  \n            SET prev2 TO prev1  \n            SET prev1 TO current  \n        END FOR  \n        \n        RETURN prev1  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "decode-ways-ii", "passing_rate": 0.7659574468085106, "pseudocode": "CLASS Solution  \n    FUNCTION numDecodings(s)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS one  \n        SET dp TO list of zeros with LENGTH OF s PLUS one  \n        SET element at position zero of dp TO one  \n  \n        FUNCTION ways_to_decode_single(char)  \n            IF char EQUALS the character star  \n                RETURN nine  \n            ELSE IF char EQUALS the character zero  \n                RETURN zero  \n            ELSE  \n                RETURN one  \n            END IF  \n        END FUNCTION  \n  \n        FUNCTION ways_to_decode_pair(char1, char2)  \n            IF char1 EQUALS the character star AND char2 EQUALS the character star  \n                RETURN fifteen  \n            ELSE IF char1 EQUALS the character star  \n                IF char2 LESS THAN OR EQUAL TO the character six  \n                    RETURN two  \n                ELSE  \n                    RETURN one  \n                END IF  \n            ELSE IF char2 EQUALS the character star  \n                IF char1 EQUALS the character one  \n                    RETURN nine  \n                ELSE IF char1 EQUALS the character two  \n                    RETURN six  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            ELSE  \n                SET num TO the integer value of the concatenation of char1 and char2  \n                IF num GREATER THAN OR EQUAL TO ten AND num LESS THAN OR EQUAL TO twenty six  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n        END FUNCTION  \n  \n        FOR i FROM one TO LENGTH OF s  \n            SET dp at position i TO dp at position i PLUS dp at position i MINUS one MULTIPLIED BY ways_to_decode_single(the element at position i MINUS one of s)  \n            SET dp at position i TO dp at position i MODULO MOD  \n            IF i GREATER THAN one  \n                SET dp at position i TO dp at position i PLUS dp at position i MINUS two MULTIPLIED BY ways_to_decode_pair(the element at position i MINUS two of s, the element at position i MINUS one of s)  \n                SET dp at position i TO dp at position i MODULO MOD  \n            END IF  \n        END FOR  \n  \n        RETURN element at the last position of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-average-subarray-ii", "passing_rate": 0.5151515151515151, "pseudocode": "CLASS Solution  \n    FUNCTION findMaxAverage(nums k)  \n        FUNCTION canFindAverage(mid)  \n            SET prefix_sums TO a list consisting of zeros with the length of the length of nums PLUS one  \n            SET min_prefix_sum TO a list consisting of zeros with the length of the length of nums PLUS one  \n            FOR i FROM zero TO the length of nums MINUS one  \n                SET element at position i PLUS one of prefix_sums TO element at position i of prefix_sums PLUS element at position i of nums MINUS mid  \n                IF i GREATER THAN OR EQUAL TO k THEN  \n                    SET element at position i PLUS one of min_prefix_sum TO the lesser value BETWEEN element at position i of min_prefix_sum AND element at position i PLUS one MINUS k of prefix_sums  \n                ELSE  \n                    SET element at position i PLUS one of min_prefix_sum TO element at position i of min_prefix_sum  \n                END IF  \n                IF i GREATER THAN OR EQUAL TO k MINUS one AND element at position i PLUS one of prefix_sums MINUS element at position i PLUS one of min_prefix_sum GREATER THAN OR EQUAL TO zero THEN  \n                    RETURN True  \n                END IF  \n            END FOR  \n            RETURN False  \n        END FUNCTION  \n        SET low TO the lesser value among elements of nums  \n        SET high TO the greater value among elements of nums  \n        WHILE high MINUS low GREATER THAN one TENTH OF ONE THOUSANDTH  \n            SET mid TO low PLUS high DIVIDED BY two  \n            IF canFindAverage(mid) THEN  \n                SET low TO mid  \n            ELSE  \n                SET high TO mid  \n            END IF  \n        END WHILE  \n        RETURN low  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS None, right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty deque  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero DO  \n        SET node TO the first element removed from queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.left TO a new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.right TO a new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with the left attribute of p AND the left attribute of q AND the result of is_same_tree with the right attribute of p AND the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION constructMaximumBinaryTree(self, nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN None  \n        END IF  \n        SET max_val TO the maximum element in nums  \n        SET max_index TO the position of max_val in nums  \n        SET root TO a new TreeNode with max_val  \n        SET the left attribute of root TO the result of constructMaximumBinaryTree with the sublist of nums from position one TO position max_index MINUS one  \n        SET the right attribute of root TO the result of constructMaximumBinaryTree with the sublist of nums from position max_index PLUS one TO the last position of nums  \n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "print-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO A NEW INSTANCE OF TreeNode USING element at position one of values  \n    SET i TO one  \n    SET queue TO AN EMPTY DEQUE  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO THE FIRST ELEMENT REMOVED FROM queue  \n        IF i LESS THAN THE LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.left TO A NEW INSTANCE OF TreeNode USING element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN THE LENGTH OF values AND element at position i of values IS NOT none  \n            SET node.right TO A NEW INSTANCE OF TreeNode USING element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN True  \n    ELSE IF p IS none OR q IS none  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree OF p.left AND q.left AND is_same_tree OF p.right AND q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION printTree(self, root)  \n        FUNCTION getHeight(node)  \n            IF node IS none  \n                RETURN zero  \n            END IF  \n            RETURN one PLUS THE GREATER VALUE BETWEEN getHeight OF node.left AND getHeight OF node.right  \n        END FUNCTION  \n\n        SET height TO getHeight OF root  \n        SET width TO two RAISED TO THE POWER OF height MINUS one  \n        SET res TO A LIST OF height ELEMENTS WHERE EACH ELEMENT IS A LIST OF width ELEMENTS CONTAINING EMPTY STRINGS  \n\n        FUNCTION placeNode(node, row, left, right)  \n            IF node IS none  \n                RETURN  \n            END IF  \n            SET mid TO THE INTEGER VALUE OF left PLUS right DIVIDED BY two  \n            SET element at position mid of element at position row of res TO THE STRING REPRESENTATION OF node.val  \n            CALL placeNode WITH node.left, row PLUS one, left, mid  \n            CALL placeNode WITH node.right, row PLUS one, mid, right  \n        END FUNCTION  \n\n        CALL placeNode WITH root, zero, zero, width  \n        RETURN res  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-width-of-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value element at position one of values  \n    SET i TO one  \n    SET queue TO empty double-ended queue  \n    APPEND root TO queue  \n    WHILE queue IS NOT empty  \n        SET node TO element at position one removed from the left of queue  \n        IF i LESS THAN LENGTH OF values AND element at position i plus one of values IS NOT none  \n            SET node.left TO new TreeNode with value element at position i plus one of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN LENGTH OF values AND element at position i plus one of values IS NOT none  \n            SET node.right TO new TreeNode with value element at position i plus one of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN true  \n    ELSE IF p IS none OR q IS none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION widthOfBinaryTree(self, root)  \n        IF root IS none  \n            RETURN zero  \n        END IF  \n        SET queue TO new empty double-ended queue containing tuple of root and zero  \n        SET max_width TO zero  \n        WHILE queue IS NOT empty  \n            SET level_length TO LENGTH OF queue  \n            SET first_index TO index element of element at position one of queue  \n            FOR each number from zero TO level_length MINUS one  \n                SET node, index TO element at position one removed from the left of queue  \n                IF number EQUALS level_length MINUS one  \n                    SET current_width TO index MINUS first_index PLUS one  \n                    IF current_width GREATER THAN max_width  \n                        SET max_width TO current_width  \n                    END IF  \n                END IF  \n                IF node.left IS NOT none  \n                    APPEND tuple of node.left and index MULTIPLIED BY two TO queue  \n                END IF  \n                IF node.right IS NOT none  \n                    APPEND tuple of node.right and index MULTIPLIED BY two PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN max_width  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-tree-partition", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ (self val left right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node (values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN Nothing  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is GREATER THAN zero  \n        SET node TO the element that is removed from the left of queue  \n        IF i is LESS THAN the LENGTH OF values AND the element at position i of values is NOT EQUALS Nothing THEN  \n            SET node.left TO a new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is LESS THAN the LENGTH OF values AND the element at position i of values is NOT EQUALS Nothing THEN  \n            SET node.right TO a new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree (p q)  \n    IF p EQUALS Nothing AND q EQUALS Nothing THEN  \n        RETURN True  \n    ELSE IF p EQUALS Nothing OR q EQUALS Nothing THEN  \n        RETURN False  \n    ELSE IF the val attribute of p is NOT EQUALS the val attribute of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the result of is_same_tree with the left attribute of p and the left attribute of q AND the result of is_same_tree with the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION checkEqualTree (self root)  \n        FUNCTION subtree_sum (node)  \n            IF node EQUALS Nothing THEN  \n                RETURN zero  \n            END IF  \n            RETURN the val attribute of node PLUS the result of subtree_sum with the left attribute of node PLUS the result of subtree_sum with the right attribute of node  \n        END FUNCTION  \n\n        SET total_sum TO the result of subtree_sum with root  \n        IF total_sum MODULO two is NOT EQUALS zero THEN  \n            RETURN False  \n        END IF  \n        SET target TO total_sum DIVIDED BY two  \n        SET found TO a list containing one element False  \n\n        FUNCTION can_split (node)  \n            IF node EQUALS Nothing THEN  \n                RETURN zero  \n            END IF  \n            SET current_sum TO the val attribute of node PLUS the result of can_split with the left attribute of node PLUS the result of can_split with the right attribute of node  \n            IF current_sum EQUALS target AND node is NOT the same object as root THEN  \n                SET the element at position one of found TO True  \n            END IF  \n            RETURN current_sum  \n        END FUNCTION  \n\n        CALL can_split with root  \n        RETURN the element at position one of found  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "beautiful-arrangement-ii", "passing_rate": 0.2647058823529412, "pseudocode": "CLASS Solution  \n    FUNCTION constructArray(n, k)  \n        SET result TO an empty list  \n        FOR each integer index FROM one TO n MINUS k MINUS one  \n            APPEND integer index TO result  \n        END FOR  \n        SET left TO n MINUS k  \n        SET right TO n  \n        WHILE left IS LESS THAN OR EQUAL TO right  \n            IF left EQUALS right  \n                APPEND left TO result  \n            ELSE  \n                APPEND left TO result  \n                APPEND right TO result  \n            END IF  \n            INCREMENT left BY one  \n            DECREMENT right BY one  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "trim-a-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN None  \n    END IF  \n    SET root TO TreeNode element at position one of values  \n    SET i TO one  \n    INITIALIZE queue as empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        REMOVE leftmost element FROM queue AND ASSIGN TO node  \n        IF i LESS THAN THE LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.left TO TreeNode element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN THE LENGTH OF values AND element at position i of values IS NOT None  \n            SET node.right TO TreeNode element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS None AND q IS None  \n        RETURN True  \n    ELSE IF p IS None OR q IS None  \n        RETURN False  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION trimBST(self, root, low, high)  \n        IF root IS None  \n            RETURN None  \n        END IF  \n\n        IF root.val LESS THAN low  \n            RETURN self.trimBST(root.right, low, high)  \n        END IF  \n\n        IF root.val GREATER THAN high  \n            RETURN self.trimBST(root.left, low, high)  \n        END IF  \n\n        SET root.left TO self.trimBST(root.left, low, high)  \n        SET root.right TO self.trimBST(root.right, low, high)  \n\n        RETURN root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "redundant-connection-ii", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION findRedundantDirectedConnection(edges)  \n        FUNCTION find(parent, i)  \n            IF element at position i of parent NOT EQUALS i THEN  \n                SET element at position i of parent TO find(parent, element at position i of parent)  \n            END IF  \n            RETURN element at position i of parent  \n        END FUNCTION  \n\n        FUNCTION union(parent, rank, x, y)  \n            SET rootX TO find(parent, x)  \n            SET rootY TO find(parent, y)  \n            IF rootX NOT EQUALS rootY THEN  \n                IF element at position rootX of rank GREATER THAN element at position rootY of rank THEN  \n                    SET element at position rootY of parent TO rootX  \n                ELSE IF element at position rootX of rank LESS THAN element at position rootY of rank THEN  \n                    SET element at position rootX of parent TO rootY  \n                ELSE  \n                    SET element at position rootY of parent TO rootX  \n                    INCREMENT element at position rootX of rank BY one  \n                END IF  \n                RETURN true  \n            END IF  \n            RETURN false  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF edges  \n        SET parent TO the list of integers starting from zero TO n inclusive  \n        SET rank TO the list of zeros of length n PLUS one  \n\n        SET candidate1 TO none  \n        SET candidate2 TO none  \n        SET last TO none  \n\n        FOR each pair u v IN edges  \n            IF element at position v of parent NOT EQUALS v THEN  \n                SET candidate1 TO the pair of element at position v of parent AND v  \n                SET candidate2 TO the pair of u AND v  \n            ELSE  \n                IF union(parent, rank, u, v) EQUALS false THEN  \n                    SET last TO the pair of u AND v  \n                END IF  \n            END IF  \n        END FOR  \n\n        IF candidate1 EQUALS none THEN  \n            RETURN last  \n        END IF  \n\n        IF last NOT EQUALS none THEN  \n            RETURN candidate1  \n        END IF  \n\n        RETURN candidate2  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-univalue-path", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position zero of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is GREATER THAN zero  \n        REMOVE the first element FROM queue AND ASSIGN TO node  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not none  \n            SET node.left TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not none  \n            SET node.right TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p IS none AND q IS none  \n        RETURN True  \n    ELSE IF p IS none OR q IS none  \n        RETURN False  \n    ELSE IF the value attribute of p NOT EQUALS the value attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(the left attribute of p, the left attribute of q) AND is_same_tree(the right attribute of p, the right attribute of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION longestUnivaluePath(self, root)  \n        FUNCTION dfs(node)  \n            IF node IS none  \n                RETURN zero, zero  \n            END IF  \n            SET left_length, left_value TO dfs(the left attribute of node)  \n            SET right_length, right_value TO dfs(the right attribute of node)  \n            SET left_arrow TO zero  \n            SET right_arrow TO zero  \n            IF the left attribute of node IS not none AND the value attribute of the left attribute of node EQUALS the value attribute of node  \n                SET left_arrow TO left_length PLUS one  \n            END IF  \n            IF the right attribute of node IS not none AND the value attribute of the right attribute of node EQUALS the value attribute of node  \n                SET right_arrow TO right_length PLUS one  \n            END IF  \n            SET self.max_length TO the GREATER OF self.max_length AND the SUM of left_arrow AND right_arrow  \n            RETURN the GREATER OF left_arrow AND right_arrow, the value attribute of node  \n        END FUNCTION  \n        SET self.max_length TO zero  \n        CALL dfs WITH root  \n        RETURN self.max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "insert-into-a-binary-search-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__ with parameters val left right  \n        SET val attribute of self TO val  \n        SET left attribute of self TO left  \n        SET right attribute of self TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node with parameter values  \n    IF values EQUALS nothing  \n        RETURN nothing  \n    END IF  \n    SET root TO new instance of TreeNode with parameter element at position one of values  \n    SET i TO one  \n    SET queue TO new double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO element removed from left side of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS nothing  \n            SET left attribute of node TO new instance of TreeNode with parameter element at position i of values  \n            APPEND left attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS nothing  \n            SET right attribute of node TO new instance of TreeNode with parameter element at position i of values  \n            APPEND right attribute of node TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree with parameters p q  \n    IF p EQUALS nothing AND q EQUALS nothing  \n        RETURN True  \n    ELSE IF p EQUALS nothing OR q EQUALS nothing  \n        RETURN False  \n    ELSE IF val attribute of p NOT EQUALS val attribute of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree with parameters left attribute of p left attribute of q AND is_same_tree with parameters right attribute of p right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION insertIntoBST with parameters root val  \n        FUNCTION dfs with parameter root  \n            IF root EQUALS nothing  \n                RETURN new instance of TreeNode with parameter val  \n            END IF  \n            IF val attribute of root LESS THAN val  \n                SET right attribute of root TO dfs with parameter right attribute of root  \n            ELSE  \n                SET left attribute of root TO dfs with parameter left attribute of root  \n            END IF  \n            RETURN root  \n        END FUNCTION  \n        RETURN dfs with parameter root  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sentence-similarity-ii", "passing_rate": 0.25, "pseudocode": "CLASS Solution  \n    FUNCTION areSentencesSimilarTwo(sentence1  \n                                    sentence2  \n                                    similarPairs)  \n        IF the LENGTH OF sentence1 NOT EQUALS the LENGTH OF sentence2  \n            RETURN false  \n        END IF  \n\n        SET parent TO empty dictionary  \n\n        FUNCTION find(x)  \n            IF the element at key x IN parent NOT EQUALS x  \n                SET the element at key x IN parent TO find(the element at key x IN parent)  \n            END IF  \n            RETURN the element at key x IN parent  \n        END FUNCTION  \n\n        FUNCTION union(x  \n                       y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET the element at key rootY IN parent TO rootX  \n            END IF  \n        END FUNCTION  \n\n        FOR each pair IN similarPairs  \n            FOR each word IN pair  \n                IF word NOT IN parent  \n                    SET the element at key word IN parent TO word  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each element x AND each element y IN corresponding positions IN sentence1 AND sentence2  \n            IF x NOT IN parent  \n                SET the element at key x IN parent TO x  \n            END IF  \n            IF y NOT IN parent  \n                SET the element at key y IN parent TO y  \n            END IF  \n            IF find(x) NOT EQUALS find(y)  \n                RETURN false  \n            END IF  \n        END FOR  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "closest-leaf-in-a-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self val SET TO zero left SET TO none right SET TO none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode with value being the element at position zero of values  \n    SET i TO one  \n    SET queue TO a new deque  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS none  \n            SET node.left TO a new TreeNode with value being the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND element at position i of values NOT EQUALS none  \n            SET node.right TO a new TreeNode with value being the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN true  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN false  \n    ELSE IF p.val NOT EQUALS q.val  \n        RETURN false  \n    ELSE  \n        RETURN is_same_tree(p.left q.left) AND is_same_tree(p.right q.right)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION findClosestLeaf(self root k)  \n        IF root.left EQUALS none AND root.right EQUALS none  \n            RETURN root.val  \n        END IF  \n        SET graph TO a new default dictionary with list as default value  \n        FUNCTION dfs(node parent SET TO none)  \n            IF parent NOT EQUALS none  \n                APPEND parent.val TO element at key node.val in graph  \n                APPEND node.val TO element at key parent.val in graph  \n            END IF  \n            IF node.left NOT EQUALS none  \n                CALL dfs with node.left and node  \n            END IF  \n            IF node.right NOT EQUALS none  \n                CALL dfs with node.right and node  \n            END IF  \n        END FUNCTION  \n        CALL dfs with root  \n        SET queue TO a new deque initialized with element k  \n        SET visited TO a new empty set  \n        WHILE queue is not empty  \n            SET current TO the element removed from the front of queue  \n            ADD current TO visited  \n            IF the LENGTH OF element at key current in graph EQUALS one AND current NOT EQUALS root.val  \n                RETURN current  \n            END IF  \n            FOR each neighbor IN element at key current in graph  \n                IF neighbor NOT IN visited  \n                    APPEND neighbor TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "set-intersection-size-at-least-two", "passing_rate": 0.09523809523809523, "pseudocode": "CLASS Solution  \n    FUNCTION intersectionSizeTwo(intervals)  \n        SORT intervals BY the element at position two of each interval AND BY the negative of the element at position one of each interval IN descending order  \n        SET first TO the element at position two of the first interval MINUS one  \n        SET second TO the element at position two of the first interval  \n        SET count TO two  \n        FOR each interval FROM the second interval TO the last interval  \n            LET start BE the element at position one of the current interval  \n            LET end BE the element at position two of the current interval  \n            IF start IS GREATER THAN second  \n                SET first TO end MINUS one  \n                SET second TO end  \n                INCREMENT count BY two  \n            ELSE IF start IS GREATER THAN first  \n                SET first TO second  \n                SET second TO end  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reorganize-string", "passing_rate": 0.2222222222222222, "pseudocode": "CLASS Solution  \n    FUNCTION reorganizeString(s)  \n        SET count TO a collection mapping each character in s to its frequency  \n        SET max_heap TO an empty list  \n        FOR each character and frequency IN the collection of count  \n            APPEND the pair of the negative of the frequency and the character TO max_heap  \n        END FOR  \n        TRANSFORM max_heap INTO a heap structure preserving the heap invariant  \n        \n        SET prev_char TO a value representing none  \n        SET prev_freq TO zero  \n        SET result TO an empty list  \n        \n        WHILE the heap max_heap is not empty OR prev_freq is less than zero holds  \n            IF the heap max_heap is empty AND prev_freq is less than zero holds  \n                RETURN an empty string  \n            END IF  \n            \n            REMOVE the element with the smallest frequency value FROM max_heap and ASSIGN its frequency TO freq and character TO char  \n            APPEND char TO result  \n            \n            INCREMENT freq BY one  \n            \n            IF prev_freq is less than zero holds  \n                ADD the pair of prev_freq and prev_char INTO the heap max_heap  \n            END IF  \n            \n            SET prev_char TO char  \n            SET prev_freq TO freq  \n        END WHILE  \n        \n        RETURN the concatenation of all characters in result as a string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "basic-calculator-iv", "passing_rate": 0.6526315789473685, "pseudocode": "CLASS Term  \n    FUNCTION __init__ with parameters coefficient variables  \n        SET self coefficient TO coefficient  \n        SET self variables TO variables  \n    END FUNCTION  \n  \n    FUNCTION __lt__ with parameters other  \n        IF the LENGTH OF self variables NOT EQUALS the LENGTH OF other variables  \n            RETURN whether the LENGTH OF self variables IS GREATER THAN the LENGTH OF other variables  \n        END IF  \n        RETURN whether the STRING formed by JOINING self variables WITH the word MULTIPLIED BY IS LESS THAN the STRING formed by JOINING other variables WITH the word MULTIPLIED BY  \n    END FUNCTION  \n  \n    FUNCTION __repr__  \n        IF the LENGTH OF self variables EQUALS zero  \n            RETURN the STRING form of self coefficient  \n        END IF  \n        RETURN the STRING concatenation of the STRING form of self coefficient FOLLOWED BY the word MULTIPLIED BY FOLLOWED BY the STRING formed by JOINING self variables WITH the word MULTIPLIED BY  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Expression  \n    FUNCTION __init__  \n        SET self terms TO a new default dictionary mapping to zero  \n    END FUNCTION  \n  \n    FUNCTION add_term with parameter term  \n        SET key TO the tuple of the SORTED list of term variables  \n        INCREMENT the value at key in self terms BY term coefficient  \n    END FUNCTION  \n  \n    FUNCTION multiply with parameter other  \n        SET result TO a new Expression  \n        FOR each vars1 coeff1 PAIR IN the items of self terms  \n            FOR each vars2 coeff2 PAIR IN the items of other terms  \n                SET combined_vars TO the SORTED list formed by CONCATENATING vars1 AND vars2  \n                CALL result add_term WITH a new Term initialized with coefficient equal to coeff1 MULTIPLIED BY coeff2 and variables equal to combined_vars  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \n  \n    FUNCTION add with parameter other  \n        FOR each vars coeff PAIR IN the items of other terms  \n            CALL self add_term WITH a new Term initialized with coefficient coeff and variables equal to the list of vars  \n        END FOR  \n        RETURN self  \n    END FUNCTION  \n  \n    FUNCTION subtract with parameter other  \n        FOR each vars coeff PAIR IN the items of other terms  \n            CALL self add_term WITH a new Term initialized with coefficient MINUS coeff and variables equal to the list of vars  \n        END FOR  \n        RETURN self  \n    END FUNCTION  \n  \n    FUNCTION evaluate with parameter var_map  \n        SET result TO a new Expression  \n        FOR each vars coeff PAIR IN the items of self terms  \n            SET new_vars TO an empty list  \n            FOR each var IN vars  \n                IF var IS IN var_map  \n                    APPEND the STRING form of the value at var in var_map TO new_vars  \n                ELSE  \n                    APPEND var TO new_vars  \n                END IF  \n            END FOR  \n            IF the LENGTH OF new_vars IS GREATER THAN zero  \n                SET new_coeff TO the evaluation of the STRING formed by JOINING all elements in new_vars with empty separation  \n            ELSE  \n                SET new_coeff TO one  \n            END IF  \n            CALL result add_term WITH a new Term initialized with coefficient equal to coeff MULTIPLIED BY new_coeff and variables equal to an empty list  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \n  \n    FUNCTION simplify  \n        SET simplified_terms TO a list  \n        FOR each vars coeff PAIR IN the items of self terms  \n            IF coeff NOT EQUALS zero  \n                APPEND a new Term initialized with coefficient coeff and variables equal to the list of vars TO simplified_terms  \n            END IF  \n        END FOR  \n        SORT simplified_terms  \n        RETURN simplified_terms  \n    END FUNCTION  \n  \n    FUNCTION __repr__  \n        RETURN the STRING formed by JOINING with the string plus the list obtained by MAPPING the __repr__ function OVER the result of calling self simplify  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION basicCalculatorIV with parameters expression evalvars evalints  \n        SET var_map TO a dictionary formed by pairing elements of evalvars WITH elements of evalints  \n        SET tokens TO the list of substrings found in expression matching the pattern consisting of any one of the following single characters parenthesis left parenthesis right plus minus asterisk or a sequence of digits or a sequence of word characters  \n        SET output TO an empty list  \n        SET operators TO an empty list  \n  \n        FUNCTION apply_operator  \n            SET right TO the last element REMOVED FROM output  \n            SET left TO the last element REMOVED FROM output  \n            SET op TO the last element REMOVED FROM operators  \n            IF op EQUALS the string plus  \n                APPEND to output the result of calling left add WITH right  \n            ELSE IF op EQUALS the string minus  \n                APPEND to output the result of calling left subtract WITH right  \n            ELSE IF op EQUALS the string asterisk  \n                APPEND to output the result of calling left multiply WITH right  \n            END IF  \n        END FUNCTION  \n  \n        SET i TO zero  \n        WHILE i IS LESS THAN the LENGTH OF tokens  \n            SET token TO the element at position i of tokens  \n            IF token is a sequence consisting only of digits  \n                APPEND a new Expression TO output  \n                CALL the last element of output add_term WITH a new Term initialized with coefficient equal to the integer value of token and variables equal to an empty list  \n            ELSE IF token is a sequence consisting only of alphabetic characters  \n                APPEND a new Expression TO output  \n                SET coef TO the value at token in var_map IF it EXISTS otherwise one  \n                IF coef EQUALS one  \n                    CALL the last element of output add_term WITH a new Term initialized with coefficient one and variables equal to a list containing token IF token NOT IN var_map otherwise an empty list  \n                ELSE  \n                    CALL the last element of output add_term WITH a new Term initialized with coefficient coef and variables equal to an empty list  \n                END IF  \n            ELSE IF token EQUALS the string left parenthesis  \n                APPEND token TO operators  \n            ELSE IF token EQUALS the string right parenthesis  \n                WHILE operators is not empty AND the last element of operators NOT EQUALS the string left parenthesis  \n                    CALL apply_operator  \n                END WHILE  \n                REMOVE the last element from operators  \n            ELSE IF token is one of the strings plus minus asterisk  \n                WHILE operators is not empty AND the last element of operators NOT EQUALS the string left parenthesis AND (token EQUALS plus OR token EQUALS minus OR the last element of operators EQUALS the string asterisk)  \n                    CALL apply_operator  \n                END WHILE  \n                APPEND token TO operators  \n            END IF  \n            INCREMENT i BY one  \n        END WHILE  \n  \n        WHILE operators is not empty  \n            CALL apply_operator  \n        END WHILE  \n  \n        SET simplified_terms TO the result of calling simplify ON the first element of output  \n        SET result TO an empty list  \n        FOR each term IN simplified_terms  \n            IF the LENGTH OF term variables IS GREATER THAN zero  \n                APPEND the STRING concatenation of the STRING form of term coefficient FOLLOWED BY the word MULTIPLIED BY FOLLOWED BY the STRING formed by JOINING term variables WITH the word MULTIPLIED BY TO result  \n            ELSE  \n                APPEND the STRING form of term coefficient TO result  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swim-in-rising-water", "passing_rate": 0.37037037037037035, "pseudocode": "CLASS Solution  \n    FUNCTION swimInWater(grid)  \n        SET n TO the LENGTH OF grid  \n        SET visited TO an empty set  \n        SET min_heap TO a list containing a tuple of the element at position zero of row zero of grid FOLLOWED BY zero FOLLOWED BY zero  \n        ADD a tuple of zero FOLLOWED BY zero TO visited  \n        SET directions TO a list containing the tuples of zero FOLLOWED BY one FOLLOWED BY one FOLLOWED BY zero FOLLOWED BY zero FOLLOWED BY MINUS one FOLLOWED BY MINUS one FOLLOWED BY zero  \n        \n        WHILE min_heap is not empty  \n            REMOVE the element with the smallest first value of min_heap AND ASSIGN IT TO t AND i AND j  \n            IF i EQUALS n MINUS one AND j EQUALS n MINUS one  \n                RETURN t  \n            END IF  \n            \n            FOR each di AND dj IN directions  \n                SET ni TO i PLUS di  \n                SET nj TO j PLUS dj  \n                IF ni IS GREATER THAN OR EQUAL TO zero AND ni IS LESS THAN n AND nj IS GREATER THAN OR EQUAL TO zero AND nj IS LESS THAN n AND the tuple of ni FOLLOWED BY nj IS NOT IN visited  \n                    ADD the tuple of ni FOLLOWED BY nj TO visited  \n                    ADD to min_heap the tuple of the GREATER VALUE BETWEEN t AND the element at position ni of row nj of grid FOLLOWED BY ni FOLLOWED BY nj  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "letter-case-permutation", "passing_rate": 0.24242424242424243, "pseudocode": "CLASS Solution  \n    FUNCTION letterCasePermutation(s)  \n        FUNCTION dfs(i)  \n            IF i GREATER THAN OR EQUAL TO the LENGTH OF t  \n                APPEND concatenation of elements of t TO ans  \n                RETURN  \n            END IF  \n            CALL dfs WITH argument i PLUS one  \n            IF element at position i of t IS an alphabetic character  \n                SET element at position i of t TO the character obtained by toggling case of element at position i of t  \n                CALL dfs WITH argument i PLUS one  \n            END IF  \n        END FUNCTION  \n        SET t TO the list of characters of s  \n        SET ans TO an empty list  \n        CALL dfs WITH argument zero  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-pruning", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self val SET TO zero left SET TO none right SET TO none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty  \n        RETURN none  \n    END IF  \n    SET root TO new TreeNode with value equal to element at position one of values  \n    SET i TO one  \n    SET queue TO new deque structure  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO element removed from the left end of queue  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS none  \n            SET node.left TO new TreeNode with value equal to element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the length of values AND element at position i of values NOT EQUALS none  \n            SET node.right TO new TreeNode with value equal to element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF the value of p NOT EQUALS the value of q  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree with arguments p.left and q.left AND is_same_tree with arguments p.right and q.right  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION pruneTree(self root)  \n        IF root EQUALS none  \n            RETURN none  \n        END IF  \n        SET root.left TO the result of calling pruneTree on root.left  \n        SET root.right TO the result of calling pruneTree on root.right  \n        IF the value of root EQUALS zero AND root.left EQUALS none AND root.right EQUALS none  \n            RETURN none  \n        END IF  \n        RETURN root  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "count-unique-characters-of-all-substrings-of-a-given-string", "passing_rate": 0.6666666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION uniqueLetterString(s)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET n TO the LENGTH OF s  \n        SET last TO a list of negative one repeated twenty six times  \n        SET last2 TO a list of negative one repeated twenty six times  \n        SET result TO zero  \n        FOR each position i and character char IN s with enumeration  \n            SET idx TO the character code number of char MINUS the character code number of uppercase A  \n            SET contribution TO (position i MINUS element at position idx of last) MULTIPLIED BY (element at position idx of last MINUS element at position idx of last2)  \n            SET result TO result PLUS contribution  \n            SET result TO result MODULO MOD  \n            SET element at position idx of last2 TO element at position idx of last  \n            SET element at position idx of last TO position i  \n        END FOR  \n        FOR each index i FROM zero TO twenty five  \n            SET contribution TO (n MINUS element at position i of last) MULTIPLIED BY (element at position i of last MINUS element at position i of last2)  \n            SET result TO result PLUS contribution  \n            SET result TO result MODULO MOD  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "similar-string-groups", "passing_rate": 0.6190476190476191, "pseudocode": "CLASS Solution  \n    FUNCTION numSimilarGroups(strs)  \n        FUNCTION are_similar(s1 s2)  \n            SET diff TO empty list  \n            FOR each index FROM zero TO the LENGTH OF s1 MINUS one  \n                IF element at position index of s1 NOT EQUALS element at position index of s2  \n                    APPEND index TO diff  \n                END IF  \n            END FOR  \n            RETURN the LENGTH OF diff EQUALS zero OR the LENGTH OF diff EQUALS two AND element at position element at position zero of diff of s1 EQUALS element at position element at position one of diff of s2 AND element at position element at position one of diff of s1 EQUALS element at position element at position zero of diff of s2  \n        END FUNCTION  \n        \n        FUNCTION dfs(node visited)  \n            ADD node TO visited  \n            FOR each neighbor IN element at position node of graph  \n                IF neighbor NOT IN visited  \n                    CALL dfs WITH neighbor visited  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        SET n TO the LENGTH OF strs  \n        SET graph TO a new mapping from each index FROM zero TO n MINUS one TO empty list  \n        \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM i PLUS one TO n MINUS one  \n                IF call are_similar WITH element at position i of strs element at position j of strs RETURNS true  \n                    APPEND j TO element at position i of graph  \n                    APPEND i TO element at position j of graph  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET visited TO empty set  \n        SET num_groups TO zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF i NOT IN visited  \n                CALL dfs WITH i visited  \n                INCREMENT num_groups BY one  \n            END IF  \n        END FOR  \n        \n        RETURN num_groups  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "score-after-flipping-matrix", "passing_rate": 0.019230769230769232, "pseudocode": "CLASS Solution  \n    FUNCTION matrixScore(grid)  \n        FOR each row IN grid  \n            IF element at position one of row EQUALS zero  \n                FOR index FROM one TO the LENGTH OF row  \n                    SET element at position index of row TO one MINUS element at position index of row  \n                END FOR  \n            END IF  \n        END FOR  \n        FOR col FROM two TO the LENGTH OF element at position one of grid  \n            SET count_ones TO zero  \n            FOR row_index FROM one TO the LENGTH OF grid  \n                INCREMENT count_ones BY element at position col of element at position row_index of grid  \n            END FOR  \n            IF count_ones LESS THAN the LENGTH OF grid DIVIDED BY two  \n                FOR row_index FROM one TO the LENGTH OF grid  \n                    SET element at position col of element at position row_index of grid TO one MINUS element at position col of element at position row_index of grid  \n                END FOR  \n            END IF  \n        END FOR  \n        SET score TO zero  \n        FOR each row IN grid  \n            SET binary_number_string TO empty string  \n            FOR each bit IN row  \n                APPEND the string representation of bit TO binary_number_string  \n            END FOR  \n            SET score TO score PLUS the integer value of binary_number_string interpreted in base two  \n        END FOR  \n        RETURN score  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-subtree-with-all-the-deepest-nodes", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with val equal to element at position zero of values  \n    SET i TO one  \n    SET queue TO empty double ended queue  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO element removed from the front of queue  \n        IF i LESS THAN length of values AND element at position i of values NOT EQUAL TO None THEN  \n            SET node.left TO new TreeNode with val equal to element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN length of values AND element at position i of values NOT EQUAL TO None THEN  \n            SET node.right TO new TreeNode with val equal to element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF value at p NOT EQUAL TO value at q THEN  \n        RETURN False  \n    ELSE  \n        RETURN is_same_tree(left node of p, left node of q) AND is_same_tree(right node of p, right node of q)  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION subtreeWithAllDeepest(self, root)  \n        FUNCTION dfs(node)  \n            IF node EQUALS None THEN  \n                RETURN node AND zero  \n            END IF  \n            SET left_node AND left_depth TO dfs(left node of node)  \n            SET right_node AND right_depth TO dfs(right node of node)  \n            IF left_depth GREATER THAN right_depth THEN  \n                RETURN left_node AND left_depth PLUS one  \n            ELSE IF right_depth GREATER THAN left_depth THEN  \n                RETURN right_node AND right_depth PLUS one  \n            ELSE  \n                RETURN node AND left_depth PLUS one  \n            END IF  \n        END FUNCTION  \n        RETURN first element of dfs(root)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "prime-palindrome", "passing_rate": 0.5925925925925926, "pseudocode": "CLASS Solution  \n    FUNCTION primePalindrome(n)  \n        FUNCTION is_prime(num)  \n            IF num LESS THAN two  \n                RETURN false  \n            END IF  \n            IF num EQUALS two OR num EQUALS three  \n                RETURN true  \n            END IF  \n            IF num MODULO two EQUALS zero OR num MODULO three EQUALS zero  \n                RETURN false  \n            END IF  \n            SET i TO five  \n            WHILE i MULTIPLIED BY i LESS THAN OR EQUAL TO num  \n                IF num MODULO i EQUALS zero OR num MODULO (i PLUS two) EQUALS zero  \n                    RETURN false  \n                END IF  \n                INCREMENT i BY six  \n            END WHILE  \n            RETURN true  \n        END FUNCTION  \n\n        FUNCTION is_palindrome(num)  \n            RETURN the string representation of num EQUALS the string representation of num REVERSED  \n        END FUNCTION  \n\n        IF n LESS THAN OR EQUAL TO two  \n            RETURN two  \n        END IF  \n\n        IF n GREATER THAN OR EQUAL TO ten AND n LESS THAN OR EQUAL TO eleven  \n            RETURN eleven  \n        END IF  \n\n        WHILE true  \n            IF n MODULO two EQUALS zero  \n                INCREMENT n BY one  \n                CONTINUE TO next iteration of WHILE  \n            END IF  \n\n            IF is_palindrome(n) AND is_prime(n)  \n                RETURN n  \n            END IF  \n\n            IF the LENGTH OF the string representation of n MODULO two EQUALS zero  \n                SET n TO ten RAISED TO THE POWER OF the LENGTH OF the string representation of n PLUS one  \n            ELSE  \n                INCREMENT n BY two  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "profitable-schemes", "passing_rate": 0.0, "pseudocode": "CLASS Solution  \n    FUNCTION profitableSchemes(n profit_minimum group profit)  \n        SET constant_mod TO ten POWERED BY nine PLUS one  \n        SET dp TO a list containing n PLUS one elements where each element IS a list containing profit_minimum PLUS one zeros  \n        FOR index_i FROM zero TO n  \n            SET element at position zero of element at position index_i of dp TO one  \n        END FOR  \n        \n        FOR each element_profit AND element_group IN profit AND group RESPECTIVELY  \n            FOR index_i FROM n DOWN TO element_group  \n                FOR index_j FROM profit_minimum DOWN TO zero  \n                    SET value_previous TO element at position index_i MINUS element_group of dp  \n                    SET j_minus_p TO index_j MINUS element_profit  \n                    IF j_minus_p LESS THAN zero  \n                        SET j_minus_p TO zero  \n                    END IF  \n                    SET value_to_add TO element at position j_minus_p of value_previous  \n                    SET element at position index_j of element at position index_i of dp TO element at position index_j of element at position index_i of dp PLUS value_to_add  \n                    SET element at position index_j of element at position index_i of dp TO element at position index_j of element at position index_i of dp MODULO constant_mod  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position profit_minimum of element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimize-malware-spread-ii", "passing_rate": 0.56, "pseudocode": "CLASS Solution  \n    FUNCTION minMalwareSpread(graph AS List OF List OF integer, initial AS List OF integer) RETURNS integer  \n        SET number_of_nodes TO the LENGTH OF graph  \n        SET adjacency_list TO a new mapping from integer to list of integers with default empty list  \n        FOR index i FROM zero TO number_of_nodes MINUS one  \n            FOR index j FROM i PLUS one TO number_of_nodes MINUS one  \n                IF the element at position j of the list at position i of graph EQUALS one  \n                    APPEND j TO the list at position i of adjacency_list  \n                    APPEND i TO the list at position j of adjacency_list  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FUNCTION dfs(node AS integer, visited AS set) RETURNS integer  \n            IF visited CONTAINS node  \n                RETURN zero  \n            END IF  \n            ADD node TO visited  \n            SET component_size TO one  \n            FOR each neighbor IN the list at position node of adjacency_list  \n                SET component_size TO component_size PLUS the result of dfs called with neighbor and visited  \n            END FOR  \n            RETURN component_size  \n        END FUNCTION  \n\n        SET infected_nodes TO a new set initialized with all elements of initial  \n        SET component_sizes TO an empty list  \n        SET visited_nodes TO an empty set  \n        SET component_indices TO a new mapping from integer to integer  \n\n        FOR each node FROM zero TO number_of_nodes MINUS one  \n            IF visited_nodes DOES NOT CONTAIN node AND infected_nodes DOES NOT CONTAIN node  \n                SET size_of_component TO the result of dfs called with node and visited_nodes  \n                APPEND size_of_component TO component_sizes  \n                FOR index i FROM the LENGTH OF component_sizes MINUS one DOWN TO zero  \n                    IF the element at position i of component_sizes EQUALS size_of_component  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n                FOR each neighbor IN the list at position node of adjacency_list  \n                    SET the element at position neighbor of component_indices TO i  \n                END FOR  \n            END IF  \n        END FOR  \n\n        SET infected_count_per_component TO a new mapping from integer to integer with default zero  \n        FOR each node IN infected_nodes  \n            IF component_indices CONTAINS the key node  \n                INCREMENT the element at position node of component_indices in infected_count_per_component BY one  \n            END IF  \n        END FOR  \n\n        SET maximum_size TO zero  \n        SET node_to_remove TO the minimum element of initial  \n\n        FOR each node IN infected_nodes  \n            IF component_indices CONTAINS the key node  \n                SET component_index TO the element at position node of component_indices  \n                IF the element at position component_index of infected_count_per_component EQUALS one  \n                    IF the element at position component_index of component_sizes GREATER THAN maximum_size  \n                        SET maximum_size TO the element at position component_index of component_sizes  \n                        SET node_to_remove TO node  \n                    ELSE IF the element at position component_index of component_sizes EQUALS maximum_size  \n                        IF node LESS THAN node_to_remove  \n                            SET node_to_remove TO node  \n                        END IF  \n                    END IF  \n                END IF  \n            END IF  \n        END FOR  \n\n        RETURN node_to_remove  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-tree-cameras", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN no value  \n    END IF  \n    SET root TO new TreeNode with value equal to the element at position one of values and left and right as no value  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is greater than zero  \n        SET node TO the first element removed FROM queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not no value THEN  \n            ASSIGN reference TO new TreeNode with value equal to the element at position i of values and left and right as no value  \n            SET node.left TO this new TreeNode  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values is not no value THEN  \n            ASSIGN reference TO new TreeNode with value equal to the element at position i of values and left and right as no value  \n            SET node.right TO this new TreeNode  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p is no value AND q is no value THEN  \n        RETURN true  \n    ELSE IF p is no value OR q is no value THEN  \n        RETURN false  \n    ELSE IF the value of p NOT EQUALS the value of q THEN  \n        RETURN false  \n    ELSE  \n        RETURN the result of calling is_same_tree with the left child of p AND the left child of q AND the result of calling is_same_tree with the right child of p AND the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION minCameraCover(self, root)  \n        FUNCTION dfs(node)  \n            IF node is no value THEN  \n                RETURN zero no camera value, zero monitored value, infinite camera value  \n            END IF  \n            SET left_no_camera, left_monitored, left_camera TO the result of calling dfs with the left child of node  \n            SET right_no_camera, right_monitored, right_camera TO the result of calling dfs with the right child of node  \n            SET no_camera TO left_monitored PLUS right_monitored  \n            SET monitored TO the minimum of the following three values  \n                left_camera PLUS the minimum of right_monitored AND right_camera  \n                right_camera PLUS the minimum of left_monitored AND left_camera  \n                left_camera PLUS right_camera  \n            SET camera TO one PLUS the minimum of left_no_camera, left_monitored, and left_camera PLUS the minimum of right_no_camera, right_monitored, and right_camera  \n            RETURN no_camera, monitored, camera  \n        END FUNCTION  \n        SET root_no_camera, root_monitored, root_camera TO the result of calling dfs with root  \n        RETURN the minimum of root_monitored AND root_camera  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "vertical-order-traversal-of-a-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val EQUALS zero, left EQUALS none, right EQUALS none)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero  \n        RETURN none  \n    END IF  \n    SET root TO a new TreeNode initialized with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double-ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue is GREATER THAN zero  \n        SET node TO the element removed from the front of queue  \n        IF i is LESS THAN the LENGTH OF values AND the element at position i of values is NOT EQUALS none  \n            SET node.left TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i is LESS THAN the LENGTH OF values AND the element at position i of values is NOT EQUALS none  \n            SET node.right TO a new TreeNode initialized with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS none AND q EQUALS none  \n        RETURN True  \n    ELSE IF p EQUALS none OR q EQUALS none  \n        RETURN False  \n    ELSE IF the value of p IS NOT EQUALS the value of q  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of the result of is_same_tree on the left child of p and the left child of q AND the result of is_same_tree on the right child of p and the right child of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION verticalTraversal(self, root)  \n        IF root EQUALS none  \n            RETURN an empty list  \n        END IF  \n        SET node_dict TO a default dictionary mapping keys to empty lists  \n        SET min_col TO zero  \n        SET max_col TO zero  \n\n        FUNCTION dfs(node, row, col)  \n            IF node EQUALS none  \n                RETURN  \n            END IF  \n            APPEND a tuple consisting of row and the value of node TO the list at key col in node_dict  \n            SET min_col TO the smaller of min_col and col  \n            SET max_col TO the larger of max_col and col  \n            CALL dfs with the left child of node, row PLUS one, col MINUS one  \n            CALL dfs with the right child of node, row PLUS one, col PLUS one  \n        END FUNCTION  \n\n        CALL dfs with root, zero, zero  \n\n        SET result TO an empty list  \n        FOR each col FROM min_col TO max_col  \n            SET values_list TO an empty list  \n            FOR each pair consisting of row_value and node_value IN the list at key col in node_dict sorted by first element then second element  \n                APPEND node_value TO values_list  \n            END FOR  \n            APPEND values_list TO result  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shortest-common-supersequence", "passing_rate": 0.2608695652173913, "pseudocode": "CLASS Solution  \n    FUNCTION shortestCommonSupersequence(str1 parameter, str2 parameter)  \n        SET m TO the LENGTH OF str1  \n        SET n TO the LENGTH OF str2  \n        SET dp TO a two dimensional list of zeroes with dimensions m PLUS one by n PLUS one  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF the element at position i MINUS one of str1 EQUALS the element at position j MINUS one of str2  \n                    SET element at position i and j of dp TO element at position i MINUS one and j MINUS one of dp PLUS one  \n                ELSE  \n                    SET element at position i and j of dp TO the GREATER OF element at position i MINUS one and j of dp AND element at position i and j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET i TO m  \n        SET j TO n  \n        SET scs TO an empty list  \n        \n        WHILE i GREATER THAN zero AND j GREATER THAN zero  \n            IF the element at position i MINUS one of str1 EQUALS the element at position j MINUS one of str2  \n                APPEND the element at position i MINUS one of str1 TO scs  \n                DECREMENT i BY one  \n                DECREMENT j BY one  \n            ELSE IF element at position i MINUS one and j of dp GREATER THAN element at position i and j MINUS one of dp  \n                APPEND the element at position i MINUS one of str1 TO scs  \n                DECREMENT i BY one  \n            ELSE  \n                APPEND the element at position j MINUS one of str2 TO scs  \n                DECREMENT j BY one  \n            END IF  \n        END WHILE  \n        \n        WHILE i GREATER THAN zero  \n            APPEND the element at position i MINUS one of str1 TO scs  \n            DECREMENT i BY one  \n        END WHILE  \n        \n        WHILE j GREATER THAN zero  \n            APPEND the element at position j MINUS one of str2 TO scs  \n            DECREMENT j BY one  \n        END WHILE  \n        \n        REVERSE the order of scs  \n        \n        RETURN the concatenation of all elements in scs  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-sufficient-team", "passing_rate": 0.6052631578947368, "pseudocode": "CLASS Solution  \n    FUNCTION smallestSufficientTeam(self, req_skills, people)  \n        INITIALIZE skill_to_index_map AS empty mapping  \n        SET skill_index TO zero  \n        FOR each skill IN req_skills  \n            ASSIGN skill_index TO the current skill in skill_to_index_map  \n            INCREMENT skill_index BY one  \n        END FOR  \n        SET total_skills TO the LENGTH OF req_skills  \n        SET total_people TO the LENGTH OF people  \n        INITIALIZE skill_bit_mask_list AS list of zeros with LENGTH total_people  \n        FOR person_index FROM zero TO total_people MINUS one  \n            FOR each skill IN the list of skills for the person at person_index IN people  \n                SET the element at person_index in skill_bit_mask_list TO the element at person_index in skill_bit_mask_list OR a bit shifted by the skill index from skill_to_index_map for the skill  \n            END FOR  \n        END FOR  \n        INITIALIZE f_list AS list of infinite values with LENGTH TWO POWER total_skills  \n        INITIALIZE g_list AS list of zeros with LENGTH TWO POWER total_skills  \n        INITIALIZE h_list AS list of zeros with LENGTH TWO POWER total_skills  \n        SET the element at position zero in f_list TO zero  \n        FOR skill_state FROM zero TO TWO POWER total_skills MINUS one  \n            IF the element at position skill_state in f_list EQUALS infinite  \n                CONTINUE to next iteration  \n            END IF  \n            FOR person_index FROM zero TO total_people MINUS one  \n                SET combined_state TO skill_state OR the element at person_index in skill_bit_mask_list  \n                IF the element at skill_state in f_list PLUS one LESS THAN the element at combined_state in f_list  \n                    SET the element at combined_state in f_list TO the element at skill_state in f_list PLUS one  \n                    SET the element at combined_state in g_list TO person_index  \n                    SET the element at combined_state in h_list TO skill_state  \n                END IF  \n            END FOR  \n        END FOR  \n        SET current_state TO TWO POWER total_skills MINUS one  \n        INITIALIZE answer_list AS empty list  \n        WHILE current_state NOT EQUAL TO zero  \n            APPEND the element at current_state in g_list TO answer_list  \n            SET current_state TO the element at current_state in h_list  \n        END WHILE  \n        RETURN answer_list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-valid-words-for-each-puzzle", "passing_rate": 0.4594594594594595, "pseudocode": "CLASS Solution  \n    FUNCTION findNumOfValidWords(words words LIST OF STRING puzzles puzzles LIST OF STRING) RETURNS LIST OF INTEGER  \n        FUNCTION to_mask(s s STRING) RETURNS INTEGER  \n            SET mask TO zero  \n            FOR each char IN s  \n                SET mask TO mask OR one SHIFTED LEFT BY the numeric position of char MINUS the numeric position of letter a  \n            END FOR  \n            RETURN mask  \n        END FUNCTION  \n        \n        SET word_count TO a dictionary with default value zero  \n        FOR each word IN words  \n            SET mask TO to_mask with word  \n            IF the number of bits set in mask IS LESS THAN OR EQUAL TO seven  \n                INCREMENT the value in word_count at mask BY one  \n            END IF  \n        END FOR  \n        \n        SET result TO an empty list  \n        FOR each puzzle IN puzzles  \n            SET first_char_mask TO one SHIFTED LEFT BY the numeric position of element at position zero of puzzle MINUS the numeric position of letter a  \n            SET puzzle_mask TO to_mask of the substring from position one TO the end of puzzle  \n            SET count TO the value in word_count at first_char_mask  \n            \n            SET subset TO puzzle_mask  \n            WHILE subset IS NOT zero  \n                SET count TO count PLUS the value in word_count at the bitwise OR of subset AND first_char_mask  \n                SET subset TO the bitwise AND of subset MINUS one AND puzzle_mask  \n            END WHILE  \n            \n            APPEND count TO result  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-paths-with-max-score", "passing_rate": 0.7674418604651163, "pseudocode": "CLASS Solution  \n    FUNCTION pathsWithMaxScore(board)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET n TO the LENGTH OF board  \n        SET dp TO a two dimensional collection of size n by n where each element is a list containing negative infinity and zero  \n        SET element at position n MINUS one of dp at position n MINUS one TO a list containing zero and one  \n        FOR i FROM n MINUS one DOWN TO zero  \n            FOR j FROM n MINUS one DOWN TO zero  \n                IF the element at position i of board at position j EQUALS the character X OR the element at position i of board at position j EQUALS the character S  \n                    CONTINUE to the next iteration of the inner loop  \n                END IF  \n                IF the element at position i of board at position j NOT EQUALS the character E  \n                    SET value TO the integer conversion of the element at position i of board at position j  \n                ELSE  \n                    SET value TO zero  \n                END IF  \n                FOR each pair of x and y IN the collection containing the pairs one and zero, zero and one, one and one  \n                    SET ni TO i PLUS x  \n                    SET nj TO j PLUS y  \n                    IF ni GREATER THAN OR EQUAL TO zero AND ni LESS THAN n AND nj GREATER THAN OR EQUAL TO zero AND nj LESS THAN n  \n                        IF the first element of dp at position ni of dp at position nj GREATER THAN the first element of dp at position i of dp at position j  \n                            SET dp at position i of dp at position j TO a list containing the sum of the first element of dp at position ni of dp at position nj PLUS value and the second element of dp at position ni of dp at position nj  \n                        ELSE IF the first element of dp at position ni of dp at position nj EQUALS the first element of dp at position i of dp at position j  \n                            SET the second element of dp at position i of dp at position j TO the sum of the second element of dp at position i of dp at position j PLUS the second element of dp at position ni of dp at position nj MODULO MOD  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        IF the first element of dp at position zero of dp at position zero EQUALS negative infinity  \n            RETURN a list containing zero and zero  \n        END IF  \n        RETURN a list containing the first element of dp at position zero of dp at position zero and the second element of dp at position zero of dp at position zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-all-valid-pickup-and-delivery-options", "passing_rate": 0.0625, "pseudocode": "CLASS Solution  \n    FUNCTION countOrders WITH PARAMETER n  \n        SET MOD TO the number one followed by nine zeros PLUS the number seven  \n        SET count TO the number one  \n        FOR i FROM the number two TO n  \n            SET count TO count MULTIPLIED BY i MULTIPLIED BY the number two MULTIPLIED BY i MINUS the number one  \n            SET count TO count MODULO MOD  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-sum-bst-in-binary-tree", "passing_rate": 0.0, "pseudocode": "CLASS TreeNode  \n    FUNCTION __init__(self, val, left, right)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF the LENGTH OF values EQUALS zero THEN  \n        RETURN None  \n    END IF  \n    SET root TO a new TreeNode with the element at position one of values  \n    SET i TO one  \n    SET queue TO an empty double ended queue  \n    APPEND root TO queue  \n    WHILE the LENGTH OF queue GREATER THAN zero  \n        SET node TO the element removed from the front of queue  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.left TO a new TreeNode with the element at position i of values  \n            APPEND node.left TO queue  \n        END IF  \n        INCREMENT i BY one  \n        IF i LESS THAN the LENGTH OF values AND the element at position i of values NOT EQUALS None THEN  \n            SET node.right TO a new TreeNode with the element at position i of values  \n            APPEND node.right TO queue  \n        END IF  \n        INCREMENT i BY one  \n    END WHILE  \n    RETURN root  \nEND FUNCTION  \n\nFUNCTION is_same_tree(p, q)  \n    IF p EQUALS None AND q EQUALS None THEN  \n        RETURN True  \n    ELSE IF p EQUALS None OR q EQUALS None THEN  \n        RETURN False  \n    ELSE IF the val attribute of p NOT EQUALS the val attribute of q THEN  \n        RETURN False  \n    ELSE  \n        RETURN the logical AND of calling is_same_tree with the left attribute of p and the left attribute of q AND calling is_same_tree with the right attribute of p and the right attribute of q  \n    END IF  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION maxSumBST(self, root)  \n        SET self.max_sum TO zero  \n        \n        FUNCTION helper(node)  \n            IF node EQUALS None THEN  \n                RETURN True AND zero AND positive infinity AND negative infinity IN THAT ORDER  \n            END IF  \n            SET left_is_bst AND left_sum AND left_min AND left_max TO the result of calling helper with the left attribute of node  \n            SET right_is_bst AND right_sum AND right_min AND right_max TO the result of calling helper with the right attribute of node  \n            IF left_is_bst EQUALS True AND right_is_bst EQUALS True AND left_max LESS THAN the val attribute of node AND the val attribute of node LESS THAN right_min THEN  \n                SET current_sum TO left_sum PLUS right_sum PLUS the val attribute of node  \n                SET current_min TO the smaller value of the val attribute of node AND left_min  \n                SET current_max TO the larger value of the val attribute of node AND right_max  \n                SET self.max_sum TO the larger value of self.max_sum AND current_sum  \n                RETURN True AND current_sum AND current_min AND current_max IN THAT ORDER  \n            END IF  \n            RETURN False AND zero AND positive infinity AND negative infinity IN THAT ORDER  \n        END FUNCTION  \n        \n        CALL helper with root  \n        RETURN self.max_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-ways-to-distribute-candies", "passing_rate": 0.35, "pseudocode": "CLASS Solution  \n    FUNCTION waysToDistribute(n parameter n INTEGER, k parameter k INTEGER) RETURNS INTEGER  \n        SET MOD TO ten POWER nine PLUS one  \n        SET dp TO a new two dimensional list with n PLUS one rows and k PLUS one columns each initialized to zero  \n        SET element at position zero of row zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM one TO k  \n                SET element at position j of row i of dp TO the remainder after dividing the sum of the product of j AND the element at position j of row i MINUS one of dp AND the element at position j MINUS one of row i MINUS one of dp BY MOD  \n            END FOR  \n        END FOR  \n        RETURN the element at position k of row n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tree-of-coprimes", "passing_rate": 0.6052631578947368, "pseudocode": "CLASS Solution  \n    FUNCTION getCoprimes(nums, edges)  \n        SET n TO the LENGTH OF nums  \n        SET tree TO a mapping from integer to a list of integers with default empty list  \n        FOR each pair u and v IN edges  \n            APPEND v TO the list at key u in tree  \n            APPEND u TO the list at key v in tree  \n        END FOR  \n          \n        SET coprime TO a two-dimensional list of boolean values with dimensions fifty by fifty all initialized to false  \n        FOR i FROM one TO fifty  \n            FOR j FROM one TO fifty  \n                SET coprime at position i and j TO the value of greatest common divisor of i and j EQUALS one  \n            END FOR  \n        END FOR  \n          \n        SET result TO a list of length n all initialized to negative one  \n        SET ancestor_stack TO a list of length fifty one all initialized to none  \n          \n        FUNCTION dfs(node, parent, depth)  \n            SET closest_ancestor TO negative one  \n            SET max_depth TO negative one  \n            FOR value FROM one TO fifty  \n                IF coprime at position nums at position node and value EQUALS true AND ancestor_stack at position value IS NOT none THEN  \n                    DECOMPOSE ancestor_stack at position value INTO anc_node AND anc_depth  \n                    IF anc_depth GREATER THAN max_depth THEN  \n                        SET max_depth TO anc_depth  \n                        SET closest_ancestor TO anc_node  \n                    END IF  \n                END IF  \n            END FOR  \n            SET result at position node TO closest_ancestor  \n              \n            SET original_ancestor TO ancestor_stack at position nums at position node  \n            SET ancestor_stack at position nums at position node TO the tuple of node AND depth  \n              \n            FOR each child IN the list at key node in tree  \n                IF child NOT EQUALS parent THEN  \n                    CALL dfs WITH child AND node AND depth PLUS one  \n                END IF  \n            END FOR  \n              \n            SET ancestor_stack at position nums at position node TO original_ancestor  \n        END FUNCTION  \n          \n        CALL dfs WITH zero AND negative one AND zero  \n          \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "make-the-xor-of-all-segments-equal-to-zero", "passing_rate": 0.575, "pseudocode": "CLASS Solution  \n    FUNCTION minChanges(nums AS list OF integers, k AS integer) RETURNS integer  \n        SET groups TO a dictionary having default empty list  \n        FOR i FROM zero TO the length of nums MINUS one  \n            APPEND element at position i of nums TO element at position i MINUS the integer division of i BY k MULTIPLIED BY k of groups  \n        END FOR  \n        \n        SET freq TO a list containing k dictionaries having default zero integer  \n        SET min_size TO a list containing k elements each initialized to infinity  \n        \n        FOR i FROM zero TO k MINUS one  \n            FOR each num IN element at position i of groups  \n                INCREMENT element at key num of element at position i of freq BY one  \n            END FOR  \n            SET element at position i of min_size TO the length of element at position i of groups  \n        END FOR  \n        \n        SET dp TO a list containing two raised to the power of ten elements each initialized to infinity  \n        SET element at position zero of dp TO zero  \n        \n        FOR i FROM zero TO k MINUS one  \n            SET new_dp TO a list containing two raised to the power of ten elements each initialized to infinity  \n            SET min_dp TO the minimum value in dp  \n            FOR j FROM zero TO two raised to the power of ten MINUS one  \n                SET element at position j of new_dp TO min_dp PLUS element at position i of min_size  \n                FOR each pair num and count IN element at position i of freq  \n                    SET candidate TO element at position j of dp PLUS element at position i of min_size MINUS count  \n                    SET candidate TO candidate PLUS zero  // Expression to emphasize the computation as natural number  \n                    IF candidate LESS THAN element at position j of new_dp  \n                        SET element at position j of new_dp TO candidate  \n                    END IF  \n                END FOR  \n            END FOR  \n            SET dp TO new_dp  \n        END FOR  \n        \n        RETURN element at position zero of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximize-the-beauty-of-the-garden", "passing_rate": 0.11764705882352941, "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers)  \n        SET indices TO an empty dictionary that assigns an empty list for each new key  \n        SET prefix_sum TO a list of zeros with length equal to the length of flowers PLUS one  \n        FOR index FROM zero TO the length of flowers MINUS one  \n            SET element_at_position_index_of_prefix_sum_plus_one TO element_at_position_index_of_prefix_sum PLUS the maximum between element_at_position_index_of_flowers AND zero  \n            APPEND index TO the list at key element_at_position_index_of_flowers in indices  \n        END FOR  \n        SET max_beauty TO negative infinity  \n        FOR each beauty IN the keys of indices  \n            IF the length of the list at key beauty in indices IS GREATER THAN OR EQUAL TO two  \n                SET first TO the element at position zero of the list at key beauty in indices  \n                SET last TO the element at the last position of the list at key beauty in indices  \n                SET current_beauty TO two MULTIPLIED BY beauty PLUS element_at_position_last_of_prefix_sum MINUS element_at_position_first PLUS one_of_prefix_sum  \n                IF current_beauty IS GREATER THAN max_beauty  \n                    SET max_beauty TO current_beauty  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-separate-numbers", "passing_rate": 0.37254901960784315, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfCombinations(num)  \n        SET MOD TO ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten PLUS seven  \n        SET n TO the LENGTH OF num  \n        SET memo TO an EMPTY DICTIONARY  \n        \n        FUNCTION dp(index, prev_len)  \n            IF index EQUALS n THEN  \n                RETURN one  \n            END IF  \n            IF the PAIR OF index AND prev_len IS IN memo THEN  \n                RETURN the VALUE ASSOCIATED WITH the PAIR OF index AND prev_len IN memo  \n            END IF  \n            \n            SET count TO zero  \n            FOR length FROM one TO n MINUS index PLUS one  \n                IF the ELEMENT at POSITION index OF num EQUALS the CHARACTER ZERO THEN  \n                    BREAK OUT OF the LOOP  \n                END IF  \n                \n                SET current_num TO the SUBSTRING FROM POSITION index TO POSITION index PLUS length MINUS one OF num  \n                \n                IF prev_len EQUALS zero OR current_num GREATER THAN OR EQUAL TO the SUBSTRING FROM POSITION index MINUS prev_len TO POSITION index MINUS one OF num THEN  \n                    SET count TO count PLUS THE RESULT OF FUNCTION dp WITH ARGUMENTS index PLUS length AND length  \n                    SET count TO count MODULO MOD  \n                END IF  \n            END FOR  \n            \n            SET the VALUE ASSOCIATED WITH the PAIR OF index AND prev_len IN memo TO count  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the RESULT OF FUNCTION dp WITH ARGUMENTS zero AND zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-number-of-good-subsets", "passing_rate": 0.6304347826086957, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfGoodSubsets(nums)  \n        SET count TO the frequency count of each element in nums  \n        SET dp TO a list of zeroes with length equal to two raised to the power of ten  \n        SET the element at position zero of dp TO one  \n        \n        FOR each num IN the keys of count  \n            IF num EQUALS one  \n                SET the element at position zero of dp TO the element at position zero of dp MULTIPLIED BY two raised to the power of the element at position one in count taken as an integer  \n                CONTINUE TO the next iteration  \n            END IF  \n            \n            IF num NOT EQUALS any key in the prime factors mapping  \n                CONTINUE TO the next iteration  \n            END IF  \n            \n            SET factors TO the list of prime factors associated with num in the prime factors mapping  \n            SET mask TO zero  \n            FOR each prime IN factors  \n                SET mask TO mask OR two raised to the power of prime MINUS one  \n            END FOR  \n            \n            FOR m FROM two raised to the power of ten MINUS one DOWN TO zero  \n                IF the bitwise AND of m and mask EQUALS zero  \n                    SET the element at position the bitwise OR of m and mask of dp TO the sum of the current element at that position of dp AND the product of the element at position m of dp MULTIPLIED BY the frequency count of num TAKEN MODULO the given modulus  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET result TO the sum of elements in dp from position one onwards TAKEN MODULO the given modulus  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-employees-to-be-invited-to-a-meeting", "passing_rate": 0.5, "pseudocode": "CLASS Solution  \n    FUNCTION maximumInvitations(favorite)  \n        SET n TO the LENGTH OF favorite  \n        SET graph TO an EMPTY DEFAULTDICTIONARY OF LISTS  \n        SET in_degree TO a LIST OF n ZEROS  \n        \n        FOR i FROM zero TO n MINUS one  \n            APPEND i TO the LIST at element at position i of favorite IN graph  \n            INCREMENT the element at position i of favorite IN in_degree BY one  \n        END FOR  \n        \n        SET mutual_chains TO zero  \n        SET visited TO a LIST OF n FALSE VALUES  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position the element at position i of favorite IN favorite EQUALS i AND i LESS THAN the element at position i of favorite  \n                SET a TO i  \n                SET b TO the element at position i of favorite  \n                SET chain_a TO CALL find_chain_length WITH a graph visited  \n                SET chain_b TO CALL find_chain_length WITH b graph visited  \n                INCREMENT mutual_chains BY chain_a PLUS chain_b  \n            END IF  \n        END FOR  \n        \n        SET longest_cycle TO zero  \n        SET visited TO a LIST OF n FALSE VALUES  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i IN visited EQUALS FALSE  \n                SET cycle_length TO CALL find_cycle_length WITH i graph visited favorite  \n                IF cycle_length GREATER THAN longest_cycle  \n                    SET longest_cycle TO cycle_length  \n                END IF  \n            END IF  \n        END FOR  \n        \n        IF mutual_chains GREATER THAN longest_cycle  \n            RETURN mutual_chains  \n        ELSE  \n            RETURN longest_cycle  \n        END IF  \n    END FUNCTION  \n    \n    FUNCTION find_chain_length(start graph visited)  \n        SET length TO zero  \n        SET queue TO a NEW DEQUE CONTAINING start  \n        SET the element at position start IN visited TO TRUE  \n        \n        WHILE queue IS NOT EMPTY  \n            REMOVE the FIRST ELEMENT FROM queue AND ASSIGN TO current  \n            FOR each neighbor IN the LIST at element at position current IN graph  \n                IF the element at position neighbor IN visited EQUALS FALSE  \n                    SET the element at position neighbor IN visited TO TRUE  \n                    APPEND neighbor TO queue  \n                    INCREMENT length BY one  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN length  \n    END FUNCTION  \n    \n    FUNCTION find_cycle_length(start graph visited favorite)  \n        IF the element at position start IN visited EQUALS TRUE  \n            RETURN zero  \n        END IF  \n        \n        SET stack TO an EMPTY LIST  \n        SET current TO start  \n        \n        WHILE the element at position current IN visited EQUALS FALSE  \n            SET the element at position current IN visited TO TRUE  \n            APPEND current TO stack  \n            SET current TO the element at position current IN favorite  \n        END WHILE  \n        \n        IF current NOT IN stack  \n            RETURN zero  \n        END IF  \n        \n        SET cycle_start_index TO the POSITION OF current IN stack  \n        SET cycle_length TO the LENGTH OF stack MINUS cycle_start_index  \n        \n        RETURN cycle_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-to-divide-a-long-corridor", "passing_rate": 0.5657894736842105, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfWays WITH PARAMETER corridor  \n        SET MOD TO one billion PLUS seven  \n        SET seats TO empty list  \n        FOR each index AND element IN corridor  \n            IF element EQUALS seat symbol  \n                APPEND index TO seats  \n            END IF  \n        END FOR  \n        IF the LENGTH OF seats MODULO two NOT EQUALS zero OR the LENGTH OF seats LESS THAN two  \n            RETURN zero  \n        END IF  \n        SET ways TO one  \n        FOR index FROM three TO the LENGTH OF seats IN STEPS OF two  \n            SET difference TO element at position index of seats MINUS element at position index MINUS one of seats  \n            SET ways TO ways MULTIPLIED BY difference  \n            SET ways TO ways MODULO MOD  \n        END FOR  \n        RETURN ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-difference-in-sums-after-removal-of-elements", "passing_rate": 0.7708333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION minimumDifference(nums)  \n        SET n TO the LENGTH OF nums DIVIDED BY three  \n        \n        SET min_heap TO an empty list  \n        SET min_sums TO a list of zeros with the LENGTH OF two MULTIPLIED BY n PLUS one  \n        \n        FOR i FROM zero TO two MULTIPLIED BY n MINUS one  \n            PUSH the NEGATIVE of element at position i of nums INTO min_heap  \n            IF the LENGTH OF min_heap GREATER THAN n THEN  \n                REMOVE the smallest element FROM min_heap  \n            END IF  \n            IF the LENGTH OF min_heap EQUALS n THEN  \n                SET element at position i of min_sums TO the NEGATIVE of the SUM of elements in min_heap  \n            END IF  \n        END FOR  \n        \n        SET max_heap TO an empty list  \n        SET max_sums TO a list of zeros with the LENGTH OF two MULTIPLIED BY n PLUS one  \n        \n        FOR i FROM three MULTIPLIED BY n MINUS one DOWN TO n  \n            PUSH element at position i of nums INTO max_heap  \n            IF the LENGTH OF max_heap GREATER THAN n THEN  \n                REMOVE the smallest element FROM max_heap  \n            END IF  \n            IF the LENGTH OF max_heap EQUALS n THEN  \n                SET element at position i of max_sums TO the SUM of elements in max_heap  \n            END IF  \n        END FOR  \n        \n        SET min_diff TO infinity  \n        FOR i FROM n MINUS one TO two MULTIPLIED BY n MINUS one  \n            SET min_diff TO the MINIMUM of min_diff AND element at position i of min_sums MINUS element at position i PLUS one of max_sums  \n        END FOR  \n        \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-moves-to-make-palindrome", "passing_rate": 0.6756756756756757, "pseudocode": "CLASS Solution  \n    FUNCTION minMovesToMakePalindrome(s)  \n        SET s TO list of elements from s  \n        SET n TO the LENGTH OF s  \n        SET moves TO zero  \n        WHILE the LENGTH OF s GREATER THAN one  \n            SET found_match TO false  \n            FOR i FROM the LENGTH OF s MINUS one TO one DECREMENTING BY one  \n                IF element at position i of s EQUALS element at position zero of s  \n                    FOR j FROM i TO the LENGTH OF s MINUS two  \n                        SWAP element at position j of s WITH element at position j PLUS one of s  \n                        INCREMENT moves BY one  \n                    END FOR  \n                    REMOVE element at position zero FROM s  \n                    REMOVE element at position at the last position FROM s  \n                    SET found_match TO true  \n                    BREAK out of the FOR loop  \n                END IF  \n            END FOR  \n            IF found_match EQUALS false  \n                REMOVE element at position zero FROM s  \n            END IF  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-total-strength-of-wizards", "passing_rate": 0.08823529411764706, "pseudocode": "CLASS Solution  \n    FUNCTION totalStrength(strength)  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF strength  \n          \n        SET prefix TO a list OF zero WITH the LENGTH OF n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i PLUS one of prefix TO element at position i of prefix PLUS element at position i of strength MODULO MOD  \n        END FOR  \n          \n        SET prefix_prefix TO a list OF zero WITH the LENGTH OF n PLUS two  \n        FOR i FROM zero TO n  \n            SET element at position i PLUS one of prefix_prefix TO element at position i of prefix_prefix PLUS element at position i of prefix MODULO MOD  \n        END FOR  \n          \n        SET prev_smaller TO a list OF minus one WITH the LENGTH OF n  \n        SET next_smaller_or_equal TO a list OF n WITH the LENGTH OF n  \n          \n        SET stack TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND element at position element at position the LAST element of stack of strength IS GREATER THAN OR EQUAL TO element at position i of strength  \n                REMOVE the LAST element FROM stack  \n            END WHILE  \n            IF the LENGTH OF stack IS GREATER THAN zero  \n                SET element at position i of prev_smaller TO element at position the LAST element of stack  \n            END IF  \n            APPEND i TO stack  \n        END FOR  \n          \n        CLEAR stack  \n        FOR i FROM n MINUS one DOWNTO zero  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND element at position element at position the LAST element of stack of strength IS GREATER THAN element at position i of strength  \n                REMOVE the LAST element FROM stack  \n            END WHILE  \n            IF the LENGTH OF stack IS GREATER THAN zero  \n                SET element at position i of next_smaller_or_equal TO element at position the LAST element of stack  \n            END IF  \n            APPEND i TO stack  \n        END FOR  \n          \n        SET total_strength TO zero  \n        FOR i FROM zero TO n MINUS one  \n            SET left TO element at position i of prev_smaller PLUS one  \n            SET right TO element at position i of next_smaller_or_equal  \n              \n            SET sum_left TO (i MINUS left PLUS one) MULTIPLIED BY element at position right PLUS one of prefix_prefix MINUS element at position i PLUS one of prefix_prefix  \n            SET sum_left TO sum_left MODULO MOD  \n              \n            SET sum_right TO (right MINUS i) MULTIPLIED BY element at position i PLUS one of prefix_prefix MINUS element at position left of prefix_prefix  \n            SET sum_right TO sum_right MODULO MOD  \n              \n            SET contribution TO element at position i of strength MULTIPLIED BY (sum_left MINUS sum_right)  \n            SET contribution TO contribution MODULO MOD  \n              \n            SET total_strength TO total_strength PLUS contribution  \n            SET total_strength TO total_strength MODULO MOD  \n        END FOR  \n          \n        RETURN total_strength  \n    END FUNCTION  \nEND CLASS"}
