{"task_id": "letter-combinations-of-a-phone-number", "passing_rate": 0.9736842105263158, "pseudocode": "CLASS Solution  \n    FUNCTION letterCombinations(digits)  \n        IF digits EQUALS empty string THEN  \n            RETURN empty list  \n        END IF  \n        \n        SET phone_map TO mapping from each digit from two to nine TO corresponding letters as follows  \n            digit two maps to letters a b c  \n            digit three maps to letters d e f  \n            digit four maps to letters g h i  \n            digit five maps to letters j k l  \n            digit six maps to letters m n o  \n            digit seven maps to letters p q r s  \n            digit eight maps to letters t u v  \n            digit nine maps to letters w x y z  \n        \n        FUNCTION backtrack(combination, next_digits)  \n            IF the length of next_digits EQUALS zero THEN  \n                APPEND combination TO output  \n            ELSE  \n                FOR each letter IN the letters mapped by the first element of next_digits in phone_map  \n                    CALL backtrack with concatenation of combination PLUS letter, and substring of next_digits from position two TO the end  \n                END FOR  \n            END IF  \n        END FUNCTION  \n        \n        SET output TO empty list  \n        CALL backtrack with empty string and digits  \n        RETURN output  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "substring-with-concatenation-of-all-words", "passing_rate": 0.9807692307692307, "pseudocode": "CLASS Solution  \n    FUNCTION findSubstring(s string words list_of_strings) RETURNS list_of_integers  \n        IF s EQUALS nothing OR words EQUALS nothing OR element at position zero of words EQUALS nothing  \n            RETURN empty list  \n        END IF  \n        \n        SET word_length TO the LENGTH OF element at position zero of words  \n        SET num_words TO the LENGTH OF words  \n        SET total_length TO word_length MULTIPLIED BY num_words  \n        SET word_count TO COUNT OF all elements IN words  \n        SET result TO empty list  \n        \n        FOR i FROM zero TO the LENGTH OF s MINUS total_length PLUS one  \n            SET seen TO empty count mapping  \n            FOR j FROM i TO i PLUS total_length MINUS one STEP word_length  \n                SET word TO substring from position j TO position j PLUS word_length MINUS one of s  \n                INCREMENT the count of word IN seen BY one  \n                IF the count of word IN seen GREATER THAN the count of word IN word_count  \n                    BREAK the inner loop  \n                END IF  \n            END FOR  \n            IF the inner loop completed without BREAKING  \n                APPEND i TO result  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combination-sum", "passing_rate": 0.9574468085106383, "pseudocode": "CLASS Solution  \n    FUNCTION combinationSum(candidates, target)  \n        FUNCTION backtrack(start, target, path)  \n            IF target EQUALS zero  \n                APPEND path TO result  \n                RETURN  \n            END IF  \n            IF target LESS THAN zero  \n                RETURN  \n            END IF  \n            FOR i FROM start TO the LENGTH OF candidates MINUS one  \n                CALL backtrack WITH i AND target MINUS element at position i of candidates AND path PLUS element at position i of candidates  \n            END FOR  \n        END FUNCTION  \n        SET result TO an empty list  \n        CALL backtrack WITH zero AND target AND an empty list  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "permutation-sequence", "passing_rate": 0.9259259259259259, "pseudocode": "CLASS Solution  \n    FUNCTION getPermutation(n k)  \n        SET numbers TO list of all integers from one TO n  \n        DECREMENT k BY one  \n        SET result TO empty list  \n        FOR i FROM n TO one DECREMENT BY one  \n            SET fact TO factorial of i MINUS one  \n            SET index TO k DIVIDED BY fact  \n            APPEND element at position index of numbers CONVERTED TO string TO result  \n            REMOVE element at position index FROM numbers  \n            SET k TO k MODULO fact  \n        END FOR  \n        RETURN concatenation of all elements of result AS a single string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-number", "passing_rate": 0.9629629629629629, "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        SET pattern TO a string representing the regular expression that matches an optional plus or minus sign followed by one or more digits optionally followed by a decimal point and zero or more digits or a decimal point followed by one or more digits followed optionally by an exponent part consisting of character e followed by an optional plus or minus sign and one or more digits  \n        IF the entire string s matches the pattern according to regular expression full match  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-a-2d-matrix", "passing_rate": 0.9791666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION searchMatrix(matrix target)  \n        IF matrix EQUALS empty OR element at position zero of matrix EQUALS empty  \n            RETURN false  \n        END IF  \n        SET m TO the LENGTH OF matrix  \n        SET n TO the LENGTH OF element at position zero of matrix  \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n MINUS one  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two using integer division  \n            SET mid_value TO element at position mid DIVIDED BY n using integer division of matrix AND element at position mid MODULO n of element at position mid DIVIDED BY n using integer division of matrix  \n            IF mid_value EQUALS target  \n                RETURN true  \n            ELSE IF mid_value LESS THAN target  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "single-number-ii", "passing_rate": 0.9423076923076923, "pseudocode": "CLASS Solution  \n    FUNCTION singleNumber WITH PARAMETER nums  \n        SET ones TO zero  \n        SET twos TO zero  \n        FOR each num IN nums  \n            SET ones TO bitwise XOR of ones AND num AND bitwise NOT of twos  \n            SET twos TO bitwise XOR of twos AND num AND bitwise NOT of ones  \n        END FOR  \n        RETURN ones  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-points-on-a-line", "passing_rate": 0.9473684210526315, "pseudocode": "CLASS Solution  \n    FUNCTION maxPoints(points)  \n        FUNCTION slope(p1, p2)  \n            IF element at position zero of p1 EQUALS element at position zero of p2  \n                RETURN infinity  \n            END IF  \n            RETURN element at position one of p1 MINUS element at position one of p2 DIVIDED BY element at position zero of p1 MINUS element at position zero of p2  \n        END FUNCTION  \n        \n        SET max_points TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF points MINUS one  \n            SET slopes TO a new mapping with default value zero  \n            FOR j FROM zero TO the LENGTH OF points MINUS one  \n                IF i NOT EQUALS j  \n                    SET s TO slope of element at position i of points AND element at position j of points  \n                    INCREMENT the value associated with s in slopes BY one  \n                    IF the value associated with s in slopes GREATER THAN max_points  \n                        SET max_points TO the value associated with s in slopes  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF points IS NOT empty  \n            RETURN max_points PLUS one  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-minimum-in-rotated-sorted-array", "passing_rate": 0.9803921568627451, "pseudocode": "CLASS Solution  \n    FUNCTION findMin WITH PARAMETER nums  \n        SET left TO zero  \n        SET right TO the LENGTH OF nums MINUS one  \n        IF element at position left of nums LESS THAN element at position right of nums  \n            RETURN element at position left of nums  \n        END IF  \n        WHILE left LESS THAN right  \n            SET mid TO the INTEGER DIVISION RESULT OF the SUM of left PLUS right BY two  \n            IF element at position mid of nums GREATER THAN element at position right of nums  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid  \n            END IF  \n        END WHILE  \n        RETURN element at position left of nums  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-gap", "passing_rate": 0.9318181818181818, "pseudocode": "CLASS Solution  \n    FUNCTION maximumGap(nums)  \n        IF the LENGTH OF nums LESS THAN two THEN  \n            RETURN zero  \n        END IF  \n        \n        FUNCTION countingSort(arr, exp)  \n            SET n TO the LENGTH OF arr  \n            SET output TO a list of zeros with the LENGTH n  \n            SET count TO a list of zeros with the LENGTH ten  \n            \n            FOR index FROM zero TO n MINUS one  \n                SET digit_index TO the INTEGER DIVISION of the element at position index of arr DIVIDED BY exp  \n                INCREMENT the element at position digit_index MODULO ten of count BY one  \n            END FOR  \n            \n            FOR index FROM one TO nine  \n                INCREMENT the element at position index of count BY the element at position index MINUS one of count  \n            END FOR  \n            \n            SET index TO n MINUS one  \n            WHILE index GREATER THAN OR EQUAL TO zero  \n                SET digit_index TO the INTEGER DIVISION of the element at position index of arr DIVIDED BY exp  \n                SET the element at position the element at position digit_index MODULO ten of count MINUS one of output TO the element at position index of arr  \n                DECREMENT the element at position digit_index MODULO ten of count BY one  \n                DECREMENT index BY one  \n            END WHILE  \n            \n            FOR index FROM zero TO n MINUS one  \n                SET the element at position index of arr TO the element at position index of output  \n            END FOR  \n        END FUNCTION  \n        \n        FUNCTION radixSort(arr)  \n            SET max_value TO the maximum element in arr  \n            SET exp TO one  \n            WHILE the INTEGER DIVISION of max_value BY exp GREATER THAN zero  \n                CALL countingSort WITH arr, exp  \n                SET exp TO exp MULTIPLIED BY ten  \n            END WHILE  \n        END FUNCTION  \n        \n        CALL radixSort WITH nums  \n        \n        SET max_diff TO zero  \n        FOR index FROM one TO the LENGTH OF nums MINUS one  \n            SET current_diff TO the element at position index of nums MINUS the element at position index MINUS one of nums  \n            IF current_diff GREATER THAN max_diff THEN  \n                SET max_diff TO current_diff  \n            END IF  \n        END FOR  \n        \n        RETURN max_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "two-sum-ii-input-array-is-sorted", "passing_rate": 0.9333333333333333, "pseudocode": "CLASS Solution  \n    FUNCTION twoSum(numbers list OF integers target integer) RETURNS list OF integers  \n        SET left TO zero  \n        SET right TO the LENGTH OF numbers MINUS one  \n        WHILE left LESS THAN right  \n            SET current_sum TO element at position left of numbers PLUS element at position right of numbers  \n            IF current_sum EQUALS target  \n                RETURN list containing left PLUS one AND right PLUS one  \n            ELSE IF current_sum LESS THAN target  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-search-ii", "passing_rate": 0.967741935483871, "pseudocode": "CLASS Trie  \n    FUNCTION __init__(self)  \n        SET self.children TO a list of twenty-six elements all set to None  \n        SET self.ref TO negative one  \n    END FUNCTION  \n\n    FUNCTION insert(self, w, ref)  \n        SET node TO self  \n        FOR each character c IN w  \n            SET idx TO the Unicode code point of character c MINUS the Unicode code point of the lowercase letter a  \n            IF element at position idx of node.children EQUALS None THEN  \n                SET element at position idx of node.children TO a new Trie object  \n            END IF  \n            SET node TO element at position idx of node.children  \n        END FOR  \n        SET node.ref TO ref  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findWords(self, board, words)  \n        FUNCTION dfs(node, i, j)  \n            SET idx TO the Unicode code point of the element at position j of the element at position i of board MINUS the Unicode code point of the lowercase letter a  \n            IF element at position idx of node.children EQUALS None THEN  \n                RETURN  \n            END IF  \n            SET node TO element at position idx of node.children  \n            IF node.ref GREATER THAN OR EQUAL TO zero THEN  \n                APPEND element at position node.ref of words TO ans  \n                SET node.ref TO negative one  \n            END IF  \n            SET c TO the element at position j of the element at position i of board  \n            SET the element at position j of the element at position i of board TO the special marker  \n            FOR each consecutive pair a and b IN the sequence of integers negative one zero one zero negative one  \n                SET x TO i PLUS a  \n                SET y TO j PLUS b  \n                IF x GREATER THAN OR EQUAL TO zero AND x LESS THAN m AND y GREATER THAN OR EQUAL TO zero AND y LESS THAN n AND the element at position y of the element at position x of board NOT EQUALS the special marker THEN  \n                    CALL dfs(node, x, y)  \n                END IF  \n            END FOR  \n            SET the element at position j of the element at position i of board TO c  \n        END FUNCTION  \n\n        SET tree TO a new Trie object  \n        FOR each index i AND element w IN words WITH indices  \n            CALL insert method of tree WITH parameters w AND i  \n        END FOR  \n        SET m TO the length of board  \n        SET n TO the length of the element at position zero of board  \n        SET ans TO an empty list  \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                CALL dfs(tree, i, j)  \n            END FOR  \n        END FOR  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "the-skyline-problem", "passing_rate": 0.9607843137254902, "pseudocode": "CLASS Solution  \n    FUNCTION getSkyline(buildings)  \n        SET events TO empty list  \n        FOR each building IN buildings  \n            LET left BE element at position one of building  \n            LET right BE element at position two of building  \n            LET height BE element at position three of building  \n            APPEND a tuple of left AND the negative value of height AND right TO events  \n            APPEND a tuple of right AND zero AND zero TO events  \n        END FOR  \n        SORT events IN ascending order by first element THEN second element THEN third element  \n        SET result TO a list containing one element which is a list of zero AND zero  \n        SET max_heap TO a list containing one element which is a tuple of zero AND positive infinity  \n        FOR each event IN events  \n            LET x BE the first element of event  \n            LET negH BE the second element of event  \n            LET r BE the third element of event  \n            WHILE the second element of the first tuple in max_heap IS LESS THAN OR EQUAL TO x  \n                REMOVE the first element from max_heap using the heap pop operation  \n            END WHILE  \n            IF negH IS NOT EQUALS TO zero  \n                ADD a tuple of negH AND r to max_heap using the heap push operation  \n            END IF  \n            IF the second element of the last element in result IS NOT EQUALS TO the negative of the first element of the first tuple in max_heap  \n                APPEND a list containing x AND the negative of the first element of the first tuple in max_heap TO result  \n            END IF  \n        END FOR  \n        IF the first element of result IS a list of zero AND zero  \n            REMOVE the first element from result  \n        END IF  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "search-a-2d-matrix-ii", "passing_rate": 0.9803921568627451, "pseudocode": "CLASS Solution  \n    FUNCTION searchMatrix(matrix target)  \n        IF matrix EQUALS nothing OR element at position zero of matrix EQUALS nothing  \n            RETURN False  \n        END IF  \n        SET row TO zero  \n        SET col TO the LENGTH OF element at position zero of matrix MINUS one  \n        WHILE row LESS THAN the LENGTH OF matrix AND col GREATER THAN OR EQUAL TO zero holds  \n            IF element at position row of matrix at position col EQUALS target  \n                RETURN True  \n            ELSE IF element at position row of matrix at position col GREATER THAN target  \n                DECREMENT col BY one  \n            ELSE  \n                INCREMENT row BY one  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "meeting-rooms-ii", "passing_rate": 0.9607843137254902, "pseudocode": "CLASS Solution  \n    FUNCTION minMeetingRooms(intervals)  \n        IF intervals EQUALS empty list  \n            RETURN zero  \n        END IF  \n        SORT intervals BY start time of each meeting  \n        SET min_heap TO empty list  \n        FOR each meeting IN intervals  \n            IF min_heap NOT EQUALS empty list AND start time of meeting GREATER THAN OR EQUAL TO element at position zero of min_heap  \n                REMOVE the smallest element FROM min_heap  \n            END IF  \n            ADD end time of meeting TO min_heap  \n        END FOR  \n        RETURN the number of elements IN min_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "alien-dictionary", "passing_rate": 0.8461538461538461, "pseudocode": "CLASS Solution  \n    FUNCTION alienOrder(words)  \n        SET graph TO a mapping from characters to empty sets  \n        SET indegree TO a mapping from characters to zero  \n        SET all_chars TO the set of every character found by concatenating all words in words  \n        \n        FOR index FROM zero TO the LENGTH OF words MINUS one  \n            SET word1 TO the element at position index of words  \n            SET word2 TO the element at position index PLUS one of words  \n            SET min_length TO the smaller of the LENGTH OF word1 AND the LENGTH OF word2  \n            SET found TO false  \n            FOR position FROM zero TO min_length MINUS one  \n                IF the character at position of word1 NOT EQUALS the character at position of word2  \n                    IF the character at position of word2 is not an element in the set mapped from the character at position of word1 in graph  \n                        ADD the character at position of word2 TO the set mapped from the character at position of word1 in graph  \n                        INCREMENT the value mapped from the character at position of word2 in indegree BY one  \n                    END IF  \n                    SET found TO true  \n                    BREAK the inner loop  \n                END IF  \n            END FOR  \n            \n            IF found IS false AND the LENGTH OF word1 GREATER THAN the LENGTH OF word2  \n                RETURN an empty string described as empty  \n            END IF  \n        END FOR  \n        \n        SET queue TO a double-ended queue initialized with characters from all_chars for which the value mapped in indegree EQUALS zero  \n        SET result TO an empty list  \n        \n        WHILE the LENGTH OF queue GREATER THAN zero  \n            REMOVE the element from the front of queue and ASSIGN it TO char  \n            APPEND char TO result  \n            FOR each neighbor IN the set mapped from char in graph  \n                DECREMENT the value mapped from neighbor in indegree BY one  \n                IF the value mapped from neighbor in indegree EQUALS zero  \n                    APPEND neighbor TO the end of queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        IF the LENGTH OF result NOT EQUALS the LENGTH OF all_chars  \n            RETURN an empty string described as empty  \n        END IF  \n        \n        RETURN the concatenation of all elements in result into a single string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-to-english-words", "passing_rate": 0.9545454545454546, "pseudocode": "CLASS Solution  \n    FUNCTION numberToWords(num)  \n        IF num EQUALS zero  \n            RETURN the word Zero  \n        END IF  \n        \n        SET below_twenty TO list of words empty string One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen  \n        SET tens TO list of words empty string empty string Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety  \n        SET thousands TO list of words empty string Thousand Million Billion  \n        \n        FUNCTION helper(n)  \n            IF n EQUALS zero  \n                RETURN empty string  \n            END IF  \n            ELSE IF n LESS THAN twenty  \n                RETURN element at position n of below_twenty concatenated with a space  \n            END IF  \n            ELSE IF n LESS THAN one hundred  \n                RETURN element at position n DIVIDED BY ten of tens concatenated with a space concatenated with result of calling helper with n MODULO ten  \n            END IF  \n            ELSE  \n                RETURN element at position n DIVIDED BY one hundred of below_twenty concatenated with the word Hundred concatenated with a space concatenated with result of calling helper with n MODULO one hundred  \n            END ELSE  \n        END FUNCTION  \n        \n        SET result TO empty string  \n        SET i TO zero  \n        \n        WHILE num GREATER THAN zero  \n            IF num MODULO one thousand NOT EQUALS zero  \n                SET result TO result of calling helper with num MODULO one thousand concatenated with element at position i of thousands concatenated with a space concatenated with result  \n            END IF  \n            SET num TO num DIVIDED BY one thousand  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        RETURN result with leading and trailing spaces removed  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-height-trees", "passing_rate": 0.9333333333333333, "pseudocode": "CLASS Solution  \n    FUNCTION findMinHeightTrees(n parameter, edges parameter)  \n        IF n parameter EQUALS one  \n            RETURN the list containing the single element zero  \n        END IF  \n        \n        SET graph TO a new mapping with default value as empty list  \n        SET degree TO a list of zero values repeated n parameter times  \n        \n        FOR each pair of values u parameter and v parameter IN edges parameter  \n            APPEND v parameter TO the list at key u parameter in graph  \n            APPEND u parameter TO the list at key v parameter in graph  \n            INCREMENT the value at position u parameter in degree BY one  \n            INCREMENT the value at position v parameter in degree BY one  \n        END FOR  \n        \n        SET leaves TO a new double ended queue containing elements i FOR each i FROM zero TO n parameter MINUS one WHERE the value at position i in degree EQUALS one  \n        \n        SET remaining_nodes TO n parameter  \n        WHILE remaining_nodes GREATER THAN two  \n            SET leaves_count TO the length of leaves  \n            DECREMENT remaining_nodes BY leaves_count  \n            FOR each index FROM zero TO leaves_count MINUS one  \n                SET leaf TO the element removed from the front of leaves  \n                FOR each neighbor IN the list at key leaf in graph  \n                    DECREMENT the value at position neighbor in degree BY one  \n                    IF the value at position neighbor in degree EQUALS one  \n                        APPEND neighbor TO leaves  \n                    END IF  \n                END FOR  \n            END FOR  \n        END WHILE  \n        \n        RETURN the list converted from leaves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "range-addition", "passing_rate": 0.9512195121951219, "pseudocode": "CLASS Solution  \n    FUNCTION getModifiedArray(length updates)  \n        SET difference_array TO a list of zeros with the size of length PLUS one  \n        FOR each element_of_updates IN updates  \n            ASSIGN start_index TO element at position zero of element_of_updates  \n            ASSIGN end_index TO element at position one of element_of_updates  \n            ASSIGN increment_value TO element at position two of element_of_updates  \n            INCREMENT element at position start_index of difference_array BY increment_value  \n            IF end_index PLUS one LESS THAN length THEN  \n                DECREMENT element at position end_index PLUS one of difference_array BY increment_value  \n            END IF  \n        END FOR  \n        SET result_array TO a list of zeros with the size of length  \n        SET element at position zero of result_array TO element at position zero of difference_array  \n        FOR index FROM one TO length MINUS one  \n            SET element at position index of result_array TO element at position index MINUS one of result_array PLUS element at position index of difference_array  \n        END FOR  \n        RETURN result_array  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-absolute-file-path", "passing_rate": 0.9811320754716981, "pseudocode": "CLASS Solution  \n    FUNCTION lengthLongestPath(input)  \n        SET lines TO the result of splitting input by the newline character  \n        SET stack TO an empty list  \n        SET max_length TO zero  \n        \n        FOR each line IN lines  \n            SET depth TO the number of tab characters contained in line  \n            SET name TO the substring of line starting from the position immediately after the last tab character to the end of line  \n            \n            WHILE the LENGTH OF stack is greater than depth  \n                REMOVE the last element FROM stack  \n            END WHILE  \n            \n            IF the LENGTH OF stack is greater than zero  \n                SET current_length TO the last element of stack PLUS the LENGTH OF name PLUS one for the directory separator character  \n            ELSE  \n                SET current_length TO the LENGTH OF name  \n            END IF  \n            \n            IF the name contains the character period  \n                SET max_length TO the greater value between max_length AND current_length  \n            ELSE  \n                APPEND current_length TO stack  \n            END IF  \n        END FOR  \n        \n        RETURN max_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ternary-expression-parser", "passing_rate": 0.8148148148148148, "pseudocode": "CLASS Solution  \n    FUNCTION parseTernary(expression)  \n        FUNCTION evaluate(index)  \n            IF index EQUALS the LENGTH OF expression MINUS one OR the element at position index PLUS one of expression EQUALS the character colon  \n                RETURN the element at position index of expression AND index PLUS two  \n            END IF  \n            SET true_part AND next_index TO the result of evaluate with argument index PLUS two  \n            SET false_part AND final_index TO the result of evaluate with argument next_index  \n            IF the element at position index of expression EQUALS the character T  \n                RETURN true_part AND final_index  \n            ELSE  \n                RETURN false_part AND final_index  \n            END IF  \n        END FUNCTION  \n        SET result AND an unused variable TO the result of evaluate with argument zero  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "circular-array-loop", "passing_rate": 0.8571428571428571, "pseudocode": "CLASS Solution  \n    FUNCTION circularArrayLoop(nums)  \n        FUNCTION sameDirection(val1 val2)  \n            RETURN val1 GREATER THAN zero AND val2 GREATER THAN zero OR val1 LESS THAN zero AND val2 LESS THAN zero  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF nums  \n\n        FOR i FROM zero TO n MINUS one  \n            SET slow TO i  \n            SET fast TO i  \n\n            IF element at position i of nums EQUALS zero  \n                CONTINUE  \n            END IF  \n\n            WHILE true  \n                SET slow TO the result of adding slow PLUS the element at position slow of nums THEN finding the remainder when divided by n  \n                IF slow LESS THAN zero  \n                    INCREMENT slow BY n  \n                END IF  \n\n                SET fast TO the result of adding fast PLUS the element at position fast of nums THEN finding the remainder when divided by n  \n                IF fast LESS THAN zero  \n                    INCREMENT fast BY n  \n                END IF  \n\n                SET fast TO the result of adding fast PLUS the element at position fast of nums THEN finding the remainder when divided by n  \n                IF fast LESS THAN zero  \n                    INCREMENT fast BY n  \n                END IF  \n\n                IF NOT sameDirection(element at position slow of nums element at position i of nums) OR NOT sameDirection(element at position fast of nums element at position i of nums)  \n                    BREAK  \n                END IF  \n\n                IF slow EQUALS fast  \n                    IF slow EQUALS the result of adding slow PLUS the element at position slow of nums THEN finding the remainder when divided by n  \n                        BREAK  \n                    END IF  \n                    RETURN true  \n                END IF  \n            END WHILE  \n        END FOR  \n\n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "encode-string-with-shortest-length", "passing_rate": 0.8333333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION encode(s)  \n        FUNCTION get_encoded_length(count, substring)  \n            SET count_length TO the LENGTH OF the STRING representation of count  \n            SET substring_length TO the LENGTH OF substring  \n            RETURN count_length PLUS substring_length PLUS two  \n        END FUNCTION  \n\n        FUNCTION dp(i, j)  \n            SET substring TO the characters from position i TO position j IN s  \n            SET n TO j MINUS i PLUS one  \n            IF n LESS THAN five THEN  \n                RETURN substring  \n            END IF  \n\n            SET shortest TO substring  \n\n            FOR k FROM one TO n DIVIDED BY two  \n                SET k_valid TO whether n MODULO k EQUALS zero  \n                IF k_valid THEN  \n                    SET repeat_count TO n DIVIDED BY k  \n                    SET candidate_substring TO the characters from position zero TO position k MINUS one IN substring  \n                    SET repeated_candidate TO candidate_substring REPEATED repeat_count TIMES  \n                    IF substring EQUALS repeated_candidate THEN  \n                        SET encoded_candidate TO the STRING representation of repeat_count CONCATENATED WITH an opening bracket CONCATENATED WITH dp(i, i PLUS k MINUS one) CONCATENATED WITH a closing bracket  \n                        IF the LENGTH OF encoded_candidate LESS THAN the LENGTH OF shortest THEN  \n                            SET shortest TO encoded_candidate  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n\n            FOR k FROM i TO j MINUS one  \n                SET left_encoded TO dp(i, k)  \n                SET right_encoded TO dp(k PLUS one, j)  \n                SET combined TO left_encoded CONCATENATED WITH right_encoded  \n                IF LENGTH OF combined LESS THAN LENGTH OF shortest THEN  \n                    SET shortest TO combined  \n                END IF  \n            END FOR  \n\n            RETURN shortest  \n        END FUNCTION  \n\n        RETURN dp(zero, the LENGTH OF s MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "magical-string", "passing_rate": 0.88, "pseudocode": "CLASS Solution  \n    FUNCTION magicalString(n)  \n        IF n EQUALS zero  \n            RETURN zero  \n        END IF  \n        IF n LESS THAN OR EQUAL TO three  \n            RETURN one  \n        END IF  \n        SET s TO a list containing one two two  \n        SET count TO one  \n        SET index TO two  \n        WHILE the length of s LESS THAN n  \n            SET next_num TO three MINUS element at position last of s  \n            FOR repetition FROM one TO element at position index of s  \n                APPEND next_num TO s  \n            END FOR  \n            IF next_num EQUALS one  \n                INCREMENT count BY element at position index of s  \n            END IF  \n            INCREMENT index BY one  \n        END WHILE  \n        IF the length of s GREATER THAN n  \n            SET count TO count MINUS element at position last of s MULTIPLIED BY the difference between the length of s AND n  \n        END IF  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tag-validator", "passing_rate": 0.8653846153846154, "pseudocode": "CLASS Solution  \n    FUNCTION isValid(code)  \n        SET pattern FOR CDATA TO the string representing less than exclamation mark left square bracket CDATA left square bracket followed by any characters lazy match followed by right square bracket right square bracket greater than  \n        SET code TO the result of replacing all matches of the CDATA pattern in code with empty string  \n        SET stack TO empty list  \n        SET i TO zero  \n        WHILE i LESS THAN the LENGTH OF code  \n            IF the element at position i of code EQUALS less than  \n                SET j TO the position of the first occurrence of greater than in code starting from position i PLUS one  \n                IF j EQUALS minus one  \n                    RETURN false  \n                END IF  \n                SET tag_content TO the substring from position i PLUS one TO position j MINUS one of code  \n                IF the LENGTH OF tag_content EQUALS zero  \n                    RETURN false  \n                END IF  \n                IF the element at position zero of tag_content EQUALS slash  \n                    SET tag_name TO the substring from position one TO the end of tag_content  \n                    IF the stack is empty OR the last element of stack NOT EQUALS tag_name  \n                        RETURN false  \n                    END IF  \n                    REMOVE the last element FROM stack  \n                ELSE IF the element at position zero of tag_content EQUALS exclamation mark  \n                    RETURN false  \n                ELSE  \n                    IF the LENGTH OF tag_content LESS THAN one OR the LENGTH OF tag_content GREATER THAN nine OR tag_content NOT EQUALS tag_content converted to uppercase  \n                        RETURN false  \n                    END IF  \n                    APPEND tag_content TO stack  \n                END IF  \n                SET i TO j PLUS one  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        RETURN the logical NOT of the stack AND the result of finding all matches of the regular expression matching less than followed by one or more uppercase letters followed by greater than followed by any characters followed by less than slash followed by one or more uppercase letters followed by greater than in code returns a nonempty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shopping-offers", "passing_rate": 0.9545454545454546, "pseudocode": "CLASS Solution  \n    FUNCTION shoppingOffers(price list_of_integers special list_of_lists_of_integers needs list_of_integers) RETURNS integer  \n        SET filtered_special TO an empty list  \n        FOR each offer IN special  \n            SET total_items_in_offer TO zero  \n            FOR each item_index FROM the first position TO the position before the last position IN offer  \n                INCREMENT total_items_in_offer BY element at position item_index of offer  \n            END FOR  \n            SET total_price_of_offer TO zero  \n            FOR each item_index FROM the first position TO the position before the last position IN offer  \n                SET offer_price TO element at position item_index of offer MULTIPLIED BY element at position item_index of price  \n                INCREMENT total_price_of_offer BY offer_price  \n            END FOR  \n            IF total_items_in_offer GREATER THAN zero AND element at the last position of offer LESS THAN total_price_of_offer THEN  \n                APPEND offer TO filtered_special  \n            END IF  \n        END FOR  \n        SET special TO filtered_special  \n        \n        FUNCTION dfs(needs_tuple tuple_of_integers) RETURNS integer  \n            SET min_cost TO zero  \n            FOR each index FROM the first position TO the last position IN needs_tuple  \n                SET cost_for_this_index TO element at position index of price MULTIPLIED BY element at position index of needs_tuple  \n                INCREMENT min_cost BY cost_for_this_index  \n            END FOR  \n            \n            FOR each offer IN special  \n                SET new_needs TO an empty list  \n                FOR each index FROM the first position TO the position before the last position IN offer  \n                    SET updated_need TO element at position index of needs_tuple MINUS element at position index of offer  \n                    APPEND updated_need TO new_needs  \n                END FOR  \n                \n                SET can_use_offer TO True  \n                FOR each need_value IN new_needs  \n                    IF need_value LESS THAN zero THEN  \n                        SET can_use_offer TO False  \n                        BREAK  \n                    END IF  \n                END FOR  \n                \n                IF can_use_offer IS True THEN  \n                    SET cost_with_offer TO element at the last position of offer PLUS dfs(tuple converted from new_needs)  \n                    IF cost_with_offer LESS THAN min_cost THEN  \n                        SET min_cost TO cost_with_offer  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dfs(tuple converted from needs)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "4-keys-keyboard", "passing_rate": 0.9375, "pseudocode": "CLASS Solution  \n    FUNCTION maxA(n)  \n        IF n LESS THAN OR EQUAL TO three  \n            RETURN n  \n        END IF  \n          \n        SET dp TO list of zeroes WITH LENGTH n PLUS one  \n          \n        FOR i FROM one TO three  \n            SET element at position i of dp TO i  \n        END FOR  \n          \n        FOR i FROM four TO n  \n            FOR j FROM i MINUS three DOWN TO one  \n                SET element at position i of dp TO the GREATER OF element at position i of dp AND element at position j of dp MULTIPLIED BY i MINUS j MINUS one  \n            END FOR  \n        END FOR  \n          \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "next-closest-time", "passing_rate": 0.9666666666666667, "pseudocode": "CLASS Solution  \n    FUNCTION nextClosestTime(time)  \n        SET digits TO the unique characters of time with all colon characters removed  \n        SET hour TO the integer value obtained by converting the substring consisting of the first two characters of time  \n        SET minute TO the integer value obtained by converting the substring consisting of the last two characters of time  \n\n        FUNCTION generate_times(digits)  \n            SET times TO an empty list  \n            FOR each first hour digit IN digits  \n                FOR each second hour digit IN digits  \n                    FOR each first minute digit IN digits  \n                        FOR each second minute digit IN digits  \n                            SET hour_value TO the integer value obtained by concatenating first hour digit and second hour digit  \n                            SET minute_value TO the integer value obtained by concatenating first minute digit and second minute digit  \n                            IF hour_value LESS THAN twenty-four AND minute_value LESS THAN sixty  \n                                APPEND the tuple consisting of hour_value and minute_value TO times  \n                            END IF  \n                        END FOR  \n                    END FOR  \n                END FOR  \n            END FOR  \n            RETURN times sorted in ascending order  \n        END FUNCTION  \n\n        SET all_times TO the result of generate_times invoked with digits  \n        SET current_time_index TO the position of the tuple consisting of hour and minute in all_times  \n        IF current_time_index PLUS one LESS THAN the length of all_times  \n            SET next_hour TO the first element of the tuple at position current_time_index PLUS one of all_times  \n            SET next_minute TO the second element of the tuple at position current_time_index PLUS one of all_times  \n        ELSE  \n            SET next_hour TO the first element of the tuple at position zero of all_times  \n            SET next_minute TO the second element of the tuple at position zero of all_times  \n        END IF  \n\n        RETURN the string composed of next_hour expressed as two digit number followed by a colon followed by next_minute expressed as two digit number  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-sum-of-3-non-overlapping-subarrays", "passing_rate": 0.8048780487804879, "pseudocode": "CLASS Solution  \n    FUNCTION maxSumOfThreeSubarrays(nums PARAMETER, k PARAMETER)  \n        SET n TO the LENGTH OF nums  \n        SET sums TO a LIST of zeros with LENGTH equal TO n MINUS k PLUS one  \n        SET current_sum TO the SUM of the ELEMENTS from POSITION one TO POSITION k OF nums  \n        SET the ELEMENT at POSITION one OF sums TO current_sum  \n        \n        FOR i FROM two TO n MINUS k PLUS one  \n            SET current_sum TO current_sum PLUS ELEMENT at POSITION i PLUS k MINUS one OF nums MINUS ELEMENT at POSITION i MINUS one OF nums  \n            SET the ELEMENT at POSITION i OF sums TO current_sum  \n        END FOR  \n        \n        SET left TO a LIST of zeros with LENGTH equal TO n MINUS k PLUS one  \n        SET right TO a LIST with ALL ELEMENTS equal TO n MINUS k with LENGTH equal TO n MINUS k PLUS one  \n        \n        SET max_sum TO zero  \n        FOR i FROM one TO n MINUS k PLUS one  \n            IF ELEMENT at POSITION i OF sums GREATER THAN ELEMENT at POSITION max_sum OF sums  \n                SET max_sum TO i  \n            END IF  \n            SET the ELEMENT at POSITION i OF left TO max_sum  \n        END FOR  \n        \n        SET max_sum TO n MINUS k  \n        FOR i FROM n MINUS k PLUS one DOWN TO one  \n            IF ELEMENT at POSITION i OF sums GREATER THAN OR EQUAL TO ELEMENT at POSITION max_sum OF sums  \n                SET max_sum TO i  \n            END IF  \n            SET the ELEMENT at POSITION i OF right TO max_sum  \n        END FOR  \n        \n        SET max_total TO zero  \n        SET result TO a LIST of three zeros  \n        FOR j FROM k PLUS one TO n MINUS two TIMES k PLUS one  \n            SET i TO ELEMENT at POSITION j MINUS k OF left  \n            SET l TO ELEMENT at POSITION j PLUS k OF right  \n            SET total TO ELEMENT at POSITION i OF sums PLUS ELEMENT at POSITION j OF sums PLUS ELEMENT at POSITION l OF sums  \n            IF total GREATER THAN max_total  \n                SET max_total TO total  \n                SET result TO a LIST containing i THEN j THEN l  \n            END IF  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands-ii", "passing_rate": 0.9795918367346939, "pseudocode": "CLASS Solution  \n    FUNCTION numDistinctIslands2(grid)  \n        FUNCTION dfs(x, y, island)  \n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero of grid OR element at position x of grid AT position y EQUALS zero  \n                RETURN  \n            END IF  \n            SET element at position x of grid AT position y TO zero  \n            APPEND the PAIR consisting of x AND y TO island  \n            CALL dfs WITH x INCREMENTED BY one AND y AND island  \n            CALL dfs WITH x DECREMENTED BY one AND y AND island  \n            CALL dfs WITH x AND y INCREMENTED BY one AND island  \n            CALL dfs WITH x AND y DECREMENTED BY one AND island  \n        END FUNCTION\n\n        FUNCTION normalize(island)  \n            SET shapes TO an EMPTY list  \n            FOR each PAIR dx AND dy IN the LIST of PAIRS consisting of one and one AND one and MINUS one AND MINUS one and one AND MINUS one and MINUS one  \n                SET new_island TO an EMPTY list  \n                FOR each PAIR x AND y IN island  \n                    APPEND the PAIR consisting of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island  \n                END FOR  \n                SORT new_island  \n                SET min_x TO the MINIMUM x value IN new_island  \n                SET min_y TO the MINIMUM y value IN new_island  \n                APPEND to shapes the TUPLE of PAIRS where each PAIR consists of element x MINUS min_x AND element y MINUS min_y FOR each PAIR x AND y IN new_island  \n            END FOR  \n            SET length_of_shapes TO the LENGTH OF shapes  \n            FOR i FROM zero TO length_of_shapes MINUS one  \n                APPEND to shapes the TUPLE of PAIRS where each PAIR consists of element y AND MINUS element x FOR each PAIR x AND y IN element at position i of shapes  \n            END FOR  \n            RETURN the MINIMUM element in shapes  \n        END FUNCTION\n\n        SET islands TO an EMPTY set  \n        FOR i FROM zero TO the LENGTH OF grid MINUS one  \n            FOR j FROM zero TO the LENGTH OF element at position zero of grid MINUS one  \n                IF element at position i of grid AT position j EQUALS one  \n                    SET island TO an EMPTY list  \n                    CALL dfs WITH i AND j AND island  \n                    ADD the RESULT of normalize called with island TO islands  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN the LENGTH OF islands  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "candy-crush", "passing_rate": 0.9285714285714286, "pseudocode": "CLASS Solution  \n    FUNCTION candyCrush(board)  \n        SET R TO the LENGTH OF board  \n        SET C TO the LENGTH OF element at position zero of board  \n        SET stable TO false  \n        \n        WHILE stable NOT EQUALS true  \n            SET stable TO true  \n            SET to_crush TO an empty set  \n            \n            FOR each r FROM zero TO R MINUS one  \n                FOR each c FROM zero TO C MINUS two  \n                    IF the absolute value of element at position r of board at position c EQUALS the absolute value of element at position r of board at position c PLUS one AND the absolute value of element at position r of board at position c PLUS one EQUALS the absolute value of element at position r of board at position c PLUS two AND the absolute value of element at position r of board at position c NOT EQUALS zero  \n                        SET stable TO false  \n                        ADD the pair consisting of r AND c TO to_crush  \n                        ADD the pair consisting of r AND c PLUS one TO to_crush  \n                        ADD the pair consisting of r AND c PLUS two TO to_crush  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            FOR each r FROM zero TO R MINUS two  \n                FOR each c FROM zero TO C MINUS one  \n                    IF the absolute value of element at position r of board at position c EQUALS the absolute value of element at position r PLUS one of board at position c AND the absolute value of element at position r PLUS one of board at position c EQUALS the absolute value of element at position r PLUS two of board at position c AND the absolute value of element at position r of board at position c NOT EQUALS zero  \n                        SET stable TO false  \n                        ADD the pair consisting of r AND c TO to_crush  \n                        ADD the pair consisting of r PLUS one AND c TO to_crush  \n                        ADD the pair consisting of r PLUS two AND c TO to_crush  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            FOR each pair r AND c IN to_crush  \n                SET element at position r of board at position c TO zero  \n            END FOR  \n            \n            FOR each c FROM zero TO C MINUS one  \n                SET wr TO R MINUS one  \n                FOR each r FROM R MINUS one DOWNTO zero  \n                    IF element at position r of board at position c NOT EQUALS zero  \n                        SET element at position wr of board at position c TO element at position r of board at position c  \n                        DECREMENT wr BY one  \n                    END IF  \n                END FOR  \n                FOR each wr FROM wr DOWNTO zero  \n                    SET element at position wr of board at position c TO zero  \n                END FOR  \n            END FOR  \n        END WHILE  \n        \n        RETURN board  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parse-lisp-expression", "passing_rate": 0.975609756097561, "pseudocode": "CLASS Solution  \n    FUNCTION evaluate(expression)  \n        FUNCTION get_tokens(expression)  \n            SET tokens TO empty list  \n            SET buf TO empty string  \n            SET depth TO zero  \n            FOR each character IN expression  \n                IF character EQUALS a space AND depth EQUALS zero THEN  \n                    APPEND buf TO tokens  \n                    SET buf TO empty string  \n                ELSE  \n                    IF character EQUALS opening parenthesis THEN  \n                        INCREMENT depth BY one  \n                    ELSE IF character EQUALS closing parenthesis THEN  \n                        DECREMENT depth BY one  \n                    END IF  \n                    SET buf TO buf PLUS character  \n                END IF  \n            END FOR  \n            IF buf NOT EQUALS empty string THEN  \n                APPEND buf TO tokens  \n            END IF  \n            RETURN tokens  \n        END FUNCTION  \n\n        FUNCTION evaluate_expression(tokens context)  \n            IF element at position zero of tokens EQUALS the word add THEN  \n                RETURN evaluate_expression(element at position one of tokens context) PLUS evaluate_expression(element at position two of tokens context)  \n            ELSE IF element at position zero of tokens EQUALS the word mult THEN  \n                RETURN evaluate_expression(element at position one of tokens context) MULTIPLIED BY evaluate_expression(element at position two of tokens context)  \n            ELSE IF element at position zero of tokens EQUALS the word let THEN  \n                SET new_context TO a copy of context  \n                SET i TO one  \n                WHILE i LESS THAN the length of tokens MINUS one DO  \n                    SET var TO element at position i of tokens  \n                    SET expr TO element at position i PLUS one of tokens  \n                    SET the element at key var of new_context TO evaluate_expression(expr new_context)  \n                    INCREMENT i BY two  \n                END WHILE  \n                RETURN evaluate_expression(element at position the last of tokens new_context)  \n            ELSE  \n                TRY  \n                    RETURN the integer value of element at position zero of tokens  \n                CATCH error for invalid integer conversion  \n                    RETURN the element at key element at position zero of tokens of context  \n                END TRY  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION parse_expression(expression)  \n            IF element at position zero of expression NOT EQUALS opening parenthesis THEN  \n                RETURN expression  \n            END IF  \n            SET tokens TO get_tokens(substring from position one TO position the last MINUS one of expression)  \n            RETURN list comprehension of parse_expression(token) for each token IN tokens  \n        END FUNCTION  \n\n        SET parsed_expression TO parse_expression(expression)  \n        RETURN evaluate_expression(parsed_expression empty dictionary)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "open-the-lock", "passing_rate": 0.9130434782608695, "pseudocode": "CLASS Solution  \n    FUNCTION openLock(deadends, target)  \n        SET deadends_set TO empty set  \n        FOR each deadend IN deadends  \n            ADD deadend TO deadends_set  \n        END FOR  \n        \n        IF deadends_set CONTAINS state consisting of four zeros  \n            RETURN negative one  \n        END IF  \n        \n        IF target EQUALS state consisting of four zeros  \n            RETURN zero  \n        END IF  \n        \n        SET queue TO new empty double ended queue  \n        APPEND pair consisting of state consisting of four zeros AND zero TO queue  \n        SET visited TO empty set  \n        ADD state consisting of four zeros TO visited  \n        \n        FUNCTION neighbors(state)  \n            SET result TO empty list  \n            FOR index FROM zero TO three  \n                SET digit_string TO element at position index of state  \n                SET digit TO digit_string CONVERTED TO integer  \n                FOR move IN list consisting of negative one AND one  \n                    SET new_digit TO digit PLUS move  \n                    IF new_digit LESS THAN zero  \n                        SET new_digit TO nine  \n                    ELSE IF new_digit GREATER THAN nine  \n                        SET new_digit TO zero  \n                    END IF  \n                    SET new_state TO concatenation of substring from position zero TO position index MINUS one of state  \n                                     PLUS string representation of new_digit  \n                                     PLUS substring from position index PLUS one TO end of state  \n                    APPEND new_state TO result  \n                END FOR  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        WHILE queue IS NOT empty  \n            REMOVE first element FROM queue AND ASSIGN TO pair current_state AND steps  \n            FOR each neighbor_state IN neighbors(current_state)  \n                IF neighbor_state NOT IN visited AND neighbor_state NOT IN deadends_set  \n                    IF neighbor_state EQUALS target  \n                        RETURN steps PLUS one  \n                    END IF  \n                    ADD neighbor_state TO visited  \n                    APPEND pair consisting of neighbor_state AND steps PLUS one TO queue  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cracking-the-safe", "passing_rate": 0.8947368421052632, "pseudocode": "CLASS Solution  \n    FUNCTION crackSafe(n k)  \n        SET visited TO empty collection of unique elements  \n        SET sequence TO empty list  \n\n        FUNCTION dfs(node)  \n            FOR each i FROM zero TO k MINUS one  \n                SET edge TO concatenation of node AND string representation of i  \n                IF edge is NOT IN visited  \n                    ADD edge TO visited  \n                    CALL dfs with argument substring of edge from position one TO the end  \n                    APPEND string representation of i TO sequence  \n                END IF  \n            END FOR  \n        END FUNCTION  \n\n        SET start_node TO string composed of character zero REPEATED n MINUS one times  \n        CALL dfs with argument start_node  \n\n        RETURN concatenation of all elements of sequence FOLLOWED BY start_node  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-chunks-to-make-sorted-ii", "passing_rate": 0.9285714285714286, "pseudocode": "CLASS Solution  \n    FUNCTION maxChunksToSorted(arr)  \n        SET max_so_far TO an empty list  \n        SET current_max TO element at position one of arr  \n        \n        FOR each num IN arr  \n            IF current_max LESS THAN num  \n                SET current_max TO num  \n            END IF  \n            APPEND current_max TO max_so_far  \n        END FOR  \n        \n        SET sorted_arr TO arr sorted in ascending order  \n        SET chunks TO zero  \n        SET max_chunk TO zero  \n        \n        FOR index FROM one TO the LENGTH OF arr  \n            IF max_chunk LESS THAN element at position index of arr  \n                SET max_chunk TO element at position index of arr  \n            END IF  \n            IF max_chunk EQUALS element at position index of sorted_arr  \n                INCREMENT chunks BY one  \n            END IF  \n        END FOR  \n        \n        RETURN chunks  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cheapest-flights-within-k-stops", "passing_rate": 0.9622641509433962, "pseudocode": "CLASS Solution  \n    FUNCTION findCheapestPrice(n parameter named n flights parameter named flights src parameter named src dst parameter named dst k parameter named k) RETURNS integer  \n        SET graph TO empty dictionary  \n        FOR index FROM zero TO n MINUS one  \n            SET element at position index of graph TO empty list  \n        END FOR  \n        FOR each element consisting of u comma v comma w IN flights  \n            APPEND pair consisting of v and w TO element at position u of graph  \n        END FOR  \n        SET min_heap TO list containing a triple consisting of zero comma negative one comma src  \n        SET min_cost TO dictionary with key src and value negative one  \n        WHILE min_heap is not empty  \n            REMOVE smallest element FROM min_heap AND UNPACK INTO cost comma stops comma city  \n            IF city EQUALS dst  \n                RETURN cost  \n            END IF  \n            IF stops GREATER THAN OR EQUAL TO k  \n                CONTINUE to next iteration of WHILE  \n            END IF  \n            FOR each element consisting of neighbor comma price IN element at position city of graph  \n                SET next_cost TO cost PLUS price  \n                SET next_stops TO stops PLUS one  \n                IF neighbor NOT IN min_cost OR next_stops LESS THAN element at position neighbor of min_cost OR next_cost LESS THAN first element of the first tuple in min_heap  \n                    SET element at position neighbor of min_cost TO next_stops  \n                    PUSH triple consisting of next_cost comma next_stops comma neighbor INTO min_heap  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-rotation-with-highest-score", "passing_rate": 0.9591836734693877, "pseudocode": "CLASS Solution  \n    FUNCTION bestRotation(nums)  \n        SET n TO the LENGTH OF nums  \n        SET delta TO a list of zeros with the LENGTH n  \n        \n        FOR each index i AND element num IN the enumeration of nums  \n            IF num LESS THAN OR EQUALS TO i  \n                INCREMENT element at position zero of delta BY one  \n                IF the result of i MINUS num PLUS one LESS THAN n  \n                    DECREMENT element at position i MINUS num PLUS one of delta BY one  \n                END IF  \n            END IF  \n            IF i PLUS one LESS THAN n  \n                INCREMENT element at position i PLUS one of delta BY one  \n                IF the result of i PLUS n MINUS num PLUS one LESS THAN n  \n                    DECREMENT element at position i PLUS n MINUS num PLUS one of delta BY one  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET score TO zero  \n        SET max_score TO zero  \n        SET best_k TO zero  \n        \n        FOR k FROM zero TO n MINUS one  \n            INCREMENT score BY element at position k of delta  \n            IF score GREATER THAN max_score  \n                SET max_score TO score  \n                SET best_k TO k  \n            END IF  \n        END FOR  \n        \n        RETURN best_k  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-eventual-safe-states", "passing_rate": 0.8181818181818182, "pseudocode": "CLASS Solution  \n    FUNCTION eventualSafeNodes(graph)  \n        FUNCTION is_safe(node)  \n            IF element at position node of visited EQUALS one  \n                RETURN false  \n            END IF  \n            IF element at position node of visited EQUALS two  \n                RETURN true  \n            END IF  \n            SET element at position node of visited TO one  \n            FOR each neighbor IN element at position node of graph  \n                IF is_safe(neighbor) EQUALS false  \n                    RETURN false  \n                END IF  \n            END FOR  \n            SET element at position node of visited TO two  \n            RETURN true  \n        END FUNCTION  \n        SET n TO the LENGTH OF graph  \n        SET visited TO a list containing zero repeated n times  \n        SET safe_nodes TO an empty list  \n        FOR each node FROM zero TO n MINUS one  \n            IF is_safe(node) EQUALS true  \n                APPEND node TO safe_nodes  \n            END IF  \n        END FOR  \n        RETURN safe_nodes  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "max-increase-to-keep-city-skyline", "passing_rate": 0.9803921568627451, "pseudocode": "CLASS Solution  \n    FUNCTION maxIncreaseKeepingSkyline(grid)  \n        SET n TO the LENGTH OF grid  \n        SET row_maxes TO an empty list  \n        FOR each row IN grid  \n            APPEND the maximum value in row TO row_maxes  \n        END FOR  \n        SET col_maxes TO an empty list  \n        FOR each column formed by collecting element at position with index of each row in grid  \n            APPEND the maximum value in column TO col_maxes  \n        END FOR  \n        SET total_increase TO zero  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET max_height TO the lesser value BETWEEN element at position i of row_maxes AND element at position j of col_maxes  \n                IF max_height MINUS element at position i of grid element at position j IS GREATER THAN zero  \n                    INCREMENT total_increase BY max_height MINUS element at position i of grid element at position j  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN total_increase  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "friends-of-appropriate-ages", "passing_rate": 0.8372093023255814, "pseudocode": "CLASS Solution  \n    FUNCTION numFriendRequests(ages)  \n        FUNCTION request_will_be_sent(age_x, age_y)  \n            RETURN NOT (age_y LESS THAN OR EQUAL TO age_x MULTIPLIED BY one half PLUS seven OR age_y GREATER THAN age_x OR age_y GREATER THAN one hundred AND age_x LESS THAN one hundred)  \n        END FUNCTION  \n        \n        SET count TO list of zero repeated one hundred and twenty one times  \n        FOR each age IN ages  \n            INCREMENT element at position age of count BY one  \n        END FOR  \n        \n        SET total_requests TO zero  \n        FOR age_x FROM one TO one hundred and twenty  \n            FOR age_y FROM one TO one hundred and twenty  \n                IF request_will_be_sent(age_x, age_y)  \n                    INCREMENT total_requests BY element at position age_x of count MULTIPLIED BY element at position age_y of count MINUS one IF age_x EQUALS age_y OTHERWISE zero  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN total_requests  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-and-replace-in-string", "passing_rate": 0.9038461538461539, "pseudocode": "CLASS Solution  \n    FUNCTION findReplaceString(s string parameter WITH name s indices parameter WITH name indices sources parameter WITH name sources targets parameter WITH name targets)  \n        SET replacements TO list CREATED BY arranging TOGETHER elements FROM indices sources AND targets AND SORTED BY elements at first position  \n        SET result TO empty list  \n        SET prev_end TO zero  \n        FOR each element IN replacements WITH names index source target  \n            APPEND substring of s FROM position prev_end TO position index TO result  \n            IF substring of s FROM position index TO position index PLUS LENGTH OF source EQUALS source THEN  \n                APPEND target TO result  \n            ELSE  \n                APPEND substring of s FROM position index TO position index PLUS LENGTH OF source TO result  \n            END IF  \n            SET prev_end TO index PLUS LENGTH OF source  \n        END FOR  \n        APPEND substring of s FROM position prev_end TO end TO result  \n        RETURN string FORMED BY JOINING all elements IN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shifting-letters", "passing_rate": 0.9545454545454546, "pseudocode": "CLASS Solution  \n    FUNCTION shiftingLetters(s, shifts)  \n        SET total_shifts TO zero  \n        FOR i FROM the LENGTH OF shifts MINUS one TO zero DECREMENT BY one  \n            INCREMENT total_shifts BY element at position i of shifts  \n            SET element at position i of shifts TO total_shifts  \n        END FOR  \n        SET result TO an empty list  \n        FOR i FROM zero TO the LENGTH OF s MINUS one  \n            SET numerical_value_of_character TO the numerical position of character at position i of s MINUS the numerical position of character a  \n            SET shifted_value TO numerical_value_of_character PLUS element at position i of shifts  \n            SET wrapped_value TO shifted_value MODULO twenty six  \n            SET new_character TO the character corresponding to the numerical position of character a PLUS wrapped_value  \n            APPEND new_character TO result  \n        END FOR  \n        SET output_string TO the concatenation of all elements in result  \n        RETURN output_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "advantage-shuffle", "passing_rate": 0.8478260869565217, "pseudocode": "CLASS Solution  \n    FUNCTION advantageCount(nums1, nums2)  \n        CALL sort nums1 in ascending order  \n        SET nums2_with_indices TO a list of pairs where each pair contains the element of nums2 and its original position in nums2  \n        CALL sort nums2_with_indices in descending order by the element value  \n        SET result TO a list of zeros with the same length as nums1  \n        SET left TO zero  \n        SET right TO the length of nums1 MINUS one  \n        FOR each pair (value, index) IN nums2_with_indices  \n            IF element at position right of nums1 GREATER THAN value  \n                SET element at position index of result TO element at position right of nums1  \n                DECREMENT right BY one  \n            ELSE  \n                SET element at position index of result TO element at position left of nums1  \n                INCREMENT left BY one  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse", "passing_rate": 0.925, "pseudocode": "CLASS Solution  \n    FUNCTION catMouseGame(graph)  \n        SET DRAW TO zero  \n        SET MOUSE_WIN TO one  \n        SET CAT_WIN TO two  \n        SET n TO the LENGTH OF graph  \n        \n        FUNCTION dfs(turn, mouse_pos, cat_pos)  \n            IF turn EQUALS two MULTIPLIED BY n THEN  \n                RETURN DRAW  \n            END IF  \n            IF mouse_pos EQUALS zero THEN  \n                RETURN MOUSE_WIN  \n            END IF  \n            IF mouse_pos EQUALS cat_pos THEN  \n                RETURN CAT_WIN  \n            END IF  \n            \n            IF turn MODULO two EQUALS zero THEN  \n                SET current_player TO mouse  \n            ELSE  \n                SET current_player TO cat  \n            END IF  \n            \n            IF current_player EQUALS mouse THEN  \n                SET result TO CAT_WIN  \n                FOR each next_pos IN element at position mouse_pos of graph  \n                    SET next_result TO dfs(turn PLUS one, next_pos, cat_pos)  \n                    IF next_result EQUALS MOUSE_WIN THEN  \n                        RETURN MOUSE_WIN  \n                    ELSE IF next_result EQUALS DRAW THEN  \n                        SET result TO DRAW  \n                    END IF  \n                END FOR  \n                RETURN result  \n            ELSE  \n                SET result TO MOUSE_WIN  \n                FOR each next_pos IN element at position cat_pos of graph  \n                    IF next_pos EQUALS zero THEN  \n                        CONTINUE  \n                    END IF  \n                    SET next_result TO dfs(turn PLUS one, mouse_pos, next_pos)  \n                    IF next_result EQUALS CAT_WIN THEN  \n                        RETURN CAT_WIN  \n                    ELSE IF next_result EQUALS DRAW THEN  \n                        SET result TO DRAW  \n                    END IF  \n                END FOR  \n                RETURN result  \n            END IF  \n        END FUNCTION  \n        \n        RETURN dfs(zero, one, two)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "three-equal-parts", "passing_rate": 0.9534883720930233, "pseudocode": "CLASS Solution  \n    FUNCTION threeEqualParts(arr)  \n        SET total_ones TO the SUM OF all elements in arr  \n        \n        IF total_ones EQUALS zero  \n            RETURN a list consisting of zero and two  \n        END IF  \n        \n        IF total_ones MODULO three NOT EQUALS zero  \n            RETURN a list consisting of negative one and negative one  \n        END IF  \n        \n        SET part_ones TO total_ones DIVIDED BY three  \n        \n        SET first_part_index TO zero  \n        SET count_ones TO zero  \n        FOR i FROM zero TO the LENGTH OF arr MINUS one  \n            IF element at position i of arr EQUALS one  \n                INCREMENT count_ones BY one  \n                IF count_ones EQUALS one  \n                    SET first_part_index TO i  \n                END IF  \n                IF count_ones EQUALS part_ones  \n                    BREAK  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET second_part_index TO zero  \n        SET count_ones TO zero  \n        FOR i FROM zero TO the LENGTH OF arr MINUS one  \n            IF element at position i of arr EQUALS one  \n                INCREMENT count_ones BY one  \n                IF count_ones EQUALS part_ones PLUS one  \n                    SET second_part_index TO i  \n                    BREAK  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET third_part_index TO zero  \n        SET count_ones TO zero  \n        FOR i FROM zero TO the LENGTH OF arr MINUS one  \n            IF element at position i of arr EQUALS one  \n                INCREMENT count_ones BY one  \n                IF count_ones EQUALS two MULTIPLIED BY part_ones PLUS one  \n                    SET third_part_index TO i  \n                    BREAK  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET n TO the LENGTH OF arr MINUS third_part_index  \n        \n        IF first_part_index PLUS n LESS THAN OR EQUAL TO the LENGTH OF arr AND second_part_index PLUS n LESS THAN OR EQUAL TO the LENGTH OF arr AND  \n           the sublist from position first_part_index TO position first_part_index PLUS n MINUS one of arr EQUALS the sublist from position second_part_index TO position second_part_index PLUS n MINUS one of arr AND  \n           the sublist from position second_part_index TO position second_part_index PLUS n MINUS one of arr EQUALS the sublist from position third_part_index TO the END OF arr  \n            RETURN a list consisting of first_part_index PLUS n MINUS one AND second_part_index PLUS n  \n        END IF  \n        \n        RETURN a list consisting of negative one AND negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-shortest-superstring", "passing_rate": 0.9310344827586207, "pseudocode": "CLASS Solution  \n    FUNCTION shortestSuperstring(words)  \n        SET n TO the LENGTH OF words  \n        \n        FUNCTION overlap(i, j)  \n            FOR k FROM the MINIMUM OF the LENGTH OF element at position i of words AND the LENGTH OF element at position j of words DOWN TO one  \n                IF the SUBSTRING consisting of the last k characters of element at position i of words EQUALS the SUBSTRING consisting of the first k characters of element at position j of words  \n                    RETURN k  \n                END IF  \n            END FOR  \n            RETURN zero  \n        END FUNCTION  \n        \n        FUNCTION dp(mask, i)  \n            IF mask EQUALS the INTEGER ONE SHIFTED LEFT BY n MINUS one  \n                RETURN a TUPLE of zero and empty string  \n            END IF  \n            \n            SET min_len TO positive infinity  \n            SET best_path TO empty string  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of mask AND integer one SHIFTED LEFT BY j EQUALS zero  \n                    SET length_and_path TO the RESULT OF dp where first parameter is the BITWISE OR of mask AND integer one SHIFTED LEFT BY j AND second parameter j  \n                    SET length TO the first element of length_and_path  \n                    SET path TO the second element of length_and_path  \n                    SET length TO length PLUS the LENGTH OF element at position j of words MINUS the RESULT OF overlap with parameters i and j  \n                    IF length LESS THAN min_len  \n                        SET min_len TO length  \n                        SET best_path TO the SUBSTRING of element at position j of words starting from the position EQUAL TO the RESULT OF overlap with parameters i and j TO the END CONCATENATED WITH path  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN a TUPLE of min_len and best_path  \n        END FUNCTION  \n        \n        SET min_len TO positive infinity  \n        SET shortest_path TO empty string  \n        FOR i FROM zero TO n MINUS one  \n            SET length_and_path TO the RESULT OF dp where first parameter is integer one SHIFTED LEFT BY i AND second parameter i  \n            SET length TO the first element of length_and_path  \n            SET path TO the second element of length_and_path  \n            SET length TO length PLUS the LENGTH OF element at position i of words  \n            IF length LESS THAN min_len  \n                SET min_len TO length  \n                SET shortest_path TO element at position i of words CONCATENATED WITH path  \n            END IF  \n        END FOR  \n        \n        RETURN shortest_path  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-component-size-by-common-factor", "passing_rate": 0.9811320754716981, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n        SET self.rank TO list of integer one repeated size times  \n        SET self.size TO list of integer one repeated size times  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET rootU TO self.find(u)  \n        SET rootV TO self.find(v)  \n        IF rootU NOT EQUALS rootV THEN  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank THEN  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.size BY element at position rootV of self.size  \n            ELSE IF element at position rootU of self.rank LESS THAN element at position rootV of self.rank THEN  \n                SET element at position rootU of self.parent TO rootV  \n                INCREMENT element at position rootV of self.size BY element at position rootU of self.size  \n            ELSE  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.rank BY integer one  \n                INCREMENT element at position rootU of self.size BY element at position rootV of self.size  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION largestComponentSize(self, nums)  \n        SET max_num TO the maximum value in nums  \n        SET uf TO a new UnionFind object initialized with max_num PLUS one  \n        SET prime_to_index TO an empty dictionary  \n        FOR each num IN nums  \n            FOR each prime IN self.prime_factors(num)  \n                IF prime IN prime_to_index THEN  \n                    CALL uf.union(element at prime in prime_to_index, num)  \n                ELSE  \n                    ASSIGN num TO prime_to_index at prime  \n                END IF  \n            END FOR  \n        END FOR  \n        SET max_component_size TO integer zero  \n        FOR each num IN nums  \n            SET root TO uf.find(num)  \n            IF element at root in uf.size GREATER THAN max_component_size THEN  \n                SET max_component_size TO element at root in uf.size  \n            END IF  \n        END FOR  \n        RETURN max_component_size  \n    END FUNCTION  \n\n    FUNCTION prime_factors(self, n)  \n        SET factors TO an empty set  \n        WHILE n MODULO integer two EQUALS integer zero  \n            ADD integer two TO factors  \n            SET n TO n DIVIDED BY integer two  \n        END WHILE  \n        FOR i FROM integer three TO the integer part of the square root of n PLUS integer one STEP integer two  \n            WHILE n MODULO i EQUALS integer zero  \n                ADD i TO factors  \n                SET n TO n DIVIDED BY i  \n            END WHILE  \n        END FOR  \n        IF n GREATER THAN integer two THEN  \n            ADD n TO factors  \n        END IF  \n        RETURN factors  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "brace-expansion-ii", "passing_rate": 0.9791666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION braceExpansionII(expression)  \n        FUNCTION parse_expression(index)  \n            SET current_set TO an empty set  \n            SET current_product TO a list containing an empty string  \n            \n            WHILE index LESS THAN the LENGTH OF expression  \n                SET char TO element at position index of expression  \n                \n                IF char EQUALS the symbol representing opening curly brace  \n                    SET inner_set AND index TO the result of parse_expression with index PLUS one  \n                    SET new_product TO an empty list  \n                    FOR each string_a IN current_product  \n                        FOR each string_b IN inner_set  \n                            APPEND concatenation of string_a AND string_b TO new_product  \n                        END FOR  \n                    END FOR  \n                    SET current_product TO new_product  \n                \n                ELSE IF char EQUALS the symbol representing closing curly brace  \n                    FOR each p IN current_product  \n                        ADD the concatenation of characters in p TO current_set  \n                    END FOR  \n                    RETURN current_set AND index  \n                \n                ELSE IF char EQUALS the symbol representing comma  \n                    FOR each p IN current_product  \n                        ADD the concatenation of characters in p TO current_set  \n                    END FOR  \n                    SET current_product TO a list containing an empty string  \n                \n                ELSE  # char is a lowercase letter  \n                    SET new_product TO an empty list  \n                    FOR each string_a IN current_product  \n                        APPEND concatenation of string_a AND char TO new_product  \n                    END FOR  \n                    SET current_product TO new_product  \n                \n                INCREMENT index BY one  \n            END WHILE  \n            \n            FOR each p IN current_product  \n                ADD the concatenation of characters in p TO current_set  \n            END FOR  \n            \n            RETURN current_set AND index  \n        END FUNCTION  \n        \n        SET result_set AND a throwaway variable TO parse_expression with zero  \n        RETURN sorted list of elements in result_set  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-score-words-formed-by-letters", "passing_rate": 0.9215686274509803, "pseudocode": "CLASS Solution  \n    FUNCTION maxScoreWords(words letters score)  \n        FUNCTION word_score(word score_map)  \n            SET total_score TO zero  \n            FOR each character IN word  \n                INCREMENT total_score BY the value at character in score_map  \n            END FOR  \n            RETURN total_score  \n        END FUNCTION  \n        \n        FUNCTION can_form(word letter_count)  \n            SET word_count TO a mapping of character frequencies in word  \n            FOR each character AND count IN word_count  \n                IF the value at character in letter_count LESS THAN count THEN  \n                    RETURN false  \n                END IF  \n            END FOR  \n            RETURN true  \n        END FUNCTION  \n        \n        FUNCTION update_letter_count(letter_count word add)  \n            FOR each character IN word  \n                IF add EQUALS true THEN  \n                    INCREMENT the value at character in letter_count BY one  \n                ELSE  \n                    DECREMENT the value at character in letter_count BY one  \n                END IF  \n            END FOR  \n        END FUNCTION  \n        \n        FUNCTION backtrack(index current_score letter_count)  \n            IF index EQUALS the length of words THEN  \n                RETURN current_score  \n            END IF  \n            \n            SET max_score TO current_score  \n            FOR i FROM index TO one LESS THAN the length of words  \n                IF can_form(the element at position i of words letter_count) EQUALS true THEN  \n                    CALL update_letter_count(letter_count the element at position i of words false)  \n                    SET candidate_score TO backtrack(i PLUS one current_score PLUS word_score(the element at position i of words score_map) letter_count)  \n                    IF candidate_score GREATER THAN max_score THEN  \n                        SET max_score TO candidate_score  \n                    END IF  \n                    CALL update_letter_count(letter_count the element at position i of words true)  \n                END IF  \n            END FOR  \n            \n            RETURN max_score  \n        END FUNCTION  \n        \n        SET score_map TO an empty mapping  \n        FOR i FROM zero TO twenty FIVE  \n            SET the character corresponding to the code point of lowercase a PLUS i in score_map TO the element at position i of score  \n        END FOR  \n        \n        SET letter_count TO a mapping of character frequencies in letters  \n        \n        RETURN backtrack(zero zero letter_count)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "handshakes-that-dont-cross", "passing_rate": 0.8333333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION numberOfWays(numPeople)  \n        SET MOD TO ten raised to the power nine PLUS one  \n        INITIALIZE dp AS a list of zeroes with the size of numPeople PLUS one  \n        SET element at position zero of dp TO one  \n        SET element at position two of dp TO one  \n        FOR i FROM four TO numPeople IN STEPS OF two  \n            FOR j FROM zero TO i MINUS one IN STEPS OF two  \n                SET element at position i of dp TO the sum of element at position i of dp PLUS the product of element at position j of dp AND element at position i MINUS two MINUS j of dp  \n                TAKE the modulo MOD of element at position i of dp  \n            END FOR  \n        END FOR  \n        RETURN element at position numPeople of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-falling-path-sum-ii", "passing_rate": 0.9183673469387755, "pseudocode": "CLASS Solution  \n    FUNCTION minFallingPathSum(grid)  \n        IF grid EQUALS empty OR element at position zero of grid EQUALS empty  \n            RETURN zero  \n        END IF  \n          \n        SET n TO the LENGTH OF grid  \n          \n        IF n EQUALS one  \n            RETURN the MINIMUM element IN element at position zero of grid  \n        END IF  \n          \n        SET dp TO a COPY OF element at position zero of grid  \n          \n        FOR i FROM one TO n MINUS one  \n            SET new_dp TO a LIST OF zero VALUES WITH the LENGTH OF n  \n            SET min1 TO positive infinity  \n            SET min2 TO positive infinity  \n            SET min1_index TO negative one  \n              \n            FOR j FROM zero TO n MINUS one  \n                IF element at position j of dp LESS THAN min1  \n                    SET min2 TO min1  \n                    SET min1 TO element at position j of dp  \n                    SET min1_index TO j  \n                ELSE IF element at position j of dp LESS THAN min2  \n                    SET min2 TO element at position j of dp  \n                END IF  \n            END FOR  \n              \n            FOR j FROM zero TO n MINUS one  \n                IF j EQUALS min1_index  \n                    SET element at position j of new_dp TO element at position i of grid AT position j PLUS min2  \n                ELSE  \n                    SET element at position j of new_dp TO element at position i of grid AT position j PLUS min1  \n                END IF  \n            END FOR  \n              \n            SET dp TO a COPY OF new_dp  \n        END FOR  \n          \n        RETURN the MINIMUM element IN dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-candies-you-can-get-from-boxes", "passing_rate": 0.8571428571428571, "pseudocode": "CLASS Solution  \n    FUNCTION maxCandies(status LIST OF INTEGER, candies LIST OF INTEGER, keys LIST OF LIST OF INTEGER, containedBoxes LIST OF LIST OF INTEGER, initialBoxes LIST OF INTEGER) RETURNS INTEGER  \n        SET boxes_we_have TO the SET containing each element of initialBoxes  \n        SET keys_we_have TO an EMPTY SET  \n        SET total_candies TO zero  \n        SET progress_made TO True  \n        WHILE progress_made holds  \n            SET progress_made TO False  \n            FOR each box IN the LIST created from boxes_we_have  \n                IF the element at position box of status EQUALS one OR box IS AN ELEMENT OF keys_we_have  \n                    SET total_candies TO total_candies PLUS the element at position box of candies  \n                    ADD each element of the element at position box of keys TO keys_we_have  \n                    ADD each element of the element at position box of containedBoxes TO boxes_we_have  \n                    REMOVE box FROM boxes_we_have  \n                    SET progress_made TO True  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN total_candies  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "verbal-arithmetic-puzzle", "passing_rate": 0.9811320754716981, "pseudocode": "CLASS Solution  \n    FUNCTION isSolvable(words, result)  \n        SET unique_chars TO the set of all characters found by concatenating all words in words plus result  \n        IF the LENGTH OF unique_chars GREATER THAN ten  \n            RETURN false  \n        END IF  \n        \n        SET non_zero_chars TO the set of first characters of each word in words WHERE the LENGTH OF word GREATER THAN one UNION the first character of result IF the LENGTH OF result GREATER THAN one OTHERWISE an empty string  \n        \n        SET char_to_digit TO an empty mapping from characters to digits  \n        SET digit_to_char TO an empty mapping from digits to characters  \n        \n        FUNCTION can_assign(char, digit)  \n            RETURN char NOT IN char_to_digit AND (digit NOT IN digit_to_char OR digit_to_char[digit] EQUALS char)  \n        END FUNCTION  \n        \n        FUNCTION assign(char, digit)  \n            SET char_to_digit at key char TO digit  \n            SET digit_to_char at key digit TO char  \n        END FUNCTION  \n        \n        FUNCTION unassign(char, digit)  \n            REMOVE the key char FROM char_to_digit  \n            REMOVE the key digit FROM digit_to_char  \n        END FUNCTION  \n        \n        FUNCTION word_value(word)  \n            SET value_sum TO zero  \n            FOR each position i and character char IN the word starting from the last character TO the first character WITH enumeration  \n                INCREMENT value_sum BY char_to_digit at key char MULTIPLIED BY ten RAISED TO the power of i  \n            END FOR  \n            RETURN value_sum  \n        END FUNCTION  \n        \n        FUNCTION backtrack(index, col, sum_col)  \n            IF col GREATER THAN OR EQUAL TO the maximum LENGTH OF any word in words AND col GREATER THAN OR EQUAL TO the LENGTH OF result  \n                RETURN sum_col EQUALS zero  \n            END IF  \n            \n            IF index EQUALS the LENGTH OF words  \n                IF col LESS THAN the LENGTH OF result  \n                    SET digit_char TO the character at position LENGTH OF result MINUS one MINUS col of result  \n                    IF digit_char IN char_to_digit  \n                        IF char_to_digit at key digit_char EQUALS sum_col MODULO ten  \n                            RETURN backtrack ZERO col PLUS one sum_col INTEGER DIVIDED BY ten  \n                        ELSE  \n                            RETURN false  \n                        END IF  \n                    ELSE IF can_assign(digit_char sum_col MODULO ten) AND (sum_col MODULO ten NOT EQUALS zero OR digit_char NOT IN non_zero_chars)  \n                        assign digit_char sum_col MODULO ten  \n                        IF backtrack ZERO col PLUS one sum_col INTEGER DIVIDED BY ten  \n                            RETURN true  \n                        END IF  \n                        unassign digit_char sum_col MODULO ten  \n                    END IF  \n                ELSE  \n                    RETURN sum_col EQUALS zero  \n                END IF  \n                RETURN false  \n            END IF  \n            \n            SET current_word TO element at position index of words  \n            IF col GREATER THAN OR EQUAL TO the LENGTH OF current_word  \n                RETURN backtrack index PLUS one col sum_col  \n            END IF  \n            \n            SET current_char TO the character at position LENGTH OF current_word MINUS one MINUS col of current_word  \n            IF current_char IN char_to_digit  \n                RETURN backtrack index PLUS one col sum_col PLUS char_to_digit at key current_char  \n            END IF  \n            \n            FOR digit FROM zero TO nine  \n                IF can_assign current_char digit AND (digit NOT EQUALS zero OR current_char NOT IN non_zero_chars)  \n                    assign current_char digit  \n                    IF backtrack index PLUS one col sum_col PLUS digit  \n                        RETURN true  \n                    END IF  \n                    unassign current_char digit  \n                END IF  \n            END FOR  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN backtrack ZERO ZERO ZERO  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-number-of-taps-to-open-to-water-a-garden", "passing_rate": 0.9591836734693877, "pseudocode": "CLASS Solution  \n    FUNCTION minTaps WITH parameters n AND ranges  \n        SET max_range TO a list of zeros with length equal to n PLUS one  \n        FOR index i FROM zero TO n  \n            IF element at position i of ranges GREATER THAN zero  \n                SET left TO the greater value between zero AND index i MINUS element at position i of ranges  \n                SET right TO the lesser value between n AND index i PLUS element at position i of ranges  \n                SET element at position left of max_range TO the greater value between element at position left of max_range AND right  \n            END IF  \n        END FOR  \n        SET taps TO zero  \n        SET current_end TO zero  \n        SET farthest TO zero  \n        FOR index i FROM zero TO n  \n            IF index i GREATER THAN farthest  \n                RETURN negative one  \n            END IF  \n            IF index i GREATER THAN current_end  \n                INCREMENT taps BY one  \n                SET current_end TO farthest  \n            END IF  \n            SET farthest TO the greater value between farthest AND element at position i of max_range  \n        END FOR  \n        RETURN taps  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-ways-of-cutting-a-pizza", "passing_rate": 0.967741935483871, "pseudocode": "CLASS Solution  \n    FUNCTION ways(pizza, k)  \n        FUNCTION dfs(i, j, k)  \n            IF k EQUALS zero  \n                SET has_apple TO the number of apples in the rectangle between row i and row m and column j and column n greater than zero  \n                RETURN the integer value of has_apple  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM i PLUS one TO m MINUS one  \n                SET has_apple_in_subrectangle TO the number of apples in the rectangle between row x and row m and column j and column n greater than zero  \n                IF has_apple_in_subrectangle  \n                    INCREMENT ans BY dfs(x, j, k MINUS one)  \n                END IF  \n            END FOR  \n            FOR y FROM j PLUS one TO n MINUS one  \n                SET has_apple_in_subrectangle TO the number of apples in the rectangle between row i and row m and column y and column n greater than zero  \n                IF has_apple_in_subrectangle  \n                    INCREMENT ans BY dfs(i, y, k MINUS one)  \n                END IF  \n            END FOR  \n            RETURN ans MODULO mod  \n        END FUNCTION  \n\n        SET mod TO ten TO THE POWER OF nine PLUS seven  \n        SET m TO the number of rows in pizza  \n        SET n TO the number of columns in pizza  \n        SET s TO a two dimensional list of zeros with dimensions m PLUS one by n PLUS one  \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                SET s at position i and j TO s at position i MINUS one and j PLUS s at position i and j MINUS one MINUS s at position i MINUS one and j MINUS one PLUS one IF the element at position j MINUS one of the element at position i MINUS one of pizza EQUALS the letter A OTHERWISE zero  \n            END FOR  \n        END FOR  \n        RETURN dfs(zero, zero, k MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "form-largest-integer-with-digits-that-add-up-to-target", "passing_rate": 0.9722222222222222, "pseudocode": "CLASS Solution  \n    FUNCTION largestNumber(cost, target)  \n        SET cost_to_digit TO an empty dictionary  \n        FOR each index i AND each element c IN the enumeration of cost  \n            SET the element at key c of cost_to_digit TO the string representation of the value of index i PLUS one  \n        END FOR  \n          \n        SET dp TO a list consisting of an empty string FOLLOWED BY target number of elements each set TO a string representing negative one  \n          \n        FOR each integer t FROM one TO target  \n            FOR each key c AND value d IN cost_to_digit  \n                IF t GREATER THAN OR EQUAL TO c AND the element at position t MINUS c of dp NOT EQUALS a string representing negative one THEN  \n                    SET candidate TO the concatenation of d PLUS the element at position t MINUS c of dp  \n                    IF the element at position t of dp EQUALS a string representing negative one OR the LENGTH OF candidate GREATER THAN the LENGTH OF the element at position t of dp OR both the LENGTH OF candidate EQUALS the LENGTH OF the element at position t of dp AND candidate GREATER THAN the element at position t of dp THEN  \n                        SET the element at position t of dp TO candidate  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n          \n        IF the element at position target of dp NOT EQUALS a string representing negative one THEN  \n            RETURN the element at position target of dp  \n        ELSE  \n            RETURN the string zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "passing_rate": 0.9354838709677419, "pseudocode": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(i, j, diff)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i of balls PLUS one MINUS one  \n                IF x EQUALS element at position i of balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO negative one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                INCREMENT ans BY dfs(i PLUS one, j MINUS x, diff PLUS y) MULTIPLIED BY combination of element at position i of balls taken x at a time  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO length of balls  \n        RETURN dfs(zero, n, zero) DIVIDED BY combination of n MULTIPLIED BY two taken n at a time  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree", "passing_rate": 0.9795918367346939, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO a list of integers from zero TO n MINUS one inclusive  \n        SET self.rank TO a list where each element is one repeated n times  \n    END FUNCTION  \n    \n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u THEN  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n    \n    FUNCTION union(self, u, v)  \n        SET rootU TO self.find(u)  \n        SET rootV TO self.find(v)  \n        \n        IF rootU NOT EQUALS rootV THEN  \n            IF element at position rootU of self.rank GREATER THAN element at position rootV of self.rank THEN  \n                SET element at position rootV of self.parent TO rootU  \n            ELSE IF element at position rootU of self.rank LESS THAN element at position rootV of self.rank THEN  \n                SET element at position rootU of self.parent TO rootV  \n            ELSE  \n                SET element at position rootV of self.parent TO rootU  \n                INCREMENT element at position rootU of self.rank BY one  \n            END IF  \n            RETURN True  \n        END IF  \n        RETURN False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION findCriticalAndPseudoCriticalEdges(self, n, edges)  \n        FOR index, edge IN enumeration of edges  \n            APPEND index TO edge  \n        END FOR  \n        \n        SORT edges BY the element at position two of each edge in ascending order  \n        \n        FUNCTION mst(exclude, include)  \n            SET uf TO new instance of UnionFind with parameter n  \n            SET weight TO zero  \n            \n            IF include IS NOT None THEN  \n                CALL uf.union with parameters element at position zero of include AND element at position one of include  \n                INCREMENT weight BY element at position two of include  \n            END IF  \n            \n            FOR each u, v, w, idx IN edges  \n                IF idx EQUALS exclude THEN  \n                    CONTINUE iteration  \n                END IF  \n                IF uf.union(u, v) THEN  \n                    INCREMENT weight BY w  \n                END IF  \n            END FOR  \n            \n            SET root TO uf.find(zero)  \n            FOR i FROM zero TO n MINUS one  \n                IF uf.find(i) NOT EQUALS root THEN  \n                    RETURN positive infinity  \n                END IF  \n            END FOR  \n            \n            RETURN weight  \n        END FUNCTION  \n        \n        SET mst_weight TO mst with no parameters  \n        \n        SET critical TO empty list  \n        SET pseudo_critical TO empty list  \n        \n        FOR each u, v, w, idx IN edges  \n            IF mst with parameter exclude equal to idx GREATER THAN mst_weight THEN  \n                APPEND idx TO critical  \n            ELSE IF mst with parameter include equal to tuple of u, v, w EQUALS mst_weight THEN  \n                APPEND idx TO pseudo_critical  \n            END IF  \n        END FOR  \n        \n        RETURN list containing critical and pseudo_critical  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "passing_rate": 0.96, "pseudocode": "CLASS Solution  \n    FUNCTION minInteger(num, k)  \n        SET num TO list of individual characters in num  \n        SET n TO the LENGTH OF num  \n        \n        WHILE k GREATER THAN zero holds  \n            SET swapped TO false  \n            FOR i FROM zero TO the LENGTH OF num MINUS one MINUS one  \n                IF element at position i of num GREATER THAN element at position i PLUS one of num THEN  \n                    SET min_digit TO the character representing nine  \n                    SET min_index TO negative one  \n                    FOR j FROM i TO the SMALLER OF i PLUS k PLUS one AND n MINUS one  \n                        IF element at position j of num LESS THAN min_digit THEN  \n                            SET min_digit TO element at position j of num  \n                            SET min_index TO j  \n                        END IF  \n                    END FOR  \n                    \n                    SET a new list TO element at position min_index of num APPENDED TO the sublist of num FROM position i TO position min_index MINUS one  \n                    REPLACE the sublist of num FROM position i TO position min_index WITH the new list  \n                    DECREMENT k BY min_index MINUS i  \n                    SET swapped TO true  \n                    BREAK the FOR loop  \n                END IF  \n            END FOR  \n            \n            IF swapped EQUALS false THEN  \n                BREAK the WHILE loop  \n            END IF  \n        END WHILE  \n        \n        SET result TO concatenation of all elements in num  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "graph-connectivity-with-threshold", "passing_rate": 0.8928571428571429, "pseudocode": "CLASS Solution  \n    FUNCTION areConnected(n, threshold, queries)  \n        IF threshold EQUALS zero  \n            RETURN list of True repeated the LENGTH OF queries  \n        END IF  \n        SET parent TO list of each number FROM zero TO n inclusive  \n        FUNCTION find(x)  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO find(element at position x of parent)  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n        FUNCTION union(x, y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootY of parent TO rootX  \n            END IF  \n        END FUNCTION  \n        FOR i FROM threshold PLUS one TO n inclusive  \n            FOR j FROM i MULTIPLIED BY two TO n inclusive STEP i  \n                union(i, j)  \n            END FOR  \n        END FOR  \n        SET result TO empty list  \n        FOR each a, b IN queries  \n            APPEND to result the expression find(a) EQUALS find(b)  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "checking-existence-of-edge-length-limited-paths", "passing_rate": 0.9487179487179487, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__ WITH PARAMETER size  \n        SET parent TO a list of integers starting from zero to size MINUS one inclusive  \n        SET rank TO a list containing size times the value one  \n    END FUNCTION  \n\n    FUNCTION find WITH PARAMETER p  \n        IF element at position p of parent NOT EQUALS p THEN  \n            SET element at position p of parent TO the result of calling find WITH PARAMETER element at position p of parent  \n        END IF  \n        RETURN element at position p of parent  \n    END FUNCTION  \n\n    FUNCTION union WITH PARAMETERS p q  \n        SET rootP TO the result of calling find WITH PARAMETER p  \n        SET rootQ TO the result of calling find WITH PARAMETER q  \n        IF rootP EQUALS rootQ THEN  \n            RETURN False  \n        END IF  \n        IF element at position rootP of rank GREATER THAN element at position rootQ of rank THEN  \n            SET element at position rootQ of parent TO rootP  \n        ELSE IF element at position rootP of rank LESS THAN element at position rootQ of rank THEN  \n            SET element at position rootP of parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of parent TO rootP  \n            INCREMENT element at position rootP of rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION distanceLimitedPathsExist WITH PARAMETERS n edgeList queries  \n        SORT edgeList IN ascending order BY the element at position two of each item  \n\n        SET indexedQueries TO an empty list  \n        FOR each index i and element having elements p q limit IN queries  \n            APPEND a tuple consisting of limit p q i TO indexedQueries  \n        END FOR  \n        SORT indexedQueries IN ascending order  \n\n        SET uf TO a new instance of UnionFind WITH PARAMETER n  \n\n        SET edgeIndex TO zero  \n        SET numEdges TO the count of elements in edgeList  \n        SET results TO a list containing the value False repeated the count of elements in queries times  \n\n        FOR each limit p q originalIndex IN indexedQueries  \n            WHILE edgeIndex LESS THAN numEdges AND the element at position two of the element at position edgeIndex of edgeList LESS THAN limit DO  \n                SET u TO the element at position zero of the element at position edgeIndex of edgeList  \n                SET v TO the element at position one of the element at position edgeIndex of edgeList  \n                CALL union ON uf WITH PARAMETERS u v  \n                INCREMENT edgeIndex BY one  \n            END WHILE  \n\n            IF the result of calling find ON uf WITH PARAMETER p EQUALS the result of calling find ON uf WITH PARAMETER q THEN  \n                SET element at position originalIndex of results TO True  \n            END IF  \n        END FOR  \n\n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-minimum-time-to-finish-all-jobs", "passing_rate": 0.9166666666666666, "pseudocode": "CLASS Solution  \n    FUNCTION minimumTimeRequired(jobs, k)  \n        SET n TO the LENGTH OF jobs  \n        SET subset_sums TO a list OF zeroes with the LENGTH OF two RAISED TO the power of n  \n        FOR i FROM zero TO n MINUS one  \n            FOR mask FROM zero TO two RAISED TO the power of i MINUS one  \n                SET element at position mask OR two RAISED TO the power of i OF subset_sums TO element at position mask OF subset_sums PLUS element at position i OF jobs  \n            END FOR  \n        END FOR  \n\n        FUNCTION dp(k_param, mask_param)  \n            IF k_param EQUALS one  \n                RETURN element at position mask_param OF subset_sums  \n            END IF  \n            SET res TO infinity  \n            SET submask TO mask_param  \n            WHILE submask IS NOT zero  \n                SET res TO the MINIMUM OF res AND the MAXIMUM OF dp with k_param MINUS one and mask_param XOR submask AND element at position submask OF subset_sums  \n                SET submask TO submask MINUS one AND mask_param  \n            END WHILE  \n            RETURN res  \n        END FUNCTION  \n\n        RETURN dp with parameters k AND two RAISED TO the power of n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-degree-of-a-connected-trio-in-a-graph", "passing_rate": 0.975609756097561, "pseudocode": "CLASS Solution  \n    FUNCTION minTrioDegree(n, edges)  \n        SET graph TO a mapping from each number FROM one TO n TO an empty set  \n        FOR each pair u AND v IN edges  \n            ADD element v TO the set associated with u in graph  \n            ADD element u TO the set associated with v in graph  \n        END FOR  \n        SET min_degree TO positive infinity  \n        SET trio_found TO false  \n        FOR i FROM one TO n  \n            FOR j FROM i PLUS one TO n  \n                FOR k FROM j PLUS one TO n  \n                    IF element j IS IN the set associated with i in graph AND element k IS IN the set associated with i in graph AND element k IS IN the set associated with j in graph  \n                        SET trio_found TO true  \n                        SET trio_degree TO the SIZE OF the set associated with i in graph PLUS the SIZE OF the set associated with j in graph PLUS the SIZE OF the set associated with k in graph MINUS six  \n                        IF trio_degree LESS THAN min_degree  \n                            SET min_degree TO trio_degree  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        IF trio_found EQUALS true  \n            RETURN min_degree  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-pairs-with-xor-in-a-range", "passing_rate": 0.9807692307692307, "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        SET children TO an empty collection mapping keys to values  \n        SET count TO zero  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Trie  \n    FUNCTION __init__(self, bit_length)  \n        ASSIGN reference TO a new instance of TrieNode TO root  \n        SET bit_length TO bit_length  \n    END FUNCTION  \n\n    FUNCTION insert(self, num)  \n        ASSIGN reference TO root TO node  \n        FOR i FROM bit_length TO zero DECREMENTING BY one  \n            SET bit TO the value of the bit at position i in num  \n            IF bit NOT IN the keys of the children collection of node THEN  \n                ASSIGN reference TO a new instance of TrieNode TO the element at key bit in the children collection of node  \n            END IF  \n            ASSIGN reference TO the element at key bit in the children collection of node TO node  \n            INCREMENT the count attribute of node BY one  \n        END FOR  \n    END FUNCTION  \n\n    FUNCTION count_less_than(self, num, threshold)  \n        SET count TO zero  \n        ASSIGN reference TO root TO node  \n        FOR i FROM bit_length TO zero DECREMENTING BY one  \n            IF node DOES NOT exist THEN  \n                EXIT the loop  \n            END IF  \n            SET bit TO the value of the bit at position i in num  \n            SET threshold_bit TO the value of the bit at position i in threshold  \n            IF threshold_bit EQUALS one THEN  \n                INCREMENT count BY count attribute of the child at key bit of node if exists OTHERWISE zero  \n                ASSIGN reference TO the child at key that is bit XOR one of node IF exists OTHERWISE to none TO node  \n            ELSE  \n                ASSIGN reference TO the child at key bit of node IF exists OTHERWISE to none TO node  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION countPairs(self, nums, low, high)  \n        ASSIGN reference TO a new instance of Trie TO trie  \n        SET nice_pairs TO zero  \n        FOR each element num IN nums  \n            INCREMENT nice_pairs BY the result of invoking count_less_than on trie with num and high PLUS one MINUS the result of invoking count_less_than on trie with num and low  \n            INVOKE the insert method of trie with argument num  \n        END FOR  \n        RETURN nice_pairs  \n    END FUNCTION  \nEND CLASS  "}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "passing_rate": 0.875, "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO empty list  \n        FOR each e IN expression  \n            IF e EQUALS left parenthesis OR e EQUALS ampersand OR e EQUALS vertical bar  \n                APPEND pair of e AND zero TO stack  \n                CONTINUE to next iteration  \n            END IF  \n            IF e EQUALS right parenthesis  \n                SET lastPair TO the last element removed FROM stack  \n                REMOVE the last element FROM stack  \n            ELSE  \n                SET lastPair TO pair of e AND one  \n            END IF  \n            IF the LENGTH OF stack GREATER THAN zero AND the first element of the last element of stack EQUALS ampersand OR vertical bar  \n                SET op TO the first element removed FROM the last element removed FROM stack  \n                SET pair a AND costA TO the last element removed FROM stack  \n                SET pair b AND costB TO lastPair  \n                IF op EQUALS ampersand  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO pair of zero AND one PLUS the lesser of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO pair of zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO pair of zero AND one  \n                    ELSE  \n                        SET lastPair TO pair of one AND the lesser of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO pair of zero AND the lesser of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO pair of one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO pair of one AND one  \n                    ELSE  \n                        SET lastPair TO pair of one AND one PLUS the lesser of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last element of stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-reach-destination-in-time", "passing_rate": 0.9245283018867925, "pseudocode": "CLASS Solution  \n    FUNCTION minCost(maxTime passingFees)  \n        SET n TO the LENGTH OF passingFees  \n        SET graph TO a list of empty lists with size n  \n        FOR each element x y time IN edges  \n            APPEND pair of y and time TO the element at position x of graph  \n            APPEND pair of x and time TO the element at position y of graph  \n        END FOR  \n        SET pq TO a list containing a triple of the element at position zero of passingFees and zero and zero  \n        SET visited_time TO a list of infinity values with size n  \n        SET the element at position zero of visited_time TO zero  \n        WHILE pq LIST is not empty  \n            SET current_cost current_city current_time TO the result of removing and returning the smallest element from pq  \n            IF current_city EQUALS n MINUS one  \n                RETURN current_cost  \n            END IF  \n            FOR each element neighbor travel_time IN the element at position current_city of graph  \n                SET new_time TO current_time PLUS travel_time  \n                SET new_cost TO current_cost PLUS the element at position neighbor of passingFees  \n                IF new_time LESS THAN OR EQUAL TO maxTime AND (new_time LESS THAN the element at position neighbor of visited_time OR new_cost LESS THAN current_cost)  \n                    SET the element at position neighbor of visited_time TO new_time  \n                    INSERT the triple of new_cost neighbor new_time INTO pq maintaining heap order  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-visible-people-in-a-queue", "passing_rate": 0.9047619047619048, "pseudocode": "CLASS Solution  \n    FUNCTION canSeePersonsCount(heights)  \n        SET n TO the LENGTH OF heights  \n        SET answer TO a list of zeros with the LENGTH OF n  \n        SET stack TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            WHILE the LENGTH OF stack IS GREATER THAN zero AND the element at position the last element of stack of heights IS LESS THAN the element at position i of heights  \n                SET top_index TO the last element of stack REMOVED from stack  \n                INCREMENT the element at position top_index of answer BY one  \n            END WHILE  \n            IF the LENGTH OF stack IS GREATER THAN zero  \n                INCREMENT the element at position the last element of stack of answer BY one  \n            END IF  \n            APPEND i TO stack  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "smallest-missing-genetic-value-in-each-subtree", "passing_rate": 0.9473684210526315, "pseudocode": "CLASS Solution  \n    FUNCTION smallestMissingValueSubtree(parents, nums)  \n        SET n TO the LENGTH OF parents  \n        INITIALIZE tree AS a mapping from each node to a list of its child nodes  \n        \n        FOR index FROM one TO n MINUS one  \n            APPEND index TO the list of children for the parent at position index in parents  \n        END FOR  \n        \n        SET node_with_one TO negative one  \n        FOR index FROM zero TO n MINUS one  \n            IF the element at position index of nums EQUALS one THEN  \n                SET node_with_one TO index  \n                BREAK the loop  \n            END IF  \n        END FOR  \n        \n        IF node_with_one EQUALS negative one THEN  \n            RETURN a list of one repeated n times  \n        END IF  \n        \n        INITIALIZE result AS a list of one repeated n times  \n        INITIALIZE visited AS an empty set  \n        \n        FUNCTION dfs(node)  \n            ADD node TO visited  \n            INITIALIZE genetic_values AS a set containing the element at position node of nums  \n            FOR each child IN the list of children for node in tree  \n                IF child NOT IN visited THEN  \n                    SET updated_values TO the result of dfs called with child  \n                    ADD all elements of updated_values TO genetic_values  \n                END IF  \n            END FOR  \n            \n            SET smallest_missing TO one  \n            WHILE smallest_missing IN genetic_values DO  \n                INCREMENT smallest_missing BY one  \n            END WHILE  \n            \n            SET the element at position node of result TO smallest_missing  \n            RETURN genetic_values  \n        END FUNCTION  \n        \n        INITIALIZE path AS an empty list  \n        SET current TO node_with_one  \n        WHILE current NOT EQUALS negative one  \n            APPEND current TO path  \n            SET current TO the element at position current of parents  \n        END WHILE  \n        \n        INITIALIZE path_set AS a set containing all elements of path  \n        \n        FOR each node IN the reverse order of path  \n            IF node IN visited THEN  \n                CONTINUE to the next iteration  \n            END IF  \n            CALL dfs(node)  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-product-of-two-sorted-arrays", "passing_rate": 0.9230769230769231, "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)  \n        FUNCTION count(p PARAMETER)  \n            SET cnt TO zero  \n            SET n TO the LENGTH OF nums2  \n            FOR each element x IN nums1  \n                IF x GREATER THAN zero THEN  \n                    INCREMENT cnt BY the NUMBER OF ELEMENTS IN nums2 UP TO AND INCLUDING THE HIGHEST POSITION WHERE the VALUE OF element at that POSITION IS LESS THAN OR EQUAL TO p DIVIDED BY x  \n                ELSE IF x LESS THAN zero THEN  \n                    INCREMENT cnt BY n MINUS the NUMBER OF ELEMENTS IN nums2 UP TO THE LOWEST POSITION WHERE the VALUE OF element at that POSITION IS GREATER THAN OR EQUAL TO p DIVIDED BY x  \n                ELSE  \n                    INCREMENT cnt BY n MULTIPLIED BY one IF p GREATER THAN OR EQUAL TO zero OTHERWISE zero  \n                END IF  \n            END FOR  \n            RETURN cnt  \n        END FUNCTION  \n\n        SET mx TO the MAXIMUM OF the ABSOLUTE VALUE OF the FIRST element of nums1 AND the ABSOLUTE VALUE OF the LAST element of nums1 MULTIPLIED BY the MAXIMUM OF the ABSOLUTE VALUE OF the FIRST element of nums2 AND the ABSOLUTE VALUE OF the LAST element of nums2  \n        RETURN the LOWEST POSITION IN the RANGE FROM the NEGATIVE OF mx TO mx PLUS one WHERE the VALUE OF k EQUALS the count FUNCTION APPLIED TO the CURRENT ELEMENT MINUS mx  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "process-restricted-friend-requests", "passing_rate": 0.8461538461538461, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        SET self.parent TO list of integers from zero TO n MINUS one  \n        SET self.size TO list of value one repeated n times  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF element at position u of self.parent NOT EQUALS u  \n            SET element at position u of self.parent TO self.find(element at position u of self.parent)  \n        END IF  \n        RETURN element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET root_u TO self.find(u)  \n        SET root_v TO self.find(v)  \n        IF root_u NOT EQUALS root_v  \n            IF element at position root_u of self.size GREATER THAN element at position root_v of self.size  \n                SET element at position root_v of self.parent TO root_u  \n                INCREMENT element at position root_u of self.size BY element at position root_v of self.size  \n            ELSE  \n                SET element at position root_u of self.parent TO root_v  \n                INCREMENT element at position root_v of self.size BY element at position root_u of self.size  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION friendRequests(self, n, restrictions, requests)  \n        SET uf TO new UnionFind with argument n  \n        SET result TO empty list  \n        SET restriction_map TO empty map  \n\n        FOR each pair x and y IN restrictions  \n            IF x is NOT a key in restriction_map  \n                SET element at key x of restriction_map TO empty set  \n            END IF  \n            IF y is NOT a key in restriction_map  \n                SET element at key y of restriction_map TO empty set  \n            END IF  \n            ADD y TO set element at key x of restriction_map  \n            ADD x TO set element at key y of restriction_map  \n        END FOR  \n\n        FUNCTION can_union(u, v)  \n            SET root_u TO uf.find(u)  \n            SET root_v TO uf.find(v)  \n            FOR each person IN element at key root_u of restriction_map or empty set if key root_u not present  \n                IF uf.find(person) EQUALS root_v  \n                    RETURN False  \n                END IF  \n            END FOR  \n            FOR each person IN element at key root_v of restriction_map or empty set if key root_v not present  \n                IF uf.find(person) EQUALS root_u  \n                    RETURN False  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n\n        FOR each pair u and v IN requests  \n            IF uf.find(u) EQUALS uf.find(v)  \n                APPEND True TO result  \n            ELSE IF can_union(u, v)  \n                CALL uf.union(u, v)  \n                APPEND True TO result  \n            ELSE  \n                APPEND False TO result  \n            END IF  \n        END FOR  \n\n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "groups-of-strings", "passing_rate": 0.9019607843137255, "pseudocode": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO a list of integers from zero TO size MINUS one  \n        SET self.rank TO a list containing size number of zeros  \n        SET self.size TO a list containing size number of ones  \n    END FUNCTION  \n\n    FUNCTION find(self, u)  \n        IF the element at position u of self.parent NOT EQUALS u  \n            SET the element at position u of self.parent TO the result of calling find with argument the element at position u of self.parent  \n        END IF  \n        RETURN the element at position u of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, u, v)  \n        SET rootU TO the result of calling find with argument u  \n        SET rootV TO the result of calling find with argument v  \n        IF rootU NOT EQUALS rootV  \n            IF the element at position rootU of self.rank GREATER THAN the element at position rootV of self.rank  \n                SET the element at position rootV of self.parent TO rootU  \n                INCREMENT the element at position rootU of self.size BY the element at position rootV of self.size  \n            ELSE IF the element at position rootU of self.rank LESS THAN the element at position rootV of self.rank  \n                SET the element at position rootU of self.parent TO rootV  \n                INCREMENT the element at position rootV of self.size BY the element at position rootU of self.size  \n            ELSE  \n                SET the element at position rootV of self.parent TO rootU  \n                INCREMENT the element at position rootU of self.size BY the element at position rootV of self.size  \n                INCREMENT the element at position rootU of self.rank BY one  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION groupStrings(self, words)  \n        FUNCTION bitmask(word)  \n            SET mask TO zero  \n            FOR each character IN word  \n                SET position TO the Unicode code point of character MINUS the Unicode code point of the lowercase letter a  \n                SET mask TO mask OR one shifted left by position places  \n            END FOR  \n            RETURN mask  \n        END FUNCTION  \n\n        SET word_map TO a default dictionary mapping keys to lists  \n        SET n TO the length of words  \n        SET uf TO a new instance of UnionFind with argument n  \n\n        FOR each index i and word IN the enumeration of words  \n            SET mask TO the result of calling bitmask with argument word  \n            APPEND i TO the list at key mask in word_map  \n        END FOR  \n\n        FOR each index i and word IN the enumeration of words  \n            SET mask TO the result of calling bitmask with argument word  \n            FOR j FROM zero TO twenty five  \n                # Delete one letter  \n                SET new_mask TO mask XOR one shifted left by j places  \n                IF new_mask IS a key in word_map  \n                    FOR each element k IN the list at key new_mask in word_map  \n                        CALL uf.union with arguments i and k  \n                    END FOR  \n                END IF  \n\n                # Add one letter  \n                IF the bitwise AND of mask and one shifted left by j places EQUALS zero  \n                    SET new_mask TO mask OR one shifted left by j places  \n                    IF new_mask IS a key in word_map  \n                        FOR each element k IN the list at key new_mask in word_map  \n                            CALL uf.union with arguments i and k  \n                        END FOR  \n                    END IF  \n                END IF  \n\n                # Replace one letter  \n                IF the bitwise AND of mask and one shifted left by j places NOT EQUALS zero  \n                    FOR k FROM zero TO twenty five  \n                        IF the bitwise AND of mask and one shifted left by k places EQUALS zero  \n                            SET new_mask TO the bitwise OR of (mask XOR one shifted left by j places) and one shifted left by k places  \n                            IF new_mask IS a key in word_map  \n                                FOR each element l IN the list at key new_mask in word_map  \n                                    CALL uf.union with arguments i and l  \n                                END FOR  \n                            END IF  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END FOR  \n\n        SET root_sizes TO a default dictionary mapping keys to zeroes  \n        FOR i FROM zero TO n MINUS one  \n            SET root TO the result of calling uf.find with argument i  \n            INCREMENT the value at key root in root_sizes BY one  \n        END FOR  \n\n        SET max_group_size TO the maximum value among all values in root_sizes  \n        SET num_groups TO the count of keys in root_sizes  \n\n        RETURN a list containing num_groups and max_group_size  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "amount-of-new-area-painted-each-day", "passing_rate": 0.9761904761904762, "pseudocode": "CLASS Solution  \n    FUNCTION amountPainted(paint)  \n        SET max_end TO the greatest value of the second element in each pair of paint  \n        SET painted TO a list containing negative one repeated for the quantity of max_end plus one  \n        SET worklog TO an empty list  \n        FOR each pair start and end IN paint  \n            SET current_start TO start  \n            SET new_paint TO zero  \n            WHILE current_start LESS THAN end  \n                IF element at position current_start of painted EQUALS negative one  \n                    SET element at position current_start of painted TO end  \n                    INCREMENT new_paint BY one  \n                    INCREMENT current_start BY one  \n                ELSE  \n                    SET current_start TO element at position current_start of painted  \n                END IF  \n            END WHILE  \n            APPEND new_paint TO worklog  \n        END FOR  \n        RETURN worklog  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distance-to-a-cycle-in-undirected-graph", "passing_rate": 0.8055555555555556, "pseudocode": "CLASS Solution  \n    FUNCTION distanceToCycle(n, edges)  \n        SET graph TO an empty mapping that assigns an empty list for missing keys  \n        FOR each pair u and v IN edges  \n            APPEND v TO the list corresponding to u in graph  \n            APPEND u TO the list corresponding to v in graph  \n        END FOR  \n\n        FUNCTION dfs(node, parent, path, visited)  \n            IF node IS IN visited  \n                SET cycle_start TO the position of node in path  \n                RETURN the sublist of path FROM position cycle_start TO the end  \n            END IF  \n            ADD node TO visited  \n            APPEND node TO path  \n            FOR each neighbor IN the list corresponding to node in graph  \n                IF neighbor IS NOT EQUAL TO parent  \n                    SET cycle TO the result of calling dfs WITH neighbor, node, path, visited  \n                    IF cycle IS NOT NONE  \n                        RETURN cycle  \n                    END IF  \n                END IF  \n            END FOR  \n            REMOVE the last element FROM path  \n            RETURN NONE  \n        END FUNCTION  \n\n        SET visited TO an empty set  \n        SET cycle TO NONE  \n        FOR node FROM zero TO n MINUS one  \n            IF node IS NOT IN visited  \n                SET cycle TO the result of calling dfs WITH node, negative one, an empty list, visited  \n                IF cycle IS NOT NONE  \n                    BREAK the loop  \n                END IF  \n            END IF  \n        END FOR  \n\n        SET distance TO a list of zeros with the length n  \n        SET queue TO a double-ended queue initialized with cycle  \n        SET visited TO a set initialized with cycle  \n\n        SET level TO zero  \n        WHILE the queue IS NOT empty  \n            SET current_length TO the LENGTH of queue  \n            FOR index FROM zero TO current_length MINUS one  \n                REMOVE the element from the front of queue and ASSIGN it TO node  \n                SET the element at position node of distance TO level  \n                FOR each neighbor IN the list corresponding to node in graph  \n                    IF neighbor IS NOT IN visited  \n                        ADD neighbor TO visited  \n                        APPEND neighbor TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n            INCREMENT level BY one  \n        END WHILE  \n\n        RETURN distance  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "make-array-non-decreasing-or-non-increasing", "passing_rate": 0.9583333333333334, "pseudocode": "CLASS Solution  \n    FUNCTION convertArray(nums)  \n        FUNCTION min_operations_to_non_decreasing(nums)  \n            SET max_heap TO empty list  \n            SET operations TO zero  \n            FOR each num IN nums  \n                IF max_heap is not empty AND the negative of the element at position zero of max_heap GREATER THAN num  \n                    INCREMENT operations BY the negative of the element extracted from max_heap MINUS num  \n                    INSERT the negative of num INTO max_heap  \n                END IF  \n                INSERT the negative of num INTO max_heap  \n            END FOR  \n            RETURN operations  \n        END FUNCTION  \n        \n        FUNCTION min_operations_to_non_increasing(nums)  \n            SET min_heap TO empty list  \n            SET operations TO zero  \n            FOR each num IN nums  \n                IF min_heap is not empty AND the element at position zero of min_heap LESS THAN num  \n                    INCREMENT operations BY num MINUS the element extracted from min_heap  \n                    INSERT num INTO min_heap  \n                END IF  \n                INSERT num INTO min_heap  \n            END FOR  \n            RETURN operations  \n        END FUNCTION  \n        \n        RETURN the smaller value BETWEEN min_operations_to_non_decreasing(nums) AND min_operations_to_non_increasing(nums)  \n    END FUNCTION  \nEND CLASS"}
