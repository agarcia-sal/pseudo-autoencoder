{
  "prompt": "Given the pseudocode below, output **`1`** if it is fully *functionally reproducible*\u2014meaning it can be straightforwardly translated into correct, executable code that **passes every relevant unit test covering the entire valid input domain**\u2014otherwise output **`0`**. Output **only** the single character `1` or `0`; no explanations or whitespace.\n\nTo decide, rigorously validate these core criteria **only from the given pseudocode** without any outside assumptions:\n\n1. **Completeness and Explicit Definition**  \n   - All variables, inputs, outputs, and data structures are explicitly declared and initialized or clearly derivable, with no missing or ambiguous components.  \n   - All operations, including control constructs (loops, conditionals, recursion), are fully specified and unambiguously described in precise, logical steps.\n\n2. **Logical Correctness and Edge Case Handling**  \n   - The pseudocode\u2019s logic is sound and consistent; control flows and data transformations correctly implement the intended algorithm for every permitted input.  \n   - Boundary conditions, special cases, and potential error scenarios are handled explicitly or can be definitively inferred from the pseudocode.\n\n3. **Self-Containment and Independence**  \n   - The pseudocode is fully self-sufficient: it does not depend on undisclosed helper functions, external procedures, hidden states, or omitted definitions.  \n   - No implicit assumptions or external context are required to understand or implement it.\n\n4. **Determinism and Clarity of Execution**  \n   - Each step of the pseudocode results in a uniquely determined operation and outcome, with no vague descriptions, unresolved ambiguities, or contradictory instructions.\n\n5. **Test-Equivalent Correctness Guarantee**  \n   - Based solely on this pseudocode, correct implementation will necessarily pass *all* unit tests designed for the problem\u2019s complete input domain without failures, misbehaviors, or exceptions.\n\n---\n\n**Evaluation instructions:**  \n- Consider only the pseudocode as given here. Do not incorporate knowledge from problem descriptions, informal comments, or external examples.  \n- Ignore formatting, style, language syntax, or superficial inconsistencies. Focus strictly on functional reproducibility and comprehensive correctness.  \n- Respond with exactly one character: `1` if all criteria above are met, otherwise `0`.  \n- Output nothing else\u2014no explanations, no spaces, no newlines.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "response": "Given the pseudocode below, output **`1`** if it is fully *functionally reproducible*\u2014meaning it can be straightforwardly translated into correct, executable code that **passes every relevant unit test covering the entire valid input domain**\u2014otherwise output **`0`**. Output **only** the single character `1` or `0`; no explanations or whitespace.\n\nTo decide, rigorously validate these core criteria **only from the given pseudocode** without any outside assumptions:\n\n1. **Completeness and Explicit Definition**  \n   - All variables, inputs, outputs, and data structures are explicitly declared and initialized or clearly derivable, with no missing or ambiguous components.  \n   - All operations, including control constructs (loops, conditionals, recursion), are fully specified and unambiguously described in precise, logical steps.\n\n2. **Logical Correctness and Edge Case Handling**  \n   - The pseudocode\u2019s logic is sound and consistent; control flows and data transformations correctly implement the intended algorithm for every permitted input.  \n   - Boundary conditions, special cases, and potential error scenarios are handled explicitly or can be definitively inferred from the pseudocode.\n\n3. **Self-Containment and Independence**  \n   - The pseudocode is fully self-sufficient: it does not depend on undisclosed helper functions, external procedures, hidden states, or omitted definitions.  \n   - No implicit assumptions or external context are required to understand or implement it.\n\n4. **Determinism and Clarity of Execution**  \n   - Each step of the pseudocode results in a uniquely determined operation and outcome, with no vague descriptions, unresolved ambiguities, or contradictory instructions.\n\n5. **Test-Equivalent Correctness Guarantee**  \n   - Based solely on this pseudocode, correct implementation will necessarily pass *all* unit tests designed for the problem\u2019s complete input domain without failures, misbehaviors, or exceptions.\n\n---\n\n**Evaluation instructions:**  \n- Consider only the pseudocode as given here. Do not incorporate knowledge from problem descriptions, informal comments, or external examples.  \n- Ignore formatting, style, language syntax, or superficial inconsistencies. Focus strictly on functional reproducibility and comprehensive correctness.  \n- Respond with exactly one character: `1` if all criteria above are met, otherwise `0`.  \n- Output nothing else\u2014no explanations, no spaces, no newlines.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "score": 0.5966666666666667,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each element m IN nums  \n            IF element m EQUALS value m1  \n                INCREMENT n1 BY one  \n            ELSE IF element m EQUALS value m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO element m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO element m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE the count of element m IN nums IS GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\n```\nif num1==\"0\" or num2==\"0\": return \"0\"\nres = [0]*(len(num1)+len(num2))\nn1, n2 = num1[::-1], num2[::-1]\nfor i in range(len(n1)):\n  for j in range(len(n2)):\n    mul = (ord(n1[i])-48)*(ord(n2[j])-48)\n    sum_ = mul + res[i+j]\n    res[i+j], res[i+j+1] = sum_%10, res[i+j+1]+sum_//10\nreturn ''.join(map(str,res[::-1])).lstrip('0')\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n```\nn = len(s)\nif n \u2264 1: return 0\n\nis_pal = [[False]*n for _ in range(n)]\nfor i in 0..n-1: is_pal[i][i] = True\n\nfor length in 2..n:\n  for start in 0..n-length:\n    end = start+length-1\n    if length=2: is_pal[start][end] = (s[start]==s[end])\n    else: is_pal[start][end] = (s[start]==s[end]) and is_pal[start+1][end-1]\n\nmin_cut = [0]*n\nfor i in 0..n-1:\n  if is_pal[0][i]: min_cut[i]=0\n  else:\n    min_cut[i] = \u221e\n    for j in 1..i:\n      if is_pal[j][i]: min_cut[i] = min(min_cut[i], min_cut[j-1]+1)\n\nreturn min_cut[n-1]\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.5966666666666667",
  "iter": 5
}