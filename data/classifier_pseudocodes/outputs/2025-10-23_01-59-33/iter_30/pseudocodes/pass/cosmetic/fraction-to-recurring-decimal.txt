CLASS Solution  
    FUNCTION fractionToDecimal(numerator, denominator)  
        DECLARE polarity AS string  
        IF (numerator < 0 AND denominator >= 0) OR (numerator >= 0 AND denominator < 0) THEN  
            polarity ← "-"  
        ELSE  
            polarity ← ""  
        ENDIF  
  
        numerator ← ABS(numerator)  
        denominator ← ABS(denominator)  
  
        DECLARE integralQuotient AS integer ← numerator DIV denominator  
        DECLARE modValue AS integer ← numerator MOD denominator  
        DECLARE integerString AS string ← TO_STRING(integralQuotient)  
  
        IF modValue = 0 THEN  
            RETURN CONCAT(polarity, integerString)  
        ENDIF  
  
        DECLARE remainderPositions AS MAP FROM integer TO integer ← EMPTY MAP  
        DECLARE digits AS LIST OF string ← EMPTY LIST  
  
        DECLARE currentRemainder AS integer ← modValue  
        WHILE currentRemainder ≠ 0 DO  
            IF remainderPositions CONTAINS currentRemainder THEN  
                DECLARE cycleStart AS integer ← remainderPositions[currentRemainder]  
                DECLARE prefix AS string ← ""  
                DECLARE suffix AS string ← ""  
                FOR idx FROM 0 TO cycleStart - 1 DO  
                    prefix ← CONCAT(prefix, digits[idx])  
                ENDFOR  
                FOR idx FROM cycleStart TO LENGTH(digits) - 1 DO  
                    suffix ← CONCAT(suffix, digits[idx])  
                ENDFOR  
                RETURN CONCAT(polarity, integerString, ".", prefix, "(", suffix, ")")  
            ENDIF  
  
            remainderPositions[currentRemainder] ← LENGTH(digits)  
  
            currentRemainder ← currentRemainder * 10  
            DECLARE digitValue AS integer ← currentRemainder DIV denominator  
            currentRemainder ← currentRemainder MOD denominator  
            APPEND TO digits: TO_STRING(digitValue)  
        ENDWHILE  
  
        RETURN CONCAT(polarity, integerString, ".", JOIN(digits))  
    END FUNCTION  
END CLASS