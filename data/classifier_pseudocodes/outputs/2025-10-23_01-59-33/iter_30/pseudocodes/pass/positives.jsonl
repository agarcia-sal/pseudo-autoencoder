{"task_id": "jump-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "palindrome-partitioning-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "fraction-to-recurring-decimal", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "count-primes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "perfect-squares", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sentence-screen-fitting", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION wordsTyping(sentence, rows, cols)  \n        SET s TO the concatenation of all elements of sentence with a single space between each followed by a single space character  \n        SET total_length TO the LENGTH OF s  \n        SET position TO zero  \n        \n        FOR each iteration IN the range from one TO rows  \n            INCREMENT position BY cols  \n            \n            IF the element at position MODULO total_length of s EQUALS a space character  \n                INCREMENT position BY one  \n            ELSE  \n                WHILE position GREATER THAN zero AND the element at position MINUS one MODULO total_length of s NOT EQUALS a space character  \n                    DECREMENT position BY one  \n                END WHILE  \n            END IF  \n        END FOR  \n        \n        RETURN position DIVIDED BY total_length  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "output-contest-matches", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        SET teams TO an empty list  \n        FOR number FROM one TO n  \n            APPEND the string representation of number TO teams  \n        END FOR  \n        WHILE n GREATER THAN one  \n            FOR i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO the concatenation of an open parenthesis concatenated with the element at position i of teams concatenated with a comma concatenated with the element at position n MINUS one MINUS i of teams concatenated with a close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN the element at position zero of teams  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "k-inverse-pairs-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION kInversePairs(n, k)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a two dimensional list of zeros with dimension n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp  \n                IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                IF j GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of element at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                SET element at position j of element at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "non-decreasing-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "longest-word-in-dictionary", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN LEXICOGRAPHICAL ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO an empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from position one TO position LENGTH OF word MINUS one IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "swap-adjacent-in-lr-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "valid-tic-tac-toe-state", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION validTicTacToe(board)  \n        SET countX TO zero  \n        FOR each row IN board  \n            INCREMENT countX BY the number of occurrences of character X in row  \n        END FOR  \n        SET countO TO zero  \n        FOR each row IN board  \n            INCREMENT countO BY the number of occurrences of character O in row  \n        END FOR  \n\n        IF countX LESS THAN countO OR countX GREATER THAN countO PLUS one  \n            RETURN False  \n        END IF  \n\n        FUNCTION check_win(player)  \n            FOR each row IN board  \n                IF row EQUALS player repeated three times in succession  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            FOR col FROM zero TO two  \n                IF element at position col of first row EQUALS player AND element at position col of second row EQUALS player AND element at position col of third row EQUALS player  \n                    RETURN True  \n                END IF  \n            END FOR  \n\n            IF element at position zero of first row EQUALS player AND element at position one of second row EQUALS player AND element at position two of third row EQUALS player  \n                RETURN True  \n            END IF  \n            IF element at position two of first row EQUALS player AND element at position one of second row EQUALS player AND element at position zero of third row EQUALS player  \n                RETURN True  \n            END IF  \n            RETURN False  \n        END FUNCTION  \n\n        SET winX TO result of invoking check_win with parameter character X  \n        SET winO TO result of invoking check_win with parameter character O  \n\n        IF winX AND winO  \n            RETURN False  \n        END IF  \n        IF winX AND countX EQUALS countO  \n            RETURN False  \n        END IF  \n        IF winO AND countX NOT EQUALS countO  \n            RETURN False  \n        END IF  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "bus-routes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numBusesToDestination(routes PARAMETER, source PARAMETER, target PARAMETER)  \n        IF source EQUALS target  \n            RETURN zero  \n        END IF  \n\n        SET stop_to_buses TO an empty mapping from keys to empty lists  \n        FOR each bus WITH index bus_index AND route IN routes  \n            FOR each stop IN route  \n                APPEND bus_index TO the list corresponding to stop IN stop_to_buses  \n            END FOR  \n        END FOR  \n\n        SET bus_queue TO an empty double ended queue  \n        SET visited_buses TO an empty set  \n        SET visited_stops TO an empty set  \n\n        FOR each bus IN the list of buses at the source stop FROM stop_to_buses  \n            APPEND the tuple consisting of bus AND one TO bus_queue  \n            ADD bus TO visited_buses  \n            ADD source TO visited_stops  \n        END FOR  \n\n        WHILE bus_queue is not empty  \n            REMOVE the first element FROM bus_queue AND ASSIGN the elements TO current_bus AND bus_count  \n\n            FOR each stop IN the route at position current_bus OF routes  \n                IF stop EQUALS target  \n                    RETURN bus_count  \n                END IF  \n\n                IF stop NOT IN visited_stops  \n                    ADD stop TO visited_stops  \n                    FOR each next_bus IN the list of buses at stop FROM stop_to_buses  \n                        IF next_bus NOT IN visited_buses  \n                            ADD next_bus TO visited_buses  \n                            APPEND the tuple consisting of next_bus AND bus_count PLUS one TO bus_queue  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n        END WHILE  \n\n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "card-flipping-game", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "binary-trees-with-factors", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "split-array-into-fibonacci-sequence", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS the character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE TO the next iteration of the loop  \n                END IF  \n                SET next_num TO the integer value of the substring of num from position start TO position end MINUS one  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at the position LENGTH OF path MINUS one of path PLUS the element at the position LENGTH OF path MINUS two of path  \n                    SET result TO the call of backtrack WITH parameters end AND the concatenation of path AND the list containing next_num  \n                    IF result IS NOT an empty list  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        RETURN the call of backtrack WITH parameters zero AND an empty list  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "shortest-path-visiting-all-nodes", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION shortestPathLength(graph)  \n        IF graph EQUALS empty collection THEN  \n            RETURN zero  \n        END IF  \n      \n        SET n TO the LENGTH OF graph  \n        SET queue TO a new double-ended queue containing pairs of each node in the range from zero TO n MINUS one together with a value obtained by ONE SHIFTED LEFT BY node  \n        SET visited TO a new set containing the same pairs as in queue  \n      \n        SET steps TO zero  \n        SET all_nodes_visited TO ONE SHIFTED LEFT BY n MINUS one  \n      \n        WHILE queue is not empty  \n            SET current_level_size TO the LENGTH OF queue  \n            FOR iteration FROM one TO current_level_size  \n                REMOVE the leftmost element from queue and DESCTRUCTURE INTO current_node and visited_nodes  \n              \n                IF visited_nodes EQUALS all_nodes_visited THEN  \n                    RETURN steps  \n                END IF  \n              \n                FOR each neighbor IN the element at position current_node of graph  \n                    SET next_visited_nodes TO visited_nodes OR ONE SHIFTED LEFT BY neighbor  \n                    SET next_state TO pair of neighbor and next_visited_nodes  \n                  \n                    IF next_state NOT IN visited THEN  \n                        ADD next_state TO visited  \n                        APPEND next_state TO queue  \n                    END IF  \n                END FOR  \n            END FOR  \n          \n            INCREMENT steps BY one  \n        END WHILE  \n      \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "loud-and-rich", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION loudAndRich(richer, quiet)  \n        SET graph TO a new default dictionary with list as the default value type  \n        FOR each pair of elements named a and b IN the collection richer  \n            APPEND element a TO the list associated with key b in graph  \n        END FOR  \n        \n        SET n TO the length of the collection quiet  \n        SET answer TO a list of length n filled with minus one values  \n        \n        FUNCTION dfs(person)  \n            IF the element at position person of answer EQUALS minus one THEN  \n                SET the element at position person of answer TO person  \n                FOR each element neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs with argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position of answer at person of quiet THEN  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        \n        FOR index i FROM zero TO n MINUS one  \n            CALL dfs with argument i  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "distinct-subsequences-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII(s)  \n        SET MOD TO ten POWER nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        SET dp TO a list OF zeroes WITH LENGTH n PLUS one  \n        SET the element at position zero of dp TO one  \n        SET last TO an empty mapping  \n        FOR i FROM one TO n  \n            SET char TO the element at position i MINUS one of s  \n            SET the element at position i of dp TO the element at position i MINUS one of dp MULTIPLIED BY two  \n            SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            IF char EXISTS IN the keys OF last  \n                SET the element at position i of dp TO the element at position i of dp MINUS the element at position last at char MINUS one of dp PLUS MOD  \n                SET the element at position i of dp TO the element at position i of dp MODULO MOD  \n            END IF  \n            ASSIGN last at char TO i  \n        END FOR  \n        RETURN the element at position n of dp MINUS one MODULO MOD  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "last-substring-in-lexicographical-order", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-difficulty-of-a-job-schedule", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minDifficulty(jobDifficulty, d)  \n        SET n TO the LENGTH OF jobDifficulty  \n        \n        IF n LESS THAN d  \n            RETURN negative one  \n        END IF  \n        \n        FUNCTION dp(i, d)  \n            IF d EQUALS one  \n                RETURN the MAXIMUM value IN the SUBLIST of jobDifficulty from position i TO the END  \n            END IF  \n            \n            SET min_difficulty TO positive infinity  \n            SET current_max TO zero  \n            \n            FOR each j FROM i TO n MINUS d  \n                SET current_max TO the GREATER BETWEEN current_max AND element at position j OF jobDifficulty  \n                SET candidate TO current_max PLUS dp(j PLUS one, d MINUS one)  \n                IF candidate LESS THAN min_difficulty  \n                    SET min_difficulty TO candidate  \n                END IF  \n            END FOR  \n            \n            RETURN min_difficulty  \n        END FUNCTION  \n        \n        RETURN dp(zero, d)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "restore-the-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-good-people-based-on-statements", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "escape-the-spreading-fire", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maximumMinutes(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET directions TO the LIST of elements each being a PAIR consisting of one and zero MINUS one and zero zero and one zero and MINUS one  \n        \n        FUNCTION can_escape(wait)  \n            SET fire_times TO a two-dimensional list of size m by n each element set TO infinity  \n            SET queue TO an empty double-ended queue  \n            \n            FOR i FROM zero TO m MINUS one  \n                FOR j FROM zero TO n MINUS one  \n                    IF element at position i of grid EQUALS one  \n                        APPEND the TRIPLE consisting of i j and zero TO queue  \n                        SET element at position i and j of fire_times TO zero  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND element at position nx and ny of grid EQUALS zero AND element at position nx and ny of fire_times EQUALS infinity  \n                        SET element at position nx and ny of fire_times TO t PLUS one  \n                        APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            SET queue TO a double-ended queue containing a single TRIPLE consisting of zero zero and wait  \n            SET visited TO a set containing the PAIR zero zero  \n            \n            WHILE queue is not empty  \n                REMOVE the first element and ASSIGN its components TO x y and t  \n                FOR each dx dy IN directions  \n                    SET nx TO x PLUS dx  \n                    SET ny TO y PLUS dy  \n                    IF nx GREATER THAN OR EQUAL TO zero AND nx LESS THAN m AND ny GREATER THAN OR EQUAL TO zero AND ny LESS THAN n AND the PAIR nx ny NOT IN visited AND element at position nx and ny of grid EQUALS zero  \n                        IF nx EQUALS m MINUS one AND ny EQUALS n MINUS one  \n                            IF element at position nx and ny of fire_times GREATER THAN OR EQUAL TO t PLUS one  \n                                RETURN true  \n                            ELSE  \n                                RETURN false  \n                            END IF  \n                        END IF  \n                        IF element at position nx and ny of fire_times GREATER THAN t PLUS one  \n                            ADD the PAIR nx ny TO visited  \n                            APPEND the TRIPLE consisting of nx ny and t PLUS one TO queue  \n                        END IF  \n                    END IF  \n                END FOR  \n            END WHILE  \n            \n            RETURN false  \n        END FUNCTION  \n        \n        SET left TO zero  \n        SET right TO m MULTIPLIED BY n  \n        SET result TO MINUS one  \n        \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO left PLUS right DIVIDED BY two rounded down to the nearest integer  \n            IF can_escape(mid)  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        \n        IF result NOT EQUALS m MULTIPLIED BY n  \n            RETURN result  \n        ELSE  \n            RETURN one followed by nine zeros  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "sentence-similarity-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION areSentencesSimilarTwo(sentence1 sentence1 TO sentence1 OF TYPE list OF strings sentence2 sentence2 TO sentence2 OF TYPE list OF strings similarPairs similarPairs TO similarPairs OF TYPE list OF list OF strings) RETURNS boolean  \n        IF the LENGTH OF sentence1 NOT EQUALS the LENGTH OF sentence2  \n            RETURN false  \n        END IF  \n\n        SET parent TO empty dictionary  \n\n        FUNCTION find(x x TO x) RETURNS x  \n            IF element at position x of parent NOT EQUALS x  \n                SET element at position x of parent TO find(element at position x of parent)  \n            END IF  \n            RETURN element at position x of parent  \n        END FUNCTION  \n\n        FUNCTION union(x x TO x y y TO y)  \n            SET rootX TO find(x)  \n            SET rootY TO find(y)  \n            IF rootX NOT EQUALS rootY  \n                SET element at position rootY of parent TO rootX  \n            END IF  \n        END FUNCTION  \n\n        FOR each pair IN similarPairs  \n            FOR each word IN pair  \n                IF word NOT IN parent  \n                    SET element at position word of parent TO word  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each x y IN similarPairs  \n            union(x y)  \n        END FOR  \n\n        FOR each w1 w2 IN sentence1 sentence2  \n            IF w1 NOT IN parent  \n                SET element at position w1 of parent TO w1  \n            END IF  \n            IF w2 NOT IN parent  \n                SET element at position w2 of parent TO w2  \n            END IF  \n            IF find(w1) NOT EQUALS find(w2)  \n                RETURN false  \n            END IF  \n        END FOR  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "find-the-derangement-of-an-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION findDerangement(n)  \n        SET MODULO TO ten RAISED TO THE POWER OF nine PLUS seven  \n        \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        IF n EQUALS two  \n            RETURN one  \n        END IF  \n        \n        SET previous_twice TO one  \n        SET previous_once TO zero  \n        \n        FOR integer i FROM three TO n  \n            SET current_value TO integer i MINUS one MULTIPLIED BY the SUM OF previous_once AND previous_twice  \n            SET current_value TO current_value MODULO MODULO  \n            SET previous_twice TO previous_once  \n            SET previous_once TO current_value  \n        END FOR  \n        \n        RETURN previous_once  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
