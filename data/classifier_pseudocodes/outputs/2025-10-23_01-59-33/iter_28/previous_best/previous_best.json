{
  "prompt": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *fully reproducible* \u2014 meaning it can be directly and unambiguously implemented into correct, complete, and deterministic executable code that will pass *all* valid unit tests *without exception* in the implied problem domain; otherwise output **`0`**. Output nothing else \u2014 no whitespace, explanation, or extra characters.\n\nTo decide, perform a rigorous holistic analysis of the entire pseudocode, strictly applying every one of these criteria:\n\n---\n\n### I. Explicitness and Completeness of Definitions  \n- All inputs, outputs, variables, constants, data structures, and subroutines must be explicitly defined or uniquely inferable directly from the pseudocode itself.  \n- Data types, sizes, initial values, and state changes of all variables and structures must be unambiguously specified or logically deducible.  \n- All functions, methods, or procedures invoked must have their algorithms fully included or behavior precisely described without reliance on external sources or assumptions.  \n- No placeholders, ellipses, or gaps in the logic or definitions are allowed.\n\n### II. Exhaustive Logical Correctness Over the Entire Input Space  \n- The pseudocode must handle **every** valid input instance in the problem domain correctly, including edge cases, minimal/maximal values, empty inputs, and all special conditions explicitly or by strong logical necessity.  \n- Control flow must be fully and deterministically specified: no infinite loops, undefined jumps, unreachable (dead) code, or ambiguous branching conditions permitted.  \n- All loops and recursions must terminate under every possible valid input scenario.\n\n### III. Determinism and Semantic Clarity  \n- Each operation and statement must have a single well-defined effect with no ambiguity, informal language, or multiple interpretations.  \n- No nondeterministic behavior (randomness, concurrency, unspecified order) can be present.  \n- The pseudocode must produce exactly one deterministic output per each valid input, without variance.\n\n### IV. Self-Containment Without Hidden Context  \n- The entire correctness and completeness must be embodied fully in the pseudocode.  \n- No dependencies on external environment state, implicit assumptions, global variables, or external system behavior may be required or implied.  \n- All necessary computation steps, data transformations, and validation checks must be internally specified.\n\n### V. Universal Validity of Passing All Unit Tests  \n- Given the intended functionality as implied by the pseudocode, any faithful implementation following it will pass **all** conceivable unit tests verifying correctness, efficiency, and robustness \u2014 no test case will fail due to vagueness, incompleteness, or logical error in the pseudocode.  \n- If any ambiguity, incomplete handling, or potential failure exists for *any* valid test or scenario, output must be **`0`**.\n\n---\n\n**Instructions:**  \n- Analyze the *entire* pseudocode as a whole; isolated fragments alone cannot confirm reproducibility.  \n- Ignore all formatting, comments, example cases, or external problem statements; rely solely on the precise details in the pseudocode block.  \n- If there exists *any* uncertainty, underspecification, logical flaw, or dependence on external data/context, output **`0`**.  \n- Output **`1`** *only* if all of the above are unequivocally satisfied and the pseudocode is fully reproducible as defined.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "response": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *fully reproducible* \u2014 meaning it can be directly and unambiguously implemented into correct, complete, and deterministic executable code that will pass *all* valid unit tests *without exception* in the implied problem domain; otherwise output **`0`**. Output nothing else \u2014 no whitespace, explanation, or extra characters.\n\nTo decide, perform a rigorous holistic analysis of the entire pseudocode, strictly applying every one of these criteria:\n\n---\n\n### I. Explicitness and Completeness of Definitions  \n- All inputs, outputs, variables, constants, data structures, and subroutines must be explicitly defined or uniquely inferable directly from the pseudocode itself.  \n- Data types, sizes, initial values, and state changes of all variables and structures must be unambiguously specified or logically deducible.  \n- All functions, methods, or procedures invoked must have their algorithms fully included or behavior precisely described without reliance on external sources or assumptions.  \n- No placeholders, ellipses, or gaps in the logic or definitions are allowed.\n\n### II. Exhaustive Logical Correctness Over the Entire Input Space  \n- The pseudocode must handle **every** valid input instance in the problem domain correctly, including edge cases, minimal/maximal values, empty inputs, and all special conditions explicitly or by strong logical necessity.  \n- Control flow must be fully and deterministically specified: no infinite loops, undefined jumps, unreachable (dead) code, or ambiguous branching conditions permitted.  \n- All loops and recursions must terminate under every possible valid input scenario.\n\n### III. Determinism and Semantic Clarity  \n- Each operation and statement must have a single well-defined effect with no ambiguity, informal language, or multiple interpretations.  \n- No nondeterministic behavior (randomness, concurrency, unspecified order) can be present.  \n- The pseudocode must produce exactly one deterministic output per each valid input, without variance.\n\n### IV. Self-Containment Without Hidden Context  \n- The entire correctness and completeness must be embodied fully in the pseudocode.  \n- No dependencies on external environment state, implicit assumptions, global variables, or external system behavior may be required or implied.  \n- All necessary computation steps, data transformations, and validation checks must be internally specified.\n\n### V. Universal Validity of Passing All Unit Tests  \n- Given the intended functionality as implied by the pseudocode, any faithful implementation following it will pass **all** conceivable unit tests verifying correctness, efficiency, and robustness \u2014 no test case will fail due to vagueness, incompleteness, or logical error in the pseudocode.  \n- If any ambiguity, incomplete handling, or potential failure exists for *any* valid test or scenario, output must be **`0`**.\n\n---\n\n**Instructions:**  \n- Analyze the *entire* pseudocode as a whole; isolated fragments alone cannot confirm reproducibility.  \n- Ignore all formatting, comments, example cases, or external problem statements; rely solely on the precise details in the pseudocode block.  \n- If there exists *any* uncertainty, underspecification, logical flaw, or dependence on external data/context, output **`0`**.  \n- Output **`1`** *only* if all of the above are unequivocally satisfied and the pseudocode is fully reproducible as defined.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "score": 0.6533333333333333,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            \n            IF n EQUALS one  \n                RETURN a list containing the string zero once the string one once the string eight  \n            END IF  \n            \n            SET middles TO the result of calling generate_strobogrammatic with arguments n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero PLUS middle PLUS zero TO result  \n                END IF  \n                APPEND the string one PLUS middle PLUS one TO result  \n                APPEND the string six PLUS middle PLUS nine TO result  \n                APPEND the string eight PLUS middle PLUS eight TO result  \n                APPEND the string nine PLUS middle PLUS six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        \n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN the result of calling generate_strobogrammatic with arguments length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN the result of calling count_strobogrammatic with arguments low and high  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION reverseWords(string_s)  \n        SET list_of_words TO the RESULT OF SPLITTING string_s BY SPACES  \n        REVERSE list_of_words  \n        SET reversed_string TO the RESULT OF JOINING list_of_words WITH SINGLE SPACE SEPARATOR  \n        RETURN reversed_string  \n    END FUNCTION  \nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION reverseWords(s)  \n        SET words TO list of words obtained by splitting s by spaces where multiple spaces are handled automatically  \n        REVERSE the order of elements in words  \n        RETURN single string obtained by joining elements of words with single spaces between them  \n    END FUNCTION  \nEND CLASS\n```\nfunction fractionToDecimal(n, d):\n    sign \u2190 \"-\" if (n < 0) xor (d < 0) else \"\"\n    n, d \u2190 abs(n), abs(d)\n    q, r \u2190 divmod(n, d)\n    int_part \u2190 str(q)\n    if r = 0: return sign + int_part\n    seen \u2190 map remainder \u2192 index\n    frac \u2190 []\n    while r \u2260 0:\n        if r in seen:\n            i \u2190 seen[r]\n            return sign + int_part + \".\" + join(frac[:i]) + \"(\" + join(frac[i:]) + \")\"\n        seen[r] \u2190 length(frac)\n        r \u2190 r * 10\n        q, r \u2190 divmod(r, d)\n        append str(q) to frac\n    return sign + int_part + \".\" + join(frac)\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION hIndex(list_of_citations)\n        CALL list_of_citations SORT IN DESCENDING ORDER\n        FOR index FROM zero TO the LENGTH OF list_of_citations MINUS one\n            SET citation_to_check TO element at position index of list_of_citations\n            IF citation_to_check LESS THAN index PLUS one\n                RETURN index\n            END IF\n        END FOR\n        RETURN the LENGTH OF list_of_citations\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6533333333333333",
  "iter": 20
}