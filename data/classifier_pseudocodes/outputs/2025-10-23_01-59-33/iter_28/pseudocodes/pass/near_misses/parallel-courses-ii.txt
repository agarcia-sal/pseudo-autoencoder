CLASS Solution
	TYPE DFS_PARAMS IS RECORD
		queue ARRAY OF INTEGER
		index INTEGER
		target INTEGER
	END RECORD

	FUNCTION minNumberOfSemesters(n, k, relations)
		SET adjacency_map TO new mapping defaulting to empty array
		SET prerequisite_counts TO array of size (n + 1) filled with zeros

		FUNCTION buildGraph(i)
			IF i > lengthOf(relations)
				RETURN
			END IF
			SET pair TO relations[i]
			SET predecessor TO pair[0]
			SET successor TO pair[1]
			APPEND successor TO adjacency_map[predecessor]
			prerequisite_counts[successor] = prerequisite_counts[successor] + 1
			call buildGraph(i + 1)
		END FUNCTION

		call buildGraph(1)

		SET course_stack TO empty stack
		FUNCTION collectCourses(c)
			IF c > n
				RETURN
			END IF
			IF prerequisite_counts[c] = 0
				PUSH c INTO course_stack
			END IF
			collectCourses(c + 1)
		END FUNCTION

		call collectCourses(1)

		SET semester_count TO 0

		FUNCTION processSemester()
			IF course_stack is empty THEN
				RETURN 0
			END IF
			SET courses_this_round TO new stack
			SET count TO 0
			WHILE count < k AND course_stack NOT empty
				SET course_id TO POP from course_stack
				PUSH course_id INTO courses_this_round
				count = count + 1
			END WHILE

			FUNCTION updatePrereqs(i)
				IF i > count
					RETURN
				END IF
				SET current TO courses_this_round[i]
				FOR idx FROM 1 TO lengthOf(adjacency_map[current])
					SET following_course TO adjacency_map[current][idx]
					prerequisite_counts[following_course] = prerequisite_counts[following_course] - 1
					IF prerequisite_counts[following_course] = 0
						PUSH following_course INTO course_stack
					END IF
				END FOR
				updatePrereqs(i + 1)
			END FUNCTION

			updatePrereqs(1)
			RETURN 1 + processSemester()
		END FUNCTION

		SET semester_count TO processSemester()

		RETURN semester_count
	END FUNCTION
END CLASS