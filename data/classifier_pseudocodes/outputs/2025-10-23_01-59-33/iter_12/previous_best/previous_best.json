{
  "prompt": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *entirely reproducible* \u2014 meaning it can be implemented as fully correct and executable code that will unconditionally pass **all** valid unit tests for the problem domain; otherwise output **`0`**. Do not output any whitespace, explanation, or extra characters.\n\nMake your determination *solely* by rigorous, holistic analysis of the pseudocode itself, applying these exhaustive criteria:\n\n1. **Complete Specification of Inputs, Outputs, and State**  \n\u2003- All inputs, outputs, variables, constants, and data structures are explicitly and unambiguously defined or derivable solely from the pseudocode.  \n\u2003- There are no undefined or implicitly assumed variables, types, values, or data structures.  \n\u2003- All control flow constructs (loops, conditionals, recursion, function calls) have precise, well-defined behavior.\n\n2. **Correctness and Exhaustive Domain Handling**  \n\u2003- The pseudocode\u2019s logic correctly implements the intended function for every input over the *entire* valid input domain (explicit or logically inferred).  \n\u2003- Edge cases (e.g., empty inputs, minimal/maximal values, boundary sizes) are either explicitly handled or clearly guaranteed correct by the logic.  \n\u2003- No logical contradictions, infinite loops, ambiguities, or unreachable code segments remain.\n\n3. **Self-Containment and No External Dependencies**  \n\u2003- The pseudocode includes full definitions or algorithms for all referenced procedures or functions.  \n\u2003- There are no hidden assumptions, unspecified preconditions, or reliance on any external code, state, or environment.\n\n4. **Deterministic, Unambiguous Semantics and Result**  \n\u2003- Each instruction and operation has precisely one well-defined effect; no vague, ambiguous, or informal statements remain.  \n\u2003- Control flow and data transformations produce exactly one deterministic output for any given input.\n\n5. **Guaranteed Passing of All Relevant Tests**  \n\u2003- Assuming a faithful implementation of this pseudocode, it necessarily passes *every* relevant unit and integration test covering the problem\u2019s valid inputs, causing no runtime errors, exceptions, or incorrect outputs.\n\n---\n\n**Important instructions:**  \n- Evaluate the *entire* pseudocode block as one unit \u2014 isolated fragments or lines must not be separately assessed.  \n- Disregard comments, formatting, examples, or any external problem statements \u2014 base your decision only on the pseudocode provided.  \n- If there is any uncertainty, missing detail, ambiguity, or partiality in the pseudocode that may prevent passing all tests *without external fixes*, output **`0`**.  \n- Only if **all** the above criteria are fully met and the pseudocode is unequivocally reproducible, output **`1`**.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "response": "Given the pseudocode below, output exactly one character: **`1`** if the pseudocode is *entirely reproducible* \u2014 meaning it can be implemented as fully correct and executable code that will unconditionally pass **all** valid unit tests for the problem domain; otherwise output **`0`**. Do not output any whitespace, explanation, or extra characters.\n\nMake your determination *solely* by rigorous, holistic analysis of the pseudocode itself, applying these exhaustive criteria:\n\n1. **Complete Specification of Inputs, Outputs, and State**  \n\u2003- All inputs, outputs, variables, constants, and data structures are explicitly and unambiguously defined or derivable solely from the pseudocode.  \n\u2003- There are no undefined or implicitly assumed variables, types, values, or data structures.  \n\u2003- All control flow constructs (loops, conditionals, recursion, function calls) have precise, well-defined behavior.\n\n2. **Correctness and Exhaustive Domain Handling**  \n\u2003- The pseudocode\u2019s logic correctly implements the intended function for every input over the *entire* valid input domain (explicit or logically inferred).  \n\u2003- Edge cases (e.g., empty inputs, minimal/maximal values, boundary sizes) are either explicitly handled or clearly guaranteed correct by the logic.  \n\u2003- No logical contradictions, infinite loops, ambiguities, or unreachable code segments remain.\n\n3. **Self-Containment and No External Dependencies**  \n\u2003- The pseudocode includes full definitions or algorithms for all referenced procedures or functions.  \n\u2003- There are no hidden assumptions, unspecified preconditions, or reliance on any external code, state, or environment.\n\n4. **Deterministic, Unambiguous Semantics and Result**  \n\u2003- Each instruction and operation has precisely one well-defined effect; no vague, ambiguous, or informal statements remain.  \n\u2003- Control flow and data transformations produce exactly one deterministic output for any given input.\n\n5. **Guaranteed Passing of All Relevant Tests**  \n\u2003- Assuming a faithful implementation of this pseudocode, it necessarily passes *every* relevant unit and integration test covering the problem\u2019s valid inputs, causing no runtime errors, exceptions, or incorrect outputs.\n\n---\n\n**Important instructions:**  \n- Evaluate the *entire* pseudocode block as one unit \u2014 isolated fragments or lines must not be separately assessed.  \n- Disregard comments, formatting, examples, or any external problem statements \u2014 base your decision only on the pseudocode provided.  \n- If there is any uncertainty, missing detail, ambiguity, or partiality in the pseudocode that may prevent passing all tests *without external fixes*, output **`0`**.  \n- Only if **all** the above criteria are fully met and the pseudocode is unequivocally reproducible, output **`1`**.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "score": 0.6,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nif num1==\"0\" or num2==\"0\": return \"0\"\nres = [0]*(len(num1)+len(num2))\nn1, n2 = num1[::-1], num2[::-1]\nfor i in range(len(n1)):\n  for j in range(len(n2)):\n    mul = (ord(n1[i])-48)*(ord(n2[j])-48)\n    sum_ = mul + res[i+j]\n    res[i+j], res[i+j+1] = sum_%10, res[i+j+1]+sum_//10\nreturn ''.join(map(str,res[::-1])).lstrip('0')\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION isMatch(string_s, string_p)\n        SET dp TO a two dimensional list of BOOLEAN false VALUES with the number of rows EQUAL TO the LENGTH OF string_s PLUS one AND the number of columns EQUAL TO the LENGTH OF string_p PLUS one\n\n        SET the element at row zero AND column zero OF dp TO true\n\n        FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n            IF the element at position index_j MINUS one OF string_p EQUALS character star\n                SET the element at row zero AND column index_j OF dp TO the element at row zero AND column index_j MINUS one OF dp\n            END IF\n        END FOR\n        \n        FOR index_i FROM one TO the LENGTH OF string_s INCLUSIVE\n            FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n                IF the element at position index_j MINUS one OF string_p EQUALS character star\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j OF dp OR the element at row index_i AND column index_j MINUS one OF dp\n                ELSE IF the element at position index_j MINUS one OF string_p EQUALS character question MARK OR the element at position index_i MINUS one OF string_s EQUALS the element at position index_j MINUS one OF string_p\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j MINUS one OF dp\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the element at row the LENGTH OF string_s AND column the LENGTH OF string_p OF dp\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n```\ndefine combine(n, k):\n  result = []\n  define backtrack(start, path):\n    if len(path) = k:\n      result.append(copy of path)\n      return\n    for i in range(start to n):\n      path.append(i)\n      backtrack(i+1, path)\n      path.pop()\n  backtrack(1, [])\n  return result\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6",
  "iter": 11
}