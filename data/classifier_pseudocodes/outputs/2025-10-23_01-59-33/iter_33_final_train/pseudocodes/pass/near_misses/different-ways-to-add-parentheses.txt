CLASS Solution  
    FUNCTION diffWaysToCompute(expression)  

        FUNCTION compute(left, right, operator)  
            SET output TO an empty queue  
            DEFINE idx1 AS 0  

            DEFINE processPair AS FUNCTION()
                IF idx1 IS EQUAL TO LENGTH(left) THEN RETURN ENDIF
                DEFINE idx2 AS 0

                DEFINE innerLoop AS FUNCTION()
                    IF idx2 IS EQUAL TO LENGTH(right) THEN
                        idx1 = idx1 + 1
                        CALL processPair()
                        RETURN
                    ENDIF

                    DEFINE operand1 AS left[idx1]
                    DEFINE operand2 AS right[idx2]
                    DEFINE operationSymbol AS operator

                    DO
                        IF operationSymbol == '+'
                            ENQUEUE (operand1 + operand2) TO output
                            BREAK
                        ENDIF
                        IF operationSymbol == '-'
                            ENQUEUE (operand1 - operand2) TO output
                            BREAK
                        ENDIF
                        IF operationSymbol == '*'
                            ENQUEUE (operand1 * operand2) TO output
                            BREAK
                        ENDIF
                    WHILE FALSE

                    idx2 = idx2 + 1
                    CALL innerLoop()
                END FUNCTION

                CALL innerLoop()
            END FUNCTION

            CALL processPair()
            RETURN LIST(output)
        END FUNCTION  


        FUNCTION helper(sub_expr)  

            DEFINE isNumeric AS FUNCTION(str)
                DEFINE pos AS 0
                DEFINE numericCheck AS FUNCTION()
                    IF pos IS EQUAL TO LENGTH(str) THEN RETURN TRUE ENDIF
                    IF str[pos] < '0' OR str[pos] > '9' THEN RETURN FALSE ENDIF
                    pos = pos + 1
                    RETURN numericCheck()
                END FUNCTION
                RETURN numericCheck()
            END FUNCTION

            IF isNumeric(sub_expr) THEN 
                RETURN [TO_INTEGER(sub_expr)]
            ENDIF

            DEFINE collectedResults AS an empty stack
            DEFINE index AS 0
            DEFINE lengthSub AS LENGTH(sub_expr)

            DEFINE traverse AS FUNCTION()
                IF index IS EQUAL TO lengthSub THEN RETURN ENDIF

                DEFINE symbol AS sub_expr[index]

                DEFINE isOperator AS FUNCTION(c)
                    IF c == '+' THEN RETURN TRUE ENDIF
                    IF c == '-' THEN RETURN TRUE ENDIF
                    IF c == '*' THEN RETURN TRUE ENDIF
                    RETURN FALSE
                END FUNCTION

                IF isOperator(symbol)
                    DEFINE leftPart AS SUBSTRING(sub_expr, 0, index)
                    DEFINE rightPart AS SUBSTRING(sub_expr, index+1, lengthSub-1)
                    DEFINE leftResults AS helper(leftPart)
                    DEFINE rightResults AS helper(rightPart)
                    DEFINE tempResults AS compute(leftResults, rightResults, symbol)

                    DEFINE addToCollected AS FUNCTION(resultsList, pos)
                        IF pos IS EQUAL TO LENGTH(resultsList) THEN RETURN ENDIF
                        PUSH resultsList[pos] TO collectedResults
                        addToCollected(resultsList, pos + 1)    
                    END FUNCTION

                    addToCollected(tempResults, 0)
                ENDIF

                index = index + 1
                CALL traverse()
            END FUNCTION

            CALL traverse()
            RETURN collectedResults
        END FUNCTION  

        RETURN helper(expression)
    END FUNCTION
END CLASS