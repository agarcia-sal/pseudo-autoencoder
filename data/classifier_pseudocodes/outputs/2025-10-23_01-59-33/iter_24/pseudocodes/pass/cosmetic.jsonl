{"task_id": "jump-game", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canJump(nums)\n        ASSIGN 0 TO positionIndex\n        ASSIGN 0 TO maximumReach\n\n        WHILE positionIndex LESS THAN LENGTH(nums)\n            IF NOT(positionIndex LESS THAN OR EQUAL TO maximumReach)\n                OUTPUT false\n                EXIT FUNCTION\n            END IF\n\n            ASSIGN (positionIndex PLUS nums[positionIndex]) TO candidateReach\n            IF candidateReach GREATER THAN maximumReach\n                ASSIGN candidateReach TO maximumReach\n            END IF\n\n            INCREMENT positionIndex BY 1\n        END WHILE\n\n        IF maximumReach GREATER THAN OR EQUAL TO (LENGTH(nums) MINUS 1)\n            OUTPUT true\n            EXIT FUNCTION\n        END IF\n\n        OUTPUT false\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "unique-paths", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET matrix AS a list containing m elements, each being a list of length n filled with 1  \n        SET rowIndex TO 1  \n        WHILE rowIndex < m DO  \n            SET columnIndex TO 1  \n            WHILE columnIndex < n DO  \n                SET currentRow TO matrix[rowIndex]  \n                SET currentRow[columnIndex] TO matrix[rowIndex - 1][columnIndex] + currentRow[columnIndex - 1]  \n                SET columnIndex TO columnIndex + 1  \n            END WHILE  \n            SET rowIndex TO rowIndex + 1  \n        END WHILE  \n        RETURN matrix[m - 1][n - 1]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "combinations", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION combine(n, k)\n        FUNCTION backtrack(begin, sequence)\n            IF NOT (LENGTH(sequence) NOT EQUAL TO k)\n                result COLLECT COPY(sequence)\n                RETURN\n            END IF\n            SET index TO begin\n            WHILE index < n + 1\n                sequence ADD index\n                backtrack(index + 1, sequence)\n                sequence REMOVE LAST\n                index INCREASE BY 1\n            END WHILE\n        END FUNCTION\n        result ASSIGN LIST()\n        backtrack(1, LIST())\n        RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gray-code", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        DECLARE result AS list OF integers  \n        DECLARE temp AS list OF integers  \n        DECLARE bitmask AS integer  \n        DECLARE index AS integer  \n        \n        IF NOT (n NOT EQUALS 0) THEN  \n            RETURN [0]  \n        END IF  \n        \n        SET temp AS grayCode(n - 1)  \n        SET bitmask AS 1 << (n - 1)  \n        \n        SET result AS temp  \n        SET index TO LENGTH(temp) - 1  \n        \n        WHILE index GREATER OR EQUAL TO 0 DO  \n            APPEND (temp[index] BITWISE_OR bitmask) TO result  \n            DECREMENT index BY 1  \n        END WHILE  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "palindrome-partitioning-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET length_s AS the LENGTH OF s  \n        \n        IF NOT (length_s GREATER THAN one)  \n            RETURN zero  \n        END IF  \n        \n        SET palindrome_flag TO a list of length_s elements each containing a list of length_s elements initialized to FALSE  \n        \n        SET idx TO zero  \n        WHILE idx LESS THAN length_s  \n            SET palindrome_flag[idx][idx] AS TRUE  \n            INCREMENT idx BY one  \n        END WHILE  \n        \n        SET substr_len TO two  \n        WHILE substr_len LESS THAN OR EQUAL TO length_s  \n            SET start_pos TO zero  \n            WHILE start_pos LESS THAN OR EQUAL TO length_s MINUS substr_len  \n                SET end_pos TO start_pos PLUS substr_len MINUS one  \n                \n                IF substr_len EQUALS two THEN  \n                    SET palindrome_flag[start_pos][end_pos] AS (s[start_pos] EQUALS s[end_pos])  \n                ELSE  \n                    SET chars_match AS (s[start_pos] EQUALS s[end_pos])  \n                    SET inner_palindrome AS palindrome_flag[start_pos PLUS one][end_pos MINUS one]  \n                    SET palindrome_flag[start_pos][end_pos] AS (chars_match AND inner_palindrome)  \n                END IF  \n                \n                INCREMENT start_pos BY one  \n            END WHILE  \n            INCREMENT substr_len BY one  \n        END WHILE  \n        \n        SET min_cut_counts TO a list of length_s elements initialized as zero  \n        \n        SET i TO zero  \n        WHILE i LESS THAN length_s  \n            IF palindrome_flag[zero][i] THEN  \n                SET min_cut_counts[i] AS zero  \n            ELSE  \n                SET min_cut_counts[i] AS positive infinity  \n                SET j TO one  \n                WHILE j LESS THAN OR EQUAL TO i  \n                    IF palindrome_flag[j][i] AND ((min_cut_counts[j MINUS one] PLUS one) LESS THAN min_cut_counts[i]) THEN  \n                        SET min_cut_counts[i] AS (min_cut_counts[j MINUS one] PLUS one)  \n                    END IF  \n                    INCREMENT j BY one  \n                END WHILE  \n            END IF  \n            INCREMENT i BY one  \n        END WHILE  \n        \n        RETURN min_cut_counts[length_s MINUS one]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reverse-words-in-a-string", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        DECLARE wordCollection AS list ← s split by spaces ignoring repeated spaces  \n        DECLARE reversedList AS list ← empty list  \n        DECLARE indexer AS integer ← LENGTH(wordCollection) - 1  \n        WHILE indexer >= 0  \n            ADD wordCollection[indexer] TO reversedList  \n            DECREMENT indexer BY 1  \n        END WHILE  \n        DECLARE resultString AS string ← reversedList elements concatenated with \" \" as delimiter  \n        RETURN resultString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        SET words TO list of words obtained by splitting s by spaces where multiple spaces are handled automatically  \n        REVERSE the order of elements in words  \n        RETURN single string obtained by joining elements of words with single spaces between them  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "fraction-to-recurring-decimal", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        DECLARE polarity AS string  \n        IF (numerator < 0 AND denominator >= 0) OR (numerator >= 0 AND denominator < 0) THEN  \n            polarity ← \"-\"  \n        ELSE  \n            polarity ← \"\"  \n        ENDIF  \n  \n        numerator ← ABS(numerator)  \n        denominator ← ABS(denominator)  \n  \n        DECLARE integralQuotient AS integer ← numerator DIV denominator  \n        DECLARE modValue AS integer ← numerator MOD denominator  \n        DECLARE integerString AS string ← TO_STRING(integralQuotient)  \n  \n        IF modValue = 0 THEN  \n            RETURN CONCAT(polarity, integerString)  \n        ENDIF  \n  \n        DECLARE remainderPositions AS MAP FROM integer TO integer ← EMPTY MAP  \n        DECLARE digits AS LIST OF string ← EMPTY LIST  \n  \n        DECLARE currentRemainder AS integer ← modValue  \n        WHILE currentRemainder ≠ 0 DO  \n            IF remainderPositions CONTAINS currentRemainder THEN  \n                DECLARE cycleStart AS integer ← remainderPositions[currentRemainder]  \n                DECLARE prefix AS string ← \"\"  \n                DECLARE suffix AS string ← \"\"  \n                FOR idx FROM 0 TO cycleStart - 1 DO  \n                    prefix ← CONCAT(prefix, digits[idx])  \n                ENDFOR  \n                FOR idx FROM cycleStart TO LENGTH(digits) - 1 DO  \n                    suffix ← CONCAT(suffix, digits[idx])  \n                ENDFOR  \n                RETURN CONCAT(polarity, integerString, \".\", prefix, \"(\", suffix, \")\")  \n            ENDIF  \n  \n            remainderPositions[currentRemainder] ← LENGTH(digits)  \n  \n            currentRemainder ← currentRemainder * 10  \n            DECLARE digitValue AS integer ← currentRemainder DIV denominator  \n            currentRemainder ← currentRemainder MOD denominator  \n            APPEND TO digits: TO_STRING(digitValue)  \n        ENDWHILE  \n  \n        RETURN CONCAT(polarity, integerString, \".\", JOIN(digits))  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION fractionToDecimal(numerator, denominator)  \n        IF numerator LESS THAN zero AND denominator GREATER THAN OR EQUAL TO zero OR numerator GREATER THAN OR EQUAL TO zero AND denominator LESS THAN zero  \n            SET sign TO the string indicating negative  \n        ELSE  \n            SET sign TO the empty string  \n        END IF  \n  \n        SET numerator TO the absolute value of numerator  \n        SET denominator TO the absolute value of denominator  \n  \n        SET quotient TO the integer division result of numerator DIVIDED BY denominator  \n        SET remainder TO the remainder of numerator DIVIDED BY denominator  \n        SET integer_part TO the string representation of quotient  \n  \n        IF remainder EQUALS zero  \n            RETURN the concatenation of sign and integer_part  \n        END IF  \n  \n        SET seen_remainders TO an empty mapping from remainder values to positions  \n        SET fractional_part TO an empty list  \n  \n        WHILE remainder NOT EQUALS zero  \n            IF remainder EXISTS AS a key in seen_remainders  \n                SET start TO the value associated with remainder in seen_remainders  \n                SET non_repeating TO the concatenation of elements from position zero UP TO position start EXCLUDING start in fractional_part  \n                SET repeating TO the concatenation of elements FROM position start TO the end of fractional_part  \n                RETURN the concatenation of sign, integer_part, the string representing a decimal point, non_repeating, the opening parenthesis string, repeating, and the closing parenthesis string  \n            END IF  \n  \n            ASSIGN to seen_remainders at key remainder the current length of fractional_part  \n  \n            SET remainder TO remainder MULTIPLIED BY ten  \n            SET quotient TO the integer division result of remainder DIVIDED BY denominator  \n            SET remainder TO the remainder of remainder DIVIDED BY denominator  \n            APPEND the string representation of quotient TO fractional_part  \n        END WHILE  \n  \n        RETURN the concatenation of sign, integer_part, the string representing a decimal point, and the concatenation of all elements in fractional_part  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-primes", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        SWITCH  \n            CASE n > 2:  \n                BREAK  \n            DEFAULT:  \n                RETURN 0  \n        END SWITCH  \n        SET primality_flags AS empty list  \n        SET counter AS 0  \n        WHILE counter IS LESS THAN n DO  \n            ADD True TO primality_flags  \n            SET counter TO counter + 1  \n        END WHILE  \n        SET primality_flags[0] TO False  \n        SET primality_flags[1] TO False  \n        SET max_check AS FLOOR(SQRT(n))  \n        SET candidate AS 2  \n        WHILE candidate <= max_check DO  \n            IF primality_flags[candidate] IS NOT False THEN  \n                SET factor AS candidate * candidate  \n                WHILE factor < n DO  \n                    SET primality_flags[factor] TO False  \n                    SET factor TO factor + candidate  \n                END WHILE  \n            END IF  \n            SET candidate TO candidate + 1  \n        END WHILE  \n        SET tally AS 0  \n        FOR element IN primality_flags DO  \n            IF element THEN tally ← tally + 1  \n        END FOR  \n        RETURN tally  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countPrimes WITH PARAMETER n  \n        IF n LESS THAN OR EQUAL TO two  \n            RETURN zero  \n        END IF  \n        SET is_prime TO an empty list  \n        FOR index FROM zero TO n MINUS one  \n            APPEND True TO is_prime  \n        END FOR  \n        SET element at position zero of is_prime TO False  \n        SET element at position one of is_prime TO False  \n        SET limit TO the integer part of the square root of n  \n        FOR start FROM two TO limit PLUS one  \n            IF element at position start of is_prime EQUALS True  \n                SET multiple TO start MULTIPLIED BY start  \n                WHILE multiple LESS THAN n  \n                    SET element at position multiple of is_prime TO False  \n                    INCREMENT multiple BY start  \n                END WHILE  \n            END IF  \n        END FOR  \n        SET count TO zero  \n        FOR each value IN is_prime  \n            IF value EQUALS True  \n                INCREMENT count BY one  \n            END IF  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "h-index", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        DECLARE sortedList ← SORT citations IN DESCENDING ORDER  \n        DECLARE pointer ← 0  \n        WHILE pointer < LENGTH OF sortedList DO  \n            DECLARE currentCitation ← sortedList[pointer]  \n            IF NOT (currentCitation ≥ pointer + 1) THEN  \n                RETURN pointer  \n            END IF  \n            SET pointer ← pointer + 1  \n        END WHILE  \n        RETURN LENGTH OF sortedList  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION hIndex(citations)  \n        SET citations TO citations SORTED IN DESCENDING ORDER  \n        FOR index FROM zero TO the LENGTH OF citations MINUS one  \n            IF element at position index of citations LESS THAN index PLUS one  \n                RETURN index  \n            END IF  \n        END FOR  \n        RETURN the LENGTH OF citations  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-squares", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        INITIALIZE dp AS a list WITH (n + 1) elements EACH SET TO infinity_value  \n        ASSIGN dp[0] ← 0  \n        INITIALIZE squares AS an empty list  \n        ASSIGN counter ← 1  \n        LOOP  \n            IF (counter * counter) > n THEN EXIT LOOP  \n            ADD (counter * counter) TO squares  \n            SET counter ← counter + 1  \n        END LOOP  \n        ASSIGN index ← 1  \n        WHILE index ≤ n DO  \n            FOR EACH current_square IN squares DO  \n                IF current_square > index THEN  \n                    EXIT FOR  \n                ELSE  \n                    TEMP ← dp[index - current_square] + 1  \n                    IF TEMP < dp[index] THEN  \n                        SET dp[index] ← TEMP  \n                    END IF  \n                END IF  \n            END FOR  \n            SET index ← index + 1  \n        END WHILE  \n        RETURN dp[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numSquares(n)  \n        SET dp TO a list of size n PLUS one FILLED WITH infinite value  \n        SET the element at position zero of dp TO zero  \n        SET squares TO an empty list  \n        SET i TO one  \n        WHILE i MULTIPLIED BY i IS LESS THAN OR EQUAL TO n  \n            APPEND i MULTIPLIED BY i TO squares  \n            INCREMENT i BY one  \n        END WHILE  \n        FOR i FROM one TO n  \n            FOR each square IN squares  \n                IF i IS LESS THAN square  \n                    BREAK the inner loop  \n                END IF  \n                SET dp at position i TO the smaller value BETWEEN dp at position i AND dp at position i MINUS square PLUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flip-game-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canWin(currentState)\n        DECLARE cache AS an empty map\n\n        FUNCTION can_win_helper(state)\n            IF NOT (state NOT IN cache) THEN\n                RETURN cache[state]\n            END IF\n\n            DECLARE iterator AS 0\n            WHILE iterator <= LENGTH(state) - 2 DO\n                IF (state[iterator] = '+') AND (state[iterator + 1] = '+') THEN\n                    DECLARE before_segment AS SUBSTRING(state, 0, iterator)\n                    DECLARE after_segment AS SUBSTRING(state, iterator + 2, LENGTH(state))\n                    DECLARE candidate_state AS CONCATENATE(before_segment, '--', after_segment)\n\n                    IF FALSE = can_win_helper(candidate_state) THEN\n                        ASSIGN TRUE TO cache[state]\n                        RETURN TRUE\n                    END IF\n                END IF\n                ASSIGN iterator + 1 TO iterator\n            END WHILE\n\n            ASSIGN FALSE TO cache[state]\n            RETURN FALSE\n        END FUNCTION\n\n        RETURN can_win_helper(currentState)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-word-lengths", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maxProduct(words)\n        DECLARE char_sets AS empty list\n        DECLARE idx1 AS 0\n        WHILE idx1 < LENGTH(words)\n            DECLARE temp_set AS empty set\n            DECLARE pos AS 0\n            WHILE pos < LENGTH(words[idx1])\n                SET temp_set TO temp_set UNION { words[idx1][pos] }\n                SET pos TO pos + 1\n            END WHILE\n            APPEND temp_set TO char_sets\n            SET idx1 TO idx1 + 1\n        END WHILE\n\n        SET highest_product TO 0\n\n        DECLARE first_pointer AS 0\n        WHILE first_pointer < LENGTH(words) - 1\n            DECLARE second_pointer AS first_pointer + 1\n            WHILE second_pointer < LENGTH(words)\n                DECLARE intersection_check AS char_sets[first_pointer] INTERSECT char_sets[second_pointer]\n                IF LENGTH(intersection_check) = 0 THEN\n                    DECLARE candidate_product AS (LENGTH(words[first_pointer]) * LENGTH(words[second_pointer]))\n                    IF candidate_product > highest_product THEN\n                        SET highest_product TO candidate_product\n                    END IF\n                END IF\n                SET second_pointer TO second_pointer + 1\n            END WHILE\n            SET first_pointer TO first_pointer + 1\n        END WHILE\n\n        RETURN highest_product\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters of word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the intersection of element at position i of word_sets AND element at position j of word_sets EQUALS empty set  \n                    SET product TO the LENGTH OF element at position i of words MULTIPLIED BY the LENGTH OF element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulb-switcher", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        DECLARE result AS INTEGER  \n        SET result TO 0  \n        WHILE (result + 1) * (result + 1) <= n DO  \n            INCREMENT result BY 1  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION bulbSwitch(n)  \n        RETURN the integer part of the square root of n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "coin-change", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET cache AS a list containing (amount + 1) copies of (amount + 1)  \n        ASSIGN 0 TO cache[0]  \n\n        SET counter TO 1  \n        WHILE counter ≤ amount  \n            SET currentMin TO cache[counter]  \n            FOR each denomination IN coins  \n                SET remainder TO counter - denomination  \n                IF remainder ≥ 0 THEN  \n                    SET candidate TO cache[remainder] + 1  \n                    IF candidate < currentMin THEN  \n                        ASSIGN candidate TO currentMin  \n                    END IF  \n                END IF  \n            END FOR  \n            ASSIGN currentMin TO cache[counter]  \n            INCREMENT counter BY 1  \n        END WHILE  \n\n        IF cache[amount] ≠ (amount + 1) THEN  \n            RETURN cache[amount]  \n        ELSE  \n            RETURN -1  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION coinChange(coins, amount)  \n        SET dp TO a list of amount PLUS one elements each set TO amount PLUS one  \n        SET element at position zero of dp TO zero  \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET dp at position a TO the minimum BETWEEN dp at position a AND dp at position a MINUS coin PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        IF dp at position amount IS NOT EQUAL TO amount PLUS one  \n            RETURN dp at position amount  \n        ELSE  \n            RETURN minus one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "integer-break", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dpList AS an array of zeros sized n PLUS 1  \n        SET dpList[1] AS 1  \n        SET outerCounter TO 2  \n        WHILE outerCounter IS LESS THAN OR EQUAL TO n DO  \n            SET currentMax TO 0  \n            SET innerCounter TO 1  \n            WHILE innerCounter IS LESS THAN outerCounter DO  \n                SET firstProduct TO innerCounter TIMES dpList[outerCounter MINUS innerCounter]  \n                SET secondProduct TO innerCounter TIMES (outerCounter MINUS innerCounter)  \n                SWITCH TRUE  \n                    CASE currentMax < firstProduct AND currentMax < secondProduct:  \n                        IF firstProduct > secondProduct THEN  \n                            SET currentMax TO firstProduct  \n                        ELSE  \n                            SET currentMax TO secondProduct  \n                        END IF  \n                    CASE currentMax < firstProduct:  \n                        SET currentMax TO firstProduct  \n                    CASE currentMax < secondProduct:  \n                        SET currentMax TO secondProduct  \n                END SWITCH  \n                INCREMENT innerCounter BY 1  \n            END WHILE  \n            SET dpList[outerCounter] TO currentMax  \n            INCREMENT outerCounter BY 1  \n        END WHILE  \n        RETURN dpList[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION integerBreak(n)  \n        SET dp TO a list of zeros with the length of n PLUS one  \n        SET element at position one of dp TO one  \n        FOR i FROM two TO n  \n            SET max_product TO zero  \n            FOR j FROM one TO i MINUS one  \n                SET product_one TO j MULTIPLIED BY element at position i MINUS j of dp  \n                SET product_two TO j MULTIPLIED BY i MINUS j  \n                IF max_product LESS THAN product_one AND max_product LESS THAN product_two  \n                    SET max_product TO the larger value BETWEEN product_one AND product_two  \n                ELSE IF max_product LESS THAN product_one  \n                    SET max_product TO product_one  \n                ELSE IF max_product LESS THAN product_two  \n                    SET max_product TO product_two  \n                END IF  \n            END FOR  \n            SET element at position i of dp TO max_product  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-numbers-with-unique-digits", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        SWITCH n  \n            CASE 0:  \n                RETURN 1  \n            CASE 1:  \n                RETURN 10  \n        END SWITCH  \n  \n        SET total_sum AS 10  \n        SET digits_left AS 9  \n        SET product AS 9  \n        SET index AS 2  \n        WHILE index <= n DO  \n            SET product AS product * digits_left  \n            SET total_sum AS total_sum + product  \n            SET digits_left AS digits_left - 1  \n            SET index AS index + 1  \n        END WHILE  \n  \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countNumbersWithUniqueDigits(n)  \n        IF n EQUALS zero THEN  \n            RETURN one  \n        END IF  \n        IF n EQUALS one THEN  \n            RETURN ten  \n        END IF  \n        SET count TO ten  \n        SET available_digits TO nine  \n        SET choices TO nine  \n        FOR i FROM two TO n INCLUSIVE  \n            SET choices TO choices MULTIPLIED BY available_digits  \n            SET count TO count PLUS choices  \n            SET available_digits TO available_digits MINUS one  \n        END FOR  \n        RETURN count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reconstruct-original-digits-from-english", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET freqMap AS map of character counts in s  \n        SET digitCounts AS list WITH TEN elements INITIATED TO 0  \n        \n        SET digitCounts[0] AS freqMap['z']  \n        SET digitCounts[2] AS freqMap['w']  \n        SET digitCounts[4] AS freqMap['u']  \n        SET digitCounts[6] AS freqMap['x']  \n        SET digitCounts[8] AS freqMap['g']  \n        \n        SET digitCounts[3] AS freqMap['h'] - digitCounts[8]  \n        SET digitCounts[5] AS freqMap['f'] - digitCounts[4]  \n        SET digitCounts[7] AS freqMap['s'] - digitCounts[6]  \n        \n        SET tempI AS freqMap['i']  \n        SET digitCounts[9] AS tempI - digitCounts[5] - digitCounts[6] - digitCounts[8]  \n        \n        SET tempO AS freqMap['o']  \n        SET digitCounts[1] AS tempO - digitCounts[0] - digitCounts[2] - digitCounts[4]  \n        \n        SET collectionOfChars AS empty list  \n        \n        SET numberIdx AS 0  \n        WHILE numberIdx LESS THAN 10  \n            SET countRepeat AS digitCounts[numberIdx]  \n            WHILE countRepeat GREATER THAN 0  \n                APPEND STRING(numberIdx) TO collectionOfChars  \n                ASSIGN countRepeat ← countRepeat - 1  \n            END WHILE  \n            ASSIGN numberIdx ← numberIdx + 1  \n        END WHILE  \n        \n        SET outputString AS CONCATENATE elements of collectionOfChars SEQUENTIALLY  \n        RETURN outputString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO the collection of character frequencies in s  \n        SET digits TO a list of ten zeros representing counts for zero to nine  \n        SET element at position zero of digits TO the number of occurrences of character corresponding to letter z in count  \n        SET element at position two of digits TO the number of occurrences of character corresponding to letter w in count  \n        SET element at position four of digits TO the number of occurrences of character corresponding to letter u in count  \n        SET element at position six of digits TO the number of occurrences of character corresponding to letter x in count  \n        SET element at position eight of digits TO the number of occurrences of character corresponding to letter g in count  \n        SET element at position three of digits TO the number of occurrences of character corresponding to letter h in count MINUS element at position eight of digits  \n        SET element at position five of digits TO the number of occurrences of character corresponding to letter f in count MINUS element at position four of digits  \n        SET element at position seven of digits TO the number of occurrences of character corresponding to letter s in count MINUS element at position six of digits  \n        SET element at position nine of digits TO the number of occurrences of character corresponding to letter i in count MINUS element at position five of digits MINUS element at position six of digits MINUS element at position eight of digits  \n        SET element at position one of digits TO the number of occurrences of character corresponding to letter o in count MINUS element at position zero of digits MINUS element at position two of digits MINUS element at position four of digits  \n        SET result TO an empty list  \n        FOR each index FROM zero TO nine  \n            FOR each repetition FROM one TO element at position index of digits  \n                APPEND string representation of index TO result  \n            END FOR  \n        END FOR  \n        SET final_string TO the concatenation of all elements in result  \n        RETURN final_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sort-characters-by-frequency", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION frequencySort WITH PARAMETER s  \n        DECLARE freqMap AS mapping from character to integer  \n        FOR index FROM 0 TO LENGTH(s) - 1 DO  \n            SET currentChar TO s[index]  \n            IF freqMap DOES NOT CONTAIN currentChar THEN  \n                SET freqMap[currentChar] AS 1  \n            ELSE  \n                SET freqMap[currentChar] TO freqMap[currentChar] + 1  \n            END IF  \n        END FOR  \n\n        DECLARE charList AS list of characters  \n        SET charList TO KEYS OF freqMap  \n\n        DECLARE descSortedChars AS list of characters  \n        SET descSortedChars TO SORT charList BY (a, b) → (freqMap[b] - freqMap[a])  \n\n        SET outputString TO EMPTY STRING  \n        DECLARE iterator AS integer ← 0  \n        WHILE iterator < LENGTH(descSortedChars) DO  \n            DECLARE ch AS character ← descSortedChars[iterator]  \n            DECLARE count AS integer ← freqMap[ch]  \n            DECLARE tempString AS string ← EMPTY STRING  \n            FOR repeatIndex FROM 1 TO count DO  \n                SET tempString ← tempString + ch  \n            END FOR  \n            SET outputString ← outputString + tempString  \n            SET iterator ← iterator + 1  \n        END WHILE  \n\n        RETURN outputString  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION frequencySort WITH PARAMETER s  \n        SET frequency TO the character frequency mapping of s  \n        SET sorted_characters TO the list of characters in frequency arranged in descending order according to their frequency values  \n        SET result TO an empty string  \n        FOR each character IN sorted_characters  \n            APPEND the character repeated the number of times equal to the frequency of the character TO result  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-time-difference", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET components TO EMPTY LIST  \n            SET pos TO 0  \n            WHILE pos LESS THAN length of time  \n                IF time[pos] EQUALS \":\"  \n                    EXIT WHILE  \n                ELSE  \n                    ADD time[pos] TO components  \n                    SET pos TO pos + 1  \n                END IF  \n            END WHILE  \n            SET colon_index TO pos  \n            \n            SET hrs_str TO SUBSTRING of time FROM 0 TO colon_index  \n            SET mins_str TO SUBSTRING of time FROM colon_index + 1 TO length of time  \n            \n            SET hrs_num TO INTEGER parsed from hrs_str  \n            SET mins_num TO INTEGER parsed from mins_str  \n            RETURN hrs_num * 60 + mins_num  \n        END FUNCTION  \n        \n        SET minute_values TO EMPTY LIST  \n        SET idx TO 0  \n        WHILE idx LESS THAN length of timePoints  \n            ADD to_minutes(timePoints[idx]) TO minute_values  \n            SET idx TO idx + 1  \n        END WHILE\n        \n        CALL sort ON minute_values IN ASCENDING ORDER  \n        \n        SET shortest_gap TO INFINITY  \n        SET pointer TO 1  \n        WHILE pointer LESS THAN length of minute_values  \n            SET gap TO minute_values[pointer] - minute_values[pointer - 1]  \n            IF gap < shortest_gap THEN  \n                SET shortest_gap TO gap  \n            END IF  \n            SET pointer TO pointer + 1  \n        END WHILE  \n        \n        SET wrap_gap TO 1440 - minute_values[length of minute_values - 1] + minute_values[0]  \n        IF wrap_gap < shortest_gap THEN  \n            SET shortest_gap TO wrap_gap  \n        END IF  \n        \n        RETURN shortest_gap  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findMinDifference(timePoints)  \n        FUNCTION to_minutes(time)  \n            SET split_result TO the list of elements obtained by splitting time at the position of the colon character  \n            SET hours TO the integer conversion of the element at position zero of split_result  \n            SET minutes TO the integer conversion of the element at position one of split_result  \n            RETURN the result of multiplication of hours by the number of minutes in one hour PLUS minutes  \n        END FUNCTION  \n        \n        SET minutes_list TO the list obtained by applying the function to_minutes to each element in timePoints  \n        SORT minutes_list in ascending order  \n        SET min_diff TO positive infinity  \n        FOR index FROM one TO the length of minutes_list MINUS one  \n            SET current_difference TO the element at position index of minutes_list MINUS the element at position index MINUS one of minutes_list  \n            IF current_difference LESS THAN min_diff  \n                SET min_diff TO current_difference  \n            END IF  \n        END FOR  \n        SET circular_difference TO the result of subtracting the element at the last position of minutes_list FROM the number of minutes in a full day PLUS the element at the first position of minutes_list  \n        IF circular_difference LESS THAN min_diff  \n            SET min_diff TO circular_difference  \n        END IF  \n        RETURN min_diff  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "output-contest-matches", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        DECLARE bracketStrings AS empty list  \n        DECLARE count AS 1  \n        WHILE count LESS THAN OR EQUAL TO n  \n            INSERT TO bracketStrings THE STRING OF count  \n            INCREMENT count BY 1  \n        END WHILE  \n        WHILE n NOT EQUAL TO 1  \n            DECLARE index AS 0  \n            DECLARE limit AS n DIV 2  \n            WHILE index LESS THAN limit  \n                DECLARE leftSide AS bracketStrings AT index  \n                DECLARE rightSide AS bracketStrings AT (n - 1 - index)  \n                ASSIGN bracketStrings AT index TO \"(\" + leftSide + \",\" + rightSide + \")\"  \n                INCREMENT index BY 1  \n            END WHILE  \n            SET n AS n DIV 2  \n        END WHILE  \n        RETURN bracketStrings AT 0  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findContestMatch(n)  \n        SET teams TO an empty list  \n        FOR number FROM one TO n  \n            APPEND the string representation of number TO teams  \n        END FOR  \n        WHILE n GREATER THAN one  \n            FOR i FROM zero TO n DIVIDED BY two MINUS one  \n                SET teams at position i TO the concatenation of an open parenthesis concatenated with the element at position i of teams concatenated with a comma concatenated with the element at position n MINUS one MINUS i of teams concatenated with a close parenthesis  \n            END FOR  \n            SET n TO n DIVIDED BY two  \n        END WHILE  \n        RETURN the element at position zero of teams  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "course-schedule-iii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION scheduleCourse(courses)\n        SORT courses BY course[1] IN ascending order\n        INITIALIZE priority_queue AS an empty list\n        SET accumulated_days TO 0\n        \n        INDEX idx = 0\n        WHILE idx < LENGTH(courses) DO\n            SET curr_course TO courses[idx]\n            SET curr_duration TO curr_course[0]\n            SET deadline TO curr_course[1]\n\n            IF accumulated_days + curr_duration <= deadline THEN\n                ADD -curr_duration INTO priority_queue USING heap push\n                accumulated_days ← accumulated_days + curr_duration\n            ELSE\n                IF NOT (LENGTH(priority_queue) = 0) AND (-priority_queue[0]) > curr_duration THEN\n                    accumulated_days ← accumulated_days + curr_duration + heap pop FROM priority_queue\n                    ADD -curr_duration INTO priority_queue USING heap push\n                END IF\n            END IF\n\n            idx ← idx + 1\n        END WHILE\n\n        RETURN LENGTH(priority_queue)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION scheduleCourse(courses)  \n        SORT courses BY the second element of each course representing the last day of the course  \n        SET max_heap TO an empty list  \n        SET current_end_day TO zero  \n        FOR each course IN courses  \n            SET duration TO the first element of course representing the duration of the course  \n            SET last_day TO the second element of course representing the last day of the course  \n            IF current_end_day PLUS duration LESS THAN OR EQUAL TO last_day THEN  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n                INCREMENT current_end_day BY duration  \n            ELSE IF max_heap IS NOT empty AND the negation of the first element of max_heap GREATER THAN duration THEN  \n                INCREMENT current_end_day BY duration PLUS the heap pop operation result from max_heap  \n                ADD the negative value of duration TO max_heap using a heap push operation  \n            END IF  \n        END FOR  \n        RETURN the length of max_heap  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-square-numbers", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET upperBound AS INTEGER PART OF THE SQUARE ROOT OF c  \n        SET lowerBound AS 0  \n        LOOP FOREVER  \n            IF lowerBound GREATER THAN upperBound THEN  \n                RETURN false  \n            END IF  \n            SET total AS (upperBound * upperBound) + (lowerBound * lowerBound)  \n            SWITCH total COMPARED TO c  \n                CASE EQUAL:  \n                    RETURN true  \n                CASE LESS:  \n                    SET lowerBound TO lowerBound + 1  \n                CASE GREATER:  \n                    SET upperBound TO upperBound - 1  \n            END SWITCH  \n        END LOOP  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION judgeSquareSum WITH parameter c  \n        SET left TO zero  \n        SET right TO integer VALUE OF the SQUARE ROOT OF c  \n        WHILE left LESS THAN OR EQUAL TO right holds  \n            SET current_sum TO left MULTIPLIED BY left PLUS right MULTIPLIED BY right  \n            IF current_sum EQUALS c THEN  \n                RETURN true  \n            ELSE IF current_sum LESS THAN c THEN  \n                INCREMENT left BY one  \n            ELSE  \n                DECREMENT right BY one  \n            END IF  \n        END WHILE  \n        RETURN false  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "dota2-senate", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        DECLARE radiantQueue AS an empty double-ended queue  \n        DECLARE direQueue AS an empty double-ended queue  \n\n        INITIALIZE counter TO 0  \n        WHILE counter IS LESS THAN LENGTH of senate  \n            DECLARE partyChar AS senate[counter]  \n            IF NOT (partyChar NOT EQUAL TO 'R')  \n                APPEND counter TO radiantQueue  \n            ELSE  \n                APPEND counter TO direQueue  \n            END IF  \n            INCREMENT counter BY 1  \n        END WHILE  \n\n        DECLARE radiantLen AS LENGTH of senate  \n\n        LOOP INDEFINITELY  \n            IF radiantQueue IS EMPTY OR direQueue IS EMPTY THEN  \n                BREAK  \n            END IF  \n\n            REMOVE FIRST ELEMENT FROM radiantQueue AND ASSIGN TO radiantPos  \n            REMOVE FIRST ELEMENT FROM direQueue AND ASSIGN TO direPos  \n\n            IF radiantPos - direPos < 0 THEN  \n                APPEND radiantPos + radiantLen TO radiantQueue  \n            ELSE  \n                APPEND direPos + radiantLen TO direQueue  \n            END IF  \n        END LOOP  \n\n        IF radiantQueue IS EMPTY IS FALSE THEN  \n            RETURN \"Radiant\"  \n        END IF  \n        RETURN \"Dire\"  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION predictPartyVictory(senate)  \n        ASSIGN reference TO new double-ended queue named radiant  \n        ASSIGN reference TO new double-ended queue named dire  \n\n        FOR each index i AND character s IN senate  \n            IF character s EQUALS the character representing Radiant party  \n                APPEND index i TO radiant  \n            ELSE  \n                APPEND index i TO dire  \n            END IF  \n        END FOR  \n\n        WHILE radiant is not empty AND dire is not empty  \n            REMOVE and ASSIGN the first element from radiant TO r_index  \n            REMOVE and ASSIGN the first element from dire TO d_index  \n\n            IF r_index LESS THAN d_index  \n                APPEND r_index PLUS the length of senate TO radiant  \n            ELSE  \n                APPEND d_index PLUS the length of senate TO dire  \n            END IF  \n        END WHILE  \n\n        IF radiant is not empty  \n            RETURN the word Radiant  \n        ELSE  \n            RETURN the word Dire  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION checkPossibility(nums)\n        SET alterationFlag AS false\n        SET pos AS 1\n        WHILE pos < (LENGTH OF nums) DO\n            IF NOT (nums[pos] >= nums[pos - 1]) THEN\n                IF alterationFlag THEN\n                    RETURN false\n                END IF\n                alterationFlag ← true\n                IF (pos < 2) OR (nums[pos] >= nums[pos - 2]) THEN\n                    nums[pos - 1] ← nums[pos]\n                ELSE\n                    nums[pos] ← nums[pos - 1]\n                END IF\n            END IF\n            pos ← pos + 1\n        END WHILE\n        RETURN true\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "repeated-string-match", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        DECLARE minReps INTEGER  \n        ASSIGN minReps TO CEILING(LENGTH(b) / LENGTH(a))  \n        \n        DECLARE candidate STRING  \n        ASSIGN candidate TO a  \n        DECLARE repeatedCandidate STRING  \n        \n        ASSIGN repeatedCandidate TO CONCATENATE(candidate REPEATED minReps TIMES)  \n        IF CONTAINS(repeatedCandidate, b) THEN  \n            RETURN minReps  \n        END IF  \n        \n        ASSIGN repeatedCandidate TO CONCATENATE(candidate REPEATED (minReps + 1) TIMES)  \n        IF CONTAINS(repeatedCandidate, b) THEN  \n            RETURN (minReps + 1)  \n        END IF  \n        \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION repeatedStringMatch(a string, b string) RETURNS integer  \n        SET minimum repetitions TO the smallest integer greater than or equal to the LENGTH OF b DIVIDED BY the LENGTH OF a  \n        IF string b IS a substring of string a repeated minimum repetitions times  \n            RETURN minimum repetitions  \n        END IF  \n        IF string b IS a substring of string a repeated minimum repetitions PLUS one times  \n            RETURN minimum repetitions PLUS one  \n        END IF  \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-ascii-delete-sum-for-two-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET length_s1 AS LENGTH OF s1  \n        SET length_s2 AS LENGTH OF s2  \n        \n        DECLARE dp AS LIST OF LISTS WITH (length_s1 + 1) ROWS AND (length_s2 + 1) COLUMNS FILLED WITH 0  \n        \n        SET idx_col TO 1  \n        WHILE idx_col <= length_s2  \n            LET previous_value BE dp[0][idx_col - 1]  \n            LET ascii_code BE ASCII OF s2[idx_col - 1]  \n            dp[0][idx_col] ← previous_value + ascii_code  \n            idx_col ← idx_col + 1  \n        END WHILE  \n        \n        SET idx_row TO 1  \n        WHILE idx_row <= length_s1  \n            LET previous_value_row BE dp[idx_row - 1][0]  \n            LET ascii_code_row BE ASCII OF s1[idx_row - 1]  \n            dp[idx_row][0] ← previous_value_row + ascii_code_row  \n            idx_row ← idx_row + 1  \n        END WHILE  \n        \n        SET outer_index TO 1  \n        WHILE outer_index <= length_s1  \n            SET inner_index TO 1  \n            WHILE inner_index <= length_s2  \n                LET char_s1 BE s1[outer_index - 1]  \n                LET char_s2 BE s2[inner_index - 1]  \n                IF char_s1 ≠ char_s2 THEN\n                    LET deletion_s1 COST ← dp[outer_index - 1][inner_index] + ASCII OF char_s1  \n                    LET deletion_s2 COST ← dp[outer_index][inner_index - 1] + ASCII OF char_s2  \n                    LET dp[outer_index][inner_index] BE MINIMUM OF deletion_s1 COST AND deletion_s2 COST  \n                ELSE  \n                    LET dp[outer_index][inner_index] BE dp[outer_index - 1][inner_index - 1]  \n                END IF  \n                inner_index ← inner_index + 1  \n            END WHILE  \n            outer_index ← outer_index + 1  \n        END WHILE  \n        \n        RETURN dp[length_s1][length_s2]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumDeleteSum(s1, s2)  \n        SET m TO the LENGTH OF s1  \n        SET n TO the LENGTH OF s2  \n        \n        CREATE a two dimensional list dp WITH dimensions m PLUS one BY n PLUS one INITIALIZED WITH zeroes  \n        \n        FOR j FROM one TO n  \n            SET element at position j of the first row of dp TO element at position j MINUS one of the first row of dp PLUS ASCII value of character at position j MINUS one of s2  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            SET element at position i of the first column of dp TO element at position i MINUS one of the first column of dp PLUS ASCII value of character at position i MINUS one of s1  \n        END FOR  \n        \n        FOR i FROM one TO m  \n            FOR j FROM one TO n  \n                IF character at position i MINUS one of s1 EQUALS character at position j MINUS one of s2  \n                    SET element at position i , position j of dp TO element at position i MINUS one , position j MINUS one of dp  \n                ELSE  \n                    SET element at position i , position j of dp TO the MINIMUM OF element at position i MINUS one , position j of dp PLUS ASCII value of character at position i MINUS one of s1 AND element at position i , position j MINUS one of dp PLUS ASCII value of character at position j MINUS one of s2  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m , position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "swap-adjacent-in-lr-string", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        INITIALIZE filteredStart AS empty list  \n        INITIALIZE posCounter TO 0  \n        WHILE posCounter < LENGTH(start parameter) DO  \n            ASSIGN currentChar TO start parameter[posCounter]  \n            IF NOT (currentChar = 'X') THEN  \n                SET filteredStart TO filteredStart CONCATENATED WITH [(currentChar, posCounter)]  \n            END IF  \n            INCREMENT posCounter BY 1  \n        END WHILE  \n\n        INITIALIZE filteredEnd AS empty list  \n        ASSIGN idxCursor TO 0  \n        WHILE idxCursor < LENGTH(end parameter) DO  \n            ASSIGN ch TO end parameter[idxCursor]  \n            IF ch <> 'X' THEN  \n                SET filteredEnd TO filteredEnd + [(ch, idxCursor)]  \n            END IF  \n            ASSIGN idxCursor TO idxCursor + 1  \n        END WHILE  \n\n        IF LENGTH(filteredStart) != LENGTH(filteredEnd) THEN  \n            RETURN false  \n        END IF  \n\n        INITIALIZE pairIndex TO 0  \n        WHILE pairIndex < LENGTH(filteredStart) DO  \n            ASSIGN firstTuple TO filteredStart[pairIndex]  \n            ASSIGN secondTuple TO filteredEnd[pairIndex]  \n\n            ASSIGN charA TO firstTuple[0]  \n            ASSIGN posA TO firstTuple[1]  \n            ASSIGN charB TO secondTuple[0]  \n            ASSIGN posB TO secondTuple[1]  \n\n            IF NOT (charA = charB) THEN  \n                RETURN false  \n            END IF  \n\n            IF charA = 'L' THEN  \n                IF posA < posB THEN  \n                    RETURN false  \n                END IF  \n            ELSE IF charA = 'R' THEN  \n                IF posA > posB THEN  \n                    RETURN false  \n                END IF  \n            END IF  \n\n            SET pairIndex TO pairIndex + 1  \n        END WHILE  \n\n        RETURN true  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canTransform(start parameter, end parameter)  \n        SET start_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF start parameter MINUS one  \n            SET character_at_index TO element at position index of start parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO start_filtered  \n            END IF  \n        END FOR  \n        SET end_filtered TO empty list  \n        FOR index FROM zero TO the LENGTH OF end parameter MINUS one  \n            SET character_at_index TO element at position index of end parameter  \n            IF character_at_index NOT EQUALS the character X  \n                APPEND tuple of character_at_index AND index TO end_filtered  \n            END IF  \n        END FOR  \n        IF the LENGTH OF start_filtered NOT EQUALS the LENGTH OF end_filtered  \n            RETURN false  \n        END IF  \n        FOR each pair of tuples first_pair AND second_pair IN the PAIRWISE ITERATION OF start_filtered AND end_filtered  \n            SET character_one TO the first element of first_pair  \n            SET index_one TO the second element of first_pair  \n            SET character_two TO the first element of second_pair  \n            SET index_two TO the second element of second_pair  \n            IF character_one NOT EQUALS character_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character L AND index_one LESS THAN index_two  \n                RETURN false  \n            END IF  \n            IF character_one EQUALS the character R AND index_one GREATER THAN index_two  \n                RETURN false  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean\n        LOOP_WHILE (tx IS_NOT_LESS_THAN sx) AND (ty IS_NOT_LESS_THAN sy)\n            IF (NOT (tx IS_DIFFERS_FROM sx)) AND (NOT (ty IS_DIFFERS_FROM sy))\n                RETURN True\n            END IF\n\n            IF tx IS_GREATER_THAN ty\n                IF ty IS_GREATER_THAN sy\n                    LET dividend = tx\n                    LET divisor = ty\n                    LET remainder = dividend MINUS (divisor TIMES FLOOR(dividend DIVIDED_BY divisor))\n                    ASSIGN remainder INTO tx\n                ELSE\n                    LET numerator = tx MINUS sx\n                    LET denominator = ty\n                    LET modulusResult = numerator MINUS (denominator TIMES FLOOR(numerator DIVIDED_BY denominator))\n                    IF NOT (modulusResult IS_NOT_EQUAL_ZERO)\n                        RETURN True\n                    ELSE\n                        RETURN False\n                    END IF\n                END IF\n            ELSE\n                IF tx IS_GREATER_THAN sx\n                    LET dividend = ty\n                    LET divisor = tx\n                    LET remainder = dividend MINUS (divisor TIMES FLOOR(dividend DIVIDED_BY divisor))\n                    ASSIGN remainder INTO ty\n                ELSE\n                    LET numerator = ty MINUS sy\n                    LET denominator = tx\n                    LET modulusResult = numerator MINUS (denominator TIMES FLOOR(numerator DIVIDED_BY denominator))\n                    IF NOT (modulusResult IS_NOT_EQUAL_ZERO)\n                        RETURN True\n                    ELSE\n                        RETURN False\n                    END IF\n                END IF\n            END IF\n        END LOOP_WHILE\n        RETURN False\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION reachingPoints(sx sx PARAMETER sy sy PARAMETER tx tx PARAMETER ty ty) RETURNS boolean  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "is-graph-bipartite", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        ASSIGN size TO LENGTH(graph)  \n        ASSIGN paint TO ARRAY OF size ELEMENTS FILLED WITH 0  \n        \n        FUNCTION dfs(vertex, shade)  \n            paint[vertex] = shade  \n            SET index TO 0  \n            WHILE index < LENGTH(graph[vertex])  \n                ASSIGN adj TO graph[vertex][index]  \n                IF paint[adj] == shade THEN  \n                    RETURN False  \n                ELSE IF paint[adj] == 0 THEN  \n                    IF dfs(adj, -shade) == False THEN  \n                        RETURN False  \n                    END IF  \n                END IF  \n                index = index + 1  \n            END WHILE  \n            RETURN True  \n        END FUNCTION  \n        \n        SET counter TO 0  \n        WHILE counter < size  \n            IF paint[counter] == 0 THEN  \n                IF dfs(counter, 1) == False THEN  \n                    RETURN False  \n                END IF  \n            END IF  \n            counter = counter + 1  \n        END WHILE  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isBipartite(graph)  \n        SET n TO the LENGTH OF graph  \n        SET color TO a list of zeros with LENGTH n  \n        \n        FUNCTION dfs(node c)  \n            SET the element at position node of color TO c  \n            FOR each neighbor IN the element at position node of graph  \n                IF the element at position neighbor of color EQUALS c  \n                    RETURN False  \n                END IF  \n                IF the element at position neighbor of color EQUALS zero  \n                    IF dfs(neighbor the NEGATION OF c) EQUALS False  \n                        RETURN False  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN True  \n        END FUNCTION  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of color EQUALS zero  \n                IF dfs(i one) EQUALS False  \n                    RETURN False  \n                END IF  \n            END IF  \n        END FOR  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "domino-and-tromino-tiling", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD to 1_000_000_007  \n        \n        SET dp AS a list initialized with zeros, size n PLUS 1  \n        SET dp1 AS a list initialized with zeros, size n PLUS 1  \n        \n        ASSIGN 1 TO dp[0]  \n        ASSIGN 1 TO dp[1]  \n        IF n LESS THAN 2 THEN  \n            GOTO after_initialization  \n        ELSE  \n            ASSIGN 2 TO dp[2]  \n            ASSIGN 1 TO dp1[2]  \n        END IF  \n        LABEL after_initialization  \n        \n        SET index TO 3  \n        WHILE index LESS THAN OR EQUAL TO n DO  \n            SET part1 TO (dp[index - 1] + dp[index - 2]) MOD MOD  \n            SET part2 TO (2 * dp1[index - 1]) MOD MOD  \n            ASSIGN (part1 + part2) MOD MOD TO dp[index]  \n            \n            SET dp1[index] TO ((dp[index - 2] + dp1[index - 1]) MOD MOD)  \n            INCREMENT index BY 1  \n        END WHILE  \n        \n        RETURN dp[n]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO the one billion PLUS seven  \n        \n        SET dp TO a list of zeros with LENGTH n PLUS one  \n        SET dp1 TO a list of zeros with LENGTH n PLUS one  \n        \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder of the sum of element at position i MINUS one of dp PLUS element at position i MINUS two of dp PLUS two MULTIPLIED BY element at position i MINUS one of dp1 when divided by MOD  \n            SET element at position i of dp1 TO the remainder of the sum of element at position i MINUS two of dp PLUS element at position i MINUS one of dp1 when divided by MOD  \n        END FOR  \n        \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "soup-servings", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION soupServings(n)\n        CASE\n            WHEN n <= 4800 THEN\n                SET n AS (n + 24) DIV 25\n            ELSE\n                RETURN 1.0\n        END CASE\n\n        SET cache AS empty dictionary\n\n        FUNCTION dp(a, b)\n            DEPLOY\n                VARIABLE key AS (a, b)\n            RETRIEVE\n                IF key IN cache THEN\n                    RETURN cache[key]\n                END IF\n            STOP\n\n            IF a <= 0 THEN\n                IF b <= 0 THEN\n                    RETURN 0.5\n                ELSE\n                    RETURN 1.0\n                END IF\n            ELSE\n                IF b <= 0 THEN\n                    RETURN 0.0\n                END IF\n            END IF\n\n            VARIABLE p1 AS dp(a - 4, b)\n            VARIABLE p2 AS dp(a - 3, b - 1)\n            VARIABLE p3 AS dp(a - 2, b - 2)\n            VARIABLE p4 AS dp(a - 1, b - 3)\n\n            VARIABLE prob AS 0.25 * (p1 + p2 + p3 + p4)\n            SET cache[key] AS prob\n\n            RETURN prob\n        END FUNCTION\n\n        RETURN dp(n, n)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION soupServings(n)  \n        IF n GREATER THAN four thousand eight hundred THEN  \n            RETURN one point zero  \n        END IF  \n        SET n TO n PLUS twenty four DIVIDED BY twenty five  \n        SET memo TO empty dictionary  \n        FUNCTION dp(a, b)  \n            IF tuple of a AND b EXISTS IN memo THEN  \n                RETURN value of tuple of a AND b IN memo  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero AND b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point five  \n            END IF  \n            IF a LESS THAN OR EQUAL TO zero THEN  \n                RETURN one point zero  \n            END IF  \n            IF b LESS THAN OR EQUAL TO zero THEN  \n                RETURN zero point zero  \n            END IF  \n            SET prob TO zero point two five MULTIPLIED BY sum of dp of a MINUS four AND b PLUS dp of a MINUS three AND b MINUS one PLUS dp of a MINUS two AND b MINUS two PLUS dp of a MINUS one AND b MINUS three  \n            SET value of tuple of a AND b IN memo TO prob  \n            RETURN prob  \n        END FUNCTION  \n        RETURN dp of n AND n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "card-flipping-game", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET repeating TO empty set  \n        DEFINE index AS 0  \n        WHILE index LESS THAN the LENGTH OF fronts  \n            SET front_val TO fronts[index]  \n            SET back_val TO backs[index]  \n            IF front_val EQUAL back_val THEN  \n                ADD front_val TO repeating  \n            END IF  \n            INCREMENT index BY 1  \n        END WHILE  \n\n        SET combined_values TO empty set  \n        FOR EACH val IN fronts DO  \n            ADD val TO combined_values  \n        END FOR  \n\n        FOR EACH val IN backs DO  \n            ADD val TO combined_values  \n        END FOR  \n\n        SET candidates TO empty set  \n        FOR EACH val IN combined_values DO  \n            IF NOT (val IN repeating) THEN  \n                ADD val TO candidates  \n            END IF  \n        END FOR  \n\n        IF LENGTH OF candidates IS NOT EQUAL TO 0 THEN  \n            SET result TO NULL  \n            SET iterator TO candidates.iterator()  \n            SET result TO iterator.next()  \n            WHILE iterator.hasNext() DO  \n                SET current_val TO iterator.next()  \n                IF current_val LESS THAN result THEN  \n                    SET result TO current_val  \n                END IF  \n            END WHILE  \n            RETURN result  \n        ELSE  \n            RETURN 0  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION flipgame(fronts, backs)  \n        SET same TO empty set  \n        FOR each pair of front_card AND back_card IN fronts AND backs simultaneously  \n            IF front_card EQUALS back_card  \n                ADD front_card TO same  \n            END IF  \n        END FOR  \n        SET all_numbers TO empty set  \n        FOR each number IN fronts  \n            ADD number TO all_numbers  \n        END FOR  \n        FOR each number IN backs  \n            ADD number TO all_numbers  \n        END FOR  \n        SET good_numbers TO empty set  \n        FOR each number IN all_numbers  \n            IF number NOT IN same  \n                ADD number TO good_numbers  \n            END IF  \n        END FOR  \n        IF the LENGTH OF good_numbers IS GREATER THAN zero  \n            SET minimum_good_number TO the smallest element IN good_numbers  \n            RETURN minimum_good_number  \n        ELSE  \n            RETURN zero  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "binary-trees-with-factors", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        ASSIGN MODULO_CONST ← (10 ^ 9) + 7  \n        SORT arr BY ascending order  \n        \n        INITIALIZE factorsCount AS empty mapping  \n        FOR each element IN arr DO  \n            SET factorsCount[element] ← 1  \n        END FOR  \n        \n        SET outerIdx ← 0  \n        WHILE outerIdx < LENGTH(arr) DO  \n            SET currentVal ← arr[outerIdx]  \n            SET innerIdx ← 0  \n            WHILE innerIdx < outerIdx DO  \n                SET divisorCandidate ← arr[innerIdx]  \n                IF (currentVal − (currentVal DIV divisorCandidate) * divisorCandidate) = 0 THEN  \n                    SET pairedFactor ← currentVal DIV divisorCandidate  \n                    IF pairedFactor IN factorsCount THEN  \n                        SET product ← factorsCount[divisorCandidate] * factorsCount[pairedFactor]  \n                        SET factorsCount[currentVal] ← (factorsCount[currentVal] + product) MODULO MODULO_CONST  \n                    END IF  \n                END IF  \n                INCREMENT innerIdx BY 1  \n            END WHILE  \n            INCREMENT outerIdx BY 1  \n        END WHILE  \n        \n        ASSIGN accumulation ← 0  \n        FOR each countValue IN factorsCount DO  \n            SET accumulation ← accumulation + countValue  \n        END FOR  \n        \n        RETURN accumulation MODULO MODULO_CONST  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numFactoredBinaryTrees(arr)  \n        SET MOD TO ten raised to the power of nine PLUS seven  \n        SORT arr IN ascending order  \n        SET dp TO an empty mapping FROM elements of arr TO the number one FOR each element in arr  \n        FOR index i FROM zero TO the LENGTH OF arr MINUS one  \n            SET num TO element at position i of arr  \n            FOR index j FROM zero TO i MINUS one  \n                SET potential_factor TO element at position j of arr  \n                IF num MODULO potential_factor EQUALS zero THEN  \n                    SET right_child TO num DIVIDED BY potential_factor  \n                    IF right_child EXISTS AS a key IN dp THEN  \n                        SET dp of num TO dp of num PLUS dp of potential_factor MULTIPLIED BY dp of right_child  \n                        SET dp of num TO dp of num MODULO MOD  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET total TO zero  \n        FOR each value IN dp values  \n            INCREMENT total BY value  \n        END FOR  \n        RETURN total MODULO MOD  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "split-array-into-fibonacci-sequence", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION splitIntoFibonacci(num)\n        FUNCTION backtrack(start, path)\n            ASSIGN sizeNum TO LENGTH(num)\n            ASSIGN sizePath TO LENGTH(path)\n            IF NOT (start NOT EQUAL sizeNum OR sizePath LESS THAN 3)\n                RETURN path\n            END IF\n            ASSIGN idx TO start + 1\n            WHILE idx <= sizeNum\n                IF NOT ((num[start] = '0') AND (idx > start + 1))\n                    ASSIGN substrVal TO SUBSTRING(num, start, idx)\n                    ASSIGN nextVal TO TO_INTEGER(substrVal)\n                    IF nextVal < 2 ^ 31\n                        IF (sizePath < 2) OR (nextVal = path[sizePath - 1] + path[sizePath - 2])\n                            ASSIGN attempt TO backtrack(idx, CONCAT(path, [nextVal]))\n                            IF attempt != []\n                                RETURN attempt\n                            END IF\n                        END IF\n                    ELSE\n                        BREAK\n                    END IF\n                END IF\n                idx = idx + 1\n            END WHILE\n            RETURN []\n        END FUNCTION\n        RETURN backtrack(0, [])\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION splitIntoFibonacci(num)  \n        FUNCTION backtrack(start, path)  \n            IF start EQUALS the LENGTH OF num AND the LENGTH OF path GREATER THAN OR EQUAL TO three  \n                RETURN path  \n            END IF  \n            FOR end FROM start PLUS one TO the LENGTH OF num PLUS one  \n                IF the element at position start of num EQUALS the character zero AND end GREATER THAN start PLUS one  \n                    CONTINUE TO the next iteration of the loop  \n                END IF  \n                SET next_num TO the integer value of the substring of num from position start TO position end MINUS one  \n                IF next_num GREATER THAN OR EQUAL TO two RAISED TO THE POWER OF thirty ONE  \n                    BREAK the loop  \n                END IF  \n                IF the LENGTH OF path LESS THAN two OR next_num EQUALS the element at the position LENGTH OF path MINUS one of path PLUS the element at the position LENGTH OF path MINUS two of path  \n                    SET result TO the call of backtrack WITH parameters end AND the concatenation of path AND the list containing next_num  \n                    IF result IS NOT an empty list  \n                        RETURN result  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN an empty list  \n        END FUNCTION  \n        RETURN the call of backtrack WITH parameters zero AND an empty list  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-mountain-in-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestMountain(arr)\n        SET length_arr AS LENGTH OF arr\n        SET maximum_length TO 0\n        SET index_counter TO 1\n        LOOP\n            IF NOT (index_counter < length_arr - 1) THEN\n                BREAK\n            END IF\n\n            IF (arr[index_counter - 1] < arr[index_counter]) AND (arr[index_counter] > arr[index_counter + 1]) THEN\n                SET left_marker AS index_counter - 1\n                SET right_marker AS index_counter + 1\n\n                WHILE (left_marker > 0) AND (arr[left_marker - 1] < arr[left_marker])\n                    left_marker ← left_marker - 1\n                END WHILE\n\n                WHILE (right_marker < length_arr - 1) AND (arr[right_marker] > arr[right_marker + 1])\n                    right_marker ← right_marker + 1\n                END WHILE\n\n                SET current_mountain_length AS right_marker - left_marker + 1\n                IF maximum_length < current_mountain_length THEN\n                    maximum_length ← current_mountain_length\n                END IF\n\n                index_counter ← right_marker\n            ELSE\n                index_counter ← index_counter + 1\n            END IF\n        END LOOP\n        RETURN maximum_length\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestMountain(arr)  \n        SET n TO the LENGTH OF arr  \n        SET longest TO zero  \n        SET i TO one  \n        WHILE i LESS THAN n MINUS one  \n            IF element at position i MINUS one of arr LESS THAN element at position i of arr AND element at position i of arr GREATER THAN element at position i PLUS one of arr  \n                SET left TO i MINUS one  \n                SET right TO i PLUS one  \n                WHILE left GREATER THAN zero AND element at position left MINUS one of arr LESS THAN element at position left of arr  \n                    DECREMENT left BY one  \n                END WHILE  \n                WHILE right LESS THAN n MINUS one AND element at position right of arr GREATER THAN element at position right PLUS one of arr  \n                    INCREMENT right BY one  \n                END WHILE  \n                IF longest LESS THAN right MINUS left PLUS one  \n                    SET longest TO right MINUS left PLUS one  \n                END IF  \n                SET i TO right  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        RETURN longest  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "loud-and-rich", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION loudAndRich(richer, quiet)\n        graph ← default dictionary with list as default value\n        iterator ← 0\n        WHILE iterator < LENGTH(richer)\n            pair ← richer[iterator]\n            graph[pair[1]] APPEND pair[0]\n            iterator ← iterator + 1\n        END WHILE\n\n        n ← LENGTH(quiet)\n        answer ← new list of size n FILLED WITH -1\n\n        FUNCTION dfs(person)\n            IF NOT (answer[person] ≠ -1) THEN\n                answer[person] ← person\n                index ← 0\n                WHILE index < LENGTH(graph[person])\n                    neighbor ← graph[person][index]\n                    candidate ← dfs(neighbor)\n                    IF quiet[candidate] < quiet[answer[person]] THEN\n                        answer[person] ← candidate\n                    END IF\n                    index ← index + 1\n                END WHILE\n            END IF\n            RETURN answer[person]\n        END FUNCTION\n\n        counter ← 0\n        WHILE counter < n\n            dfs(counter)\n            counter ← counter + 1\n        END WHILE\n\n        RETURN answer\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION loudAndRich(richer, quiet)  \n        SET graph TO a new default dictionary with list as the default value type  \n        FOR each pair of elements named a and b IN the collection richer  \n            APPEND element a TO the list associated with key b in graph  \n        END FOR  \n        \n        SET n TO the length of the collection quiet  \n        SET answer TO a list of length n filled with minus one values  \n        \n        FUNCTION dfs(person)  \n            IF the element at position person of answer EQUALS minus one THEN  \n                SET the element at position person of answer TO person  \n                FOR each element neighbor IN the list at key person of graph  \n                    SET candidate TO the result of calling dfs with argument neighbor  \n                    IF the element at position candidate of quiet LESS THAN the element at position of answer at person of quiet THEN  \n                        SET the element at position person of answer TO candidate  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN the element at position person of answer  \n        END FUNCTION  \n        \n        FOR index i FROM zero TO n MINUS one  \n            CALL dfs with argument i  \n        END FOR  \n        \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "super-egg-drop", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        LET tests BE 0  \n        LET attempts BE a list initialized with zeros whose size equals k + 1  \n        REPEAT  \n            tests ← tests + 1  \n            LET eggIndex BE k  \n            WHILE eggIndex GREATER THAN 0  \n                attempts[eggIndex] ← 1 + attempts[eggIndex - 1] + attempts[eggIndex]  \n                eggIndex ← eggIndex - 1  \n            END WHILE  \n        UNTIL attempts[k] GREATER THAN OR EQUAL TO n  \n        RETURN tests  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION superEggDrop(k, n)  \n        SET dp TO a list of zeros with length k PLUS one  \n        SET moves TO zero  \n        WHILE element at position k of dp LESS THAN n holds  \n            INCREMENT moves BY one  \n            FOR eggs FROM k DOWN TO one  \n                SET element at position eggs of dp TO one PLUS element at position eggs MINUS one of dp PLUS element at position eggs of dp  \n            END FOR  \n        END WHILE  \n        RETURN moves  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "triples-with-bitwise-and-equal-to-zero", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        INITIALIZE pairCountMap AS a default dictionary mapping integer keys to integers  \n        SET indexA TO 0  \n        WHILE indexA < LENGTH(nums)  \n            SET elementA TO nums[indexA]  \n            INITIALIZE indexB TO 0  \n            WHILE indexB < LENGTH(nums)  \n                SET elementB TO nums[indexB]  \n                SET bitwiseKey TO elementB BITWISE_AND elementA  \n                SET existingValue TO 0  \n                IF pairCountMap CONTAINS bitwiseKey THEN  \n                    existingValue ← pairCountMap[bitwiseKey]  \n                END IF  \n                pairCountMap[bitwiseKey] ← existingValue + 1  \n                indexB ← indexB + 1  \n            END WHILE  \n            indexA ← indexA + 1  \n        END WHILE  \n\n        SET accumulatedTriplets TO 0  \n        SET idxC TO 0  \n        WHILE idxC < LENGTH(nums)  \n            SET currentElement TO nums[idxC]  \n            FOR pairKey WITH occurrence IN pairCountMap ITEMS  \n                IF NOT ((pairKey BITWISE_AND currentElement) != 0) THEN  \n                    accumulatedTriplets ← accumulatedTriplets + occurrence  \n                END IF  \n            END FOR  \n            idxC ← idxC + 1  \n        END WHILE  \n\n        RETURN accumulatedTriplets  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countTriplets(nums)  \n        SET pair_and_count TO a new default dictionary of integers  \n        FOR each element i IN nums  \n            FOR each element j IN nums  \n                SET current_key TO the bitwise AND of i AND j  \n                INCREMENT the value at current_key in pair_and_count BY one  \n            END FOR  \n        END FOR  \n        SET triplet_count TO zero  \n        FOR each element k IN nums  \n            FOR each key pair_and and associated count IN pair_and_count items  \n                IF the bitwise AND of pair_and AND k EQUALS zero THEN  \n                    INCREMENT triplet_count BY count  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN triplet_count  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "last-substring-in-lexicographical-order", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        LET lengthVar BE LENGTH OF s  \n        LET highestChar BE MAXIMUM CHARACTER IN s  \n        LET positions BE AN EMPTY LIST  \n        LET index COUNTER TO 0  \n        WHILE index < lengthVar DO  \n            IF s[index] = highestChar THEN  \n                APPEND index TO positions  \n            END IF  \n            SET index TO index + 1  \n        END WHILE  \n\n        LET candidateSubstring BE \"\"  \n        LET posIndex POINTER TO 0  \n        WHILE posIndex < LENGTH OF positions DO  \n            LET substringStart BE positions[posIndex]  \n            LET tempSubstring BE SLICE OF s FROM substringStart TO (LENGTH OF s)  \n            IF NOT (candidateSubstring >= tempSubstring) THEN  \n                SET candidateSubstring TO tempSubstring  \n            END IF  \n            SET posIndex TO posIndex + 1  \n        END WHILE  \n        RETURN candidateSubstring  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION lastSubstring(s)  \n        SET n TO the LENGTH OF s  \n        SET max_char TO the MAXIMUM CHARACTER IN s  \n        SET max_indices TO an empty list  \n        FOR i FROM zero TO n MINUS one  \n            IF the element at position i of s EQUALS max_char  \n                APPEND i TO max_indices  \n            END IF  \n        END FOR  \n        SET max_substring TO the empty string  \n        FOR each start IN max_indices  \n            SET current_substring TO the substring of s from position start TO the END  \n            IF current_substring GREATER THAN max_substring  \n                SET max_substring TO current_substring  \n            END IF  \n        END FOR  \n        RETURN max_substring  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "restore-the-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer\n        SET MOD TO 1000000000 PLUS 7\n        SET length_s TO LENGTH OF s\n        INITIALIZE dp AS an array containing (length_s PLUS 1) zeros\n        SET dp[0] AS 1\n\n        SET outer_index TO 1\n        WHILE outer_index LESS THAN OR EQUAL TO length_s DO\n            SET inner_idx TO 0\n            WHILE inner_idx LESS THAN outer_index DO\n                SET current_char TO s[inner_idx]\n                IF NOT (current_char EQUALS '0') THEN\n                    SET substring_str TO EXTRACT s FROM inner_idx TO (outer_index MINUS 1)\n                    SET num_value TO CONVERT substring_str TO integer\n                    IF (num_value GREATER THAN OR EQUAL TO 1) AND (num_value LESS THAN OR EQUAL TO k) THEN\n                        SET dp[outer_index] TO (dp[outer_index] PLUS dp[inner_idx]) MODULO MOD\n                    END IF\n                END IF\n                INCREMENT inner_idx BY 1\n            END WHILE\n            INCREMENT outer_index BY 1\n        END WHILE\n\n        RETURN dp[length_s]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numberOfArrays(s PARAMETER string, k PARAMETER integer) RETURNS integer  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of n PLUS one zeros  \n        SET element at position zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO i MINUS one  \n                IF character at position j of s NOT EQUALS zero AND  \n                   the integer value of substring from position j TO position i MINUS one of s GREATER THAN OR EQUAL TO one AND  \n                   the integer value of substring from position j TO position i MINUS one of s LESS THAN OR EQUAL TO k  \n                THEN  \n                    SET element at position i of dp TO the sum of element at position i of dp AND element at position j of dp MODULO MOD  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        LET rowCount BE LENGTH OF mat  \n        LET colCount BE LENGTH OF FIRST ELEMENT IN mat  \n        LET baseSum BE 0  \n        LET accumulator BE 0  \n        WHILE accumulator < rowCount  \n            baseSum ← baseSum + mat[accumulator][0]  \n            accumulator ← accumulator + 1  \n        END WHILE  \n        \n        LET startIndices BE A TUPLE WITH rowCount COPIES OF 0  \n        LET heapList BE A LIST CONTAINING (baseSum, startIndices)  \n        LET seenIndices BE A SET CONTAINING startIndices  \n        \n        LOOP UNTIL k IS 0  \n            EXTRACT (currentSum, currentIndices) FROM heapList BY REMOVING SMALLEST ELEMENT  \n            k ← k - 1  \n            \n            IF k = 0 THEN RETURN currentSum END IF  \n            \n            LET position BE 0  \n            WHILE position < rowCount DO  \n                LET currentIndexValue BE currentIndices[position]  \n                IF currentIndexValue + 1 < colCount THEN  \n                    LET tempIndices BE CONVERT_TO_LIST(currentIndices)  \n                    LET tempIndexValue BE tempIndices[position] + 1  \n                    tempIndices[position] ← tempIndexValue  \n                    LET nextIndices BE CONVERT_TO_TUPLE(tempIndices)  \n                    \n                    LET replacedSumPart BE mat[position][currentIndexValue]  \n                    LET newSumPart BE mat[position][tempIndexValue]  \n                    LET updatedSum BE currentSum - replacedSumPart + newSumPart  \n                    \n                    IF nextIndices NOT IN seenIndices THEN  \n                        ADD nextIndices TO seenIndices  \n                        ADD (updatedSum, nextIndices) TO heapList  \n                    END IF  \n                END IF  \n                position ← position + 1  \n            END WHILE  \n        END LOOP  \n        \n        RETURN -1  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallest(mat AS List OF List OF Integer k AS Integer) RETURNS Integer  \n        SET m TO the LENGTH OF mat  \n        SET n TO the LENGTH OF the element at position zero of mat  \n        SET initial_sum TO zero  \n        FOR each row IN mat  \n            INCREMENT initial_sum BY the element at position zero of row  \n        END FOR  \n        SET initial_indices TO a tuple of zero repeated m times  \n        SET min_heap TO a list containing a tuple of initial_sum and initial_indices  \n        SET visited TO a set containing initial_indices  \n        \n        WHILE k GREATER THAN zero  \n            EXTRACT the tuple containing current_sum and indices by removing the smallest element from min_heap  \n            DECREMENT k BY one  \n            \n            IF k EQUALS zero  \n                RETURN current_sum  \n            END IF  \n            \n            FOR i FROM zero TO m MINUS one  \n                IF the element at position i of indices PLUS one LESS THAN n  \n                    SET new_indices_list TO a list converted from indices  \n                    INCREMENT the element at position i of new_indices_list BY one  \n                    SET new_indices_tuple TO a tuple converted from new_indices_list  \n                    SET new_sum TO current_sum MINUS the element at position i of mat AT the element at position i of indices PLUS the element at position i of mat AT the element at position i of new_indices_tuple  \n                    \n                    IF new_indices_tuple NOT IN visited  \n                        ADD new_indices_tuple TO visited  \n                        ADD the tuple containing new_sum and new_indices_tuple TO min_heap  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        \n        RETURN negative one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-incompatibility", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        LET totalElements ← LENGTH nums  \n        LET sizePerSubset ← totalElements DIV k  \n        LET elementCounts ← COUNT ELEMENTS IN nums  \n        \n        FOR countValue IN elementCounts.VALUES  \n            IF countValue > k THEN RETURN -1  \n        END FOR  \n        \n        LET incompatibilityMap ← EMPTY DICTIONARY  \n        LET maxMask ← (2 POWER totalElements) - 1  \n        LET currentMask ← 0  \n        \n        WHILE currentMask <= maxMask DO  \n            LET bitsSet ← COUNT OF BITS SET IN currentMask  \n            \n            IF bitsSet = sizePerSubset THEN  \n                LET collected ← EMPTY LIST  \n                LET index ← 0  \n                \n                WHILE index < totalElements DO  \n                    IF (currentMask BITWISE-AND (2 POWER index)) ≠ 0 THEN  \n                        collected.APPEND(nums[index])  \n                    END IF  \n                    index ← index + 1  \n                END WHILE  \n                \n                LET uniqueElements ← SET OF collected  \n                IF LENGTH uniqueElements = sizePerSubset THEN  \n                    LET maxVal ← MAX OF collected  \n                    LET minVal ← MIN OF collected  \n                    LET diff ← maxVal - minVal  \n                    incompatibilityMap[currentMask] ← diff  \n                END IF  \n            END IF  \n            \n            currentMask ← currentMask + 1  \n        END WHILE  \n        \n        LET dpArray ← ARRAY OF SIZE (2 POWER totalElements) FILLED WITH INFINITY  \n        dpArray[0] ← 0  \n        \n        FOR maskValue FROM 0 TO maxMask DO  \n            IF (COUNT OF BITS SET IN maskValue) MOD sizePerSubset ≠ 0 THEN CONTINUE  \n            \n            FOR each candidateSubset IN incompatibilityMap.KEYS DO  \n                IF (maskValue BITWISE-AND candidateSubset) = candidateSubset THEN  \n                    LET attempt ← dpArray[maskValue - candidateSubset] + incompatibilityMap[candidateSubset]  \n                    IF attempt < dpArray[maskValue] THEN  \n                        dpArray[maskValue] ← attempt  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        LET fullSetMask ← maxMask  \n        IF dpArray[fullSetMask] ≠ INFINITY THEN  \n            RETURN dpArray[fullSetMask]  \n        ELSE  \n            RETURN -1  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        CREATE counter_object AS a COUNT of each element IN nums  \n        IF any count IN the VALUES OF counter_object is GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        CREATE empty dictionary subset_incompatibility  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask  \n            IF bit_count EQUALS subset_size THEN  \n                CREATE empty list elements  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BITWISE AND OF mask AND TWO RAISED TO THE POWER OF i is NOT EQUAL TO zero THEN  \n                        APPEND element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the NUMBER OF UNIQUE ELEMENTS IN elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM ELEMENT IN elements MINUS the MINIMUM ELEMENT IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT key mask  \n                END IF  \n            END IF  \n        END FOR  \n        CREATE list dp WITH LENGTH TWO RAISED TO THE POWER OF n FILLED WITH infinity  \n        SET dp AT position zero TO zero  \n        FOR mask FROM zero TO TWO RAISED TO THE POWER OF n MINUS one  \n            IF the REMAINDER OF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask DIVIDED BY subset_size IS NOT EQUAL TO zero THEN  \n                CONTINUE TO the NEXT iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND OF mask AND subset_mask EQUALS subset_mask THEN  \n                    SET candidate_value TO dp AT position mask MINUS subset_mask PLUS subset_incompatibility AT subset_mask  \n                    IF candidate_value IS LESS THAN dp AT position mask THEN  \n                        SET dp AT position mask TO candidate_value  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        SET full_mask TO TWO RAISED TO THE POWER OF n MINUS one  \n        IF dp AT position full_mask IS NOT EQUAL TO infinity THEN  \n            RETURN dp AT position full_mask  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "painting-a-grid-with-three-different-colors", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION colorTheGrid(m PARAMETER n PARAMETER)  \n        SET MOD ← 10^9 + 7  \n        \n        FUNCTION generate_valid_columns(prev_col PARAMETER)  \n            SET palette ← [2, 1, 3]  \n            SET valid_columns ← []  \n            \n            FUNCTION backtrack(col PARAMETER row PARAMETER)  \n                IF (m = row) THEN  \n                    SET valid_columns ← valid_columns + [(col)]  \n                    RETURN  \n                END IF  \n                \n                SET index ← 0  \n                WHILE index < LENGTH(palette) DO  \n                    SET current_color ← palette[index]  \n                    \n                    IF (LENGTH(col) = 0 OR col[-1] ≠ current_color) THEN  \n                        IF (prev_col ≠ null AND prev_col[row] = current_color) THEN  \n                            SET index ← index + 1  \n                            CONTINUE  \n                        END IF  \n                        \n                        SET col ← col + [current_color]  \n                        CALL backtrack(col, row + 1)  \n                        SET col ← col[0 : LENGTH(col) - 1]  \n                    END IF  \n                    SET index ← index + 1  \n                END WHILE  \n            END FUNCTION  \n            \n            CALL backtrack([], 0)  \n            RETURN valid_columns  \n        END FUNCTION  \n        \n        SET all_valid_cols ← generate_valid_columns(null)  \n        SET total_valid_cols ← LENGTH(all_valid_cols)  \n        \n        SET compatible_cols ← DICTIONARY()  \n        SET pos_i ← 0  \n        WHILE pos_i < total_valid_cols DO  \n            SET compatible_cols[pos_i] ← []  \n            SET pos_j ← 0  \n            WHILE pos_j < total_valid_cols DO  \n                SET compatible ← true  \n                SET pos_k ← 0  \n                WHILE pos_k < m DO  \n                    IF all_valid_cols[pos_i][pos_k] = all_valid_cols[pos_j][pos_k] THEN  \n                        SET compatible ← false  \n                        BREAK  \n                    END IF  \n                    SET pos_k ← pos_k + 1  \n                END WHILE  \n                \n                IF compatible THEN  \n                    SET compatible_cols[pos_i] ← compatible_cols[pos_i] + [pos_j]  \n                END IF  \n                SET pos_j ← pos_j + 1  \n            END WHILE  \n            SET pos_i ← pos_i + 1  \n        END WHILE  \n        \n        SET dp ← []  \n        SET idx ← 0  \n        WHILE idx < total_valid_cols DO  \n            SET dp ← dp + [1]  \n            SET idx ← idx + 1  \n        END WHILE  \n        \n        SET iteration ← 1  \n        WHILE iteration < n DO  \n            SET next_dp ← []  \n            SET jdx ← 0  \n            WHILE jdx < total_valid_cols DO  \n                SET next_dp ← next_dp + [0]  \n                SET jdx ← jdx + 1  \n            END WHILE  \n            \n            SET idx ← 0  \n            WHILE idx < total_valid_cols DO  \n                FOR each compatible_index IN compatible_cols[idx] DO  \n                    SET next_dp[compatible_index] ← (next_dp[compatible_index] + dp[idx]) MOD MOD  \n                END FOR  \n                SET idx ← idx + 1  \n            END WHILE  \n            \n            SET dp ← next_dp  \n            SET iteration ← iteration + 1  \n        END WHILE  \n        \n        SET sum_ways ← 0  \n        FOR each val IN dp DO  \n            SET sum_ways ← sum_ways + val  \n        END FOR  \n        SET sum_ways ← sum_ways MOD MOD  \n        \n        RETURN sum_ways  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION colorTheGrid(m PARAMETER n PARAMETER)  \n        SET MOD TO one billion PLUS seven  \n        \n        FUNCTION generate_valid_columns(prev_col PARAMETER)  \n            SET colors TO list containing one two three  \n            SET valid_cols TO empty list  \n            \n            FUNCTION backtrack(col PARAMETER row PARAMETER)  \n                IF row EQUALS m  \n                    APPEND a tuple of col TO valid_cols  \n                    RETURN  \n                END IF  \n                FOR each color IN colors  \n                    IF col IS empty OR element at position the last of col NOT EQUALS color  \n                        IF prev_col IS NOT null AND element at position row of prev_col EQUALS color  \n                            CONTINUE to next iteration of loop  \n                        END IF  \n                        APPEND color TO col  \n                        CALL backtrack WITH col AND row PLUS one  \n                        REMOVE last element FROM col  \n                    END IF  \n                END FOR  \n            END FUNCTION  \n            \n            CALL backtrack WITH empty list AND zero  \n            RETURN valid_cols  \n        END FUNCTION  \n        \n        SET all_valid_cols TO the result of calling generate_valid_columns WITH null  \n        SET num_valid_cols TO the length of all_valid_cols  \n        \n        SET compatible_cols TO a mapping FROM each index i FROM zero TO num_valid_cols MINUS one TO empty list  \n        FOR i FROM zero TO num_valid_cols MINUS one  \n            FOR j FROM zero TO num_valid_cols MINUS one  \n                SET are_compatible TO true  \n                FOR k FROM zero TO m MINUS one  \n                    IF element at position k of element at position i of all_valid_cols EQUALS element at position k of element at position j of all_valid_cols  \n                        SET are_compatible TO false  \n                        BREAK inner loop  \n                    END IF  \n                END FOR  \n                IF are_compatible  \n                    APPEND j TO element at position i of compatible_cols  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET dp TO a list of length num_valid_cols WITH each element SET TO one  \n        \n        FOR each _ FROM one TO n MINUS one  \n            SET next_dp TO a list of length num_valid_cols WITH each element SET TO zero  \n            FOR i FROM zero TO num_valid_cols MINUS one  \n                FOR each j IN element at position i of compatible_cols  \n                    SET element at position j of next_dp TO element at position j of next_dp PLUS element at position i of dp MODULO MOD  \n                END FOR  \n            END FOR  \n            SET dp TO next_dp  \n        END FOR  \n        \n        SET total_ways TO zero  \n        FOR each value IN dp  \n            INCREMENT total_ways BY value  \n        END FOR  \n        SET total_ways TO total_ways MODULO MOD  \n        \n        RETURN total_ways  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-good-people-based-on-statements", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumGood(statements)\n        ASSIGN n AS LENGTH(statements)\n        LET maximumCount BE 0\n        LET mask BE 0\n        WHILE mask < (1 << n)\n            DECLARE truthful AS ARRAY OF n ELEMENTS FILLED WITH FALSE\n            DECLARE deceitful AS ARRAY OF n ELEMENTS FILLED WITH FALSE\n            LET position BE 0\n            REPEAT UNTIL position = n\n                LET bitmask BE (1 << position)\n                IF (mask & bitmask) = bitmask THEN\n                    truthful[position] ← TRUE\n                ELSE\n                    deceitful[position] ← TRUE\n                END IF\n                position ← position + 1\n            END REPEAT\n            LET isConsistent BE TRUE\n            LET idx BE 0\n            WHILE idx < n AND isConsistent\n                IF truthful[idx] = TRUE THEN\n                    LET innerIdx BE 0\n                    REPEAT UNTIL innerIdx = n OR NOT isConsistent\n                        LET statementValue BE statements[idx][innerIdx]\n                        IF (statementValue = 0 AND truthful[innerIdx] = TRUE) OR (statementValue = 1 AND deceitful[innerIdx] = TRUE) THEN\n                            isConsistent ← FALSE\n                        END IF\n                        innerIdx ← innerIdx + 1\n                    END REPEAT\n                END IF\n                idx ← idx + 1\n            END WHILE\n            IF isConsistent THEN\n                LET countTruthful BE 0\n                FOR countIdx FROM 0 TO n - 1\n                    IF truthful[countIdx] = TRUE THEN\n                        countTruthful ← countTruthful + 1\n                    END IF\n                END FOR\n                IF countTruthful > maximumCount THEN\n                    maximumCount ← countTruthful\n                END IF\n            END IF\n            mask ← mask + 1\n        END WHILE\n        RETURN maximumCount\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumGood(statements)  \n        SET n TO the LENGTH OF statements  \n        SET max_good TO zero  \n        FOR i FROM zero TO the NUMBER ONE SHIFTED LEFT BY n MINUS one  \n            SET good TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            SET bad TO a LIST OF n ELEMENTS EACH SET TO FALSE  \n            FOR j FROM zero TO n MINUS one  \n                IF the BITWISE AND of i AND the NUMBER ONE SHIFTED LEFT BY j EQUALS the NUMBER ONE SHIFTED LEFT BY j  \n                    SET the element at position j of good TO TRUE  \n                ELSE  \n                    SET the element at position j of bad TO TRUE  \n                END IF  \n            END FOR  \n            SET valid TO TRUE  \n            FOR j FROM zero TO n MINUS one WHILE valid HOLDS  \n                IF the element at position j of good EQUALS TRUE  \n                    FOR k FROM zero TO n MINUS one  \n                        IF the element at position j of statements AT position k EQUALS zero AND the element at position k of good EQUALS TRUE OR the element at position j of statements AT position k EQUALS one AND the element at position k of bad EQUALS TRUE  \n                            SET valid TO FALSE  \n                            BREAK the inner FOR loop  \n                        END IF  \n                    END FOR  \n                END IF  \n            END FOR  \n            IF valid EQUALS TRUE  \n                SET max_good TO the GREATER OF max_good AND the SUM OF elements in good WHERE each TRUE IS COUNTED AS one AND each FALSE AS zero  \n            END IF  \n        END FOR  \n        RETURN max_good  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-total-beauty-of-the-gardens", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET length_of_flowers TO the LENGTH OF flowers  \n        SET highest_beauty TO 0  \n        DEFINE prefix_accumulation AS A LIST WITH length_of_flowers PLUS one ELEMENTS INITIALIZED TO 0  \n        \n        SET idx TO 0  \n        WHILE idx < length_of_flowers  \n            SET prefix_accumulation[idx + 1] AS prefix_accumulation[idx] + flowers[idx]  \n            SET idx TO idx + 1  \n        END WHILE  \n        \n        SET count_full_gardens TO 0  \n        SET pointer TO length_of_flowers - 1  \n        LOOP  \n            IF pointer < 0 THEN  \n                BREAK  \n            ENDIF  \n            \n            IF flowers[pointer] >= target THEN  \n                SET count_full_gardens AS count_full_gardens + 1  \n                SET pointer AS pointer - 1  \n            ELSE  \n                BREAK  \n            ENDIF  \n        END LOOP  \n        \n        SET flowers_left TO newFlowers  \n        SET incomplete_max_flowers TO 0  \n        \n        SET current_index TO count_full_gardens  \n        WHILE current_index <= length_of_flowers  \n            \n            IF current_index > 0 THEN  \n                SET flowers_left AS flowers_left - (target - flowers[length_of_flowers - current_index])  \n                IF NOT (flowers_left >= 0) THEN  \n                    BREAK  \n                ENDIF  \n            ENDIF  \n            \n            SET low_bound TO 0  \n            SET high_bound TO length_of_flowers - current_index - 1  \n            \n            WHILE low_bound <= high_bound  \n                SET midpoint TO (low_bound + high_bound) DIVIDED BY 2 USING INTEGER DIVISION  \n                \n                SET required_flowers TO (flowers[midpoint] * (midpoint+1)) - (prefix_accumulation[midpoint + 1])  \n                \n                IF required_flowers > flowers_left THEN  \n                    SET high_bound TO midpoint - 1  \n                ELSE  \n                    SET low_bound TO midpoint + 1  \n                ENDIF  \n            END WHILE  \n            \n            IF high_bound >= 0 THEN  \n                SET numerator TO flowers_left - ((flowers[high_bound] * (high_bound + 1)) - prefix_accumulation[high_bound + 1])  \n                SET incomplete_max_flowers AS flowers[high_bound] + (numerator DIVIDED BY (high_bound + 1) USING INTEGER DIVISION)  \n            ELSE  \n                SET incomplete_max_flowers TO 0  \n            ENDIF  \n            \n            SET candidate_beauty TO (current_index * full) + (MIN(incomplete_max_flowers, target - 1) * partial)  \n            IF candidate_beauty > highest_beauty THEN  \n                SET highest_beauty AS candidate_beauty  \n            ENDIF  \n            \n            SET current_index TO current_index + 1  \n        END WHILE  \n        \n        RETURN highest_beauty  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumBeauty(flowers newFlowers target full partial)  \n        CALL flowers SORT IN ASCENDING ORDER  \n        SET n TO the LENGTH OF flowers  \n        SET max_beauty TO zero  \n        SET prefix_sum TO A LIST OF ZEROS WITH LENGTH n PLUS one  \n        FOR i FROM zero TO n MINUS one  \n            SET element at POSITION i PLUS one OF prefix_sum TO element at POSITION i OF prefix_sum PLUS element at POSITION i OF flowers  \n        END FOR  \n        SET complete_gardens TO zero  \n        FOR i FROM n MINUS one DOWN TO zero  \n            IF element at POSITION i OF flowers GREATER THAN OR EQUAL TO target THEN  \n                INCREMENT complete_gardens BY one  \n            ELSE  \n                BREAK  \n            END IF  \n        END FOR  \n        SET remaining_flowers TO newFlowers  \n        SET max_incomplete_flowers TO zero  \n        FOR i FROM complete_gardens TO n  \n            IF i GREATER THAN zero THEN  \n                DECREMENT remaining_flowers BY target MINUS element at POSITION n MINUS i OF flowers  \n                IF remaining_flowers LESS THAN zero THEN  \n                    BREAK  \n                END IF  \n            END IF  \n            SET left TO zero  \n            SET right TO n MINUS i MINUS one  \n            WHILE left LESS THAN OR EQUAL TO right  \n                SET mid TO left PLUS right DIVIDED BY two USING INTEGER DIVISION  \n                SET cost TO element at POSITION mid OF flowers MULTIPLIED BY mid PLUS one MINUS element at POSITION mid PLUS one OF prefix_sum  \n                IF cost GREATER THAN remaining_flowers THEN  \n                    DECREMENT right BY one PLUS mid MINUS right  \n                ELSE  \n                    INCREMENT left BY one PLUS mid MINUS left  \n                END IF  \n            END WHILE  \n            IF right GREATER THAN OR EQUAL TO zero THEN  \n                SET max_incomplete_flowers TO element at POSITION right OF flowers PLUS remaining_flowers MINUS element at POSITION right OF flowers MULTIPLIED BY right PLUS one PLUS NEGATION OF element at POSITION right PLUS one OF prefix_sum DIVIDED BY right PLUS one USING INTEGER DIVISION  \n            ELSE  \n                SET max_incomplete_flowers TO zero  \n            END IF  \n            SET total_beauty TO i MULTIPLIED BY full PLUS THE MINIMUM OF max_incomplete_flowers AND target MINUS one MULTIPLIED BY partial  \n            IF total_beauty GREATER THAN max_beauty THEN  \n                SET max_beauty TO total_beauty  \n            END IF  \n        END FOR  \n        RETURN max_beauty  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "total-appeal-of-a-string", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION appealSum(s)\n        DECLARE lastIndices AS list WITH size 26 INITIALIZED BY -1 REPEATEDLY\n        DECLARE sumOfAppeals AS 0\n        DECLARE currentValue AS 0\n        DECLARE pos AS 0\n        WHILE pos < LENGTH(s)\n            DECLARE character AS s[pos]\n            DECLARE letterIndex AS (ORD(character) - ORD('a'))\n            DECLARE contribution AS (pos - lastIndices[letterIndex])\n            currentValue ← currentValue + contribution\n            sumOfAppeals ← sumOfAppeals + currentValue\n            lastIndices[letterIndex] ← pos\n            pos ← pos + 1\n        END WHILE\n        RETURN sumOfAppeals\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION appealSum(s)  \n        SET last TO a list of length twenty six with each element set to minus one  \n        SET total_appeal TO zero  \n        SET current_appeal TO zero  \n        FOR each position i AND character char IN the enumeration of s  \n            SET index TO the numeric code of character char MINUS the numeric code of character a  \n            INCREMENT current_appeal BY position i MINUS element at position index of last  \n            INCREMENT total_appeal BY current_appeal  \n            SET element at position index of last TO position i  \n        END FOR  \n        RETURN total_appeal  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "shopping-offers", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION shoppingOffers(price, special, needs)\n        SET filtered_special TO empty collection\n        SET idx TO 0\n        WHILE idx < LENGTH(special)\n            SET bundle TO special[idx]\n            SET sum_items TO 0\n            SET total_value TO 0\n            SET pos TO 0\n            WHILE pos < LENGTH(bundle) - 1\n                SET sum_items TO sum_items + bundle[pos]\n                SET total_value TO total_value + bundle[pos] * price[pos]\n                INCREMENT pos BY 1\n            END WHILE\n            IF sum_items > 0 AND bundle[LENGTH(bundle) - 1] < total_value THEN\n                APPEND bundle TO filtered_special\n            END IF\n            INCREMENT idx BY 1\n        END WHILE\n        \n        FUNCTION dfs(current_needs)\n            SET minimal_cost TO 0\n            DECLARE counter AS 0\n            WHILE counter < LENGTH(price)\n                SET minimal_cost TO minimal_cost + price[counter] * current_needs[counter]\n                INCREMENT counter BY 1\n            END WHILE\n            \n            SET offer_index TO 0\n            WHILE offer_index < LENGTH(filtered_special)\n                SET offer_bundle TO filtered_special[offer_index]\n                SET updated_needs TO empty collection\n                FOR position IN 0 TO LENGTH(current_needs) - 1\n                    APPEND current_needs[position] - offer_bundle[position] TO updated_needs\n                END FOR\n                \n                SET eligible TO TRUE\n                FOR demand IN updated_needs\n                    IF demand < 0 THEN\n                        SET eligible TO FALSE\n                        EXIT FOR\n                    END IF\n                END FOR\n                \n                IF eligible THEN\n                    SET cost_if_used TO offer_bundle[LENGTH(offer_bundle) - 1] + dfs(CONVERT_TO_TUPLE(updated_needs))\n                    IF cost_if_used < minimal_cost THEN\n                        SET minimal_cost TO cost_if_used\n                    END IF\n                END IF\n                \n                INCREMENT offer_index BY 1\n            END WHILE\n            \n            RETURN minimal_cost\n        END FUNCTION\n        \n        RETURN dfs(CONVERT_TO_TUPLE(needs))\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION shoppingOffers(price, special, needs)  \n        SET special TO an empty list  \n        FOR each offer IN the original special list  \n            IF the sum of elements at all positions except the last in offer IS GREATER THAN zero AND  \n               the last element of offer IS LESS THAN the sum of the product of corresponding elements of price and offer except the last element  \n                APPEND offer TO special  \n            END IF  \n        END FOR  \n        \n        FUNCTION dfs(needs)  \n            SET min_cost TO zero  \n            FOR each element at position index FROM zero TO the length of price MINUS one  \n                INCREMENT min_cost BY the element at position index of price MULTIPLIED BY the element at position index of needs  \n            END FOR  \n            \n            FOR each offer IN special  \n                SET new_needs TO an empty list  \n                FOR each index FROM zero TO the length of needs MINUS one  \n                    APPEND to new_needs the element at position index of needs MINUS the element at position index of offer  \n                END FOR  \n                \n                SET can_use_offer TO true  \n                FOR each element n IN new_needs  \n                    IF n IS LESS THAN zero  \n                        SET can_use_offer TO false  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n                \n                IF can_use_offer EQUALS true  \n                    SET possible_cost TO the last element of offer PLUS dfs(the tuple version of new_needs)  \n                    IF possible_cost IS LESS THAN min_cost  \n                        SET min_cost TO possible_cost  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dfs(the tuple version of needs)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "friends-of-appropriate-ages", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numFriendRequests(ages)\n        FUNCTION request_will_be_sent(age_x age_y)\n            IF age_y <= (age_x / 2 + 7) THEN\n                RETURN false\n            ELSE IF age_y > age_x THEN\n                RETURN false\n            ELSE IF (age_y > 100) AND (age_x < 100) THEN\n                RETURN false\n            ELSE\n                RETURN true\n            END IF\n        END FUNCTION\n\n        SET tally TO dictionary()\n        SET idx TO 0\n        WHILE idx < LENGTH(ages)\n            IF ages[idx] IN tally THEN\n                tally[ages[idx]] = tally[ages[idx]] + 1\n            ELSE\n                tally[ages[idx]] = 1\n            END IF\n            idx = idx + 1\n        END WHILE\n\n        SET accumulated TO 0\n        SET p_age_x TO 1\n        WHILE p_age_x <= 120\n            SET p_age_y TO 1\n            WHILE p_age_y <= 120\n                IF request_will_be_sent(p_age_x, p_age_y) THEN\n                    IF p_age_x = p_age_y THEN\n                        accumulated = accumulated + (tally.get(p_age_x, 0) * (tally.get(p_age_y, 0) - 1))\n                    ELSE\n                        accumulated = accumulated + (tally.get(p_age_x, 0) * tally.get(p_age_y, 0))\n                    END IF\n                END IF\n                p_age_y = p_age_y + 1\n            END WHILE\n            p_age_x = p_age_x + 1\n        END WHILE\n\n        RETURN accumulated\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION numFriendRequests(ages)  \n        FUNCTION request_will_be_sent(age_x age_y)  \n            RETURN NOT (age_y IS LESS THAN OR EQUAL TO age_x MULTIPLIED BY one half PLUS seven OR age_y IS GREATER THAN age_x OR age_y IS GREATER THAN one hundred AND age_x IS LESS THAN one hundred)  \n        END FUNCTION  \n\n        SET count TO list of zero repeated one hundred and twenty one times  \n        FOR each age IN ages  \n            INCREMENT element at position age of count BY one  \n        END FOR  \n\n        SET total_requests TO zero  \n        FOR age_x FROM one TO one hundred and twenty  \n            FOR age_y FROM one TO one hundred and twenty  \n                IF request_will_be_sent(age_x age_y)  \n                    INCREMENT total_requests BY element at position age_x of count MULTIPLIED BY element at position age_y of count MINUS one IF age_x EQUALS age_y ELSE element at position age_y of count  \n                END IF  \n            END FOR  \n        END FOR  \n\n        RETURN total_requests  \n    END FUNCTION  \nEND CLASS"}
