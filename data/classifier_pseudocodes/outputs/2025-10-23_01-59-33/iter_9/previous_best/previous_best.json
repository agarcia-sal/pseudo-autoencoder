{
  "prompt": "Given the pseudocode provided below, output exactly and only a single character: **`1`** if the pseudocode is *fully functionally reproducible*, meaning it can be consistently and precisely implemented as correct, runnable code that passes **every** relevant unit test across the entire valid input domain; otherwise output **`0`**. No whitespace, no explanations, no additional characters.\n\nTo determine this, analyze **only the pseudocode itself**, applying all of the following rigorous and exhaustive checks:\n\n1. **Explicitness & Completeness**  \n\u2003- Every input, output, variable, constant, and data structure is fully defined or deterministically derivable within the pseudocode.  \n\u2003- All steps, operations, and control flow structures (loops, conditionals, recursion, assignments) unambiguously specify how data is processed.  \n\u2003- The pseudocode contains no missing definitions, undeclared variables, or implied values.\n\n2. **Logical Soundness & Coverage of Input Domain**  \n\u2003- The logic must be correct and consistent for all inputs within the specified domain (or inferred domain if none stated).  \n\u2003- Edge cases and boundary conditions\u2014such as empty inputs, smallest/largest values, minimal and maximal lengths\u2014are either explicitly managed or can be conclusively inferred to be correctly handled.  \n\u2003- No contradictions, infinite loops, unreachable code blocks, or inconsistencies exist.\n\n3. **Independence & Self-Containment**  \n\u2003- The pseudocode requires no external knowledge, hidden states, or auxiliary functions not fully provided or explained within its own text.  \n\u2003- No unstated assumptions, external dependencies, or partial snippets limiting reproducibility.\n\n4. **Deterministic Execution & Unambiguous Semantics**  \n\u2003- Each instruction clearly defines the exact effect and outcome with no ambiguous or vague phrasing.  \n\u2003- Control flow and data transformations lead to a uniquely defined, predictable result.\n\n5. **Guarantee of Passing All Unit Tests**  \n\u2003- Based solely on this pseudocode, any faithful implementation necessarily passes all relevant unit or integration tests for the problem domain, producing correct output or behavior without runtime errors or exceptions.\n\n---\n\n**Important:**  \n- Base your decision solely on the provided pseudocode, ignoring comments, informal notes, formatting, and any external problem statements or examples.  \n- Consider the entirety of the given pseudocode together, not fragments or isolated lines.  \n- If any criterion is not fully met or there is any doubt about reproducibility, output **`0`**.  \n- If, and only if, the pseudocode meets *all* criteria above in full clarity and correctness, output **`1`**.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "response": "Given the pseudocode provided below, output exactly and only a single character: **`1`** if the pseudocode is *fully functionally reproducible*, meaning it can be consistently and precisely implemented as correct, runnable code that passes **every** relevant unit test across the entire valid input domain; otherwise output **`0`**. No whitespace, no explanations, no additional characters.\n\nTo determine this, analyze **only the pseudocode itself**, applying all of the following rigorous and exhaustive checks:\n\n1. **Explicitness & Completeness**  \n\u2003- Every input, output, variable, constant, and data structure is fully defined or deterministically derivable within the pseudocode.  \n\u2003- All steps, operations, and control flow structures (loops, conditionals, recursion, assignments) unambiguously specify how data is processed.  \n\u2003- The pseudocode contains no missing definitions, undeclared variables, or implied values.\n\n2. **Logical Soundness & Coverage of Input Domain**  \n\u2003- The logic must be correct and consistent for all inputs within the specified domain (or inferred domain if none stated).  \n\u2003- Edge cases and boundary conditions\u2014such as empty inputs, smallest/largest values, minimal and maximal lengths\u2014are either explicitly managed or can be conclusively inferred to be correctly handled.  \n\u2003- No contradictions, infinite loops, unreachable code blocks, or inconsistencies exist.\n\n3. **Independence & Self-Containment**  \n\u2003- The pseudocode requires no external knowledge, hidden states, or auxiliary functions not fully provided or explained within its own text.  \n\u2003- No unstated assumptions, external dependencies, or partial snippets limiting reproducibility.\n\n4. **Deterministic Execution & Unambiguous Semantics**  \n\u2003- Each instruction clearly defines the exact effect and outcome with no ambiguous or vague phrasing.  \n\u2003- Control flow and data transformations lead to a uniquely defined, predictable result.\n\n5. **Guarantee of Passing All Unit Tests**  \n\u2003- Based solely on this pseudocode, any faithful implementation necessarily passes all relevant unit or integration tests for the problem domain, producing correct output or behavior without runtime errors or exceptions.\n\n---\n\n**Important:**  \n- Base your decision solely on the provided pseudocode, ignoring comments, informal notes, formatting, and any external problem statements or examples.  \n- Consider the entirety of the given pseudocode together, not fragments or isolated lines.  \n- If any criterion is not fully met or there is any doubt about reproducibility, output **`0`**.  \n- If, and only if, the pseudocode meets *all* criteria above in full clarity and correctness, output **`1`**.\n\n---\n\nPseudocode:  \n```\n{pseudocode here}\n```",
  "score": 0.5966666666666667,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION majorityElement(nums)  \n        SET n1 TO zero  \n        SET n2 TO zero  \n        SET m1 TO zero  \n        SET m2 TO one  \n        FOR each element m IN nums  \n            IF element m EQUALS value m1  \n                INCREMENT n1 BY one  \n            ELSE IF element m EQUALS value m2  \n                INCREMENT n2 BY one  \n            ELSE IF n1 EQUALS zero  \n                SET m1 TO element m  \n                SET n1 TO one  \n            ELSE IF n2 EQUALS zero  \n                SET m2 TO element m  \n                SET n2 TO one  \n            ELSE  \n                DECREMENT n1 BY one  \n                DECREMENT n2 BY one  \n            END IF  \n        END FOR  \n        RETURN list of elements m FROM list containing m1 and m2 WHERE the count of element m IN nums IS GREATER THAN the LENGTH OF nums DIVIDED BY three  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nif num1==\"0\" or num2==\"0\": return \"0\"\nres = [0]*(len(num1)+len(num2))\nn1, n2 = num1[::-1], num2[::-1]\nfor i in range(len(n1)):\n  for j in range(len(n2)):\n    mul = (ord(n1[i])-48)*(ord(n2[j])-48)\n    sum_ = mul + res[i+j]\n    res[i+j], res[i+j+1] = sum_%10, res[i+j+1]+sum_//10\nreturn ''.join(map(str,res[::-1])).lstrip('0')\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n```\ndefine combine(n, k):\n  result = []\n  define backtrack(start, path):\n    if len(path) = k:\n      result.append(copy of path)\n      return\n    for i in range(start to n):\n      path.append(i)\n      backtrack(i+1, path)\n      path.pop()\n  backtrack(1, [])\n  return result\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION evalRPN(tokens_of_strings)\n        SET stack TO an empty list\n        FOR each token IN tokens_of_strings\n            IF token IS IN the collection plus minus multiplied by divided by\n                SET b TO the element removed FROM the end of stack\n                SET a TO the element removed FROM the end of stack\n                IF token EQUALS plus\n                    APPEND a PLUS b TO stack\n                ELSE IF token EQUALS minus\n                    APPEND a MINUS b TO stack\n                ELSE IF token EQUALS multiplied by\n                    APPEND a MULTIPLIED BY b TO stack\n                ELSE IF token EQUALS divided by\n                    APPEND the integer conversion OF a DIVIDED BY b TO stack\n                END IF\n            ELSE\n                APPEND the integer conversion OF token TO stack\n            END IF\n        END FOR\n        RETURN the element at position zero of stack\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION evalRPN(tokens)  \n        SET stack TO an empty list  \n        FOR each token IN tokens  \n            IF token EQUALS one of the symbols plus MINUS MULTIPLY DIVIDE  \n                SET b TO the last element removed from stack  \n                SET a TO the last element removed from stack  \n                IF token EQUALS plus  \n                    APPEND a PLUS b TO stack  \n                ELSE IF token EQUALS minus  \n                    APPEND a MINUS b TO stack  \n                ELSE IF token EQUALS multiply  \n                    APPEND a MULTIPLIED BY b TO stack  \n                ELSE IF token EQUALS divide  \n                    APPEND the integer value of a DIVIDED BY b TO stack  \n                END IF  \n            ELSE  \n                APPEND the integer value of token TO stack  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stack  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.5966666666666667",
  "iter": 9
}