{"task_id": "maximum-size-of-a-set-after-removals", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maximumSetSize(nums1 PARAMETER List OF integers nums2 PARAMETER List OF integers) RETURNS integer\n        FUNCTION getUniqueElements(inputList PARAMETER List OF integers) RETURNS List OF integers\n            SET resultCollection TO empty List OF integers\n            SET indexCounter TO 0\n            FUNCTION findInCollection(val PARAMETER integer) RETURNS boolean\n                SET iterIndex TO 0\n                FUNCTION hasValue() RETURNS boolean\n                    IF iterIndex >= LENGTH OF resultCollection THEN\n                        RETURN false\n                    ELSE \n                        IF resultCollection[iterIndex] = val THEN\n                            RETURN true\n                        ELSE\n                            SET iterIndex TO iterIndex + 1\n                            RETURN hasValue()\n                        END IF\n                    END IF\n                END FUNCTION\n                RETURN hasValue()\n            END FUNCTION\n            FUNCTION loopAdd() RETURNS void\n                IF indexCounter >= LENGTH OF inputList THEN\n                    RETURN\n                ELSE\n                    SET currentElem TO inputList[indexCounter]\n                    IF NOT findInCollection(currentElem) THEN\n                        APPEND currentElem TO resultCollection\n                    END IF\n                    SET indexCounter TO indexCounter + 1\n                    loopAdd()\n                END IF\n            END FUNCTION\n            loopAdd()\n            RETURN resultCollection\n        END FUNCTION\n        \n        FUNCTION intersectLists(listA PARAMETER List OF integers listB PARAMETER List OF integers) RETURNS List OF integers\n            SET intersectResult TO empty List OF integers\n            SET pointerA TO 0\n            FUNCTION hasInB(val PARAMETER integer) RETURNS boolean\n                SET pointerB TO 0\n                FUNCTION checkB() RETURNS boolean\n                    IF pointerB >= LENGTH OF listB THEN\n                        RETURN false\n                    ELSE\n                        IF listB[pointerB] = val THEN\n                            RETURN true\n                        ELSE\n                            SET pointerB TO pointerB + 1\n                            RETURN checkB()\n                        END IF\n                    END IF\n                END FUNCTION\n                RETURN checkB()\n            END FUNCTION\n            FUNCTION loopIntersect() RETURNS void\n                IF pointerA >= LENGTH OF listA THEN\n                    RETURN\n                ELSE\n                    SET currentVal TO listA[pointerA]\n                    IF hasInB(currentVal) THEN\n                        APPEND currentVal TO intersectResult\n                    END IF\n                    SET pointerA TO pointerA + 1\n                    loopIntersect()\n                END IF\n            END FUNCTION\n            loopIntersect()\n            RETURN intersectResult\n        END FUNCTION\n        \n        FUNCTION differenceLists(listMain PARAMETER List OF integers listExclude PARAMETER List OF integers) RETURNS List OF integers\n            SET diffs TO empty List OF integers\n            SET posMain TO 0\n            FUNCTION containsVal(v PARAMETER integer) RETURNS boolean\n                SET posExclude TO 0\n                FUNCTION innerCheck() RETURNS boolean\n                    IF posExclude >= LENGTH OF listExclude THEN\n                        RETURN false\n                    ELSE\n                        IF listExclude[posExclude] = v THEN\n                            RETURN true\n                        ELSE\n                            SET posExclude TO posExclude + 1\n                            RETURN innerCheck()\n                        END IF\n                    END IF\n                END FUNCTION\n                RETURN innerCheck()\n            END FUNCTION\n            FUNCTION diffLoop() RETURNS void\n                IF posMain >= LENGTH OF listMain THEN\n                    RETURN\n                ELSE\n                    SET valNow TO listMain[posMain]\n                    IF NOT containsVal(valNow) THEN\n                        APPEND valNow TO diffs\n                    END IF\n                    SET posMain TO posMain + 1\n                    diffLoop()\n                END IF\n            END FUNCTION\n            diffLoop()\n            RETURN diffs\n        END FUNCTION\n        \n        FUNCTION minInt(a PARAMETER integer b PARAMETER integer) RETURNS integer\n            IF a <= b THEN\n                RETURN a\n            ELSE\n                RETURN b\n            END IF\n        END FUNCTION\n        \n        FUNCTION maxInt(a PARAMETER integer b PARAMETER integer) RETURNS integer\n            IF a >= b THEN\n                RETURN a\n            ELSE\n                RETURN b\n            END IF\n        END FUNCTION\n        \n        SET lengthNums TO 0\n        FUNCTION countNums() RETURNS void\n            IF lengthNums < LENGTH OF nums1 THEN\n                SET lengthNums TO lengthNums + 1\n                countNums()\n            END IF\n        END FUNCTION\n        countNums()\n        \n        SET halfLength TO 0\n        FUNCTION calcHalf() RETURNS void\n            IF halfLength + halfLength < lengthNums THEN\n                SET halfLength TO halfLength + 1\n                calcHalf()\n            END IF\n        END FUNCTION\n        calcHalf()\n        \n        SET uniqueSet1 TO getUniqueElements(nums1)\n        SET uniqueSet2 TO getUniqueElements(nums2)\n        \n        SET commonElements TO intersectLists(uniqueSet1, uniqueSet2)\n        SET uniqueOnly1 TO differenceLists(uniqueSet1, commonElements)\n        SET uniqueOnly2 TO differenceLists(uniqueSet2, commonElements)\n        \n        SET takeUnique1 TO 0\n        IF halfLength < LENGTH OF uniqueOnly1 THEN\n            SET takeUnique1 TO halfLength\n        ELSE\n            SET takeUnique1 TO LENGTH OF uniqueOnly1\n        END IF\n        \n        SET takeUnique2 TO 0\n        IF halfLength < LENGTH OF uniqueOnly2 THEN\n            SET takeUnique2 TO halfLength\n        ELSE\n            SET takeUnique2 TO LENGTH OF uniqueOnly2\n        END IF\n        \n        SET temp1 TO halfLength - takeUnique1\n        SET temp2 TO halfLength - takeUnique2\n        SET temp1a TO 0\n        IF temp1 > 0 THEN\n            SET temp1a TO temp1\n        END IF\n        SET temp2a TO 0\n        IF temp2 > 0 THEN\n            SET temp2a TO temp2\n        END IF\n        \n        SET remainingCommonAllowed TO temp1a + temp2a\n        \n        SET leastCommonTake TO 0\n        IF remainingCommonAllowed < LENGTH OF commonElements THEN\n            SET leastCommonTake TO remainingCommonAllowed\n        ELSE\n            SET leastCommonTake TO LENGTH OF commonElements\n        END IF\n        \n        SET resultTotal TO 0\n        SET resultTotal TO takeUnique1 + takeUnique2 + leastCommonTake\n        \n        RETURN resultTotal\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-beautiful-indices-in-the-given-array-i", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION beautifulIndices(s parameter, a parameter, b parameter, k parameter)\n        FUNCTION matchPositions(strParam parameter, pattern parameter) RETURNS list\n            SET accumPositions TO EMPTY LIST\n            SET lenStr TO LENGTH OF strParam\n            SET lenPat TO LENGTH OF pattern\n            FUNCTION iter(pos parameter)\n                IF NOT (pos <= lenStr - lenPat) THEN\n                    RETURN\n                END IF\n                SET currSubstr TO SUBSTRING OF strParam FROM pos TO (pos + lenPat - 1)\n                IF currSubstr == pattern THEN\n                    APPEND pos TO accumPositions\n                END IF\n                CALL iter(pos + 1)\n            END FUNCTION\n            CALL iter(0)\n            RETURN accumPositions\n        END FUNCTION\n\n        SET collectedA TO matchPositions(s, a)\n        SET collectedB TO matchPositions(s, b)\n        SET resultIndices TO EMPTY LIST\n\n        FUNCTION outerLoop(xList parameter, yList parameter, limit parameter)\n            FUNCTION innerLoop(i parameter, j parameter, appended parameter)\n                IF j >= LENGTH OF yList THEN\n                    RETURN\n                END IF\n                IF ABS(i - yList[j]) <= limit THEN\n                    IF NOT appended THEN\n                        APPEND i TO resultIndices\n                        SET appended TO TRUE\n                    END IF\n                    RETURN\n                END IF\n                CALL innerLoop(i, j + 1, appended)\n            END FUNCTION\n\n            FUNCTION recurseIndices(index parameter)\n                IF index >= LENGTH OF xList THEN\n                    RETURN\n                END IF\n                CALL innerLoop(xList[index], 0, FALSE)\n                CALL recurseIndices(index + 1)\n            END FUNCTION\n\n            CALL recurseIndices(0)\n        END FUNCTION\n\n        CALL outerLoop(collectedA, collectedB, k)\n        RETURN resultIndices\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-number-of-pushes-to-type-word-ii", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION minimumPushes(word)  \n        FUNCTION helperCountFrequency(sequence)  \n            SET acc TO empty map  \n            FUNCTION recur(index)  \n                IF (index) GREATER THAN (length of sequence MINUS 1) THEN RETURN acc END IF  \n                SET ch TO sequence AT index  \n                IF (ch NOT IN acc) OR (NOT acc HAS_KEY ch) THEN SET acc[ch] TO 0 END IF  \n                SET acc[ch] TO acc[ch] PLUS 1  \n                RETURN recur(index PLUS 1)  \n            END FUNCTION  \n            RETURN recur(0)  \n        END FUNCTION  \n\n        FUNCTION helperSortDescending(list_in)  \n            SET temp TO copy of list_in  \n            FUNCTION sortPass(i)  \n                IF i GREATER THAN OR EQUAL TO length of temp MINUS 1 THEN RETURN END IF  \n                FUNCTION innerSort(j)  \n                    IF j LESS THAN (length of temp MINUS i MINUS 1) THEN  \n                        IF temp[j] LESS THAN temp[j PLUS 1] THEN  \n                            SET swap_temp TO temp[j]  \n                            SET temp[j] TO temp[j PLUS 1]  \n                            SET temp[j PLUS 1] TO swap_temp  \n                        END IF  \n                        innerSort(j PLUS 1)  \n                    END IF  \n                END FUNCTION  \n                innerSort(0)  \n                sortPass(i PLUS 1)  \n            END FUNCTION  \n            sortPass(0)  \n            RETURN temp  \n        END FUNCTION  \n\n        SET freq_map TO helperCountFrequency(word)  \n\n        SET freq_values TO empty list  \n        FOR EACH key IN freq_map DO  \n            Append freq_map[key] TO freq_values  \n        END FOR  \n\n        SET sorted_freq TO helperSortDescending(freq_values)  \n\n        SET accumulator TO 0  \n        SET counter_keys TO 0  \n        SET multiplier_presses TO 1  \n\n        FUNCTION processFreq(list_vals, idx, acc_pushes, count_keys, mult_presses)  \n            IF idx GREATER THAN OR EQUAL TO length of list_vals THEN RETURN acc_pushes END IF  \n            SET current_val TO list_vals[idx]  \n            SET new_acc TO acc_pushes PLUS current_val TIMES mult_presses  \n            SET new_count_keys TO count_keys PLUS 1  \n            IF new_count_keys EQUALS 8 THEN  \n                RETURN processFreq(list_vals, idx PLUS 1, new_acc, 0, mult_presses PLUS 1)  \n            ELSE  \n                RETURN processFreq(list_vals, idx PLUS 1, new_acc, new_count_keys, mult_presses)  \n            END IF  \n        END FUNCTION  \n\n        RETURN processFreq(sorted_freq, 0, accumulator, counter_keys, multiplier_presses)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "apply-operations-to-make-string-empty", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION lastNonEmptyString(s)  \n        SET idxCounter TO 0  \n        SET freqMap TO empty map  \n        SET charIter TO 0  \n        WHILE charIter < LENGTH(s)  \n            SET currChar TO s[charIter]  \n            IF currChar IN freqMap THEN  \n                SET freqMap[currChar] TO freqMap[currChar] + (1 * 1)  \n            ELSE  \n                SET freqMap[currChar] TO (2 - 1)  \n            END IF  \n            SET charIter TO charIter + 1  \n        END WHILE  \n\n        SET maxObservedFreq TO (0 * 2)  \n        FOR EACH keyValuePair IN freqMap  \n            SET freqVal TO keyValuePair.value  \n            IF ((maxObservedFreq < freqVal) = true) THEN  \n                SET maxObservedFreq TO freqVal  \n            END IF  \n        END FOR  \n\n        SET candidateChars TO empty set  \n        SET mapIterator TO freqMap.begin()  \n        WHILE mapIterator != freqMap.end()  \n            SET pairChar TO mapIterator.key  \n            SET pairFreq TO mapIterator.value  \n            IF (pairFreq = maxObservedFreq) THEN  \n                INSERT pairChar INTO candidateChars  \n            END IF  \n            ADVANCE mapIterator  \n        END WHILE  \n\n        SET collectedList TO empty list  \n\n        FUNCTION traverseReverse(position)  \n            IF position < 0 THEN  \n                RETURN  \n            ELSE  \n                SET currSymbol TO s[position]  \n                IF currSymbol IN candidateChars THEN  \n                    APPEND currSymbol TO collectedList  \n                    REMOVE currSymbol FROM candidateChars  \n                END IF  \n                CALL traverseReverse(position - 1)  \n            END IF  \n        END FUNCTION  \n\n        CALL traverseReverse(LENGTH(s) - 1)  \n\n        SET outputString TO \"\"  \n        SET outputIndex TO LENGTH(collectedList) - 1  \n        WHILE outputIndex >= 0  \n            SET outputString TO outputString + collectedList[outputIndex]  \n            SET outputIndex TO outputIndex - 1  \n        END WHILE  \n\n        RETURN outputString  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "most-frequent-prime", "label": "true_positive", "pseudocode": "FUNCTION is_prime(n)  \n    IF NOT (n GREATER THAN one)  \n        RETURN false  \n    END IF  \n    IF n GREATER THAN OR EQUAL TO two AND n LESS THAN OR EQUAL TO three  \n        RETURN true  \n    END IF  \n    IF (n MODULO two) EQUALS zero OR (n MODULO three) EQUALS zero  \n        RETURN false  \n    END IF  \n    SET h TO 5  \n    LOOP WHILE (h * h) LESS THAN OR EQUAL TO n  \n        IF (n MODULO h) EQUALS zero OR (n MODULO (h + 2)) EQUALS zero  \n            RETURN false  \n        END IF  \n        SET h TO h + 6  \n    END LOOP  \n    RETURN true  \nEND FUNCTION  \n\nCLASS Solution  \n    FUNCTION mostFrequentPrime(mat)  \n        SET p TO LENGTH OF mat  \n        SET q TO LENGTH OF mat AT INDEX zero  \n        SET moves TO [(-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1), (0,-1), (-1,-1)]  \n        DECLARE prime_count AS empty map from elements to integers  \n        \n        FUNCTION traverse(a, b, dx, dy, val)  \n            SET x_next TO a + dx  \n            SET y_next TO b + dy  \n            IF x_next GREATER THAN OR EQUAL TO zero AND x_next LESS THAN p AND y_next GREATER THAN OR EQUAL TO zero AND y_next LESS THAN q THEN  \n                SET value_new TO val * 10 + mat[x_next][y_next]  \n                IF value_new GREATER THAN 10 AND is_prime(value_new) THEN  \n                    IF value_new IN prime_count THEN  \n                        SET prime_count[value_new] TO prime_count[value_new] + 1  \n                    ELSE  \n                        SET prime_count[value_new] TO 1  \n                    END IF  \n                END IF  \n                CALL traverse(x_next, y_next, dx, dy, value_new)  \n            END IF  \n        END FUNCTION  \n        \n        FOR row FROM 0 TO p - 1  \n            FOR col FROM 0 TO q - 1  \n                FOR EACH (dx, dy) IN moves  \n                    CALL traverse(row, col, dx, dy, mat[row][col])  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        IF prime_count IS empty THEN  \n            RETURN -1  \n        END IF  \n        \n        SET max_pair TO (-1, -1)  \n        SET result TO -1  \n        FOR key IN prime_count KEYS  \n            SET candidate TO (prime_count[key], key)  \n            IF candidate GREATER THAN max_pair THEN  \n                SET max_pair TO candidate  \n                SET result TO key  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximize-happiness-of-selected-children", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION maximumHappinessSum(happiness, k)\n        PROCEDURE quicksortDescending(arr, left, right)\n            IF left < right THEN\n                DECLARE pivotIndex AS INTEGER\n                CALL partition(arr, left, right, pivotIndex)\n                CALL quicksortDescending(arr, left, pivotIndex - (1 + 0))\n                CALL quicksortDescending(arr, pivotIndex + 1, right)\n            END IF\n        END PROCEDURE\n\n        PROCEDURE partition(arr, left, right, OUT pivotPos)\n            DECLARE pivotVal AS INTEGER = arr[right]\n            DECLARE fillPos AS INTEGER = left - (0 - 0)\n            DECLARE iterator AS INTEGER = left\n            WHILE iterator <= right - 1 DO\n                IF arr[iterator] >= pivotVal THEN\n                    SET fillPos TO fillPos + 1\n                    CALL swap(arr, fillPos, iterator)\n                END IF\n                SET iterator TO iterator + 1\n            END WHILE\n            CALL swap(arr, fillPos + 1, right)\n            SET pivotPos TO fillPos + 1\n        END PROCEDURE\n\n        PROCEDURE swap(arr, posA, posB)\n            DECLARE tmpVal AS INTEGER = arr[posA]\n            SET arr[posA] TO arr[posB]\n            SET arr[posB] TO tmpVal\n        END PROCEDURE\n\n        CALL quicksortDescending(happiness, 0, LENGTH(happiness) - 1)\n\n        DECLARE accumulatedScore AS INTEGER = 0\n        DECLARE decrementCounter AS INTEGER = 0\n\n        DECLARE indexPointer AS INTEGER = 0\n        LABELLoopStart:\n            IF indexPointer > k - 1 THEN GOTO LABELLoopEnd\n            DECLARE tempNumber AS INTEGER = happiness[indexPointer] - decrementCounter\n            IF NOT (tempNumber >= 0) THEN\n                SET tempNumber TO 0\n            END IF\n            SET accumulatedScore TO accumulatedScore + tempNumber\n            SET decrementCounter TO decrementCounter + 1\n            SET indexPointer TO indexPointer + 1\n            GOTO LABELLoopStart\n        LABELLoopEnd:\n\n        RETURN accumulatedScore\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "shortest-subarray-with-or-at-least-k-ii", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION minimumSubarrayLength(nums LIST OF integers k integer) RETURNS integer\n        FUNCTION update_count(count LIST OF integers num integer add integer)\n            SET bit_mask TO integer 1\n            SET idx TO integer 0\n            WHILE idx LESS THAN integer 32\n                IF (num BITWISE_AND bit_mask) NOT_EQUALS integer 0 THEN\n                    SET temp_val TO count at idx\n                    SET count at idx TO temp_val PLUS add\n                END IF\n                SET bit_mask TO bit_mask MULTIPLY integer 2\n                SET idx TO idx PLUS integer 1\n            END WHILE\n        END FUNCTION\n\n        FUNCTION compute_current_or(count LIST OF integers) RETURNS integer\n            SET res TO integer 0\n            SET pos TO integer 0\n            WHILE pos LESS_THAN integer 32\n                IF count at pos GREATER_THAN integer 0 THEN\n                    SET res TO res BITWISE_OR (integer 1 LEFT_SHIFT pos)\n                END IF\n                SET pos TO pos PLUS integer 1\n            END WHILE\n            RETURN res\n        END FUNCTION\n\n        SET size TO LENGTH_OF nums\n        SET tally TO LIST OF integer 32 ELEMENTS EACH integer 0\n        SET overall_or TO integer 0\n        SET start_idx TO integer 0\n        SET best_len TO positive_infinity\n\n        SET curr_idx TO integer 0\n        WHILE curr_idx LESS_THAN size\n            CALL update_count WITH tally nums at curr_idx integer 1\n            SET overall_or TO overall_or BITWISE_OR nums at curr_idx\n\n            WHILE overall_or GREATER_THAN_OR_EQUAL k AND start_idx LESS_OR_EQUAL curr_idx\n                IF best_len GREATER_THAN (curr_idx MINUS start_idx PLUS integer 1) THEN\n                    SET best_len TO (curr_idx MINUS start_idx PLUS integer 1)\n                END IF\n                CALL update_count WITH tally nums at start_idx MINUS integer 1\n                SET overall_or TO CALL compute_current_or WITH tally\n                SET start_idx TO start_idx PLUS integer 1\n            END WHILE\n\n            SET curr_idx TO curr_idx PLUS integer 1\n        END WHILE\n\n        IF best_len EQUALS positive_infinity THEN\n            RETURN integer -1\n        ELSE\n            RETURN best_len\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "count-alternating-subarrays", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION countAlternatingSubarrays(nums)\n        SET totalElements TO LENGTH OF nums\n        IF totalElements EQUALS 0 THEN\n            SET result TO 0\n        ELSE\n            SET result TO totalElements\n            SET sequenceLength TO 1\n\n            FUNCTION recur(j)\n                IF j GREATER THAN OR EQUAL TO totalElements THEN\n                    RETURN\n                END IF\n                IF NOT (nums[j] EQUALS nums[j - 1]) THEN\n                    SET sequenceLength TO sequenceLength + 1\n                ELSE\n                    SET sequenceLength TO 1\n                END IF\n                SET result TO result + (sequenceLength - 1)\n                CALL recur(j + 1)\n            END FUNCTION\n\n            CALL recur(1)\n        END IF\n        RETURN result\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-cost-walk-in-weighted-graph", "label": "true_positive", "pseudocode": "```  \nCLASS UnionFind  \n    FUNCTION __init__(self, n)  \n        PROCEDURE buildList(x, y, z, acc)  \n            IF y GREATER THAN z THEN  \n                RETURN acc  \n            ELSE  \n                RETURN buildList(x, y + 1, z, acc + [y])  \n            END IF  \n        END PROCEDURE  \n  \n        SET tempA TO buildList(0, 0, n - 1, [])  \n        SET tempB TO []  \n        PROCEDURE fillOnes(count, arr)  \n            IF count EQUALS 0 THEN  \n                RETURN arr  \n            ELSE  \n                RETURN fillOnes(count - 1, arr + [1])  \n            END IF  \n        END PROCEDURE  \n  \n        SET tempB TO fillOnes(n, [])  \n        SET self.parent TO tempA  \n        SET self.rank TO tempB  \n    END FUNCTION  \n  \n    FUNCTION find(self, u)  \n        FUNCTION internalFind(x)  \n            IF self.parent[x] EQUALS x THEN  \n                RETURN x  \n            ELSE  \n                SET r TO internalFind(self.parent[x])  \n                SET self.parent[x] TO r  \n                RETURN r  \n            END IF  \n        END FUNCTION  \n  \n        RETURN internalFind(u)  \n    END FUNCTION  \n  \n    FUNCTION union(self, u, v)  \n        SET aVal TO self.find(u)  \n        SET bVal TO self.find(v)  \n        IF (aVal NOT EQUALS bVal) THEN  \n            IF (self.rank[aVal] GREATER THAN self.rank[bVal]) THEN  \n                SET self.parent[bVal] TO aVal  \n            ELSE   \n                IF (self.rank[aVal] LESS THAN self.rank[bVal]) THEN  \n                    SET self.parent[aVal] TO bVal  \n                ELSE  \n                    SET self.parent[bVal] TO aVal  \n                    SET tempC TO self.rank[aVal] + (1 * 1)  \n                    SET self.rank[aVal] TO tempC  \n                END IF  \n            END IF  \n        END IF  \n    END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n    FUNCTION minimumCost(self, n, edges, query)  \n        SET ufVar TO UnionFind(n)  \n  \n        SET maxInt TO (2 SHIFT_LEFT_BY 32) - 1  \n        PROCEDURE initList(size, val, acc)  \n            IF size EQUALS 0 THEN  \n                RETURN acc  \n            ELSE  \n                RETURN initList(size - 1, val, acc + [val])  \n            END IF  \n        END PROCEDURE  \n  \n        SET compAnd TO initList(n, maxInt, [])  \n  \n        PROCEDURE processEdges(idx, arr)  \n            IF idx GREATER_OR_EQUALS LENGTH(arr) THEN  \n                RETURN  \n            ELSE  \n                SET triple TO arr[idx]  \n                SET first TO triple[0]  \n                SET second TO triple[1]  \n                SET weight TO triple[2]  \n  \n                CALL ufVar.union(first, second)  \n  \n                SET rootIdx TO ufVar.find(first)  \n  \n                SET newVal TO compAnd[rootIdx] BITWISE_AND weight  \n  \n                SET compAnd[rootIdx] TO newVal  \n  \n                CALL processEdges(idx + 1, arr)  \n            END IF  \n        END PROCEDURE  \n  \n        CALL processEdges(0, edges)  \n  \n        SET compCost TO {}  \n  \n        PROCEDURE buildCostMap(i)  \n            IF i GREATER_OR_EQUALS n THEN  \n                RETURN  \n            ELSE  \n                SET r TO ufVar.find(i)  \n                IF r NOT_IN compCost THEN  \n                    SET compCost[r] TO compAnd[r]  \n                END IF  \n                CALL buildCostMap(i + 1)  \n            END IF  \n        END PROCEDURE  \n  \n        CALL buildCostMap(0)  \n  \n        SET resList TO []  \n  \n        PROCEDURE processQueries(j)  \n            IF j GREATER_OR_EQUALS LENGTH(query) THEN  \n                RETURN  \n            ELSE  \n                SET qPair TO query[j]  \n                SET leftVal TO qPair[0]  \n                SET rightVal TO qPair[1]  \n  \n                IF leftVal EQUALS rightVal THEN  \n                    SET resList TO resList + [0]  \n                ELSE  \n                    SET rootLeft TO ufVar.find(leftVal)  \n                    SET rootRight TO ufVar.find(rightVal)  \n  \n                    IF rootLeft EQUALS rootRight THEN  \n                        SET resList TO resList + [compCost[rootLeft]]  \n                    ELSE  \n                        SET resList TO resList + [-1]  \n                    END IF  \n                END IF  \n                CALL processQueries(j + 1)  \n            END IF  \n        END PROCEDURE  \n  \n        CALL processQueries(0)  \n  \n        RETURN resList  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "count-the-number-of-special-characters-ii", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION numberOfSpecialChars(word)  \n        DECLARE resultVar AS INTEGER INITIALIZED TO 0  \n        DECLARE mapOne AS A MAPPING FROM CHAR TO INTEGER INITIALIZED TO an empty mapping  \n        DECLARE mapTwo AS A MAPPING FROM CHAR TO INTEGER INITIALIZED TO an empty mapping  \n        \n        FUNCTION recurseIndices(pos, seq)  \n            IF pos >= LENGTH(seq) THEN  \n                RETURN  \n            ELSE  \n                DECLARE currentChar AS CHAR ASSIGNED TO seq[pos]  \n                DECLARE keyExistsInMapOne AS BOOLEAN ASSIGNED TO FALSE  \n                FOR EACH k IN KEYS(mapOne) DO  \n                    IF k == currentChar THEN  \n                        keyExistsInMapOne = TRUE  \n                    END IF  \n                END FOR  \n                IF NOT keyExistsInMapOne THEN  \n                    mapOne[currentChar] = pos  \n                END IF  \n                mapTwo[currentChar] = pos  \n                recurseIndices(pos + 1, seq)  \n            END IF  \n        END FUNCTION  \n        \n        CALL recurseIndices(0, word)  \n        \n        DECLARE charsetLeft AS SEQUENCE OF CHAR INITIALIZED TO [CHARACTER('a') + i for i = 0 TO 25]  \n        DECLARE charsetRight AS SEQUENCE OF CHAR INITIALIZED TO [CHARACTER('A') + j for j = 0 TO 25]  \n        \n        FUNCTION loopCount(index)  \n            IF index >= LENGTH(charsetLeft) THEN  \n                RETURN  \n            ELSE  \n                DECLARE lowerChar AS CHAR ASSIGNED TO charsetLeft[index]  \n                DECLARE upperChar AS CHAR ASSIGNED TO charsetRight[index]  \n                DECLARE hasLowerInMapTwo AS BOOLEAN ASSIGNED TO FALSE  \n                DECLARE hasUpperInMapOne AS BOOLEAN ASSIGNED TO FALSE  \n                \n                FOR EACH k IN KEYS(mapTwo) DO  \n                    IF k == lowerChar THEN  \n                        hasLowerInMapTwo = TRUE  \n                    END IF  \n                END FOR  \n                FOR EACH k IN KEYS(mapOne) DO  \n                    IF k == upperChar THEN  \n                        hasUpperInMapOne = TRUE  \n                    END IF  \n                END FOR  \n                \n                IF hasLowerInMapTwo AND hasUpperInMapOne THEN  \n                    IF mapTwo[lowerChar] < mapOne[upperChar] THEN  \n                        resultVar = resultVar + 1  \n                    END IF  \n                END IF  \n                \n                loopCount(index + 1)  \n            END IF  \n        END FUNCTION  \n        \n        CALL loopCount(0)  \n        \n        RETURN resultVar  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "equalize-strings-by-adding-or-removing-characters-at-ends", "label": "true_positive", "pseudocode": "```  \nCLASS Solution  \n    FUNCTION minOperations(initial parameter TO string, target parameter TO string) RETURNS integer  \n        SET u3f4 TO (LENGTH OF initial)  \n        SET z9w8 TO (LENGTH OF target)  \n        SET T2v7 TO a two dimensional list with dimensions (u3f4 + 1) by (z9w8 + 1) filled with zeros  \n        SET Xq_a TO 0  \n        FUNCTION recurse_i(kL0) RETURNS VOID  \n            IF NOT (kL0 <= u3f4) THEN  \n                RETURN  \n            END IF  \n            FUNCTION recurse_j(jWd2) RETURNS VOID  \n                IF jWd2 > z9w8 THEN  \n                    RETURN  \n                END IF  \n                IF (initial[(kL0 - 1)]) == (target[(jWd2 - 1)]) THEN  \n                    SET T2v7[kL0][jWd2] TO (T2v7[(kL0 - 1)][(jWd2 - 1)] + (1 * 1))  \n                    IF Xq_a < T2v7[kL0][jWd2] THEN  \n                        SET Xq_a TO T2v7[kL0][jWd2]  \n                    END IF  \n                END IF  \n                recurse_j(jWd2 + 1)  \n            END FUNCTION  \n            recurse_j(1)  \n            recurse_i(kL0 + 1)  \n        END FUNCTION  \n        recurse_i(1)  \n        RETURN (u3f4 + z9w8) - (2 * Xq_a)  \n    END FUNCTION  \nEND CLASS  \n```", "score": 1.0}
{"task_id": "maximum-number-of-upgradable-servers", "label": "true_positive", "pseudocode": "CLASS Solution\n    FUNCTION maxUpgrades(count LIST OF INTEGER upgrade LIST OF INTEGER sell LIST OF INTEGER money LIST OF INTEGER) RETURNS LIST OF INTEGER\n      SET result TO an empty list\n      SET pos TO 0\n      WHILE pos LESS THAN LENGTH OF count\n        SET curCount TO count[pos]\n        SET costUpgrade TO upgrade[pos]\n        SET priceSell TO sell[pos]\n        SET cashStart TO money[pos]\n        SET topUpgrade TO 0\n        SET i TO 0\n        REPEAT\n          SET serversLeft TO curCount MINUS i\n          SET incomeSell TO i MULTIPLIED BY priceSell\n          SET totalCash TO cashStart PLUS incomeSell\n          SET possible TO totalCash DIVIDED BY costUpgrade\n          IF possible GREATER THAN serversLeft THEN\n            SET possible TO serversLeft\n          END IF\n          IF possible GREATER THAN topUpgrade THEN\n            SET topUpgrade TO possible\n          END IF\n          SET i TO i PLUS 1\n        UNTIL i GREATER THAN curCount\n        APPEND topUpgrade TO result\n        SET pos TO pos PLUS 1\n      END WHILE\n      RETURN result\n    END FUNCTION\nEND CLASS", "score": 1.0}
{"task_id": "find-occurrences-of-an-element-in-an-array", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION occurrencesOfElement(nums, queries, x)\n        FUNCTION locatePositions(collection, target, posList, idx)\n            IF idx GREATER THAN OR EQUAL TO (0 + (0 + LENGTH OF collection)) THEN\n                RETURN posList\n            ELSE\n                IF NOT (collection[idx] NOT EQUAL TO target) THEN\n                    SET tempPos TO posList + [idx]\n                ELSE\n                    SET tempPos TO posList\n                END IF\n                RETURN locatePositions(collection, target, tempPos, idx + 1)\n            END IF\n        END FUNCTION\n\n        FUNCTION resolveQueries(queriesList, posList, outList, qIdx)\n            IF qIdx GREATER THAN OR EQUAL TO (LENGTH OF queriesList + 0) THEN\n                RETURN outList\n            ELSE\n                SET currentQuery TO queriesList[qIdx]\n                IF (currentQuery - 1) LESS THAN LENGTH OF posList AND currentQuery GREATER THAN 0 THEN\n                    SET elementAtPos TO posList[(currentQuery + (-1))]\n                    SET updatedOutList TO outList + [elementAtPos]\n                ELSE\n                    SET updatedOutList TO outList + [-1]\n                END IF\n                RETURN resolveQueries(queriesList, posList, updatedOutList, qIdx + 1)\n            END IF\n        END FUNCTION\n\n        SET foundPositions TO locatePositions(nums, x, [], 0)\n        SET responses TO resolveQueries(queries, foundPositions, [], 0)\n        RETURN responses\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-first-player-to-win-k-games-in-a-row", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION findWinningPlayer(skills, k)\n        SET size TO LENGTH OF skills\n        DEFINE FUNCTION dequeueFirst(L)\n            SET firstElem TO L[0]\n            REMOVE ELEMENT AT INDEX 0 FROM L\n            RETURN firstElem\n        END FUNCTION\n        SET idxQueue TO EMPTY LIST\n        SET iterIndex TO 0\n        WHILE iterIndex LESS THAN size\n            APPEND iterIndex TO idxQueue\n            SET iterIndex TO iterIndex PLUS 1\n        END WHILE\n        SET countWins TO 0\n        SET champ TO dequeueFirst(idxQueue)\n        FUNCTION conditionCheck(winsVal, qList)\n            IF winsVal GREATER OR EQUAL TO k OR LENGTH OF qList EQUALS 0\n                RETURN true\n            ELSE\n                RETURN false\n            END IF\n        END FUNCTION\n        WHILE NOT conditionCheck(countWins, idxQueue)\n            SET challenger TO dequeueFirst(idxQueue)\n            IF (skills[champ] MINUS skills[challenger]) GREATER THAN 0\n                SET countWins TO countWins PLUS 1\n                APPEND challenger TO idxQueue\n            ELSE\n                SET countWins TO 1\n                APPEND champ TO idxQueue\n                SET champ TO challenger\n            END IF\n        END WHILE\n        RETURN champ\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "minimum-cost-for-cutting-cake-ii", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minimumCost(m n horizontalCut verticalCut)\n        FUNCTION sortDescending(arr) \n            FUNCTION recurseSort(startIndex endIndex)\n                IF startIndex GREATER OR EQUAL endIndex RETURN\n                SET pivotIndex TO startIndex\n                SET leftCursor TO startIndex PLUS one\n                SET rightCursor TO endIndex\n                WHILE leftCursor LESS OR EQUAL rightCursor\n                    IF arr[leftCursor] GREATER OR EQUAL arr[pivotIndex]\n                        SET leftCursor TO leftCursor PLUS one\n                    ELSE IF arr[rightCursor] LESS arr[pivotIndex]\n                        SET rightCursor TO rightCursor MINUS one\n                    ELSE\n                        SET tempVal TO arr[leftCursor]\n                        SET arr[leftCursor] TO arr[rightCursor]\n                        SET arr[rightCursor] TO tempVal\n                        SET leftCursor TO leftCursor PLUS one\n                        SET rightCursor TO rightCursor MINUS one\n                    END IF\n                END WHILE\n                SET tempPivot TO arr[pivotIndex]\n                SET arr[pivotIndex] TO arr[rightCursor]\n                SET arr[rightCursor] TO tempPivot\n                CALL recurseSort(startIndex rightCursor MINUS one)\n                CALL recurseSort(rightCursor PLUS one endIndex)\n            END FUNCTION\n            CALL recurseSort(0 LENGTH OF arr MINUS one)\n        END FUNCTION\n\n        CALL sortDescending(horizontalCut)\n        CALL sortDescending(verticalCut)\n\n        SET accumulator TO 0\n        SET idxA TO 0\n        SET idxB TO 0\n        SET countH TO 1\n        SET countV TO 1\n\n        FUNCTION loopProcess(indexA indexB acc countHorizontal countVertical)\n            IF (indexA GREATER OR EQUAL LENGTH OF horizontalCut) AND (indexB GREATER OR EQUAL LENGTH OF verticalCut)\n                RETURN acc\n            ELSE\n                IF (indexB GREATER OR EQUAL LENGTH OF verticalCut) OR ((indexA LESS LENGTH OF horizontalCut) AND (horizontalCut[indexA] GREATER verticalCut[indexB]))\n                    SET partialSum TO acc PLUS (horizontalCut[indexA] MULTIPLIED BY countVertical)\n                    RETURN loopProcess(indexA PLUS one indexB partialSum countHorizontal PLUS one countVertical)\n                ELSE\n                    SET partialSum TO acc PLUS (verticalCut[indexB] MULTIPLIED BY countHorizontal)\n                    RETURN loopProcess(indexA indexB PLUS one partialSum countHorizontal countVertical PLUS one)\n                END IF\n            END IF\n        END FUNCTION\n\n        RETURN loopProcess(idxA idxB accumulator countH countV)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "find-the-occurrence-of-first-almost-equal-substring", "label": "true_positive", "pseudocode": "```pseudocode\nCLASS Solution\n    FUNCTION minStartingIndex WITH PARAMETERS s pattern\n        FUNCTION is_almost_equal WITH PARAMETERS substring pattern\n            SET count_difference TO 0\n            FUNCTION check_difference WITH PARAMETERS pos max_pos\n                IF pos GREATER OR EQUAL TO max_pos THEN\n                    RETURN True\n                ELSE\n                    SET char1 TO substring[pos]\n                    SET char2 TO pattern[pos]\n                    IF NOT (char1 EQUALS char2) THEN\n                        SET count_difference TO count_difference + 1\n                        IF count_difference GREATER THAN 1 THEN\n                            RETURN False\n                        END IF\n                    END IF\n                    RETURN check_difference(pos + 1, max_pos)\n                END IF\n            END FUNCTION\n            RETURN check_difference(0, (LENGTH OF substring))\n        END FUNCTION\n\n        SET len_p TO LENGTH OF pattern\n        FUNCTION find_index WITH PARAMETERS idx max_idx\n            IF idx GREATER OR EQUAL TO max_idx THEN\n                RETURN -1\n            ELSE\n                SET sub_s TO EMPTY LIST\n                FUNCTION gather_substring WITH PARAMETERS pos end_pos accumulator\n                    IF pos GREATER OR EQUAL TO end_pos THEN\n                        RETURN accumulator\n                    ELSE\n                        RETURN gather_substring(pos + 1, end_pos, accumulator + [s[pos]])\n                    END IF\n                END FUNCTION\n                SET sub_s TO gather_substring(idx, idx + len_p, [])\n\n                IF is_almost_equal(sub_s, pattern) THEN\n                    RETURN idx\n                ELSE\n                    RETURN find_index(idx + 1, max_idx)\n                END IF\n            END IF\n        END FUNCTION\n        RETURN find_index(0, (LENGTH OF s) - len_p + 1)\n    END FUNCTION\nEND CLASS\n```", "score": 1.0}
{"task_id": "smallest-substring-with-identical-characters-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minLength(s parameter representing a string, numOps parameter representing an integer) RETURNS integer  \n        FUNCTION check(m parameter representing an integer) RETURNS boolean  \n            SET operationsUsed TO 0  \n            SET currentSeqLength TO 0  \n            FOR i FROM 0 TO LENGTH OF s MINUS 1  \n                INCREMENT currentSeqLength BY 1  \n                IF i IS LAST INDEX OR s[i] IS NOT EQUAL TO s[i + 1]  \n                    SET operationsUsed TO operationsUsed + INTEGER_DIVISION(currentSeqLength, m + 1)  \n                    IF operationsUsed > numOps  \n                        RETURN false  \n                    END IF  \n                    SET currentSeqLength TO 0  \n                END IF  \n            END FOR  \n            RETURN operationsUsed <= numOps  \n        END FUNCTION  \n\n        SET n TO LENGTH OF s  \n        SET low TO 1  \n        SET high TO n  \n        WHILE low < high  \n            SET middle TO FLOOR((low + high) / 2)  \n            IF check(middle) == true  \n                SET high TO middle  \n            ELSE  \n                SET low TO middle + 1  \n            END IF  \n        END WHILE  \n        RETURN low  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
