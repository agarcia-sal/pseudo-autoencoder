{"task_id": "longest-palindromic-substring", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestPalindrome(s)\n        SET length AS THE COUNT OF s\n        SET truth_matrix AS AN ARRAY (length) OF ARRAYS (length) FILLED WITH TRUE\n        SET start_index AS 0\n        SET max_length AS 1\n        \n        SET outer_index AS length MINUS 2\n        WHILE outer_index IS GREATER THAN OR EQUAL TO 0 DO\n            SET inner_index AS outer_index PLUS 1\n            WHILE inner_index IS LESS THAN length DO\n                SET truth_matrix[outer_index][inner_index] AS FALSE\n                \n                IF NOT (s[outer_index] NOT EQUAL TO s[inner_index]) THEN\n                    SET truth_matrix[outer_index][inner_index] AS truth_matrix[outer_index PLUS 1][inner_index MINUS 1]\n                    \n                    IF truth_matrix[outer_index][inner_index] IS TRUE THEN\n                        IF (max_length LESS THAN (inner_index MINUS outer_index PLUS 1)) THEN\n                            SET start_index AS outer_index\n                            SET max_length AS (inner_index MINUS outer_index PLUS 1)\n                        END IF\n                    END IF\n                END IF\n                INCREMENT inner_index BY 1\n            END WHILE\n            DECREMENT outer_index BY 1\n        END WHILE\n        \n        RETURN s SUBSTRING FROM start_index TO (start_index PLUS max_length MINUS 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-to-integer-atoi", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position ← position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity ← 0 - 1  \n                    position ← position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity ← 1  \n                    position ← position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber ← (accumulatedNumber * 10) + numericValue  \n            position ← position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "wildcard-matching", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        DECLARE table AS two-dimensional array FILLED WITH False, SIZE (length(s) + 1) BY (length(p) + 1)  \n        ASSIGN table[0][0] ← True  \n\n        SET indexP TO 1  \n        WHILE indexP ≤ length(p)  \n            IF p[indexP - 1] = '*' THEN  \n                ASSIGN table[0][indexP] ← table[0][indexP - 1]  \n            END IF  \n            INCREMENT indexP BY 1  \n        END WHILE  \n\n        SET indexS TO 1  \n        WHILE indexS ≤ length(s)  \n            SET indexPTmp TO 1  \n            WHILE indexPTmp ≤ length(p)  \n                IF p[indexPTmp - 1] = '*' THEN  \n                    ASSIGN table[indexS][indexPTmp] ← (table[indexS - 1][indexPTmp] OR table[indexS][indexPTmp - 1])  \n                ELSE  \n                    IF (p[indexPTmp - 1] = '?' OR s[indexS - 1] = p[indexPTmp - 1]) THEN  \n                        ASSIGN table[indexS][indexPTmp] ← table[indexS - 1][indexPTmp - 1]  \n                    END IF  \n                END IF  \n                SET indexPTmp ← indexPTmp + 1  \n            END WHILE  \n            SET indexS ← indexS + 1  \n        END WHILE  \n\n        RETURN table[length(s)][length(p)]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "evaluate-reverse-polish-notation", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION evalRPN(tokens)\n        INITIALIZE ledger WITH empty collection\n        INITIALIZE index TO 0\n        WHILE index LESS THAN LENGTH OF tokens\n            LET current_token BE tokens[index]\n            INCREMENT index BY 1\n            SWITCH current_token\n                CASE plus, minus, multiply, divide:\n                    LET right_operand BE ledger.REMOVE_LAST_ELEMENT()\n                    LET left_operand BE ledger.REMOVE_LAST_ELEMENT()\n                    IF current_token EQUALS plus THEN\n                        SET operation_result TO left_operand PLUS right_operand\n                    ELSE IF current_token EQUALS minus THEN\n                        SET operation_result TO left_operand MINUS right_operand\n                    ELSE IF current_token EQUALS multiply THEN\n                        SET operation_result TO left_operand MULTIPLIED BY right_operand\n                    ELSE /* current_token EQUALS divide */\n                        SET intermediate_result TO left_operand DIVIDED BY right_operand\n                        SET operation_result TO INTEGER_VALUE_OF(intermediate_result)\n                    END IF\n                    ledger.ADD_ELEMENT(operation_result)\n                DEFAULT:\n                    LET numeric_value BE INTEGER_VALUE_OF(current_token)\n                    ledger.ADD_ELEMENT(numeric_value)\n            END SWITCH\n        END WHILE\n        RETURN ledger[0]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION evalRPN(tokens)  \n        SET stack TO an empty list  \n        FOR each token IN tokens  \n            IF token EQUALS one of the symbols plus MINUS MULTIPLY DIVIDE  \n                SET b TO the last element removed from stack  \n                SET a TO the last element removed from stack  \n                IF token EQUALS plus  \n                    APPEND a PLUS b TO stack  \n                ELSE IF token EQUALS minus  \n                    APPEND a MINUS b TO stack  \n                ELSE IF token EQUALS multiply  \n                    APPEND a MULTIPLIED BY b TO stack  \n                ELSE IF token EQUALS divide  \n                    APPEND the integer value of a DIVIDED BY b TO stack  \n                END IF  \n            ELSE  \n                APPEND the integer value of token TO stack  \n            END IF  \n        END FOR  \n        RETURN the element at position zero of stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "flip-game-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canWin(currentState)\n        DECLARE cache AS an empty map\n\n        FUNCTION can_win_helper(state)\n            IF NOT (state NOT IN cache) THEN\n                RETURN cache[state]\n            END IF\n\n            DECLARE iterator AS 0\n            WHILE iterator <= LENGTH(state) - 2 DO\n                IF (state[iterator] = '+') AND (state[iterator + 1] = '+') THEN\n                    DECLARE before_segment AS SUBSTRING(state, 0, iterator)\n                    DECLARE after_segment AS SUBSTRING(state, iterator + 2, LENGTH(state))\n                    DECLARE candidate_state AS CONCATENATE(before_segment, '--', after_segment)\n\n                    IF FALSE = can_win_helper(candidate_state) THEN\n                        ASSIGN TRUE TO cache[state]\n                        RETURN TRUE\n                    END IF\n                END IF\n                ASSIGN iterator + 1 TO iterator\n            END WHILE\n\n            ASSIGN FALSE TO cache[state]\n            RETURN FALSE\n        END FUNCTION\n\n        RETURN can_win_helper(currentState)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "bulls-and-cows", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION getHint(secret PARAMETER, guess PARAMETER)  \n        IMPORT a data structure offering a dictionary with zero as the default for any missing key  \n        \n        SET alpha TO 0  \n        SET beta TO 0  \n        \n        CREATE secret_map AS a dictionary defaulting to zero  \n        CREATE guess_map AS a dictionary defaulting to zero  \n        \n        SET counter TO 0  \n        WHILE counter LESS THAN LENGTH(secret)  \n            SET secret_char TO secret[counter]  \n            SET guess_char TO guess[counter]  \n            \n            IF NOT (secret_char DIFFERENT FROM guess_char) THEN\n                SET alpha TO alpha + 1\n            ELSE\n                INCREASE secret_map[secret_char] BY 1\n                INCREASE guess_map[guess_char] BY 1\n            END IF  \n            SET counter TO counter + 1\n        END WHILE  \n        \n        FOR each key_element IN secret_map KEYS  \n            SET min_val TO guess_map[key_element]  \n            IF min_val GREATER THAN secret_map[key_element] THEN\n                SET min_val TO secret_map[key_element]\n            END IF\n            SET beta TO beta + min_val\n        END FOR  \n        \n        RETURN (string CONCAT alpha CONCAT \"A\" CONCAT beta CONCAT \"B\")  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getHint(secret PARAMETER, guess PARAMETER)  \n        IMPORT a data structure that provides a dictionary with default zero values\n        \n        SET bulls TO zero  \n        SET cows TO zero  \n        \n        CREATE a dictionary named secret_count with default zero values  \n        CREATE a dictionary named guess_count with default zero values  \n        \n        FOR each element s and element g taken correspondingly from secret and guess  \n            IF element s EQUALS element g  \n                INCREMENT bulls BY one  \n            ELSE  \n                INCREMENT the value at key element s in secret_count BY one  \n                INCREMENT the value at key element g in guess_count BY one  \n            END IF  \n        END FOR  \n        \n        FOR each digit IN the keys of secret_count  \n            INCREMENT cows BY the smaller value BETWEEN the value at key digit in secret_count AND the value at key digit in guess_count  \n        END FOR  \n        \n        RETURN a string expressing bulls FOLLOWED BY the character representing bulls AND THEN cows FOLLOWED BY the character representing cows  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "perfect-rectangle", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        LET minX BE positive infinity  \n        LET minY BE positive infinity  \n        LET maxX BE negative infinity  \n        LET maxY BE negative infinity  \n        \n        INITIALIZE corners AS empty set  \n        DEFINE totalArea AS 0  \n        \n        DEFINE idx AS 0  \n        WHILE idx LESS THAN LENGTH OF rectangles DO  \n            LET rect BE rectangles[idx]  \n            LET leftX BE rect[0]  \n            LET bottomY BE rect[1]  \n            LET rightX BE rect[2]  \n            LET topY BE rect[3]  \n            \n            IF NOT (leftX >= minX) THEN  \n                minX ← leftX  \n            END IF  \n            IF NOT (bottomY >= minY) THEN  \n                minY ← bottomY  \n            END IF  \n            IF NOT (rightX <= maxX) THEN  \n                maxX ← rightX  \n            END IF  \n            IF NOT (topY <= maxY) THEN  \n                maxY ← topY  \n            END IF  \n            \n            LET rectArea BE (rightX - leftX)  \n            LET height BE (topY - bottomY)  \n            LET thisArea BE rectArea * height  \n            totalArea ← totalArea + thisArea  \n            \n            LET cornerPoints BE list of pairs: (leftX, bottomY), (leftX, topY), (rightX, bottomY), (rightX, topY)  \n            \n            LET ctr AS 0  \n            WHILE ctr LESS THAN LENGTH OF cornerPoints DO  \n                LET corner BE cornerPoints[ctr]  \n                IF corners CONTAINS corner THEN  \n                    REMOVE corner FROM corners  \n                ELSE  \n                    INSERT corner INTO corners  \n                END IF  \n                ctr ← ctr + 1  \n            END WHILE  \n            idx ← idx + 1  \n        END WHILE  \n        \n        LET fullWidth BE maxX - minX  \n        LET fullHeight BE maxY - minY  \n        LET expectedArea BE fullWidth * fullHeight  \n        \n        IF totalArea IS NOT expectedArea THEN  \n            RETURN False  \n        END IF  \n        \n        LET requiredCorners BE set of pairs: (minX, minY), (minX, maxY), (maxX, minY), (maxX, maxY)  \n        IF corners IS NOT EQUAL TO requiredCorners THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strong-password-checker", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION strongPasswordChecker(password)\n        SET length_password AS LENGTH OF password\n        SET lower_found AS EXISTS character IN password WHERE character IS lowercase letter\n        SET upper_found AS EXISTS character IN password WHERE character IS uppercase letter\n        SET digit_found AS EXISTS character IN password WHERE character IS digit\n\n        SET missing_char_types AS 3 MINUS (lower_found PLUS upper_found PLUS digit_found)\n\n        SET replacements_needed TO 0\n        SET count_mod0 TO 0\n        SET count_mod1 TO 0\n        SET index_counter TO 2\n\n        WHILE index_counter < length_password\n            IF (password[index_counter] EQUALS password[index_counter - 1]) AND (password[index_counter] EQUALS password[index_counter - 2])\n                SET streak_length TO 2\n                WHILE (index_counter < length_password) AND (password[index_counter] EQUALS password[index_counter - 1])\n                    SET streak_length TO (streak_length PLUS 1)\n                    SET index_counter TO (index_counter PLUS 1)\n                END WHILE\n\n                SET replacements_needed TO replacements_needed PLUS (streak_length DIV 3)\n\n                IF (streak_length MOD 3) EQUALS 0\n                    SET count_mod0 TO count_mod0 PLUS 1\n                ELSE IF (streak_length MOD 3) EQUALS 1\n                    SET count_mod1 TO count_mod1 PLUS 1\n                END IF\n            ELSE\n                SET index_counter TO (index_counter PLUS 1)\n            END IF\n        END WHILE\n\n        IF length_password < 6\n            RETURN MAXIMUM OF missing_char_types AND (6 MINUS length_password)\n        ELSE IF length_password <= 20\n            RETURN MAXIMUM OF missing_char_types AND replacements_needed\n        ELSE\n            SET excess_length TO length_password MINUS 20\n\n            SET min_del0 AS MINIMUM OF excess_length AND count_mod0\n            SET replacements_needed TO replacements_needed MINUS min_del0\n\n            SET remaining_after_del0 TO MAXIMUM OF (excess_length MINUS min_del0) AND 0\n            SET min_del1 AS MINIMUM OF remaining_after_del0 AND (count_mod1 TIMES 2)\n            SET replacements_needed TO replacements_needed MINUS (min_del1 DIV 2)\n\n            SET remaining_after_del1 TO MAXIMUM OF (remaining_after_del0 MINUS min_del1) AND 0\n            SET replacements_needed TO replacements_needed MINUS (remaining_after_del1 DIV 3)\n\n            RETURN excess_length PLUS MAXIMUM OF missing_char_types AND replacements_needed\n        END IF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION strongPasswordChecker(password)  \n        SET n TO the LENGTH OF password  \n        \n        SET has_lower TO BOOLEAN VALUE OF WHETHER any character IN password is a lowercase letter  \n        SET has_upper TO BOOLEAN VALUE OF WHETHER any character IN password is an uppercase letter  \n        SET has_digit TO BOOLEAN VALUE OF WHETHER any character IN password is a digit  \n        \n        SET missing_types TO three MINUS the SUM OF has_lower PLUS has_upper PLUS has_digit  \n        \n        SET replace TO zero  \n        SET one TO zero  \n        SET two TO zero  \n        SET i TO two  \n        WHILE i LESS THAN n  \n            IF the character at position i of password EQUALS the character at position i MINUS one of password AND the character at position i of password EQUALS the character at position i MINUS two of password  \n                SET length TO two  \n                WHILE i LESS THAN n AND the character at position i of password EQUALS the character at position i MINUS one of password  \n                    INCREMENT length BY one  \n                    INCREMENT i BY one  \n                END WHILE  \n                INCREMENT replace BY the INTEGER DIVISION of length BY three  \n                IF the MODULO of length BY three EQUALS zero  \n                    INCREMENT one BY one  \n                ELSE IF the MODULO of length BY three EQUALS one  \n                    INCREMENT two BY one  \n                END IF  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        \n        IF n LESS THAN six  \n            RETURN the GREATER VALUE BETWEEN missing_types AND six MINUS n  \n        ELSE IF n LESS THAN OR EQUAL TO twenty  \n            RETURN the GREATER VALUE BETWEEN missing_types AND replace  \n        ELSE  \n            SET delete TO n MINUS twenty  \n            \n            SET replace TO replace MINUS the SMALLER VALUE BETWEEN delete AND one  \n            SET replace TO replace MINUS the INTEGER DIVISION BY two OF the SMALLER VALUE BETWEEN the GREATER VALUE BETWEEN delete MINUS one AND zero AND two MULTIPLIED BY two  \n            SET replace TO replace MINUS the INTEGER DIVISION BY three OF the GREATER VALUE BETWEEN delete MINUS one MINUS two MULTIPLIED BY two AND zero  \n            \n            RETURN delete PLUS the GREATER VALUE BETWEEN missing_types AND replace  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "word-squares", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION wordSquares(words)\n        SET lookup TO an empty mapping from string to list of strings\n\n        SET w_index TO 0\n        WHILE w_index < LENGTH(words)\n            SET current_word TO words[w_index]\n            SET i TO 0\n            WHILE i < LENGTH(current_word)\n                SET key TO substring(current_word, 0, i)\n                IF NOT lookup HAS KEY key THEN\n                    lookup[key] ← an empty list\n                END IF\n                SET word_list TO lookup[key]\n                word_list ← word_list + [current_word]\n                lookup[key] ← word_list\n                i ← i + 1\n            END WHILE\n            w_index ← w_index + 1\n        END WHILE\n\n        SET output TO an empty list\n\n        FUNCTION backtrack(square)\n            IF NOT LENGTH(square) ≠ LENGTH(words[0]) THEN\n                output ← output + [square]\n                RETURN\n            END IF\n\n            SET build_prefix TO \"\"\n            SET idx TO 0\n            WHILE idx < LENGTH(square)\n                SET temp_word TO square[idx]\n                SET prefix_char TO temp_word[LENGTH(square)]\n                build_prefix ← build_prefix + prefix_char\n                idx ← idx + 1\n            END WHILE\n\n            IF lookup HAS KEY build_prefix THEN\n                SET candidates_list TO lookup[build_prefix]\n                SET c_idx TO 0\n                WHILE c_idx < LENGTH(candidates_list)\n                    SET next_word TO candidates_list[c_idx]\n                    backtrack(square + [next_word])\n                    c_idx ← c_idx + 1\n                END WHILE\n            END IF\n        END FUNCTION\n\n        FOR EACH initial_word IN words\n            backtrack([initial_word])\n        END FOR\n\n        RETURN output\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION wordSquares(words)  \n        SET prefix_to_words TO an empty mapping from string to list of strings  \n        FOR each word IN words  \n            FOR index FROM zero TO the LENGTH OF word MINUS one  \n                SET prefix TO the substring of word from position zero TO position index MINUS one  \n                APPEND word TO the list at prefix_to_words corresponding to prefix  \n            END FOR  \n        END FOR  \n        \n        SET results TO an empty list  \n        \n        FUNCTION backtrack(square)  \n            IF the LENGTH OF square EQUALS the LENGTH OF the first element of words THEN  \n                APPEND square TO results  \n                RETURN  \n            END IF  \n            \n            SET prefix TO an empty string  \n            FOR each word_element IN square  \n                APPEND the element at position the LENGTH OF square of word_element TO prefix  \n            END FOR  \n            \n            FOR each candidate IN the list at prefix_to_words corresponding to prefix  \n                CALL backtrack WITH the argument of the concatenation of square with candidate as a new list element  \n            END FOR  \n        END FUNCTION  \n        \n        FOR each word IN words  \n            CALL backtrack WITH a list containing only word  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "ones-and-zeroes", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        DECLARE matrix AS LIST OF LIST OF INTEGER ← LIST CONTAINING (m + 1) ELEMENTS, EACH BEING A LIST OF (n + 1) ZEROS  \n        \n        INDEX ← 0  \n        WHILE INDEX < LENGTH OF strs  \n            STRING currentString ← strs AT INDEX  \n            ZEROES ← 0  \n            ONES ← 0  \n            \n            POSITION ← 0  \n            WHILE POSITION < LENGTH OF currentString  \n                CHARACTER char ← currentString AT POSITION  \n                IF char = '0' THEN  \n                    ZEROES ← ZEROES + 1  \n                ELSE IF char = '1' THEN  \n                    ONES ← ONES + 1  \n                END IF  \n                POSITION ← POSITION + 1  \n            END WHILE  \n            \n            iCounter ← m  \n            WHILE iCounter >= ZEROES  \n                jCounter ← n  \n                REPEAT  \n                    currentVal ← matrix AT iCounter AT jCounter  \n                    candidateVal ← matrix AT (iCounter - ZEROES) AT (jCounter - ONES) + 1  \n                    \n                    IF candidateVal > currentVal THEN  \n                        matrix AT iCounter AT jCounter ← candidateVal  \n                    END IF  \n                    jCounter ← jCounter - 1  \n                UNTIL jCounter < ONES  \n                iCounter ← iCounter - 1  \n            END WHILE  \n            \n            INDEX ← INDEX + 1  \n        END WHILE  \n        \n        RETURN matrix AT m AT n  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findMaxForm(strs, m, n)  \n        SET dp TO a two dimensional list with the dimensions of m plus one by n plus one where each element is zero  \n        FOR each string s IN strs  \n            SET count_0 TO the number of elements EQUALS to zero in the string s  \n            SET count_1 TO the number of elements EQUALS to one in the string s  \n            FOR variable i FROM m DOWN TO count_0  \n                FOR variable j FROM n DOWN TO count_1  \n                    SET dp at position i and position j TO the maximum value between dp at position i and position j AND the value of dp at position i MINUS count_0 and position j MINUS count_1 PLUS one  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN dp at position m and position n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sliding-window-median", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION medianSlidingWindow(nums k)\n        ASSIGN [] TO alpha\n        ASSIGN [] TO beta\n\n        FUNCTION balance_heaps()\n            WHEN LENGTH(alpha) > LENGTH(beta) + 1:\n                CALL heappush beta NEGATE CALL heappop alpha\n            OTHERWISE WHEN LENGTH(beta) > LENGTH(alpha):\n                CALL heappush alpha NEGATE CALL heappop beta\n            END WHEN\n        END FUNCTION\n\n        FUNCTION add_num(delta)\n            WHEN LENGTH(alpha) = 0 OR delta <= NEGATE alpha[0]:\n                CALL heappush alpha NEGATE delta\n            OTHERWISE:\n                CALL heappush beta delta\n            END WHEN\n            CALL balance_heaps()\n        END FUNCTION\n\n        FUNCTION remove_num(delta)\n            WHEN delta <= NEGATE alpha[0]:\n                DELETE element NEGATE delta FROM alpha\n                WHEN LENGTH(alpha) > 0:\n                    CALL heapify alpha\n                END WHEN\n            OTHERWISE:\n                DELETE element delta FROM beta\n                WHEN LENGTH(beta) > 0:\n                    CALL heapify beta\n                END WHEN\n            END WHEN\n            CALL balance_heaps()\n        END FUNCTION\n\n        FUNCTION get_median()\n            WHEN LENGTH(alpha) > LENGTH(beta):\n                RETURN NEGATE alpha[0]\n            END WHEN\n            RETURN (NEGATE alpha[0] + beta[0]) / 2\n        END FUNCTION\n\n        ASSIGN 0 TO mu\n        WHILE mu < k:\n            CALL add_num nums[mu]\n            ASSIGN mu + 1 TO mu\n        END WHILE\n\n        ASSIGN [get_median()] TO omegas\n\n        ASSIGN k TO pi\n        WHILE NOT (pi >= LENGTH(nums)):\n            CALL add_num nums[pi]\n            CALL remove_num nums[pi - k]\n            APPEND get_median() TO omegas\n            ASSIGN pi + 1 TO pi\n        END WHILE\n\n        RETURN omegas\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION medianSlidingWindow(nums k)  \n        SET lo TO empty list  \n        SET hi TO empty list  \n\n        FUNCTION balance_heaps()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi PLUS one  \n                CALL heappush WITH the argument hi AND NEGATIVE of the result of heappop ON lo  \n            ELSE IF the LENGTH OF hi IS GREATER THAN the LENGTH OF lo  \n                CALL heappush WITH the argument lo AND NEGATIVE of the result of heappop ON hi  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION add_num(num)  \n            IF lo IS empty OR num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                CALL heappush WITH the argument lo AND NEGATIVE num  \n            ELSE  \n                CALL heappush WITH the argument hi AND num  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION remove_num(num)  \n            IF num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                REMOVE NEGATIVE num FROM lo  \n                IF lo IS NOT empty  \n                    CALL heapify WITH the argument lo  \n                END IF  \n            ELSE  \n                REMOVE num FROM hi  \n                IF hi IS NOT empty  \n                    CALL heapify WITH the argument hi  \n                END IF  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION get_median()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi  \n                RETURN NEGATIVE of element at position zero of lo  \n            END IF  \n            RETURN NEGATIVE of element at position zero of lo PLUS element at position zero of hi DIVIDED BY two  \n        END FUNCTION  \n\n        FOR i FROM zero TO k MINUS one  \n            CALL add_num WITH element at position i of nums  \n        END FOR  \n\n        SET medians TO a list containing the result of get_median()  \n\n        FOR i FROM k TO the LENGTH OF nums MINUS one  \n            CALL add_num WITH element at position i of nums  \n            CALL remove_num WITH element at position i MINUS k of nums  \n            APPEND the result of get_median() TO medians  \n        END FOR  \n\n        RETURN medians  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "student-attendance-record-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION checkRecord(n)\n        ASSIGN 1000000000 + 7 TO MOD\n        ASSIGN a list composed of (n + 1) elements, each a list of 2 elements, each a list of 3 zeros TO dp\n        ASSIGN 1 TO dp[0][0][0]\n\n        ASSIGN 1 TO p\n        WHILE p <= n DO\n            ASSIGN 0 TO xq\n            WHILE xq <= 1 DO\n                ASSIGN 0 TO yf\n                WHILE yf <= 2 DO\n                    ASSIGN dp[p][xq][0] + dp[p - 1][xq][yf] TO dp[p][xq][0]\n                    ASSIGN dp[p][xq][0] MOD MOD TO dp[p][xq][0]\n\n                    IF NOT (xq != 0) THEN\n                        ASSIGN dp[p][1][0] + dp[p - 1][0][yf] TO dp[p][1][0]\n                        ASSIGN dp[p][1][0] MOD MOD TO dp[p][1][0]\n                    END IF\n\n                    IF yf < 2 THEN\n                        ASSIGN dp[p][xq][yf + 1] + dp[p - 1][xq][yf] TO dp[p][xq][yf + 1]\n                        ASSIGN dp[p][xq][yf + 1] MOD MOD TO dp[p][xq][yf + 1]\n                    END IF\n\n                    ASSIGN yf + 1 TO yf\n                END WHILE\n                ASSIGN xq + 1 TO xq\n            END WHILE\n            ASSIGN p + 1 TO p\n        END WHILE\n\n        ASSIGN 0 TO summary\n        ASSIGN 0 TO dt\n        WHILE dt <= 1 DO\n            ASSIGN 0 TO jq\n            WHILE jq <= 2 DO\n                ASSIGN (summary + dp[n][dt][jq]) MOD MOD TO summary\n                ASSIGN jq + 1 TO jq\n            END WHILE\n            ASSIGN dt + 1 TO dt\n        END WHILE\n\n        RETURN summary\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION checkRecord(n)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a three dimensional list of zeroes with dimensions n PLUS one BY two BY three  \n        SET element at position zero BY zero BY zero of dp TO one  \n        FOR i FROM one TO n  \n            FOR j FROM zero TO one  \n                FOR k FROM zero TO two  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp PLUS element at position i MINUS one BY j BY k of dp  \n                    SET element at position i BY j BY zero of dp TO element at position i BY j BY zero of dp MODULO MOD  \n                    IF j EQUALS zero  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp PLUS element at position i MINUS one BY zero BY k of dp  \n                        SET element at position i BY one BY zero of dp TO element at position i BY one BY zero of dp MODULO MOD  \n                    END IF  \n                    IF k LESS THAN two  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp PLUS element at position i MINUS one BY j BY k of dp  \n                        SET element at position i BY j BY k PLUS one of dp TO element at position i BY j BY k PLUS one of dp MODULO MOD  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        SET result TO zero  \n        FOR j FROM zero TO one  \n            FOR k FROM zero TO two  \n                SET result TO result PLUS element at position n BY j BY k of dp  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-operation-for-two-strings", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        ASSIGN length1 ← LENGTH OF word1  \n        ASSIGN length2 ← LENGTH OF word2  \n        \n        CREATE dp AS a list of (length1 PLUS 1) elements, EACH BEING a list of (length2 PLUS 1) zeros  \n        \n        ASSIGN outerCounter ← 1  \n        WHILE outerCounter <= length1  \n            ASSIGN innerCounter ← 1  \n            WHILE innerCounter <= length2  \n                ASSIGN charFromWord1 ← word1[outerCounter MINUS 1]  \n                ASSIGN charFromWord2 ← word2[innerCounter MINUS 1]  \n                \n                IF NOT (charFromWord1 NOT EQUAL TO charFromWord2) THEN  \n                    SET dp[outerCounter][innerCounter] ← dp[outerCounter MINUS 1][innerCounter MINUS 1] PLUS 1  \n                ELSE  \n                    ASSIGN topValue ← dp[outerCounter MINUS 1][innerCounter]  \n                    ASSIGN leftValue ← dp[outerCounter][innerCounter MINUS 1]  \n                    \n                    IF topValue >= leftValue THEN  \n                        SET dp[outerCounter][innerCounter] ← topValue  \n                    ELSE  \n                        SET dp[outerCounter][innerCounter] ← leftValue  \n                    END IF  \n                END IF  \n                \n                INCREMENT innerCounter BY 1  \n            END WHILE  \n            INCREMENT outerCounter BY 1  \n        END WHILE  \n        \n        ASSIGN lcsLength ← dp[length1][length2]  \n        \n        RETURN (length1 MINUS lcsLength) PLUS (length2 MINUS lcsLength)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minDistance(word1, word2)  \n        SET m TO the LENGTH OF word1  \n        SET n TO the LENGTH OF word2  \n        \n        CREATE a two dimensional list named dp with dimensions m PLUS one and n PLUS one  \n        FOR each index i FROM one TO m  \n            FOR each index j FROM one TO n  \n                IF the element at position i MINUS one of word1 EQUALS the element at position j MINUS one of word2  \n                    SET the element at position i and position j of dp TO the element at position i MINUS one and position j MINUS one of dp PLUS one  \n                ELSE  \n                    SET the element at position i and position j of dp TO the GREATER VALUE BETWEEN the element at position i MINUS one and position j of dp AND the element at position i and position j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET lcs_length TO the element at position m and position n of dp  \n        \n        RETURN the value of m MINUS lcs_length PLUS the value of n MINUS lcs_length  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-inverse-pairs-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION kInversePairs(n, k)\n        ASSIGN 1000000007 TO MOD\n        ASSIGN LIST containing (k + 1) zeros TO dp_row_template\n        ASSIGN LIST containing (n + 1) copies of dp_row_template TO dp\n        ASSIGN 1 TO dp[0][0]\n\n        ASSIGN 1 TO outer_counter\n        WHILE outer_counter <= n\n            ASSIGN 0 TO cumulative_total\n            ASSIGN 0 TO inner_index\n            WHILE inner_index <= k\n                ASSIGN cumulative_total + dp[outer_counter - 1][inner_index] TO cumulative_total\n                IF cumulative_total >= MOD THEN\n                    ASSIGN cumulative_total - MOD TO cumulative_total\n                END IF\n                IF inner_index >= outer_counter THEN\n                    ASSIGN cumulative_total - dp[outer_counter - 1][inner_index - outer_counter] + MOD TO cumulative_total\n                    IF cumulative_total >= MOD THEN\n                        ASSIGN cumulative_total - MOD TO cumulative_total\n                    END IF\n                END IF\n                ASSIGN cumulative_total TO dp[outer_counter][inner_index]\n                ADD 1 TO inner_index\n            END WHILE\n            ADD 1 TO outer_counter\n        END WHILE\n        RETURN dp[n][k]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kInversePairs(n, k)  \n        SET MOD TO one billion PLUS seven  \n        SET dp TO a two dimensional list of zeros with dimension n PLUS one by k PLUS one  \n        SET element at position zero of element at position zero of dp TO one  \n        \n        FOR i FROM one TO n  \n            SET prefix_sum TO zero  \n            FOR j FROM zero TO k  \n                SET prefix_sum TO prefix_sum PLUS element at position j of element at position i MINUS one of dp  \n                IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                    SET prefix_sum TO prefix_sum MINUS MOD  \n                END IF  \n                IF j GREATER THAN OR EQUAL TO i  \n                    SET prefix_sum TO prefix_sum MINUS element at position j MINUS i of element at position i MINUS one of dp PLUS MOD  \n                    IF prefix_sum GREATER THAN OR EQUAL TO MOD  \n                        SET prefix_sum TO prefix_sum MINUS MOD  \n                    END IF  \n                END IF  \n                SET element at position j of element at position i of dp TO prefix_sum  \n            END FOR  \n        END FOR  \n        RETURN element at position k of element at position n of dp  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        DEFINE index AS 0  \n        SORT words USING a comparator THAT prioritizes shorter LENGTH first, THEN lex ORDER ascending  \n        INITIALIZE valid_words AS an empty set  \n        INITIALIZE longest_word AS empty string \"\"  \n  \n        WHILE index < LENGTH(words)  \n            LET candidate_word = words[index]  \n            LET candidate_length = LENGTH(candidate_word)  \n            LET prefix_word = candidate_word[0 : candidate_length - 1]  \n  \n            IF NOT (candidate_length ≠ 1 OR prefix_word ∈ valid_words) THEN  \n                INCREMENT index BY 1  \n                CONTINUE  \n            END IF  \n  \n            ADD candidate_word TO valid_words  \n  \n            IF LENGTH(longest_word) < candidate_length THEN  \n                longest_word ← candidate_word  \n            END IF  \n  \n            index ← index + 1  \n        END WHILE  \n  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN LEXICOGRAPHICAL ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO an empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from position one TO position LENGTH OF word MINUS one IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "pour-water", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers\n        ASSIGN n TO LENGTH(heights)\n\n        SET stepCounter TO 1\n        WHILE stepCounter LESS THAN OR EQUAL TO volume\n            ASSIGN cursor TO k\n\n            WHILE NOT (cursor EQUALS 0 OR heights[cursor - 1] GREATER THAN heights[cursor])\n                SUBTRACT 1 FROM cursor\n            END WHILE\n\n            WHILE NOT (cursor EQUALS k OR heights[cursor] NOT EQUAL heights[cursor + 1])\n                ADD 1 TO cursor\n            END WHILE\n\n            IF NOT cursor GREATER OR EQUAL k THEN\n                ASSIGN prevHeight TO heights[cursor]\n                ASSIGN updatedHeight TO prevHeight + 1\n                ASSIGN heights[cursor] TO updatedHeight\n                ADD 1 TO stepCounter\n                CONTINUE TO NEXT iteration of WHILE\n            END IF\n\n            ASSIGN cursor TO k\n\n            WHILE NOT (cursor EQUALS n - 1 OR heights[cursor + 1] GREATER THAN heights[cursor])\n                ADD 1 TO cursor\n            END WHILE\n\n            WHILE NOT (cursor EQUALS k OR heights[cursor] NOT EQUAL heights[cursor - 1])\n                SUBTRACT 1 FROM cursor\n            END WHILE\n\n            IF cursor GREATER THAN k THEN\n                ASSIGN baseHeight TO heights[cursor]\n                ASSIGN incrementedHeight TO baseHeight + 1\n                ASSIGN heights[cursor] TO incrementedHeight\n                ADD 1 TO stepCounter\n                CONTINUE TO NEXT iteration of WHILE\n            END IF\n\n            ASSIGN currentHeight TO heights[k]\n            ASSIGN newHeight TO currentHeight + 1\n            ASSIGN heights[k] TO newHeight\n\n            ADD 1 TO stepCounter\n        END WHILE\n\n        RETURN heights\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION pourWater(heights WITH TYPE List of integers volume WITH TYPE integer k WITH TYPE integer) RETURNS List of integers  \n        SET n TO the LENGTH OF heights  \n        \n        FOR each iteration FROM one TO volume  \n            SET i TO k  \n            WHILE i GREATER THAN zero AND element at position i MINUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            WHILE i LESS THAN k AND element at position i of heights EQUALS element at position i PLUS one of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            IF i LESS THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            SET i TO k  \n            WHILE i LESS THAN n MINUS one AND element at position i PLUS one of heights LESS THAN OR EQUAL TO element at position i of heights  \n                INCREMENT i BY one  \n            END WHILE  \n            WHILE i GREATER THAN k AND element at position i of heights EQUALS element at position i MINUS one of heights  \n                DECREMENT i BY one  \n            END WHILE  \n            IF i GREATER THAN k  \n                INCREMENT element at position i of heights BY one  \n                CONTINUE  \n            END IF  \n            \n            INCREMENT element at position k of heights BY one  \n        END FOR  \n        \n        RETURN heights  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "k-th-symbol-in-grammar", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION kthGrammar(n k)  \n        WHILE TRUE  \n            IF n IS 1 THEN  \n                RETURN 0  \n            END IF  \n            ASSIGN (2 ^ (n - 1)) TO temp_length  \n            ASSIGN temp_length TO half_length  \n            IF k <= half_length THEN  \n                ASSIGN n - 1 TO next_n  \n                RETURN kthGrammar(next_n k)  \n            ELSE  \n                ASSIGN n - 1 TO prev_n  \n                ASSIGN k - half_length TO index_offset  \n                ASSIGN kthGrammar(prev_n index_offset) TO prev_val  \n                ASSIGN 1 - prev_val TO result_val  \n                RETURN result_val  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthGrammar(n k)  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET length_of_previous_row TO two MULTIPLIED BY two RAISED TO THE POWER OF n MINUS two MINUS one  \n        IF k LESS THAN OR EQUAL TO length_of_previous_row  \n            RETURN call kthGrammar WITH n MINUS one AND k  \n        ELSE  \n            SET previous_value TO call kthGrammar WITH n MINUS one AND k MINUS length_of_previous_row  \n            SET complement_value TO one MINUS previous_value  \n            RETURN complement_value  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "race-car", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION racecar(target)  \n        DECLARE sequence ← new double ended queue containing [(0, 1, 0)]  \n        DECLARE visited ← empty set  \n        INSERT (0, 1) INTO visited  \n        \n        LOOP indefinitely  \n            IF sequence IS empty THEN BREAK  \n            END IF  \n            \n            POP (current_pos, current_spd, current_steps) FROM the front of sequence  \n            \n            SWITCH  \n                CASE current_pos = target:  \n                    RETURN current_steps  \n                DEFAULT:  \n                    CONTINUE  \n            END SWITCH  \n            \n            SET projected_pos TO current_pos + current_spd  \n            SET projected_spd TO current_spd × 2  \n            \n            IF NOT ((projected_pos, projected_spd) IN visited) AND 0 ≤ projected_pos < (2 × target) THEN  \n                INSERT (projected_pos, projected_spd) INTO visited  \n                ENQUEUE (projected_pos, projected_spd, current_steps + 1) TO the rear of sequence  \n            END IF  \n            \n            DECLARE alt_spd  \n            IF current_spd > 0 THEN  \n                alt_spd ← -1  \n            ELSE  \n                alt_spd ← +1  \n            END IF  \n            \n            IF NOT ((current_pos, alt_spd) IN visited) AND 0 ≤ current_pos < (2 × target) THEN  \n                INSERT (current_pos, alt_spd) INTO visited  \n                ENQUEUE (current_pos, alt_spd, current_steps + 1) TO the rear of sequence  \n            END IF  \n        END LOOP  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION racecar(target)  \n        ASSIGN reference TO a new double ended queue containing a single tuple of zero for position one for speed and zero for steps  \n        ASSIGN reference TO a new empty set  \n        ADD a tuple of zero for position and one for speed TO the set  \n        \n        WHILE the queue is not empty  \n            REMOVE and ASSIGN a tuple from the left side of the queue TO position speed and steps  \n            \n            IF position EQUALS target  \n                RETURN steps  \n            END IF  \n            \n            SET next_position TO position PLUS speed  \n            SET next_speed TO speed MULTIPLIED BY two  \n            IF the tuple of next_position and next_speed NOT IN the set AND next_position IS GREATER THAN OR EQUAL TO zero AND next_position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of next_position and next_speed TO the set  \n                APPEND the tuple of next_position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n            \n            IF speed IS GREATER THAN zero  \n                SET next_speed TO negative one  \n            ELSE  \n                SET next_speed TO one  \n            END IF  \n            IF the tuple of position and next_speed NOT IN the set AND position IS GREATER THAN OR EQUAL TO zero AND position IS LESS THAN two MULTIPLIED BY target  \n                ADD the tuple of position and next_speed TO the set  \n                APPEND the tuple of position next_speed and steps PLUS one TO the right side of the queue  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "new-21-game", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION new21Game(n INTEGER, k INTEGER, maxPts INTEGER) RETURNS FLOAT\n        FUNCTION dfs(pos INTEGER) RETURNS FLOAT\n            SWITCH TRUE\n                CASE pos >= k:\n                    RETURN 1.0 IF pos <= n ELSE 0.0\n                CASE pos = k - 1:\n                    LET coverage FLOAT = n - k + 1\n                    RETURN coverage / maxPts IF coverage < maxPts ELSE 1.0\n            END SWITCH\n\n            LET valStart FLOAT = dfs(pos + 1)\n            LET valEnd FLOAT = dfs(pos + maxPts + 1)\n            LET outcome FLOAT = valStart + (valStart - valEnd) / maxPts\n            RETURN outcome\n        END FUNCTION\n\n        RETURN dfs(0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION new21Game(n INTEGER PARAMETER k INTEGER PARAMETER maxPts INTEGER PARAMETER) RETURNS FLOAT  \n        FUNCTION dfs(i INTEGER PARAMETER) RETURNS FLOAT  \n            IF i GREATER THAN OR EQUAL TO k THEN  \n                IF i LESS THAN OR EQUAL TO n THEN  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF i EQUALS k MINUS one THEN  \n                IF n MINUS k PLUS one LESS THAN maxPts THEN  \n                    RETURN (n MINUS k PLUS one) DIVIDED BY maxPts  \n                ELSE  \n                    RETURN one  \n                END IF  \n            END IF  \n            SET first_call TO dfs(i PLUS one)  \n            SET second_call TO dfs(i PLUS maxPts PLUS one)  \n            SET result TO first_call PLUS (first_call MINUS second_call) DIVIDED BY maxPts  \n            RETURN result  \n        END FUNCTION  \n        RETURN dfs(zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "numbers-at-most-n-given-digit-set", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION numbers_of_length(k)  \n            VAR base_num <- LENGTH OF digits  \n            VAR total_count <- 1  \n            VAR step <- 0  \n            WHILE step < k  \n                total_count <- total_count * base_num  \n                step <- step + 1  \n            END WHILE  \n            RETURN total_count  \n        END FUNCTION  \n        \n        FUNCTION count_up_to_limit(limit)  \n            VAR rep <- TO_STRING(limit)  \n            VAR len_rep <- LENGTH OF rep  \n            VAR acc <- 0  \n            \n            VAR idx <- 1  \n            LOOP UNTIL idx >= len_rep  \n                acc <- acc + numbers_of_length(idx)  \n                idx <- idx + 1  \n            END LOOP  \n            \n            VAR pos <- 0  \n            WHILE pos < len_rep  \n                VAR val <- TO_INTEGER(rep[pos])  \n                VAR j <- 0  \n                \n                REPEAT  \n                    IF j >= LENGTH OF digits THEN  \n                        BREAK  \n                    END IF  \n                    \n                    VAR d_val <- TO_INTEGER(digits[j])  \n                    \n                    IF d_val < val THEN  \n                        acc <- acc + numbers_of_length(len_rep - pos - 1)  \n                        j <- j + 1  \n                    ELSE IF d_val = val THEN  \n                        IF pos = len_rep - 1 THEN  \n                            acc <- acc + 1  \n                        END IF  \n                        BREAK  \n                    ELSE  \n                        BREAK  \n                    END IF  \n                UNTIL FALSE  \n                pos <- pos + 1  \n            END WHILE  \n            \n            RETURN acc  \n        END FUNCTION  \n        \n        RETURN count_up_to_limit(n)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION atMostNGivenDigitSet(digits, n)  \n        FUNCTION count_numbers_with_length(length)  \n            RETURN the LENGTH OF digits RAISED TO THE POWER OF length  \n        END FUNCTION  \n        \n        FUNCTION count_numbers_up_to_n(n)  \n            SET str_n TO the string representation of n  \n            SET length TO the LENGTH OF str_n  \n            SET count TO zero  \n            \n            FOR l FROM one TO length MINUS one  \n                INCREMENT count BY count_numbers_with_length(l)  \n            END FOR  \n            \n            FOR i FROM zero TO length MINUS one  \n                SET current_digit TO the integer value of the element at position i of str_n  \n                FOR each digit IN digits  \n                    IF the integer value of digit LESS THAN current_digit THEN  \n                        INCREMENT count BY count_numbers_with_length(length MINUS i MINUS one)  \n                    ELSE IF the integer value of digit EQUALS current_digit THEN  \n                        IF i EQUALS length MINUS one THEN  \n                            INCREMENT count BY one  \n                        END IF  \n                    ELSE IF the integer value of digit GREATER THAN current_digit THEN  \n                        BREAK the inner loop  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN count  \n        END FUNCTION  \n        \n        RETURN count_numbers_up_to_n(n)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-rational-numbers", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean  \n        SET fractions AS [1, 1/9, 1/99, 1/999, 1/9999]  \n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number  \n            SET openPos TO INDEX_OF('(' IN s)  \n            IF openPos IS NOT_EQUAL_TO -1 THEN  \n                SET closePos TO INDEX_OF(')' IN s)  \n                SET decimalPos TO INDEX_OF('.' IN s)  \n                SET baseValue TO TO_FLOAT(SUBSTRING(s, 0, openPos))  \n                SET nonRepeatCount TO openPos - decimalPos - 1  \n                SET repeatValue TO TO_INT(SUBSTRING(s, openPos + 1, closePos))  \n                SET repeatLength TO closePos - openPos - 1  \n\n                SET part1 TO repeatValue * fractions[repeatLength]  \n                SET part2 TO part1 / (10 ^ nonRepeatCount)  \n                RETURN baseValue + part2  \n            END IF  \n            RETURN TO_FLOAT(s)  \n        END FUNCTION  \n\n        SET diff TO ABS(valueOf(s) - valueOf(t))  \n        RETURN diff < (1 / (10 ^ 9))  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean  \n        SET ratios TO a list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number  \n            IF position of opening parenthesis in s EQUALS negative one  \n                RETURN the conversion of s TO a floating point number  \n            END IF  \n\n            SET leftParenIndex TO position of opening parenthesis in s  \n            SET rightParenIndex TO position of closing parenthesis in s  \n            SET dotIndex TO position of decimal point in s  \n\n            SET integerAndNonRepeating TO the conversion TO floating point number OF the substring of s from the start TO the position leftParenIndex minus one  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the conversion TO integer OF the substring of s from position leftParenIndex PLUS one TO position rightParenIndex MINUS one  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY the number one DIVIDED BY ten RAISED TO the power of nonRepeatingLength MULTIPLIED BY element at position repeatingLength OF the list ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of valueOf of s MINUS valueOf of t LESS THAN one DIVIDED BY ten RAISED TO the power of nine  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-transforms-into-another-string", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canConvert WITH PARAMETERS str1 str2\n        IF NOT (str1 IS NOT str2) THEN\n            RETURN True\n        END IF\n\n        DEFINE char_to_char_map AS empty dictionary\n\n        SET index_var TO 0\n        WHILE index_var LESS THAN LENGTH(str1)\n            ASSIGN charA TO str1 AT index_var\n            ASSIGN charB TO str2 AT index_var\n\n            IF charA IN char_to_char_map THEN\n                IF NOT (char_to_char_map[charA] EQUALS charB) THEN\n                    RETURN False\n                END IF\n            ELSE\n                ASSIGN charB TO char_to_char_map AT charA\n            END IF\n\n            INCREMENT index_var BY 1\n        END WHILE\n\n        IF LENGTH(SET OF ELEMENTS OF str2) GREATER THAN OR EQUAL TO 26 THEN\n            RETURN False\n        END IF\n\n        RETURN True\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO an empty mapping from characters to characters  \n        FOR each pair of characters char1 and char2 FROM str1 AND str2 in order  \n            IF char1 IS IN conversion_map  \n                IF the value mapped from char1 in conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET the value mapped from char1 in conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the number of unique characters IN str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "divide-chocolate", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximizeSweetness(sweetness list OF integer, k integer) RETURNS integer\n        FUNCTION canDivide(min_sweet integer) RETURNS boolean\n            ASSIGN 0 TO count_pieces\n            ASSIGN 0 TO aggregate_sweet\n            ASSIGN 0 TO idx\n            WHILE idx LESS THAN LENGTH(sweetness)\n                ASSIGN aggregate_sweet PLUS sweetness[idx] TO aggregate_sweet\n                IF NOT (aggregate_sweet LESS THAN min_sweet)\n                    ASSIGN count_pieces PLUS 1 TO count_pieces\n                    ASSIGN 0 TO aggregate_sweet\n                    IF NOT (count_pieces LESS THAN OR EQUAL TO k)\n                        RETURN True\n                    END IF\n                END IF\n                INCREMENT idx BY 1\n            END WHILE\n            RETURN count_pieces GREATER THAN k\n        END FUNCTION\n\n        ASSIGN sweetness[0] TO low\n        ASSIGN 0 TO i\n        WHILE i LESS THAN LENGTH(sweetness)\n            IF sweetness[i] LESS THAN low\n                ASSIGN sweetness[i] TO low\n            END IF\n            INCREMENT i BY 1\n        END WHILE\n\n        ASSIGN 0 TO total_value\n        ASSIGN 0 TO j\n        WHILE j LESS THAN LENGTH(sweetness)\n            ASSIGN total_value PLUS sweetness[j] TO total_value\n            INCREMENT j BY 1\n        END WHILE\n\n        ASSIGN total_value DIVIDED BY (k PLUS 1) TO high\n        ASSIGN 0 TO final_ans\n\n        WHILE low LESS THAN OR EQUAL TO high\n            ASSIGN (low PLUS high) DIVIDED BY 2 TO mid_val\n            IF canDivide(mid_val) IS True\n                ASSIGN mid_val TO final_ans\n                ASSIGN mid_val PLUS 1 TO low\n                CONTINUE\n            ELSE\n                ASSIGN mid_val MINUS 1 TO high\n            END IF\n        END WHILE\n\n        RETURN final_ans\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximizeSweetness(sweetness list OF integer k integer) RETURNS integer  \n        FUNCTION canDivide(min_sweet integer) RETURNS boolean  \n            SET pieces TO zero  \n            SET current_sweet TO zero  \n            FOR each sweet IN sweetness  \n                SET current_sweet TO current_sweet PLUS sweet  \n                IF current_sweet GREATER THAN OR EQUAL TO min_sweet  \n                    INCREMENT pieces BY one  \n                    SET current_sweet TO zero  \n                    IF pieces GREATER THAN k  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            RETURN pieces GREATER THAN k  \n        END FUNCTION  \n\n        SET left TO the smallest element IN sweetness  \n        SET right TO the total sum OF all elements IN sweetness DIVIDED BY the value of k PLUS one  \n        SET result TO zero  \n        WHILE left LESS THAN OR EQUAL TO right  \n            SET mid TO the integer value of left PLUS right DIVIDED BY two  \n            IF canDivide(mid) IS True  \n                SET result TO mid  \n                SET left TO mid PLUS one  \n            ELSE  \n                SET right TO mid MINUS one  \n            END IF  \n        END WHILE  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-performance-of-a-team", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maxPerformance(n speed efficiency k)\n        ASSIGN empty array TO specialist_tuples\n        ASSIGN 0 TO idx\n        WHILE idx LESS THAN length of efficiency\n            ASSIGN (efficiency[idx], speed[idx]) TO pair_val\n            APPEND pair_val TO specialist_tuples\n            INCREMENT idx BY 1\n        END WHILE\n\n        ASSIGN specialist_tuples SORTED BY first element DESCENDING TO sorted_specialists\n\n        ASSIGN empty min-heap TO velocity_container\n        ASSIGN 0 TO cumulative_velocity\n        ASSIGN 0 TO top_performance\n\n        ASSIGN 0 TO iterate_index\n        WHILE iterate_index LESS THAN length of sorted_specialists\n            ASSIGN sorted_specialists[iterate_index] TO current_pair\n            ASSIGN current_pair.first TO efficiency_val\n            ASSIGN current_pair.second TO velocity_val\n\n            PUSH velocity_val INTO velocity_container\n            SET cumulative_velocity TO cumulative_velocity PLUS velocity_val\n\n            IF SIZE of velocity_container GREATER THAN k THEN\n                ASSIGN HEAP POP from velocity_container TO lowest_velocity\n                SET cumulative_velocity TO cumulative_velocity MINUS lowest_velocity\n            END IF\n\n            ASSIGN cumulative_velocity TIMES efficiency_val TO performance_val\n\n            IF performance_val GREATER THAN top_performance THEN\n                SET top_performance TO performance_val\n            END IF\n\n            INCREMENT iterate_index BY 1\n        END WHILE\n\n        RETURN top_performance MOD (10 POWER 9 PLUS 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxPerformance(n speed efficiency k)  \n        SET engineers TO list of pairs of element at position index of efficiency AND element at position index of speed FOR index FROM the first TO the last position in efficiency  \n        SORT engineers BY the first element of each pair IN descending order  \n        SET speed_heap TO empty list  \n        SET speed_sum TO zero  \n        SET max_performance TO zero  \n        FOR each pair IN engineers  \n            SET eff TO the first element of pair  \n            SET spd TO the second element of pair  \n            ADD spd TO speed_heap USING heap push operation  \n            INCREMENT speed_sum BY spd  \n            IF the LENGTH OF speed_heap GREATER THAN k THEN  \n                SET smallest_speed TO the result of heap pop operation on speed_heap  \n                DECREMENT speed_sum BY smallest_speed  \n            END IF  \n            SET current_performance TO speed_sum MULTIPLIED BY eff  \n            IF current_performance GREATER THAN max_performance THEN  \n                SET max_performance TO current_performance  \n            END IF  \n        END FOR  \n        RETURN max_performance MODULO the result of ten RAISED TO THE POWER OF nine PLUS one  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cherry-pickup-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION cherryPickup(grid)\n        SET totalRows AS LENGTH(grid)\n        SET totalCols AS LENGTH(grid[0])\n        \n        FUNCTION dp(r c1 c2)\n            IF (c1 < 0) OR (c1 >= totalCols) OR (c2 < 0) OR (c2 >= totalCols) THEN\n                RETURN 0\n            END IF\n\n            IF c1 = c2 THEN\n                SET gathered AS grid[r][c1]\n            ELSE\n                SET gathered AS grid[r][c1] + grid[r][c2]\n            END IF\n\n            IF r = totalRows - 1 THEN\n                RETURN gathered\n            END IF\n            \n            SET supremeValue TO 0\n            SET deltaIndexOneList TO [-1 0 1]\n            SET deltaIndexTwoList TO [-1 0 1]\n            SET outerCounter TO 0\n            WHILE outerCounter < LENGTH(deltaIndexOneList)\n                SET innerCounter TO 0\n                WHILE innerCounter < LENGTH(deltaIndexTwoList)\n                    SET candidateSum TO dp(r + 1 c1 + deltaIndexOneList[outerCounter] c2 + deltaIndexTwoList[innerCounter])\n                    IF candidateSum > supremeValue THEN\n                        supremeValue ← candidateSum\n                    END IF\n                    innerCounter ← innerCounter + 1\n                END WHILE\n                outerCounter ← outerCounter + 1\n            END WHILE\n\n            RETURN gathered + supremeValue\n        END FUNCTION\n\n        RETURN dp(0 0 totalCols - 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION cherryPickup(grid)  \n        SET rows TO the LENGTH OF grid  \n        SET cols TO the LENGTH OF element at position zero of grid  \n        \n        FUNCTION dp(r c1 c2)  \n            IF c1 LESS THAN zero OR c1 GREATER THAN OR EQUAL TO cols OR c2 LESS THAN zero OR c2 GREATER THAN OR EQUAL TO cols THEN  \n                RETURN zero  \n            END IF  \n            \n            IF c1 EQUALS c2 THEN  \n                SET cherries TO element at position r of grid element at position c1  \n            ELSE  \n                SET cherries TO element at position r of grid element at position c1 PLUS element at position r of grid element at position c2  \n            END IF  \n            \n            IF r EQUALS rows MINUS one THEN  \n                RETURN cherries  \n            END IF  \n            \n            SET max_cherries TO zero  \n            FOR each dc1 IN list containing negative one zero and one  \n                FOR each dc2 IN list containing negative one zero and one  \n                    SET possible TO dp(r PLUS one c1 PLUS dc1 c2 PLUS dc2)  \n                    IF possible GREATER THAN max_cherries THEN  \n                        SET max_cherries TO possible  \n                    END IF  \n                END FOR  \n            END FOR  \n            \n            RETURN cherries PLUS max_cherries  \n        END FUNCTION  \n        \n        RETURN dp(zero zero cols MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "best-position-for-a-service-centre", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION getMinDistSum(positions)\n        LET totalPoints ← LENGTH OF positions\n        LET centerX ← 0\n        LET centerY ← 0\n        FOR each coord IN positions DO\n            LET px ← coord[0]\n            LET py ← coord[1]\n            centerX ← centerX + px\n            centerY ← centerY + py\n        END FOR\n        centerX ← centerX / totalPoints\n        centerY ← centerY / totalPoints\n\n        LET shrinkFactor ← 0.999\n        LET threshold ← 0.000001\n        LET rate ← 0.5\n\n        REPEAT\n            LET gradientX ← 0\n            LET gradientY ← 0\n            LET totalDistance ← 0\n            FOR each coord IN positions DO\n                LET xVal ← coord[0]\n                LET yVal ← coord[1]\n                LET diffX ← centerX - xVal\n                LET diffY ← centerY - yVal\n                LET distVal ← SQRT(diffX * diffX + diffY * diffY)\n                gradientX ← gradientX + (diffX / distVal + 0.00000001)\n                gradientY ← gradientY + (diffY / distVal + 0.00000001)\n                totalDistance ← totalDistance + distVal\n            END FOR\n\n            LET stepX ← gradientX * rate\n            LET stepY ← gradientY * rate\n\n            centerX ← centerX - stepX\n            centerY ← centerY - stepY\n\n            rate ← rate * shrinkFactor\n\n            IF (ABS(stepX) ≤ threshold) AND (ABS(stepY) ≤ threshold) THEN\n                RETURN totalDistance\n            END IF\n        UNTIL FALSE\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getMinDistSum(positions)  \n        SET n TO the LENGTH OF positions  \n        SET x TO zero  \n        SET y TO zero  \n        FOR each position IN positions  \n            SET x1 TO the first element AT position  \n            SET y1 TO the second element AT position  \n            INCREMENT x BY x1  \n            INCREMENT y BY y1  \n        END FOR  \n        SET x TO x DIVIDED BY n  \n        SET y TO y DIVIDED BY n  \n        SET decay TO zero POINT nine nine nine  \n        SET eps TO zero POINT zero zero zero zero zero one  \n        SET alpha TO zero POINT five  \n        WHILE TRUE  \n            SET grad_x TO zero  \n            SET grad_y TO zero  \n            SET dist TO zero  \n            FOR each position IN positions  \n                SET x1 TO the first element AT position  \n                SET y1 TO the second element AT position  \n                SET a TO x MINUS x1  \n                SET b TO y MINUS y1  \n                SET c TO the square root of a MULTIPLIED BY a PLUS b MULTIPLIED BY b  \n                INCREMENT grad_x BY a DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT grad_y BY b DIVIDED BY c PLUS zero POINT zero zero zero zero zero zero zero one  \n                INCREMENT dist BY c  \n            END FOR  \n            SET dx TO grad_x MULTIPLIED BY alpha  \n            SET dy TO grad_y MULTIPLIED BY alpha  \n            DECREMENT x BY dx  \n            DECREMENT y BY dy  \n            MULTIPLY alpha BY decay  \n            IF the absolute value of dx IS LESS THAN OR EQUAL TO eps AND the absolute value of dy IS LESS THAN OR EQUAL TO eps  \n                RETURN dist  \n            END IF  \n        END WHILE  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-cut-a-stick", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minCost(n, cuts)\n        SET boundaries TO an ordered collection formed by merging cuts WITH [0, n]\n        \n        FUNCTION dp(start, end)\n            IF NOT (end - start > 1) THEN\n                OUTPUT 0\n            END IF\n            \n            SET lowest_cost TO a very large number\n            SET index_tracker TO start + 1\n            WHILE index_tracker < end\n                SET segment_cost TO (boundaries[end] - boundaries[start]) + dp(start, index_tracker) + dp(index_tracker, end)\n                \n                IF NOT (lowest_cost <= segment_cost) THEN\n                    SET lowest_cost TO segment_cost\n                END IF\n                \n                ADD 1 TO index_tracker\n            END WHILE\n            \n            OUTPUT lowest_cost\n        END FUNCTION\n        \n        OUTPUT dp(0, LENGTH(boundaries) - 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO sorted list consisting of all elements of cuts PLUS zero PLUS n  \n        \n        FUNCTION dp(left, right)  \n            IF right MINUS left LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing positive infinity  \n            FOR i FROM left PLUS one TO right MINUS one  \n                SET cost TO element at position right of cuts MINUS element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-instructions", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION kthSmallestPath(destination PARAMETERS destination AND k)  \n        SET xPos AS destination AT index 0  \n        SET yPos AS destination AT index 1  \n        SET resultPath AS an empty list  \n        SET stepsTotal AS xPos PLUS yPos  \n        SET counter AS 0  \n        WHILE counter NOT EQUAL stepsTotal  \n            IF yPos NOT EQUAL 0 THEN  \n                SET combCount AS combinations(xPos PLUS yPos MINUS 1, yPos MINUS 1)  \n                IF k GREATER THAN combCount THEN  \n                    APPEND 'V' TO resultPath  \n                    SET xPos AS xPos MINUS 1  \n                    SET k AS k MINUS combCount  \n                ELSE  \n                    APPEND 'H' TO resultPath  \n                    SET yPos AS yPos MINUS 1  \n                END IF  \n            ELSE  \n                APPEND 'V' TO resultPath  \n                SET xPos AS xPos MINUS 1  \n            END IF  \n            SET counter AS counter PLUS 1  \n        END WHILE  \n        RETURN combined string of elements in resultPath  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallestPath(destination PARAMETERS destination AND k)  \n        SET row TO element at position zero of destination  \n        SET col TO element at position one of destination  \n        SET path TO empty list  \n        SET total_moves TO col PLUS row  \n        FOR i FROM zero TO total_moves MINUS one  \n            IF col GREATER THAN zero  \n                SET paths_with_H TO the number of combinations of row PLUS col MINUS one TAKEN col MINUS one  \n                IF k LESS THAN OR EQUAL TO paths_with_H  \n                    APPEND character H TO path  \n                    DECREMENT col BY one  \n                ELSE  \n                    APPEND character V TO path  \n                    DECREMENT row BY one  \n                    DECREMENT k BY paths_with_H  \n                END IF  \n            ELSE  \n                APPEND character V TO path  \n                DECREMENT row BY one  \n            END IF  \n        END FOR  \n        RETURN concatenation of all elements in path as a string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canMouseWin(grid, catJump, mouseJump)\n        ASSIGN rows_count ← SIZE OF grid\n        ASSIGN cols_count ← SIZE OF grid AT zero\n        ASSIGN cat_init ← 0\n        ASSIGN mouse_init ← 0\n        ASSIGN food_pos ← 0\n        ASSIGN directions ← [ -1, 0, 1, 0, -1 ]\n        ASSIGN mouse_graph ← LIST OF EMPTY LISTS REPEATED rows_count * cols_count TIMES\n        ASSIGN cat_graph ← LIST OF EMPTY LISTS REPEATED rows_count * cols_count TIMES\n\n        FOR each row_index, row_val IN ENUMERATE(grid)\n            FOR each col_index, cell IN ENUMERATE(row_val)\n                IF cell IS EQUAL TO '#'\n                    CONTINUE TO NEXT LOOP ITERATION\n                END IF\n                ASSIGN vertex ← (row_index * cols_count) + col_index\n                IF cell IS 'C'\n                    ASSIGN cat_init ← vertex\n                ELSE IF cell IS 'M'\n                    ASSIGN mouse_init ← vertex\n                ELSE IF cell IS 'F'\n                    ASSIGN food_pos ← vertex\n                END IF\n\n                FOR pos IN 0 TO LENGTH(directions) - 2\n                    ASSIGN delta_x ← directions[pos]\n                    ASSIGN delta_y ← directions[pos + 1]\n\n                    FOR step FROM 0 TO mouseJump\n                        ASSIGN new_x ← row_index + step * delta_x\n                        ASSIGN new_y ← col_index + step * delta_y\n                        IF new_x < 0 OR new_x >= rows_count OR new_y < 0 OR new_y >= cols_count OR grid[new_x][new_y] = '#'\n                            LEAVE INNER LOOP\n                        END IF\n                        APPEND (new_x * cols_count + new_y) TO mouse_graph[vertex]\n                    END FOR\n\n                    FOR step FROM 0 TO catJump\n                        ASSIGN new_x ← row_index + step * delta_x\n                        ASSIGN new_y ← col_index + step * delta_y\n                        IF new_x < 0 OR new_x >= rows_count OR new_y < 0 OR new_y >= cols_count OR grid[new_x][new_y] = '#'\n                            LEAVE INNER LOOP\n                        END IF\n                        APPEND (new_x * cols_count + new_y) TO cat_graph[vertex]\n                    END FOR\n                END FOR\n            END FOR\n        END FOR\n        RETURN calc(mouse_graph, cat_graph, mouse_init, cat_init, food_pos) IS EQUAL TO 1\n    END FUNCTION\n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)\n        FUNCTION get_prev_states(state)\n            ASSIGN mouse_pos ← state[0]\n            ASSIGN cat_pos ← state[1]\n            ASSIGN turn_indicator ← state[2]\n            ASSIGN prev_turn ← turn_indicator XOR 1\n            ASSIGN results ← EMPTY LIST\n\n            IF prev_turn = 1\n                FOR each candidate_cat IN g_cat[cat_pos]\n                    IF ans[mouse_pos][candidate_cat][1] = 0\n                        APPEND (mouse_pos, candidate_cat, prev_turn) TO results\n                    END IF\n                END FOR\n            ELSE\n                FOR each candidate_mouse IN g_mouse[mouse_pos]\n                    IF ans[candidate_mouse][cat_pos][0] = 0\n                        APPEND (candidate_mouse, cat_pos, 0) TO results\n                    END IF\n                END FOR\n            END IF\n            RETURN results\n        END FUNCTION\n\n        ASSIGN total_states ← SIZE OF g_mouse\n        ASSIGN degree ← 3D ARRAY FILLED WITH 0 WITH DIMENSIONS [total_states][total_states][2]\n\n        FOR outer FROM 0 TO total_states - 1\n            FOR inner FROM 0 TO total_states - 1\n                degree[outer][inner][0] ← SIZE OF g_mouse[outer]\n                degree[outer][inner][1] ← SIZE OF g_cat[inner]\n            END FOR\n        END FOR\n\n        ASSIGN ans ← 3D ARRAY FILLED WITH 0 WITH DIMENSIONS [total_states][total_states][2]\n        ASSIGN queue ← EMPTY DOUBLE-ENDED QUEUE\n\n        FOR index FROM 0 TO total_states - 1\n            ans[hole][index][1] ← 1\n            ans[index][hole][0] ← 2\n            ans[index][index][1] ← 2\n            ans[index][index][0] ← 2\n\n            APPEND (hole, index, 1) TO queue\n            APPEND (index, hole, 0) TO queue\n            APPEND (index, index, 0) TO queue\n            APPEND (index, index, 1) TO queue\n        END FOR\n\n        WHILE queue IS NOT EMPTY\n            ASSIGN current_state ← POP LEFT FROM queue\n            ASSIGN current_value ← ans[current_state[0]][current_state[1]][current_state[2]]\n\n            FOR each predecessor IN get_prev_states(current_state)\n                ASSIGN pm ← predecessor[0]\n                ASSIGN pc ← predecessor[1]\n                ASSIGN pt ← predecessor[2]\n\n                IF pt = current_value - 1\n                    ans[pm][pc][pt] ← current_value\n                    APPEND predecessor TO queue\n                ELSE\n                    degree[pm][pc][pt] ← degree[pm][pc][pt] - 1\n                    IF degree[pm][pc][pt] = 0\n                        ans[pm][pc][pt] ← current_value\n                        APPEND predecessor TO queue\n                    END IF\n                END IF\n            END FOR\n        END WHILE\n        RETURN ans[mouse_start][cat_start][0]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the LIST of MINUS one zero ONE zero MINUS one  \n        SET g_mouse TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n        SET g_cat TO a LIST containing an empty LIST repeated m MULTIPLIED BY n times  \n\n        FOR each index i AND element row IN the ENUMERATION OF grid  \n            FOR each index j AND element c IN the ENUMERATION OF row  \n                IF c EQUALS the character representing a HASH  \n                    CONTINUE  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character representing uppercase C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character representing uppercase M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character representing uppercase F  \n                    SET food TO v  \n                END IF  \n                FOR each element a AND next element b IN consecutive pairs of dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR element at position x AND position y of grid EQUALS the character representing a HASH  \n                            BREAK  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the RESULT OF calling calc WITH g_mouse, g_cat, mouse_start, cat_start, food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            SET m TO element at position zero of state  \n            SET c TO element at position one of state  \n            SET t TO element at position two of state  \n            SET pt TO the EXCLUSIVE OR of t AND one  \n            SET pre TO an empty LIST  \n            IF pt EQUALS one  \n                FOR each pc IN element at position c of g_cat  \n                    IF element at position m AND position pc AND position one of ans EQUALS zero  \n                        APPEND the TUPLE of m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN element at position m of g_mouse  \n                    IF element at position pm AND position c AND position zero of ans EQUALS zero  \n                        APPEND the TUPLE of pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET element at position zero of element at position j of element at position i of degree TO the LENGTH OF element at position i of g_mouse  \n                SET element at position one of element at position j of element at position i of degree TO the LENGTH OF element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a LIST containing a LIST containing a LIST of zero zero repeated twice repeated n times repeated n times  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET element at position hole AND position i AND position one of ans TO one  \n            SET element at position i AND position hole AND position zero of ans TO two  \n            SET element at position i AND position i AND position one of ans TO two  \n            SET element at position i AND position i AND position zero of ans TO two  \n            ADD the TUPLE of hole i one TO the end of q  \n            ADD the TUPLE of i hole zero TO the end of q  \n            ADD the TUPLE of i i zero TO the end of q  \n            ADD the TUPLE of i i one TO the end of q  \n        END FOR  \n        WHILE q is not empty  \n            REMOVE the element from the front of q AND ASSIGN to state  \n            SET t TO element at position zero AND position one AND position two of ans ACCORDING TO state  \n            FOR each prev_state IN get_prev_states WITH state  \n                SET pm TO element at position zero of prev_state  \n                SET pc TO element at position one of prev_state  \n                SET pt TO element at position two of prev_state  \n                IF pt EQUALS t MINUS one  \n                    SET element at position pm AND position pc AND position pt of ans TO t  \n                    ADD prev_state TO the end of q  \n                ELSE  \n                    DECREMENT element at position pm AND position pc AND position pt of degree BY one  \n                    IF element at position pm AND position pc AND position pt of degree EQUALS zero  \n                        SET element at position pm AND position pc AND position pt of ans TO t  \n                        ADD prev_state TO the end of q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN element at position mouse_start AND position cat_start AND position zero of ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-floored-pairs", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION sumOfFlooredPairs(nums)\n        ASSIGN MOD ← 1_000_000_001\n        ASSIGN max_val ← MAXIMUM element in nums\n        ASSIGN freq_map ← DICTIONARY mapping elements in nums TO their respective counts\n        ASSIGN prefix_arr ← ARRAY filled with 0, of size (max_val + 1)\n\n        FOR EACH element IN freq_map DO\n            prefix_arr[element] ← prefix_arr[element] + freq_map[element]\n        END FOR\n\n        SET idx ← 1\n        WHILE idx ≤ max_val DO\n            prefix_arr[idx] ← prefix_arr[idx] + prefix_arr[idx - 1]\n            idx ← idx + 1\n        END WHILE\n\n        ASSIGN ans ← 0\n\n        FOR key IN freq_map DO\n            ASSIGN multiplier ← 1\n            WHILE multiplier * key ≤ max_val DO\n                ASSIGN range_start ← multiplier * key\n                \n                IF multiplier * key + key - 1 ≤ max_val THEN\n                    ASSIGN range_end ← multiplier * key + key - 1\n                ELSE\n                    ASSIGN range_end ← max_val\n                END IF\n                \n                ASSIGN count_in_range ← prefix_arr[range_end] - prefix_arr[range_start - 1]\n                ans ← (ans + (count_in_range * multiplier * freq_map[key])) MOD MOD\n                multiplier ← multiplier + 1\n            END WHILE\n        END FOR\n\n        RETURN ans\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION sumOfFlooredPairs(nums)  \n        SET MOD TO ten raised to the power of nine PLUS one  \n        SET max_num TO the maximum element in nums  \n        SET count TO a mapping from elements in nums to their frequencies  \n        SET prefix_sum TO a list of zeroes with length max_num PLUS one  \n        \n        FOR each num IN count  \n            INCREMENT element at position num of prefix_sum BY the frequency of num in count  \n        END FOR  \n        \n        FOR index FROM one TO max_num  \n            INCREMENT element at position index of prefix_sum BY element at position index MINUS one of prefix_sum  \n        END FOR  \n        \n        SET result TO zero  \n        \n        FOR each num IN count  \n            FOR multiple FROM one TO the integer division of max_num BY num  \n                SET start TO num MULTIPLIED BY multiple  \n                IF num MULTIPLIED BY the sum of multiple PLUS one MINUS one LESS THAN OR EQUAL TO max_num  \n                    SET end TO num MULTIPLIED BY multiple PLUS one MINUS one  \n                ELSE  \n                    SET end TO max_num  \n                END IF  \n                SET multiples_count TO element at position end of prefix_sum MINUS element at position start MINUS one of prefix_sum  \n                INCREMENT result BY multiples_count MULTIPLIED BY multiple MULTIPLIED BY the frequency of num in count  \n                SET result TO result MODULO MOD  \n            END FOR  \n        END FOR  \n        \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "delete-duplicate-folders-in-system", "label": "cosmetic", "pseudocode": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        LET alphaChildren BE a newly created default dictionary that returns TrieNode objects  \n        ASSIGN self.children ← alphaChildren  \n        SET self.deleted AS False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION deleteDuplicateFolder(self, paths)  \n        LET collectedResults BE an empty list  \n        INITIALIZE root TO a new TrieNode instance  \n        LET groupsBySubtree BE a fresh default dictionary that defaults to empty lists  \n\n        LET indexA BE 0  \n        LET sortedPaths BE paths arranged in ascending order  \n        WHILE indexA < LENGTH OF sortedPaths  \n            LET currentPath BE sortedPaths[indexA]  \n            LET cursorNode BE root  \n\n            LET indexB BE 0  \n            WHILE indexB < LENGTH OF currentPath  \n                LET folderName BE currentPath[indexB]  \n                cursorNode ← cursorNode.children[folderName]  \n                indexB ← indexB + 1  \n            END WHILE  \n\n            indexA ← indexA + 1  \n        END WHILE  \n\n        FUNCTION buildSubtreeToRoots(node)  \n            LET componentList BE \"(\"  \n            LET keyCollection BE KEYS OF node.children  \n            LET idx BE 0  \n            WHILE idx < LENGTH OF keyCollection  \n                LET keyString BE keyCollection[idx]  \n                LET childNode BE node.children[keyString]  \n                LET childSubtree BE buildSubtreeToRoots(childNode)  \n                componentList ← componentList + keyString + childSubtree  \n                idx ← idx + 1  \n            END WHILE  \n            componentList ← componentList + \")\"  \n\n            IF componentList <> \"()\" THEN  \n                groupsBySubtree[componentList].APPEND(node)  \n            END IF  \n\n            RETURN componentList  \n        END FUNCTION  \n\n        CALL buildSubtreeToRoots WITH root  \n\n        FOR EACH nodeGroup IN groupsBySubtree.VALUES() DO  \n            IF LENGTH OF nodeGroup > 1 THEN  \n                LET pos BE 0  \n                WHILE pos < LENGTH OF nodeGroup  \n                    LET currentNode TO nodeGroup[pos]  \n                    currentNode.deleted ← True  \n                    pos ← pos + 1  \n                END WHILE  \n            END IF  \n        END FOR  \n\n        FUNCTION constructPath(node, path)  \n            LET keysList BE node.children.KEYS()  \n            LET i BE 0  \n            WHILE i < LENGTH OF keysList  \n                LET keyName BE keysList[i]  \n                LET childNode BE node.children[keyName]  \n                IF childNode.deleted = False THEN  \n                    constructPath(childNode, path + [keyName])  \n                END IF  \n                i ← i + 1  \n            END WHILE  \n            IF LENGTH OF path > 0 THEN  \n                collectedResults.APPEND(path)  \n            END IF  \n        END FUNCTION  \n\n        constructPath(root, [])  \n        RETURN collectedResults  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS TrieNode  \n    FUNCTION __init__(self)  \n        SET self.children TO a new default dictionary that creates TrieNode objects  \n        SET self.deleted TO False  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION deleteDuplicateFolder(self, paths)  \n        SET ans TO an empty list  \n        SET root TO a new TrieNode object  \n        SET subtreeToNodes TO a new default dictionary with list as default value  \n\n        FOR each path IN the sorted order of paths  \n            SET node TO root  \n            FOR each s IN path  \n                SET node TO the child node of node.children corresponding to the element s  \n            END FOR  \n        END FOR  \n\n        FUNCTION buildSubtreeToRoots(node)  \n            SET subtree TO the concatenation of an opening parenthesis WITH  \n                the concatenation FOR each s IN the children of node OF  \n                    the element s concatenated WITH buildSubtreeToRoots called with the child node corresponding to s  \n                AND THEN a closing parenthesis  \n            IF subtree NOT EQUALS the string consisting of opening and closing parenthesis with nothing in between  \n                APPEND node TO the list in subtreeToNodes corresponding to the key subtree  \n            END IF  \n            RETURN subtree  \n        END FUNCTION  \n\n        CALL buildSubtreeToRoots with root as argument  \n\n        FOR each nodes IN the values of subtreeToNodes  \n            IF the length of nodes GREATER THAN one  \n                FOR each node IN nodes  \n                    SET node.deleted TO True  \n                END FOR  \n            END IF  \n        END FOR  \n\n        FUNCTION constructPath(node, path)  \n            FOR each pair of s and child IN the items of node.children  \n                IF child.deleted EQUALS False  \n                    CALL constructPath with child and the concatenation of path WITH the element s as a new list  \n                END IF  \n            END FOR  \n            IF the length of path GREATER THAN zero  \n                APPEND path TO ans  \n            END IF  \n        END FUNCTION  \n\n        CALL constructPath with root and an empty list as arguments  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "gcd-sort-of-an-array", "label": "cosmetic", "pseudocode": "CLASS UnionFind  \n  FUNCTION __init__(self, size)  \n    LET ancestry_list BE empty list  \n    LET hierarchy_levels BE empty list  \n    LET index_counter BE 0  \n    WHILE index_counter LESS THAN OR EQUAL TO size MINUS 1  \n      APPEND index_counter TO ancestry_list  \n      INCREMENT index_counter BY 1  \n    END WHILE  \n    LET copy_counter BE 0  \n    WHILE copy_counter LESS THAN size  \n      APPEND 1 TO hierarchy_levels  \n      INCREMENT copy_counter BY 1  \n    END WHILE  \n    ASSIGN self.parent TO ancestry_list  \n    ASSIGN self.rank TO hierarchy_levels  \n  END FUNCTION  \n  \n  FUNCTION find(self, p)  \n    IF self.parent[p] IS NOT EQUAL TO p  \n      ASSIGN self.parent[p] TO self.find(self.parent[p])  \n    END IF  \n    RETURN self.parent[p]  \n  END FUNCTION  \n  \n  FUNCTION union(self, p, q)  \n    LET rootA BE self.find(p)  \n    LET rootB BE self.find(q)  \n    IF NOT (rootA IS NOT rootB)  \n      RETURN False  \n    END IF  \n    IF self.rank[rootA] GREATER THAN self.rank[rootB]  \n      ASSIGN self.parent[rootB] TO rootA  \n    ELSE IF NOT (self.rank[rootA] GREATER THAN OR EQUAL TO self.rank[rootB])  \n      ASSIGN self.parent[rootA] TO rootB  \n    ELSE  \n      ASSIGN self.parent[rootB] TO rootA  \n      LET current_rank BE self.rank[rootA]  \n      LET updated_rank BE current_rank PLUS 1  \n      ASSIGN self.rank[rootA] TO updated_rank  \n    END IF  \n    RETURN True  \n  END FUNCTION  \nEND CLASS  \n  \nCLASS Solution  \n  FUNCTION gcdSort(self, nums)  \n    LET ordered_nums BE new list of elements of nums sorted by ascending order  \n    LET peak_value BE nums[0]  \n    LET idx_check BE 1  \n    WHILE idx_check LESS THAN LENGTH of nums  \n      IF nums[idx_check] GREATER THAN peak_value  \n        ASSIGN peak_value TO nums[idx_check]  \n      END IF  \n      INCREMENT idx_check BY 1  \n    END WHILE  \n  \n    LET union_struct BE UnionFind(peak_value PLUS 1)  \n  \n    LET outer_pos BE 0  \n    WHILE outer_pos LESS THAN LENGTH of nums  \n      LET current_element BE nums[outer_pos]  \n      LET factor_check BE 2  \n      LET limit_factor BE INTEGER(SQRT(current_element)) PLUS 1  \n      WHILE factor_check LESS THAN limit_factor  \n        LET division_remainder BE (current_element MINUS factor_check * (current_element DIV factor_check))  \n        IF division_remainder IS EQUAL TO 0  \n          union_struct.union(current_element, factor_check)  \n          union_struct.union(current_element, current_element DIV factor_check)  \n        END IF  \n        INCREMENT factor_check BY 1  \n      END WHILE  \n      INCREMENT outer_pos BY 1  \n    END WHILE  \n  \n    LET compare_index BE 0  \n    WHILE compare_index LESS THAN LENGTH of nums  \n      LET original_parent BE union_struct.find(nums[compare_index])  \n      LET sorted_parent BE union_struct.find(ordered_nums[compare_index])  \n      IF original_parent IS NOT EQUAL TO sorted_parent  \n        RETURN False  \n      END IF  \n      INCREMENT compare_index BY 1  \n    END WHILE  \n  \n    RETURN True  \n  END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS UnionFind  \n    FUNCTION __init__(self, size)  \n        SET self.parent TO list of integers from zero TO size MINUS one  \n        SET self.rank TO list containing size copies of one  \n    END FUNCTION  \n\n    FUNCTION find(self, p)  \n        IF element at position p of self.parent NOT EQUALS p  \n            SET element at position p of self.parent TO self.find(element at position p of self.parent)  \n        END IF  \n        RETURN element at position p of self.parent  \n    END FUNCTION  \n\n    FUNCTION union(self, p, q)  \n        SET rootP TO self.find(p)  \n        SET rootQ TO self.find(q)  \n        IF rootP EQUALS rootQ  \n            RETURN False  \n        END IF  \n        IF element at position rootP of self.rank GREATER THAN element at position rootQ of self.rank  \n            SET element at position rootQ of self.parent TO rootP  \n        ELSE IF element at position rootP of self.rank LESS THAN element at position rootQ of self.rank  \n            SET element at position rootP of self.parent TO rootQ  \n        ELSE  \n            SET element at position rootQ of self.parent TO rootP  \n            INCREMENT element at position rootP of self.rank BY one  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION gcdSort(self, nums)  \n        SET sorted_nums TO nums sorted in ascending order  \n        SET max_val TO the maximum value in nums  \n        SET uf TO a new UnionFind object initialized with max_val PLUS one  \n\n        FOR each num IN nums  \n            FOR each factor FROM two TO the integer part of the square root of num PLUS one  \n                IF num MODULO factor EQUALS zero  \n                    CALL uf.union(num, factor)  \n                    CALL uf.union(num, num DIVIDED BY factor)  \n                END IF  \n            END FOR  \n        END FOR  \n\n        FOR each i FROM zero TO the length of nums MINUS one  \n            IF uf.find(element at position i of nums) NOT EQUALS uf.find(element at position i of sorted_nums)  \n                RETURN False  \n            END IF  \n        END FOR  \n\n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-and-sum-of-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maximumANDSum(nums numSlots)\n        FUNCTION dp(index slots)\n            IF NOT (index DIFFERENT FROM LENGTH OF nums) THEN\n                YIELD zero\n            END IF\n\n            ASSIGN zero TO highest_and\n            ASSIGN list(slots) TO modifiable_slots\n\n            SET iterator TO zero\n            WHILE iterator LESS THAN numSlots DO\n                IF modifiable_slots[iterator] LESS THAN 2 THEN\n                    ASSIGN (modifiable_slots[iterator] + 1) TO modifiable_slots[iterator]\n                    ASSIGN ( (nums[index] BITWISE-AND (iterator + 1)) + dp(index + 1, tuple(modifiable_slots)) ) TO current_and\n                    IF current_and GREATER THAN highest_and THEN\n                        ASSIGN current_and TO highest_and\n                    END IF\n                    ASSIGN (modifiable_slots[iterator] - 1) TO modifiable_slots[iterator]\n                END IF\n                INCREMENT iterator BY 1\n            END WHILE\n\n            YIELD highest_and\n        END FUNCTION\n\n        ASSIGN tuple REPEATED zero NUMSLOTS TIMES TO start_slots\n        RETURN dp(zero, start_slots)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maximumANDSum(nums numSlots)  \n        FUNCTION dp(index slots)  \n            IF index EQUALS LENGTH OF nums  \n                RETURN zero  \n            END IF  \n              \n            SET max_and_sum TO zero  \n            SET slots_list TO list converted from slots  \n              \n            FOR i FROM zero TO numSlots MINUS one  \n                IF element at position i of slots_list LESS THAN two  \n                    INCREMENT element at position i of slots_list BY one  \n                    SET and_sum TO bitwise AND of element at position index of nums AND i PLUS one PLUS dp function called with index PLUS one AND tuple converted from slots_list  \n                    IF and_sum GREATER THAN max_and_sum  \n                        SET max_and_sum TO and_sum  \n                    END IF  \n                    DECREMENT element at position i of slots_list BY one  \n                END IF  \n            END FOR  \n              \n            RETURN max_and_sum  \n        END FUNCTION  \n          \n        SET initial_slots TO tuple consisting of zero repeated numSlots times  \n        RETURN dp function called with zero AND initial_slots  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-of-one-repeating-character", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestRepeating(s queryCharacters queryIndices)\n        FUNCTION merge_intervals()\n            SET counter AS 0\n            WHILE counter < (LENGTH(intervals) - 1)\n                SET currentTriplet TO intervals[counter]\n                SET nextTriplet TO intervals[counter + 1]\n                IF (currentTriplet[2] = nextTriplet[2])\n                    SET mergedStart TO currentTriplet[0]\n                    SET mergedEnd TO (currentTriplet[1] + 1)\n                    SET mergedChar TO currentTriplet[2]\n                    SET intervals[counter] AS (mergedStart, mergedEnd, mergedChar)\n                    REMOVE intervals[counter + 1]\n                ELSE\n                    SET counter AS (counter + 1)\n                END IF\n            END WHILE\n        END FUNCTION\n\n        SET intervals AS []\n        SET lengthOfS AS LENGTH(s)\n        SET initialPos AS 0\n        SET positionTracker AS 1\n        WHILE positionTracker < lengthOfS\n            IF s[positionTracker] ≠ s[initialPos]\n                APPEND (initialPos, (positionTracker - 1), s[initialPos]) TO intervals\n                SET initialPos AS positionTracker\n            END IF\n            SET positionTracker AS (positionTracker + 1)\n        END WHILE\n        APPEND (initialPos, (lengthOfS - 1), s[initialPos]) TO intervals\n\n        SET outputList AS []\n        SET maxLength AS MAXIMUM OVER EACH (start, end, c) IN intervals OF ((end - start) + 1)\n\n        FOR EACH charValue indexValue IN PAIRS(queryCharacters, queryIndices)\n            SET intervalIndex AS 0\n            WHILE intervalIndex < LENGTH(intervals)\n                SET (segmentStart, segmentEnd, segmentChar) AS intervals[intervalIndex]\n                IF (segmentStart ≤ indexValue) AND (indexValue ≤ segmentEnd)\n                    EXIT WHILE\n                END IF\n                SET intervalIndex AS (intervalIndex + 1)\n            END WHILE\n\n            IF indexValue > segmentStart\n                INSERT AT intervals[intervalIndex] THE TUPLE (segmentStart, (indexValue - 1), segmentChar)\n                SET intervals[intervalIndex + 1] AS (indexValue, segmentEnd, segmentChar)\n            END IF\n            IF indexValue < segmentEnd\n                INSERT AT intervals[intervalIndex + 1] THE TUPLE ((indexValue + 1), segmentEnd, segmentChar)\n                SET intervals[intervalIndex] AS (segmentStart, indexValue, segmentChar)\n            END IF\n\n            SET intervals[intervalIndex] AS (intervals[intervalIndex][0], intervals[intervalIndex][1], charValue)\n\n            CALL merge_intervals()\n\n            SET maxLength AS MAXIMUM OVER EACH (start, end, c) IN intervals OF ((end - start) + 1)\n            APPEND maxLength TO outputList\n        END FOR\n\n        RETURN outputList\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestRepeating(s queryCharacters queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF the character element at position three of element at position i of intervals EQUALS the character element at position three of element at position i PLUS one of intervals  \n                    SET element at position i of intervals TO a tuple consisting of element at position one of element at position i of intervals COMMA element at position two of element at position i PLUS one of intervals COMMA character element at position three of element at position i of intervals  \n                    REMOVE element at position i PLUS one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n        \n        SET intervals TO an empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple consisting of start COMMA i MINUS one COMMA element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple consisting of start COMMA n MINUS one COMMA element at position start of s TO intervals  \n        \n        SET results TO an empty list  \n        SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n        \n        FOR each char idx IN the corresponding pairs of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start end c TO the tuple element at position i of intervals  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n            \n            IF idx GREATER THAN start  \n                INSERT a tuple consisting of start COMMA idx MINUS one COMMA c AT position i OF intervals  \n                SET element at position i PLUS one of intervals TO a tuple consisting of idx COMMA end COMMA c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT a tuple consisting of idx PLUS one COMMA end COMMA c AT position i PLUS one OF intervals  \n                SET element at position i of intervals TO a tuple consisting of start COMMA idx COMMA c  \n            END IF  \n            \n            SET element at position i of intervals TO a tuple consisting of the first element of element at position i of intervals COMMA the second element of element at position i of intervals COMMA char  \n            \n            CALL merge_intervals()  \n            \n            SET longest TO the maximum value of the difference between end and start PLUS one FOR each tuple of start end char IN intervals  \n            APPEND longest TO results  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "check-if-there-is-a-valid-parentheses-string-path", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET totalRows AS the LENGTH OF grid  \n        SET totalColumns AS the LENGTH OF element at position zero of grid  \n        \n        IF ( (totalRows PLUS totalColumns MINUS 1) MOD 2 ) IS NOT EQUAL TO 0  \n            RETURN false  \n        END IF  \n        \n        INITIALIZE dp AS a three-dimensional array of size (totalRows PLUS 1) BY (totalColumns PLUS 1) BY (totalRows PLUS totalColumns PLUS 1) FILLED WITH false  \n        \n        dp[1][0][0] ← true  \n        \n        SET rowIndex TO 0  \n        WHILE rowIndex LESS THAN totalRows  \n            SET columnIndex TO 0  \n            WHILE columnIndex LESS THAN totalColumns  \n                SET depthIndex TO 0  \n                WHILE depthIndex LESS THAN OR EQUAL TO totalRows PLUS totalColumns  \n                    IF (dp[rowIndex][columnIndex PLUS 1][depthIndex] OR dp[rowIndex PLUS 1][columnIndex][depthIndex]) IS true THEN  \n                        IF (grid[rowIndex][columnIndex] IS '(' AND depthIndex PLUS 1 LESS THAN totalRows PLUS totalColumns PLUS 1) THEN  \n                            dp[rowIndex PLUS 1][columnIndex PLUS 1][depthIndex PLUS 1] ← true  \n                        ELSE  \n                            IF (grid[rowIndex][columnIndex] IS ')' AND depthIndex MINUS 1 GREATER THAN OR EQUAL TO 0) THEN  \n                                dp[rowIndex PLUS 1][columnIndex PLUS 1][depthIndex MINUS 1] ← true  \n                            END IF  \n                        END IF  \n                    END IF  \n                    SET depthIndex TO depthIndex PLUS 1  \n                END WHILE  \n                SET columnIndex TO columnIndex PLUS 1  \n            END WHILE  \n            SET rowIndex TO rowIndex PLUS 1  \n        END WHILE  \n        \n        RETURN dp[totalRows][totalColumns][0]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION hasValidPath(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        \n        IF the sum of m PLUS n MINUS one MODULO two NOT EQUALS zero  \n            RETURN false  \n        END IF  \n        \n        SET dp TO a three dimensional collection of size m PLUS one BY n PLUS one BY m PLUS n PLUS one FILLED WITH false  \n        \n        SET element at position zero of element at position one of dp TO true  \n        \n        FOR i FROM zero TO m MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                FOR k FROM zero TO m PLUS n  \n                    IF element at position i of element at position j PLUS one of dp at position k OR element at position i PLUS one of element at position j of dp at position k  \n                        IF element at position i of element at position j of grid EQUALS the opening parenthesis AND k PLUS one LESS THAN m PLUS n PLUS one  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k PLUS one TO true  \n                        ELSE IF element at position i of element at position j of grid EQUALS the closing parenthesis AND k MINUS one GREATER THAN OR EQUAL TO zero  \n                            SET element at position i PLUS one of element at position j PLUS one of dp at position k MINUS one TO true  \n                        END IF  \n                    END IF  \n                END FOR  \n            END FOR  \n        END FOR  \n        \n        RETURN element at position m of element at position n of dp at position zero  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-subsequences", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(currentIndex, previousValue, sequenceAccumulator)  \n            IF currentIndex IS THE SAME AS LENGTH OF nums THEN  \n                IF LENGTH OF sequenceAccumulator EXCEEDS 1 THEN  \n                    APPEND COPY OF sequenceAccumulator INTO results  \n                END IF  \n                EXIT FUNCTION  \n            END IF  \n            IF nums[currentIndex] IS AT LEAST previousValue THEN  \n                ADD nums[currentIndex] TO sequenceAccumulator  \n                EXECUTE dfs WITH (currentIndex + 1, nums[currentIndex], sequenceAccumulator)  \n                DISCARD LAST ELEMENT FROM sequenceAccumulator  \n            END IF  \n            IF nums[currentIndex] IS DISTINCT FROM previousValue THEN  \n                INVOKE dfs WITH (currentIndex + 1, previousValue, sequenceAccumulator)  \n            END IF  \n        END FUNCTION  \n        INITIALIZE results AS EMPTY LIST  \n        INVOKE dfs WITH (0, -1000, EMPTY LIST)  \n        RETURN results  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findSubsequences(nums)  \n        FUNCTION dfs(u, last, t)  \n            IF u EQUALS the LENGTH OF nums  \n                IF the LENGTH OF t GREATER THAN one  \n                    APPEND a copy of t TO ans  \n                END IF  \n                RETURN  \n            END IF  \n            IF element at position u of nums GREATER THAN OR EQUAL TO last  \n                APPEND element at position u of nums TO t  \n                CALL dfs with arguments u PLUS one, element at position u of nums, t  \n                REMOVE last element FROM t  \n            END IF  \n            IF element at position u of nums NOT EQUALS last  \n                CALL dfs with arguments u PLUS one, last, t  \n            END IF  \n        END FUNCTION  \n        SET ans TO an empty list  \n        CALL dfs with arguments zero, negative one thousand, an empty list  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        INITIALIZE cache AS an empty list  \n        SET index TO 0  \n        WHILE index LESS THAN length of expression DO  \n            SET token TO expression[index]  \n            IF token IS \"(\" OR token IS \"&\" OR token IS \"|\" THEN  \n                INSERT (token, 0) AT END OF cache  \n                INCREMENT index BY 1  \n                CONTINUE WHILE  \n            ELSE IF token IS \")\" THEN  \n                SET group TO REMOVE and RETURN last element of cache  \n                DISCARD last element from cache (which must be the opening parenthesis)  \n            ELSE  \n                SET group TO (token, 1)  \n            END IF  \n\n            IF length of cache GREATER THAN 0 AND (cache[-1][0] IS \"&\" OR cache[-1][0] IS \"|\") THEN  \n                SET operatorPair TO REMOVE and RETURN last element of cache  \n                SET operator TO operatorPair[0]  \n\n                SET leftPair TO REMOVE and RETURN last element of cache  \n                SET leftValue TO leftPair[0]  \n                SET leftCost TO leftPair[1]  \n\n                SET rightValue TO group[0]  \n                SET rightCost TO group[1]  \n\n                IF operator IS \"&\" THEN  \n                    IF leftValue + rightValue EQUALS 0 THEN  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (0, 1 + minCost)  \n                    ELSE IF leftValue IS 0 AND rightValue IS 1 THEN  \n                        SET group TO (0, 1)  \n                    ELSE IF leftValue IS 1 AND rightValue IS 0 THEN  \n                        SET group TO (0, 1)  \n                    ELSE  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (1, minCost)  \n                    END IF  \n                ELSE  /* operator IS \"|\" */  \n                    IF leftValue + rightValue EQUALS 0 THEN  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (0, minCost)  \n                    ELSE IF leftValue IS 0 AND rightValue IS 1 THEN  \n                        SET group TO (1, 1)  \n                    ELSE IF leftValue IS 1 AND rightValue IS 0 THEN  \n                        SET group TO (1, 1)  \n                    ELSE  \n                        SET minCost TO leftCost  \n                        IF rightCost LESS THAN minCost THEN  \n                            SET minCost TO rightCost  \n                        END IF  \n                        SET group TO (1, 1 + minCost)  \n                    END IF  \n                END IF  \n            END IF  \n\n            INSERT group AT END OF cache  \n            INCREMENT index BY 1  \n        END WHILE  \n\n        RETURN cache[-1][1]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS an opening parenthesis OR element e EQUALS an ampersand OR element e EQUALS a vertical bar  \n                APPEND a tuple containing element e AND zero TO stack  \n                CONTINUE to the next iteration  \n            ELSE IF element e EQUALS a closing parenthesis  \n                SET lastPair TO the result of removing and returning the last element from stack  \n                REMOVE and discard the last element from stack corresponding to an opening parenthesis  \n            ELSE  \n                SET lastPair TO a tuple containing element e AND one  \n            END IF  \n            IF the length of stack IS GREATER THAN zero AND the first item of the last tuple in stack IS EQUAL TO an ampersand OR a vertical bar  \n                SET op TO the first element of the result of removing and returning the last tuple from stack  \n                SET a AND costA TO the elements of the result of removing and returning the last tuple from stack  \n                SET b AND costB TO the elements of lastPair  \n                IF op EQUALS an ampersand  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one PLUS the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND the smaller of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a tuple containing zero AND the smaller of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a tuple containing one AND one  \n                    ELSE  \n                        SET lastPair TO a tuple containing one AND one PLUS the smaller of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last tuple in stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "encode-string-with-shortest-length", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION encode(s)\n        FUNCTION get_encoded_length(count, substring)\n            ASSIGN LENGTH(TO_STRING(count)) + LENGTH(substring) + 2 TO result\n            GIVE BACK result\n        END FUNCTION\n\n        FUNCTION dp(i, j)\n            ASSIGN SUBSTRING(s; i; j + 1) TO segment\n            ASSIGN j + 1 - i TO segment_length\n            IF NOT(segment_length >= 5) THEN\n                GIVE BACK segment\n            END IF\n\n            ASSIGN segment TO minimal_encoding\n            ASSIGN 1 TO index_var\n            WHILE index_var <= (segment_length // 2 + 1)\n                IF segment_length MOD index_var = 0 THEN\n                    ASSIGN segment_length // index_var TO repetition_times\n                    ASSIGN TRUE TO matches_pattern\n                    ASSIGN SUBSTRING(segment; 0; index_var) TO pattern_piece\n\n                    IF segment = REPEAT(pattern_piece; repetition_times) THEN\n                        ASSIGN TO_STRING(repetition_times) + \"[\" + dp(i; i + index_var - 1) + \"]\" TO candidate_encoding\n                        IF LENGTH(candidate_encoding) < LENGTH(minimal_encoding) THEN\n                            ASSIGN candidate_encoding TO minimal_encoding\n                        END IF\n                    END IF\n                END IF\n                ASSIGN index_var + 1 TO index_var\n            END WHILE\n\n            ASSIGN i TO left_pointer\n            WHILE left_pointer <= j - 1\n                ASSIGN dp(i; left_pointer) TO left_part\n                ASSIGN dp(left_pointer + 1; j) TO right_part\n                ASSIGN left_part + right_part TO combined_candidate\n                IF LENGTH(combined_candidate) < LENGTH(minimal_encoding) THEN\n                    ASSIGN combined_candidate TO minimal_encoding\n                END IF\n                ASSIGN left_pointer + 1 TO left_pointer\n            END WHILE\n\n            GIVE BACK minimal_encoding\n        END FUNCTION\n\n        GIVE BACK dp(0; LENGTH(s) - 1)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION encode(s)  \n        FUNCTION get_encoded_length(count, substring)  \n            RETURN the LENGTH OF the string CONVERTED FROM count PLUS the LENGTH OF substring PLUS two  \n        END FUNCTION  \n\n        FUNCTION dp(i, j)  \n            SET substring TO the element at position i UP TO and INCLUDING position j OF s  \n            SET n TO j MINUS i PLUS one  \n            IF n LESS THAN five THEN  \n                RETURN substring  \n            END IF  \n\n            SET shortest TO substring  \n            FOR k FROM one TO n DIVIDED BY two PLUS one  \n                IF n MODULO k EQUALS zero THEN  \n                    SET repeat_count TO n DIVIDED BY k  \n                    IF substring EQUALS substring from position zero UP TO but NOT INCLUDING position k REPEATED repeat_count TIMES THEN  \n                        SET encoded_candidate TO string CONVERTED FROM repeat_count CONCATENATED WITH the LEFT SQUARE BRACKET CONCATENATED WITH dp(i, i PLUS k MINUS one) CONCATENATED WITH the RIGHT SQUARE BRACKET  \n                        IF the LENGTH OF encoded_candidate LESS THAN the LENGTH OF shortest THEN  \n                            SET shortest TO encoded_candidate  \n                        END IF  \n                    END IF  \n                END IF  \n            END FOR  \n\n            FOR k FROM i TO j MINUS one  \n                SET left_encoded TO dp(i, k)  \n                SET right_encoded TO dp(k PLUS one, j)  \n                SET combined TO left_encoded CONCATENATED WITH right_encoded  \n                IF the LENGTH OF combined LESS THAN the LENGTH OF shortest THEN  \n                    SET shortest TO combined  \n                END IF  \n            END FOR  \n\n            RETURN shortest  \n        END FUNCTION  \n\n        RETURN dp(zero, the LENGTH OF s MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION getProbability(balls)\n        FUNCTION dfs(i, j, diff)\n            IF i IS AT LEAST k THEN\n                RETURN 1 IF j IS 0 AND diff IS 0 OTHERWISE 0\n            END IF\n            IF j IS LESS THAN 0 THEN\n                RETURN 0\n            END IF\n            ASSIGN 0 TO result\n            ASSIGN 0 TO idx\n            WHILE idx <= balls[i] DO\n                IF idx IS balls[i] THEN\n                    ASSIGN 1 TO val\n                ELSEIF idx IS 0 THEN\n                    ASSIGN -1 TO val\n                ELSE\n                    ASSIGN 0 TO val\n                END IF\n                ASSIGN result + (dfs(i + 1, j - idx, diff + val) * (combination(balls[i], idx))) TO result\n                INCREMENT idx BY 1\n            END WHILE\n            RETURN result\n        END FUNCTION\n\n        ASSIGN (SUM over element IN balls) / 2 TO half_total\n        ASSIGN LENGTH(balls) TO k\n        RETURN dfs(0, half_total, 0) / combination(half_total + half_total, half_total)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(i, j, diff)  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i of balls INCLUSIVE  \n                IF x EQUALS element at position i of balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO minus one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS dfs(i PLUS one, j MINUS x, diff PLUS y) MULTIPLIED BY combination of element at position i of balls CHOOSE x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO LENGTH OF balls  \n        RETURN dfs(zero, n, zero) DIVIDED BY combination of n PLUS n CHOOSE n  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "find-the-derangement-of-an-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION findDerangement(n)\n        ASSIGN (10 ^ 9 + 7) TO modulus\n        \n        IF NOT (n <> 1) THEN\n            RETURN 0\n        END IF\n        \n        IF NOT (n <> 2) THEN\n            RETURN 1\n        END IF\n        \n        ASSIGN 1 TO alpha\n        ASSIGN 0 TO beta\n        \n        ASSIGN 3 TO omega\n        \n        WHILE omega <= n\n            ASSIGN (omega - 1) * (beta + alpha) TO delta\n            ASSIGN delta - (delta / modulus) * modulus TO delta        # delta MOD modulus without using MOD operator directly\n            ASSIGN alpha TO beta\n            ASSIGN delta TO alpha\n            ASSIGN omega + 1 TO omega\n        END WHILE\n        \n        RETURN alpha\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION findDerangement(n)  \n        SET MODULO TO ten RAISED TO THE POWER OF nine PLUS seven  \n        \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        \n        IF n EQUALS two  \n            RETURN one  \n        END IF  \n        \n        SET previous_twice TO one  \n        SET previous_once TO zero  \n        \n        FOR integer i FROM three TO n  \n            SET current_value TO integer i MINUS one MULTIPLIED BY the SUM OF previous_once AND previous_twice  \n            SET current_value TO current_value MODULO MODULO  \n            SET previous_twice TO previous_once  \n            SET previous_once TO current_value  \n        END FOR  \n        \n        RETURN previous_once  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "kth-smallest-product-of-two-sorted-arrays", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)\n\n        FUNCTION count(p PARAMETER)\n            ASSIGN 0 TO tally\n            ASSIGN LENGTH OF nums2 TO lengthB\n            ASSIGN 0 TO idxA\n            WHILE idxA LESS THAN LENGTH OF nums1\n                ASSIGN nums1[idxA] TO valA\n                IF valA NOT EQUAL TO 0 THEN\n                    IF valA GREATER THAN 0 THEN\n                        ASSIGN TRUNCATED_UPPER_BOUND(nums2, p DIVIDED BY valA) TO pos\n                        ADD pos TO tally\n                    ELSE\n                        ASSIGN lengthB MINUS TRUNCATED_LOWER_BOUND(nums2, p DIVIDED BY valA) TO remainder\n                        ADD remainder TO tally\n                    END IF\n                ELSE\n                    ADD (p GREATER THAN OR EQUAL TO 0) TIMES lengthB TO tally\n                END IF\n                ADD 1 TO idxA\n            END WHILE\n            YIELD tally\n        END FUNCTION\n\n        ASSIGN MAX(ABS(nums1[0]), ABS(nums1[-1])) TIMES MAX(ABS(nums2[0]), ABS(nums2[-1])) TO maximumValue\n        ASSIGN -maximumValue TO leftExtreme\n        ASSIGN maximumValue TO rightExtreme\n        ASSIGN BINARY_SEARCH(leftExtreme, rightExtreme + 1, k, count) TO answer\n        YIELD answer MINUS maximumValue\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION kthSmallestProduct(nums1 PARAMETER, nums2 PARAMETER, k PARAMETER)  \n        \n        FUNCTION count(p PARAMETER)  \n            SET cnt TO zero  \n            SET n TO the LENGTH OF nums2  \n            FOR each element x IN nums1  \n                IF x GREATER THAN zero  \n                    INCREMENT cnt BY the POSITION TO THE RIGHT IN nums2 OF the value p DIVIDED BY x  \n                ELSE IF x LESS THAN zero  \n                    INCREMENT cnt BY n MINUS the POSITION TO THE LEFT IN nums2 OF the value p DIVIDED BY x  \n                ELSE  \n                    INCREMENT cnt BY n MULTIPLIED BY the LOGICAL VALUE OF p GREATER THAN OR EQUAL TO zero  \n                END IF  \n            END FOR  \n            RETURN cnt  \n        END FUNCTION  \n        \n        SET mx TO the MAXIMUM OF the ABSOLUTE VALUE OF the element at POSITION zero OF nums1 AND the ABSOLUTE VALUE OF the element at the LAST POSITION OF nums1 MULTIPLIED BY the MAXIMUM OF the ABSOLUTE VALUE OF the element at POSITION zero OF nums2 AND the ABSOLUTE VALUE OF the element at the LAST POSITION OF nums2  \n        RETURN the POSITION TO THE LEFT WITHIN THE RANGE FROM NEGATIVE mx TO mx PLUS one OF the value k WHERE the KEY FUNCTION IS count MINUS mx  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "tag-validator", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION isValid(code)\n        IMPORT regular expression module\n        DEFINE cdata_regex AS the pattern: literal \"<![CDATA[\" concatenated with any characters repeated reluctantly followed by \"]]>\"\n        SET code TO the output of substituting all matches of cdata_regex in code with empty string using regular expression substitution\n        ASSIGN pile TO an empty list\n        ASSIGN position TO 0\n        WHILE position < LENGTH(code)\n            IF code[position] = \"<\"\n                ASSIGN end_pos TO the index of \">\" found in code starting from position + 1\n                IF end_pos = -1\n                    RETURN false\n                END IF\n                ASSIGN content TO SUBSTRING(code, position + 1, end_pos)\n                IF content IS EMPTY\n                    RETURN false\n                END IF\n                IF content[0] = \"/\"\n                    ASSIGN tag TO SUBSTRING(content, 1, LENGTH(content))\n                    IF pile IS EMPTY OR pile[ LENGTH(pile) - 1 ] ≠ tag\n                        RETURN false\n                    END IF\n                    REMOVE the element at pile[ LENGTH(pile) - 1 ]\n                ELSE\n                    IF content[0] = \"!\"\n                        RETURN false\n                    OTHERWISE\n                        DEFINE is_valid_tag AS (LENGTH(content) ≥ 1) AND (LENGTH(content) ≤ 9)\n                        ASSIGN is_valid_tag TO is_valid_tag AND ALL(char IS UPPERCASE LETTER FOR EACH char IN content)\n                        IF NOT is_valid_tag\n                            RETURN false\n                        END IF\n                        APPEND content TO pile\n                    END IF\n                END IF\n                ASSIGN position TO end_pos + 1\n            OTHERWISE\n                INCREMENT position BY 1\n            END IF\n        END WHILE\n        DEFINE valid_tag_expr AS the pattern: \"<\" + one or more uppercase letters + \">\" + any characters any number of times + \"</\" + one or more uppercase letters + \">\"\n        RETURN (pile IS EMPTY) AND (COUNT OF ALL MATCHES OF valid_tag_expr IN code > 0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isValid(code)  \n        IMPORT regular expression module  \n        SET cdata_pattern TO the regular expression pattern representing the string starting with less than followed by an exclamation mark followed by open square bracket followed by CDATA followed by open square bracket followed by any character any number of times reluctantly followed by close square bracket followed by close square bracket followed by greater than  \n        SET code TO the result of replacing all occurrences matching cdata_pattern in code with empty string using regular expression substitution  \n        SET stack TO an empty list  \n        SET i TO zero  \n        WHILE i IS LESS THAN the LENGTH OF code  \n            IF the character at position i of code EQUALS the less than character  \n                SET j TO the position of the first occurrence of the greater than character in code starting from one position after i  \n                IF j EQUALS negative one  \n                    RETURN false  \n                END IF  \n                SET tag_content TO the substring from position i plus one TO position j of code  \n                IF tag_content IS EMPTY  \n                    RETURN false  \n                END IF  \n                IF the first character of tag_content EQUALS the forward slash character  \n                    SET tag_name TO the substring from position two TO the end of tag_content  \n                    IF stack IS EMPTY OR element at the last position of stack DOES NOT EQUAL tag_name  \n                        RETURN false  \n                    END IF  \n                    REMOVE the element at the last position FROM stack  \n                ELSE IF the first character of tag_content EQUALS the exclamation mark character  \n                    RETURN false  \n                ELSE  \n                    IF NOT the condition that the LENGTH OF tag_content IS GREATER THAN OR EQUAL TO one AND IS LESS THAN OR EQUAL TO nine AND every character in tag_content IS AN UPPERCASE LETTER  \n                        RETURN false  \n                    END IF  \n                    APPEND tag_content TO stack  \n                END IF  \n                SET i TO j PLUS one  \n            ELSE  \n                INCREMENT i BY one  \n            END IF  \n        END WHILE  \n        SET valid_tag_pattern TO the regular expression pattern representing the string starting with less than followed by one or more uppercase letters followed by greater than followed by any character any number of times followed by less than followed by forward slash followed by one or more uppercase letters followed by greater than  \n        RETURN the condition that stack IS EMPTY AND the count of all occurrences matching valid_tag_pattern in code IS GREATER THAN zero  \n    END FUNCTION  \nEND CLASS"}
