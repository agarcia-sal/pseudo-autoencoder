{"task_id": "maximum-product-of-word-lengths", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters in word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the set at position i of word_sets has NO COMMON ELEMENTS WITH the set at position j of word_sets  \n                    SET product TO the LENGTH OF the element at position i of words MULTIPLIED BY the LENGTH OF the element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "coin-change", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION coinChange(coins AS list of integers, amount AS integer) RETURNS integer  \n        SET dp TO a list with the length of amount PLUS one where each element is amount PLUS one  \n        SET element at position zero of dp TO zero  \n        \n        FOR each a FROM one TO amount  \n            FOR each coin IN coins  \n                IF a MINUS coin IS GREATER THAN OR EQUAL TO zero  \n                    SET element at position a of dp TO the smaller value BETWEEN element at position a of dp AND element at position a MINUS coin of dp PLUS one  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF element at position amount of dp IS NOT EQUALS TO amount PLUS one  \n            RETURN element at position amount of dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "frog-jump", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS an empty list OR the LENGTH OF stones LESS THAN two THEN  \n            RETURN False  \n        END IF  \n        \n        SET stone_set TO a new empty set  \n        FOR each stone IN stones  \n            ADD stone TO stone_set  \n        END FOR  \n        \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the last element of stones THEN  \n                RETURN True  \n            END IF  \n            \n            IF the tuple of position and jump IS IN memo THEN  \n                RETURN the value from memo with key tuple of position and jump  \n            END IF  \n            \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the sum of position PLUS next_jump IS IN stone_set THEN  \n                    IF can_jump_to(the sum of position PLUS next_jump, next_jump) THEN  \n                        SET the value in memo with key tuple of position and jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value in memo with key tuple of position and jump TO False  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_jump_to(the first element of stones, zero)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reconstruct-original-digits-from-english", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION originalDigits(s)  \n        SET count TO mapping of character frequencies in s  \n        SET digits TO list of zero FOR each position FROM zero TO nine  \n        SET digit at position zero TO the frequency of character z in count  \n        SET digit at position two TO the frequency of character w in count  \n        SET digit at position four TO the frequency of character u in count  \n        SET digit at position six TO the frequency of character x in count  \n        SET digit at position eight TO the frequency of character g in count  \n        SET digit at position three TO the frequency of character h in count MINUS digit at position eight  \n        SET digit at position five TO the frequency of character f in count MINUS digit at position four  \n        SET digit at position seven TO the frequency of character s in count MINUS digit at position six  \n        SET digit at position nine TO the frequency of character i in count MINUS digit at position five MINUS digit at position six MINUS digit at position eight  \n        SET digit at position one TO the frequency of character o in count MINUS digit at position zero MINUS digit at position two MINUS digit at position four  \n        SET result TO empty list  \n        FOR index FROM zero TO nine  \n            FOR count_index FROM one TO digit at position index  \n                APPEND index converted to string TO result  \n            END FOR  \n        END FOR  \n        RETURN concatenation of all elements in result  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "longest-word-in-dictionary", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN alphabetical ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO the empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from the first character TO the character before the last character IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "reaching-points", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION reachingPoints(sx sy tx ty)  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of the difference of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of the difference of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "domino-and-tromino-tiling", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION numTilings(n)  \n        SET MOD TO one billion plus seven  \n        SET dp TO a list of zeros of length n plus one  \n        SET dp1 TO a list of zeros of length n plus one  \n        SET element at position zero of dp TO one  \n        SET element at position one of dp TO one  \n        IF n GREATER THAN OR EQUAL TO two THEN  \n            SET element at position two of dp TO two  \n            SET element at position two of dp1 TO one  \n        END IF  \n        FOR i FROM three TO n DO  \n            SET element at position i of dp TO the remainder after division by MOD of the sum of element at position i minus one of dp PLUS element at position i minus two of dp PLUS two MULTIPLIED BY element at position i minus one of dp1  \n            SET element at position i of dp1 TO the remainder after division by MOD of the sum of element at position i minus two of dp PLUS element at position i minus one of dp1  \n        END FOR  \n        RETURN element at position n of dp  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "distinct-subsequences-ii", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION distinctSubseqII WITH parameter s  \n        SET MODULO TO ten RAISED TO THE power of nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of zeros WITH LENGTH n PLUS one  \n        SET element at position zero of dp TO one  \n        INITIALIZE last AS an empty dictionary  \n        FOR i FROM one TO n  \n            SET character TO element at position i MINUS one of s  \n            SET element at position i of dp TO the value of element at position i MINUS one of dp MULTIPLIED BY two MODULO MODULO  \n            IF character IS a key in last  \n                SET element at position i of dp TO element at position i of dp MINUS element at position last of character MINUS one of dp PLUS MODULO MODULO MODULO  \n            END IF  \n            ASSIGN i TO last at character  \n        END FOR  \n        RETURN element at position n of dp MINUS one MODULO MODULO  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "string-transforms-into-another-string", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION canConvert(str1 str2)  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO empty mapping  \n        FOR each pair of char1 AND char2 IN corresponding elements of str1 AND str2  \n            IF char1 IN keys of conversion_map  \n                IF value at key char1 of conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET value at key char1 of conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the LENGTH OF the set of all unique characters in str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-cost-to-cut-a-stick", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO the sorted result of appending zero and n to cuts  \n        \n        FUNCTION dp(left, right)  \n            IF the result of right MINUS left is LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing infinity  \n            FOR i FROM the result of left PLUS one TO the result of right MINUS one  \n                SET cost TO the element at position right of cuts MINUS the element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost IS LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the result of the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "minimum-incompatibility", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        \n        IF there EXISTS a count of any number in nums WHERE the count GREATER THAN k  \n            RETURN negative one  \n        END IF  \n        \n        SET subset_incompatibility TO an empty mapping  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF bit_count EQUALS subset_size  \n                SET elements TO an empty list  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BIT AT position i OF mask EQUALS one  \n                        APPEND the element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                \n                IF the NUMBER OF UNIQUE elements IN elements EQUALS subset_size  \n                    SET incompatibility TO the MAXIMUM OF elements MINUS the MINIMUM OF elements  \n                    ASSIGN incompatibility TO the ENTRY of mask IN subset_incompatibility  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET dp TO a list of LENGTH two RAISED TO THE POWER OF n FILLED WITH positive infinity  \n        SET the ELEMENT AT position zero OF dp TO zero  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF the REMAINDER of bit_count DIVIDED BY subset_size NOT EQUAL TO zero  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BINARY AND OF mask AND subset_mask EQUALS subset_mask  \n                    SET dp AT position mask TO the MINIMUM OF the CURRENT dp AT position mask AND the dp AT position of the BINARY XOR OF mask AND subset_mask PLUS the VALUE of subset_mask IN subset_incompatibility  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET full_mask TO two RAISED TO THE POWER OF n MINUS one  \n        IF the ELEMENT AT position full_mask OF dp NOT EQUAL TO positive infinity  \n            RETURN the ELEMENT AT position full_mask OF dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
{"task_id": "maximum-number-of-ways-to-partition-an-array", "label": "true_positive", "pseudocode": "CLASS Solution  \n    FUNCTION waysToPartition(nums parameter the list of integers k parameter the integer) RETURNS integer  \n        SET total_sum TO the sum of all elements in nums  \n        SET n TO the length of nums  \n        CREATE an empty dictionary left_diff that returns zero for missing keys  \n        CREATE an empty dictionary right_diff that returns zero for missing keys  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            INCREMENT the value at key diff of right_diff BY one  \n        END FOR  \n        SET max_ways TO the value at key zero of right_diff  \n        SET current_sum TO zero  \n        FOR each index i FROM zero TO the number n MINUS one  \n            INCREMENT current_sum BY the element at position i of nums  \n            SET diff_change TO k MINUS the element at position i of nums  \n            SET new_ways TO the sum of the value at key the negative of diff_change of left_diff AND the value at key diff_change of right_diff  \n            IF max_ways LESS THAN new_ways THEN  \n                SET max_ways TO new_ways  \n            END IF  \n            SET diff TO total_sum MINUS two MULTIPLIED BY current_sum  \n            DECREMENT the value at key diff of right_diff BY one  \n            INCREMENT the value at key diff of left_diff BY one  \n        END FOR  \n        RETURN max_ways  \n    END FUNCTION  \nEND CLASS", "score": 1.0}
