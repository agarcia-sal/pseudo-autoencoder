CLASS Solution
    FUNCTION canMouseWin(grid, catJump, mouseJump)
        SET m TO LENGTH OF grid
        SET n TO LENGTH OF grid[0]
        SET cat_start TO 0
        SET mouse_start TO 0
        SET food TO 0
        SET dirs TO (-1, 0, 1, 0, -1)
        SET g_mouse TO LIST OF EMPTY LISTS OF SIZE m * n
        SET g_cat TO LIST OF EMPTY LISTS OF SIZE m * n

        FOR i FROM 0 TO m - 1
            FOR j FROM 0 TO n - 1
                IF grid[i][j] IS "#"
                    CONTINUE
                SET v TO i * n + j
                IF grid[i][j] IS "C"
                    SET cat_start TO v
                ELSE IF grid[i][j] IS "M"
                    SET mouse_start TO v
                ELSE IF grid[i][j] IS "F"
                    SET food TO v
                FOR a, b IN PAIRWISE(dirs)
                    FOR k FROM 0 TO mouseJump
                        SET x TO i + k * a
                        SET y TO j + k * b
                        IF x NOT IN [0, m - 1] OR y NOT IN [0, n - 1] OR grid[x][y] IS "#"
                            BREAK
                        APPEND x * n + y TO g_mouse[v]
                    FOR k FROM 0 TO catJump
                        SET x TO i + k * a
                        SET y TO j + k * b
                        IF x NOT IN [0, m - 1] OR y NOT IN [0, n - 1] OR grid[x][y] IS "#"
                            BREAK
                        APPEND x * n + y TO g_cat[v]

        RETURN self.calc(g_mouse, g_cat, mouse_start, cat_start, food) EQUALS 1
    END FUNCTION

    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)
        FUNCTION get_prev_states(state)
            SET m, c, t TO state
            SET pt TO t XOR 1
            SET pre TO EMPTY LIST
            IF pt EQUALS 1
                FOR pc IN g_cat[c]
                    IF ans[m][pc][1] EQUALS 0
                        APPEND (m, pc, pt) TO pre
            ELSE
                FOR pm IN g_mouse[m]
                    IF ans[pm][c][0] EQUALS 0
                        APPEND (pm, c, 0) TO pre
            RETURN pre
        END FUNCTION

        SET n TO LENGTH OF g_mouse
        SET degree TO THREE-DIMENSIONAL LIST OF SIZE [n][n][2] FILLED WITH ZEROS
        FOR i FROM 0 TO n - 1
            FOR j FROM 0 TO n - 1
                SET degree[i][j][0] TO LENGTH OF g_mouse[i]
                SET degree[i][j][1] TO LENGTH OF g_cat[j]

        SET ans TO THREE-DIMENSIONAL LIST OF SIZE [n][n][2] FILLED WITH ZEROS
        SET q TO EMPTY QUEUE
        FOR i FROM 0 TO n - 1
            SET ans[hole][i][1] TO 1
            SET ans[i][hole][0] TO 2
            SET ans[i][i][1] TO 2
            SET ans[i][i][0] TO 2
            ENQUEUE (hole, i, 1) TO q
            ENQUEUE (i, hole, 0) TO q
            ENQUEUE (i, i, 0) TO q
            ENQUEUE (i, i, 1) TO q

        WHILE q IS NOT EMPTY
            SET state TO DEQUEUE FROM q
            SET t TO ans[state[0]][state[1]][state[2]]
            FOR prev_state IN get_prev_states(state)
                SET pm, pc, pt TO prev_state
                IF pt EQUALS t - 1
                    SET ans[pm][pc][pt] TO t
                    ENQUEUE prev_state TO q
                ELSE
                    DECREMENT degree[pm][pc][pt] BY 1
                    IF degree[pm][pc][pt] EQUALS 0
                        SET ans[pm][pc][pt] TO t
                        ENQUEUE prev_state TO q

        RETURN ans[mouse_start][cat_start][0]
    END FUNCTION
END CLASS