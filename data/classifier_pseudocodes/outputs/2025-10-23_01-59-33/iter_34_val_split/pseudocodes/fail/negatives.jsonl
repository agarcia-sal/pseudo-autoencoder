{"task_id": "non-decreasing-array", "label": "true_negative", "pseudocode": "CLASS Solution\n    FUNCTION checkPossibility(list_of_numbers)\n        SET modified_flag TO false\n        FOR index FROM one TO the LENGTH OF list_of_numbers MINUS one\n            IF element at position index of list_of_numbers LESS THAN element at position index MINUS one of list_of_numbers\n                IF modified_flag IS true\n                    RETURN false\n                END IF\n                SET modified_flag TO true\n                IF index LESS THAN two OR element at position index of list_of_numbers GREATER THAN OR EQUAL TO element at position index MINUS two of list_of_numbers\n                    SET element at position index MINUS one of list_of_numbers TO element at position index of list_of_numbers\n                ELSE\n                    SET element at position index of list_of_numbers TO element at position index MINUS one of list_of_numbers\n                END IF\n            END IF\n        END FOR\n        RETURN true\n    END FUNCTION\nEND CLASS", "score": 0, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp6ba6o5oq/solution_0.py\", line 35, in <module>\\n    print(Solution().checkPossibility(nums = [4,2,3]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'checkPossibility\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR index i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "reaching-points", "label": "true_negative", "pseudocode": "CLASS Solution\n    FUNCTION reachingPoints(start_x, start_y, target_x, target_y) RETURNS boolean\n        WHILE target_x GREATER THAN OR EQUAL TO start_x AND target_y GREATER THAN OR EQUAL TO start_y HOLDS\n            IF target_x EQUALS start_x AND target_y EQUALS start_y THEN\n                RETURN true\n            END IF\n            IF target_x GREATER THAN target_y THEN\n                IF target_y GREATER THAN start_y THEN\n                    SET target_x TO target_x MODULO target_y\n                ELSE\n                    RETURN whether the result of target_x MINUS start_x MODULO target_y EQUALS zero\n                END IF\n            ELSE\n                IF target_x GREATER THAN start_x THEN\n                    SET target_y TO target_y MODULO target_x\n                ELSE\n                    RETURN whether the result of target_y MINUS start_y MODULO target_x EQUALS zero\n                END IF\n            END IF\n        END WHILE\n        RETURN false\n    END FUNCTION\nEND CLASS", "score": 0, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpa7s5v2g2/solution_0.py\", line 45, in <module>\\n    print(Solution().reachingPoints(sx = 1, sy = 1, tx = 3, ty = 5))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'reachingPoints\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION reachingPoints(sx sy tx ty)  \n        WHILE tx GREATER THAN OR EQUAL TO sx AND ty GREATER THAN OR EQUAL TO sy  \n            IF tx EQUALS sx AND ty EQUALS sy  \n                RETURN True  \n            END IF  \n            IF tx GREATER THAN ty  \n                IF ty GREATER THAN sy  \n                    SET tx TO the remainder of tx DIVIDED BY ty  \n                ELSE  \n                    RETURN the remainder of the difference of tx MINUS sx DIVIDED BY ty EQUALS zero  \n                END IF  \n            ELSE  \n                IF tx GREATER THAN sx  \n                    SET ty TO the remainder of ty DIVIDED BY tx  \n                ELSE  \n                    RETURN the remainder of the difference of ty MINUS sy DIVIDED BY tx EQUALS zero  \n                END IF  \n            END IF  \n        END WHILE  \n        RETURN False  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-subsequence-widths", "label": "true_negative", "pseudocode": "CLASS Solution\n    FUNCTION sumSubseqWidths(list_of_numbers)\n        SET MODULO_MODULUS TO ten TO THE POWER OF nine PLUS seven\n        CALL sort ON list_of_numbers\n        SET length_of_list TO the LENGTH OF list_of_numbers\n        SET total_sum TO zero\n        SET power_list TO a list WITH length length_of_list FILLED WITH one\n\n        FOR index FROM one TO length_of_list MINUS one\n            SET element_at position index OF power_list TO element_at position index MINUS one OF power_list MULTIPLIED BY two MODULO_MODULUS\n        END FOR\n\n        FOR index FROM zero TO length_of_list MINUS one\n            SET total_sum TO total_sum PLUS element_at position index OF list_of_numbers MULTIPLIED BY element_at position index OF power_list MINUS element_at position length_of_list MINUS index MINUS one OF power_list MODULO_MODULUS\n            SET total_sum TO total_sum MODULO_MODULUS\n        END FOR\n        \n        RETURN total_sum\n    END FUNCTION\nEND CLASS", "score": 0, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpy973coti/solution_0.py\", line 34, in <module>\\n    print(Solution().sumSubseqWidths(nums = [2,1,3]))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'sumSubseqWidths\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION sumSubseqWidths(nums)  \n        SET MODULO TO ten POWERED BY nine PLUS one  \n        SORT nums IN ascending order  \n        SET n TO the LENGTH OF nums  \n        SET total_sum TO zero  \n        SET power TO a list WITH n elements EACH EQUAL TO one  \n        \n        FOR i FROM one TO n MINUS one  \n            SET element at position i of power TO the element at position i MINUS one of power MULTIPLIED BY two MODULO MODULO  \n        END FOR  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET total_sum TO total_sum PLUS the element at position i of nums MULTIPLIED BY the element at position i of power MINUS the element at position n MINUS i MINUS one of power MODULO MODULO  \n        END FOR  \n        \n        RETURN total_sum  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "distinct-subsequences-ii", "label": "true_negative", "pseudocode": "CLASS Solution\n    FUNCTION distinctSubseqII(string_s)\n        SET MOD TO one billion PLUS seven\n        SET n TO the LENGTH OF string_s\n        SET dp TO a list OF zero REPEATED n PLUS one TIMES\n        SET element at position zero OF dp TO one\n\n        SET last TO an empty dictionary\n\n        FOR index i FROM one TO n\n            SET character char TO element at position i MINUS one OF string_s\n            SET element at position i OF dp TO dp at position i MINUS one MULTIPLIED BY two MODULO MOD\n\n            IF char IS IN last\n                SET element at position i OF dp TO dp at position i MINUS element at position last at char MINUS one PLUS MODULO MOD\n            END IF\n\n            SET last at key char TO i\n        END FOR\n\n        RETURN element at position n OF dp MINUS one MODULO MOD\n    END FUNCTION\nEND CLASS", "score": 0, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpogs__rhd/solution_0.py\", line 38, in <module>\\n    print(Solution().distinctSubseqII(s = \"abc\"))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']", "true_positive": "CLASS Solution  \n    FUNCTION distinctSubseqII WITH parameter s  \n        SET MODULO TO ten RAISED TO THE power of nine PLUS seven  \n        SET n TO the LENGTH OF s  \n        INITIALIZE dp AS a list of zeros WITH LENGTH n PLUS one  \n        SET element at position zero of dp TO one  \n        INITIALIZE last AS an empty dictionary  \n        FOR i FROM one TO n  \n            SET character TO element at position i MINUS one of s  \n            SET element at position i of dp TO the value of element at position i MINUS one of dp MULTIPLIED BY two MODULO MODULO  \n            IF character IS a key in last  \n                SET element at position i of dp TO element at position i of dp MINUS element at position last of character MINUS one of dp PLUS MODULO MODULO MODULO  \n            END IF  \n            ASSIGN i TO last at character  \n        END FOR  \n        RETURN element at position n of dp MINUS one MODULO MODULO  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-incompatibility", "label": "true_negative", "pseudocode": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        \n        IF any count IN the COUNTER of nums VALUES IS GREATER THAN k THEN  \n            RETURN negative one  \n        END IF  \n        \n        SET subset_incompatibility TO an empty map  \n        FOR each mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            IF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask EQUALS subset_size THEN  \n                SET elements TO an empty list  \n                FOR each i FROM zero TO n MINUS one  \n                    IF the BITWISE AND of mask AND two RAISED TO THE POWER OF i IS GREATER THAN zero THEN  \n                        APPEND the element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                IF the SIZE OF the SET OF elements EQUALS subset_size THEN  \n                    SET incompatibility TO the MAXIMUM value IN elements MINUS the MINIMUM value IN elements  \n                    ASSIGN incompatibility TO subset_incompatibility AT KEY mask  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET dp TO a list OF length two RAISED TO THE POWER OF n FILLED WITH positive infinity  \n        SET dp AT position zero TO zero  \n        \n        FOR each mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            IF the NUMBER OF ONES IN the BINARY REPRESENTATION OF mask MODULO subset_size NOT EQUALS zero THEN  \n                CONTINUE TO next iteration  \n            END IF  \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BITWISE AND of mask AND subset_mask EQUALS subset_mask THEN  \n                    SET dp AT position mask TO the MINIMUM value BETWEEN dp AT position mask AND dp AT position mask XOR subset_mask PLUS subset_incompatibility AT KEY subset_mask  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        IF dp AT position two RAISED TO THE POWER OF n MINUS one EQUALS positive infinity THEN  \n            RETURN negative one  \n        ELSE  \n            RETURN dp AT position two RAISED TO THE POWER OF n MINUS one  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 0, "error": "", "error_string": "['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpxpe5au7k/solution_0.py\", line 46, in <module>\\n    print(Solution().minimumIncompatibility(nums = [1,2,1,4], k = 2))\\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'minimumIncompatibility\\'\\n']", "true_positive": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        \n        IF there EXISTS a count of any number in nums WHERE the count GREATER THAN k  \n            RETURN negative one  \n        END IF  \n        \n        SET subset_incompatibility TO an empty mapping  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF bit_count EQUALS subset_size  \n                SET elements TO an empty list  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BIT AT position i OF mask EQUALS one  \n                        APPEND the element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                \n                IF the NUMBER OF UNIQUE elements IN elements EQUALS subset_size  \n                    SET incompatibility TO the MAXIMUM OF elements MINUS the MINIMUM OF elements  \n                    ASSIGN incompatibility TO the ENTRY of mask IN subset_incompatibility  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET dp TO a list of LENGTH two RAISED TO THE POWER OF n FILLED WITH positive infinity  \n        SET the ELEMENT AT position zero OF dp TO zero  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF the REMAINDER of bit_count DIVIDED BY subset_size NOT EQUAL TO zero  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BINARY AND OF mask AND subset_mask EQUALS subset_mask  \n                    SET dp AT position mask TO the MINIMUM OF the CURRENT dp AT position mask AND the dp AT position of the BINARY XOR OF mask AND subset_mask PLUS the VALUE of subset_mask IN subset_incompatibility  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET full_mask TO two RAISED TO THE POWER OF n MINUS one  \n        IF the ELEMENT AT position full_mask OF dp NOT EQUAL TO positive infinity  \n            RETURN the ELEMENT AT position full_mask OF dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
