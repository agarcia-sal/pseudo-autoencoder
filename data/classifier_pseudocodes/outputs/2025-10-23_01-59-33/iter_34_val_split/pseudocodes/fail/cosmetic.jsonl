{"task_id": "reverse-words-in-a-string", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION reverseWords(s)  \n        ASSIGN tokens TO array derived by dividing s on whitespace, ignoring extra spaces  \n        DECLARE idx AS integer = 0  \n        WHILE idx < LENGTH(tokens) / 2 DO  \n            DECLARE temp AS string = tokens[idx]  \n            ASSIGN tokens[idx] TO tokens[LENGTH(tokens) - 1 - idx]  \n            ASSIGN tokens[LENGTH(tokens) - 1 - idx] TO temp  \n            INCREMENT idx BY 1  \n        END WHILE  \n        DECLARE result AS string = EMPTY STRING  \n        FOR i FROM 0 TO LENGTH(tokens) - 1 DO  \n            IF i EQUALS 0 THEN  \n                ASSIGN result TO tokens[i]  \n            ELSE  \n                ASSIGN result TO result + \" \" + tokens[i]  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION reverseWords WITH PARAMETER s  \n        SET words TO the result of splitting s BY spaces handling multiple spaces implicitly  \n        REVERSE the order of words  \n        SET reversed_string TO the concatenation of words JOINED BY a single space  \n        RETURN reversed_string  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "strobogrammatic-number-iii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low  \n                                    high)  \n        FUNCTION generate_strobogrammatic(n  \n                                         final_length)  \n            IF NOT (n NOT EQUALS 0)  \n                RETURN LIST(\"\")\n            END IF  \n            \n            IF n == 1  \n                RETURN LIST(\"0\", \"1\", \"8\")\n            END IF  \n            \n            ASSIGN generate_strobogrammatic(n - 2, final_length) TO temp_collection  \n            ASSIGN LIST() TO output_collection  \n            ASSIGN 0 TO idx  \n            WHILE idx < LENGTH(temp_collection)  \n                ASSIGN temp_collection[idx] TO current_string  \n                IF n != final_length  \n                    APPEND (\"0\" + current_string + \"0\") TO output_collection  \n                END IF  \n                APPEND (\"1\" + current_string + \"1\") TO output_collection  \n                APPEND (\"6\" + current_string + \"9\") TO output_collection  \n                APPEND (\"8\" + current_string + \"8\") TO output_collection  \n                APPEND (\"9\" + current_string + \"6\") TO output_collection  \n                INCREMENT idx BY 1  \n            END WHILE  \n            RETURN output_collection  \n        END FUNCTION  \n        \n        FUNCTION count_strobogrammatic(low  \n                                       high)  \n            ASSIGN 0 TO aggregate_counter  \n            FOR curr_length FROM LENGTH(low) TO LENGTH(high)  \n                ASSIGN generate_strobogrammatic(curr_length, curr_length) TO candidates  \n                ASSIGN 0 TO index_tracker  \n                WHILE index_tracker < LENGTH(candidates)  \n                    ASSIGN candidates[index_tracker] TO candidate_str  \n                    IF NOT ( (curr_length == LENGTH(low) AND candidate_str >= low) AND (curr_length == LENGTH(high) AND candidate_str <= high) )  \n                        OR (curr_length != LENGTH(low) AND curr_length != LENGTH(high))  \n                        IF (curr_length == LENGTH(low) AND candidate_str < low) OR (curr_length == LENGTH(high) AND candidate_str > high)  \n                            INCREMENT index_tracker BY 1  \n                            CONTINUE  \n                        END IF  \n                    END IF  \n                    INCREMENT aggregate_counter BY 1  \n                    INCREMENT index_tracker BY 1  \n                END WHILE  \n            END FOR  \n            RETURN aggregate_counter  \n        END FUNCTION  \n        \n        RETURN count_strobogrammatic(low, high)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION strobogrammaticInRange(low, high)  \n        FUNCTION generate_strobogrammatic(n, final_length)  \n            IF n EQUALS zero  \n                RETURN a list containing an empty string  \n            END IF  \n            IF n EQUALS one  \n                RETURN a list containing the strings zero one and eight  \n            END IF  \n            SET middles TO the result of generate_strobogrammatic of n MINUS two and final_length  \n            SET result TO an empty list  \n            FOR each middle IN middles  \n                IF n NOT EQUALS final_length  \n                    APPEND the string zero concatenated with middle concatenated with zero TO result  \n                END IF  \n                APPEND the string one concatenated with middle concatenated with one TO result  \n                APPEND the string six concatenated with middle concatenated with nine TO result  \n                APPEND the string eight concatenated with middle concatenated with eight TO result  \n                APPEND the string nine concatenated with middle concatenated with six TO result  \n            END FOR  \n            RETURN result  \n        END FUNCTION  \n        FUNCTION count_strobogrammatic(low, high)  \n            SET count TO zero  \n            FOR length FROM the length of low TO the length of high  \n                FOR each num IN generate_strobogrammatic of length and length  \n                    IF (length EQUALS the length of low AND num LESS THAN low) OR (length EQUALS the length of high AND num GREATER THAN high)  \n                        CONTINUE to the next iteration  \n                    END IF  \n                    INCREMENT count BY one  \n                END FOR  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        RETURN count_strobogrammatic of low and high  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-product-of-word-lengths", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        DECLARE characterCollections AS an empty array  \n        DECLARE idxOuter AS 0  \n        WHILE idxOuter < SIZE(words) DO  \n            DECLARE currentWord AS words[idxOuter]  \n            APPEND UNIQUE_CHAR_SET(currentWord) TO characterCollections  \n            INCREMENT idxOuter BY 1  \n        END WHILE  \n        \n        ASSIGN 0 TO highestProduct  \n        \n        DECLARE outerIdx AS 0  \n        WHILE outerIdx < SIZE(words) - 1 DO  \n            DECLARE innerIdx AS outerIdx + 1  \n            WHILE innerIdx < SIZE(words) DO  \n                DECLARE setA AS characterCollections[outerIdx]  \n                DECLARE setB AS characterCollections[innerIdx]  \n                IF NOT EXISTS(ALL elements IN setA THAT ARE ALSO IN setB) THEN  \n                    DECLARE currentProduct AS (LENGTH(words[outerIdx]) * LENGTH(words[innerIdx]))  \n                    IF highestProduct < currentProduct THEN  \n                        ASSIGN currentProduct TO highestProduct  \n                    END IF  \n                END IF  \n                INCREMENT innerIdx BY 1  \n            END WHILE  \n            INCREMENT outerIdx BY 1  \n        END WHILE  \n        \n        RETURN highestProduct  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxProduct(words)  \n        SET word_sets TO empty list  \n        FOR each word IN words  \n            APPEND the set of characters in word TO word_sets  \n        END FOR  \n        \n        SET max_product TO zero  \n        \n        FOR i FROM zero TO the LENGTH OF words MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF words MINUS one  \n                IF the set at position i of word_sets has NO COMMON ELEMENTS WITH the set at position j of word_sets  \n                    SET product TO the LENGTH OF the element at position i of words MULTIPLIED BY the LENGTH OF the element at position j of words  \n                    IF product GREATER THAN max_product  \n                        SET max_product TO product  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        RETURN max_product  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "frog-jump", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION canCross(stones)\n        IF (stones IS empty) OR NOT (LENGTH stones GREATER OR EQUAL 2) THEN\n            RETURN False\n        END IF\n\n        SET positions TO an empty MAP\n        FOR EACH s IN stones\n            SET positions[s] TO True\n        END FOR\n\n        SET cache TO an empty MAP\n\n        FUNCTION checkReachable(current, step)\n            IF current IS stones[ LENGTH stones - 1 ] THEN\n                RETURN True\n            END IF\n            SET key_pair TO (current, step)\n            IF key_pair EXISTS IN cache THEN\n                RETURN cache[key_pair]\n            END IF\n\n            FUNCTION attempts(offsetList)\n                IF offsetList IS empty THEN\n                    RETURN False\n                END IF\n                LET offset BE offsetList[0]\n                LET remainder BE offsetList[1 to END]\n                IF (offset > 0) AND ((current + offset) IN positions) THEN\n                    IF checkReachable(current + offset, offset) THEN\n                        cache[key_pair] = True\n                        RETURN True\n                    END IF\n                END IF\n                RETURN attempts(remainder)\n            END FUNCTION\n\n            RETURN attempts([step - 1, step, step + 1])\n                OR cache.set(key_pair, False); False\n        END FUNCTION\n\n        RETURN checkReachable(stones[0], 0)\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS an empty list OR the LENGTH OF stones LESS THAN two THEN  \n            RETURN False  \n        END IF  \n        \n        SET stone_set TO a new empty set  \n        FOR each stone IN stones  \n            ADD stone TO stone_set  \n        END FOR  \n        \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the last element of stones THEN  \n                RETURN True  \n            END IF  \n            \n            IF the tuple of position and jump IS IN memo THEN  \n                RETURN the value from memo with key tuple of position and jump  \n            END IF  \n            \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the sum of position PLUS next_jump IS IN stone_set THEN  \n                    IF can_jump_to(the sum of position PLUS next_jump, next_jump) THEN  \n                        SET the value in memo with key tuple of position and jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value in memo with key tuple of position and jump TO False  \n            RETURN False  \n        END FUNCTION  \n        \n        RETURN can_jump_to(the first element of stones, zero)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "non-decreasing-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION checkPossibility(nums)\n        ASSIGN false TO alteredFlag\n        SET idx TO 1\n        WHILE idx < LENGTH(nums)\n            IF NOT (nums[idx] >= nums[idx - 1])\n                IF alteredFlag\n                    IMMEDIATELY RETURN false\n                END IF\n                alteredFlag = true\n                IF (idx < 2) OR (nums[idx] >= nums[idx - 2])\n                    ASSIGN nums[idx] TO nums[idx - 1]\n                ELSE\n                    ASSIGN nums[idx - 1] TO nums[idx]\n                END IF\n            END IF\n            INCREMENT idx BY 1\n        END WHILE\n        IMMEDIATELY RETURN true\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION checkPossibility(nums)  \n        SET modified TO false  \n        FOR index i FROM one TO the LENGTH OF nums MINUS one  \n            IF the element at position i of nums LESS THAN the element at position i MINUS one of nums  \n                IF modified EQUALS true  \n                    RETURN false  \n                END IF  \n                SET modified TO true  \n                IF i LESS THAN two OR the element at position i of nums GREATER THAN OR EQUAL TO the element at position i MINUS two of nums  \n                    SET the element at position i MINUS one of nums TO the element at position i of nums  \n                ELSE  \n                    SET the element at position i of nums TO the element at position i MINUS one of nums  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-word-in-dictionary", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestWord(words)\n        REORDER words USING a comparator that PRIORITIZES shorter length first, THEN lex order ascending\n        INITIALIZE valid_words AS an empty set container\n        ASSIGN \"\" TO longest_word\n        \n        ASSIGN 0 TO cursor\n        WHILE cursor < LENGTH(words)\n            ASSIGN words[cursor] TO current_candidate\n            \n            ASSIGN (LENGTH(current_candidate) = 1) OR (SUBSTRING(current_candidate, 0, LENGTH(current_candidate) - 1) IS IN valid_words) TO is_valid\n            \n            IF NOT is_valid THEN\n                INCREMENT cursor BY 1\n                CONTINUE TO next iteration\n            END IF\n            \n            INSERT current_candidate INTO valid_words\n            \n            IF LENGTH(current_candidate) > LENGTH(longest_word) THEN\n                ASSIGN current_candidate TO longest_word\n            END IF\n            \n            INCREMENT cursor BY 1\n        END WHILE\n        RETURN longest_word\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestWord(words)  \n        SORT words BY the LENGTH OF element AND THEN BY element IN alphabetical ORDER  \n        SET valid_words TO an empty set  \n        SET longest_word TO the empty string  \n        FOR each word IN words  \n            IF the LENGTH OF word EQUALS one OR the substring of word from the first character TO the character before the last character IS IN valid_words  \n                ADD word TO valid_words  \n                IF the LENGTH OF word GREATER THAN the LENGTH OF longest_word  \n                    SET longest_word TO word  \n                END IF  \n            END IF  \n        END FOR  \n        RETURN longest_word  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "rectangle-area-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION rectangleArea(rectangles)\n        ASSIGN MOD TO (1_000_000_000 PLUS 1)\n        CREATE unique_ys AS empty associative array\n        FOR EACH quartet left_x bottom_y right_x top_y IN rectangles\n            INSERT bottom_y INTO unique_ys WITH VALUE true\n            INSERT top_y INTO unique_ys WITH VALUE true\n        END FOR\n        ASSIGN sorted_ys TO LIST OF KEYS FROM unique_ys\n        SORT sorted_ys IN ascending order\n        CREATE index_map AS empty map\n        SET idx_counter TO 0\n        WHILE idx_counter LESS THAN LENGTH OF sorted_ys\n            ASSIGN index_map[sorted_ys[idx_counter]] TO idx_counter\n            INCREMENT idx_counter BY 1\n        END WHILE\n        CREATE coverage AS ARRAY OF ZEROS WITH LENGTH EQUAL TO LENGTH OF sorted_ys\n        CREATE line_events AS empty array\n        SET k TO 0\n        WHILE k LESS THAN LENGTH OF rectangles\n            DESTRUCTURE rectangles[k] INTO left_x bottom_y right_x top_y\n            APPEND (left_x, 1, bottom_y, top_y) TO line_events\n            APPEND (right_x, -1, bottom_y, top_y) TO line_events\n            INCREMENT k BY 1\n        END WHILE\n        SORT line_events BY FIRST ELEMENT IN ascending order\n        ASSIGN previous_x TO 0\n        ASSIGN total_area TO 0\n        SET pointer TO 0\n        WHILE pointer LESS THAN LENGTH OF line_events\n            ASSIGN (curr_x, ev_type, y_start, y_end) TO line_events[pointer]\n            ASSIGN segment_length TO 0\n            SET pos TO 1\n            WHILE pos LESS THAN LENGTH OF coverage\n                WHEN coverage[pos - 1] GREATER THAN 0:\n                    ASSIGN segment_length TO segment_length PLUS (sorted_ys[pos] MINUS sorted_ys[pos - 1])\n                INCREMENT pos BY 1\n            END WHILE\n            ASSIGN total_area TO (total_area PLUS segment_length TIMES (curr_x MINUS previous_x)) MODULO MOD\n            ASSIGN start_i TO index_map[y_start]\n            ASSIGN end_i TO index_map[y_end] MINUS 1\n            SET iterator TO start_i\n            IF ev_type EQUALS 1\n                WHILE iterator LESS THAN OR EQUAL TO end_i\n                    ASSIGN coverage[iterator] TO coverage[iterator] PLUS 1\n                    INCREMENT iterator BY 1\n                END WHILE\n            ELSE\n                WHILE iterator LESS THAN OR EQUAL TO end_i\n                    ASSIGN coverage[iterator] TO coverage[iterator] MINUS 1\n                    INCREMENT iterator BY 1\n                END WHILE\n            END IF\n            ASSIGN previous_x TO curr_x\n            INCREMENT pointer BY 1\n        END WHILE\n        RETURN total_area\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION rectangleArea(rectangles)  \n        SET MOD TO ten TO THE POWER OF nine PLUS one  \n        SET y_coords TO an empty set  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            ADD y1 TO y_coords  \n            ADD y2 TO y_coords  \n        END FOR  \n        \n        SET y_coords TO the sorted list of elements of y_coords  \n        SET y_index TO an empty dictionary  \n        FOR each index AND y IN the enumeration of y_coords  \n            ASSIGN y_index at key y TO index  \n        END FOR  \n        \n        SET count TO a list of zeros with the length equal to the length of y_coords  \n        SET events TO an empty list  \n        FOR each rectangle IN rectangles  \n            SET x1 TO element at position zero of rectangle  \n            SET y1 TO element at position one of rectangle  \n            SET x2 TO element at position two of rectangle  \n            SET y2 TO element at position three of rectangle  \n            APPEND a tuple containing x1 PLUS one PLUS y1 PLUS y2 TO events  \n            APPEND a tuple containing x2 MINUS one PLUS y1 PLUS y2 TO events  \n        END FOR  \n        \n        SORT events by the first element of each tuple in ascending order  \n        \n        SET prev_x TO zero  \n        SET area TO zero  \n        \n        FOR each event IN events  \n            SET x TO element at position zero of event  \n            SET eventType TO element at position one of event  \n            SET y1 TO element at position two of event  \n            SET y2 TO element at position three of event  \n            \n            SET current_length TO zero  \n            FOR index FROM one TO the length of count MINUS one  \n                IF element at position index MINUS one of count GREATER THAN zero THEN  \n                    INCREMENT current_length BY the difference between element at position index of y_coords AND element at position index MINUS one of y_coords  \n                END IF  \n            END FOR  \n            \n            INCREMENT area BY current_length MULTIPLIED BY the difference between x AND prev_x  \n            SET area TO area MODULO MOD  \n            \n            IF eventType EQUALS one THEN  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    INCREMENT element at position index of count BY one  \n                END FOR  \n            ELSE  \n                FOR index FROM element at position y_index with key y1 TO element at position y_index with key y2 MINUS one  \n                    DECREMENT element at position index of count BY one  \n                END FOR  \n            END IF  \n            \n            SET prev_x TO x  \n        END FOR  \n        \n        RETURN area  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "equal-rational-numbers", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION isRationalEqual WITH PARAMETER s OF TYPE string WITH PARAMETER t OF TYPE string RETURNS boolean\n        ASSIGN [1, 1/9, 1/99, 1/999, 1/9999] TO ratiosList\n\n        FUNCTION valueOf WITH PARAMETER s OF TYPE string RETURNS a floating point number\n            ASSIGN indexOfOpenParen TO index(s, \"(\")\n            IF NOT (indexOfOpenParen >= 0) THEN\n                RETURN float(s)\n            END IF\n\n            ASSIGN indexOpen TO indexOfOpenParen\n            ASSIGN indexClose TO index(s, \")\")\n            ASSIGN decimalDot TO index(s, \".\")\n\n            ASSIGN baseNum TO float(substring(s, 0, indexOpen - 1))\n            ASSIGN lengthNonRepeat TO indexOpen - decimalDot - 1\n\n            ASSIGN repeatNum TO int(substring(s, indexOpen + 1, indexClose - 1))\n            ASSIGN lengthRepeat TO indexClose - indexOpen - 1\n            RETURN baseNum + repeatNum * (1 / (10 ^ lengthNonRepeat)) * ratiosList[lengthRepeat]\n        END FUNCTION\n\n        ASSIGN diff TO abs(valueOf(s) - valueOf(t))\n        RETURN diff < (1 / (10 ^ 9))\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isRationalEqual(s, t)  \n        SET ratios TO list containing one FOLLOWED BY one DIVIDED BY nine FOLLOWED BY one DIVIDED BY ninety nine FOLLOWED BY one DIVIDED BY nine hundred ninety nine FOLLOWED BY one DIVIDED BY nine thousand nine hundred ninety nine  \n\n        FUNCTION valueOf(s)  \n            IF the position of the opening parenthesis character in s EQUALS negative one THEN  \n                RETURN the floating point conversion of s  \n            END IF  \n\n            SET leftParenIndex TO the position of the opening parenthesis character in s  \n            SET rightParenIndex TO the position of the closing parenthesis character in s  \n            SET dotIndex TO the position of the decimal point character in s  \n\n            SET integerAndNonRepeating TO the floating point conversion of the substring from the start of s TO the position before leftParenIndex of s  \n            SET nonRepeatingLength TO leftParenIndex MINUS dotIndex MINUS one  \n\n            SET repeating TO the integer conversion of the substring from the position after leftParenIndex TO the position before rightParenIndex of s  \n            SET repeatingLength TO rightParenIndex MINUS leftParenIndex MINUS one  \n            RETURN integerAndNonRepeating PLUS repeating MULTIPLIED BY zero POINT one RAISED TO THE POWER OF nonRepeatingLength MULTIPLIED BY the element at position repeatingLength of ratios  \n        END FUNCTION  \n\n        RETURN the absolute value of the result of valueOf applied to s MINUS the result of valueOf applied to t LESS THAN one TIMES ten RAISED TO THE POWER OF negative nine  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "parsing-a-boolean-expression", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION parseBoolExpr(expression)\n        INITIALIZE pile AS empty array\n        INITIALIZE idx AS 0\n        WHILE idx < LENGTH(expression)\n            SET sym TO expression[idx]\n            IF sym == 't' OR sym == 'f' OR sym == '!' OR sym == '&' OR sym == '|'\n                ADD sym TO END OF pile\n            ELSE IF sym == ')'\n                SET tallyTrue TO 0\n                SET tallyFalse TO 0\n                WHILE pile[LAST_INDEX(pile)] == 't' OR pile[LAST_INDEX(pile)] == 'f'\n                    IF pile[LAST_INDEX(pile)] == 't'\n                        tallyTrue <- tallyTrue + 1\n                    END IF\n                    IF pile[LAST_INDEX(pile)] == 'f'\n                        tallyFalse <- tallyFalse + 1\n                    END IF\n                    REMOVE LAST ELEMENT FROM pile\n                END WHILE\n\n                SET operatorSym TO pile[LAST_INDEX(pile)]\n                REMOVE LAST ELEMENT FROM pile\n\n                IF operatorSym == '!'\n                    IF tallyFalse > 0\n                        SET sym TO 't'\n                    ELSE\n                        SET sym TO 'f'\n                    END IF\n                ELSE IF operatorSym == '&'\n                    IF tallyFalse > 0\n                        SET sym TO 'f'\n                    ELSE\n                        SET sym TO 't'\n                    END IF\n                ELSE IF operatorSym == '|'\n                    IF tallyTrue > 0\n                        SET sym TO 't'\n                    ELSE\n                        SET sym TO 'f'\n                    END IF\n                END IF\n                ADD sym TO END OF pile\n            END IF\n            SET idx TO idx + 1\n        END WHILE\n        RETURN pile[0] == 't'\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION parseBoolExpr(expression)  \n        SET stk TO empty list  \n        FOR each character c IN expression  \n            IF c EQUALS one of the characters representing true false negation and and or  \n                APPEND c TO stk  \n            ELSE IF c EQUALS the character representing closing parenthesis  \n                SET count_true TO zero  \n                SET count_false TO zero  \n                WHILE the last element in stk EQUALS one of the characters representing true or false  \n                    INCREMENT count_true BY one IF the last element in stk EQUALS the character representing true  \n                    INCREMENT count_false BY one IF the last element in stk EQUALS the character representing false  \n                    REMOVE the last element FROM stk  \n                END WHILE  \n                SET operator TO the last element FROM stk  \n                REMOVE the last element FROM stk  \n                IF operator EQUALS the character representing negation  \n                    SET c TO the character representing true IF count_false IS GREATER THAN zero OTHERWISE the character representing false  \n                ELSE IF operator EQUALS the character representing and  \n                    SET c TO the character representing false IF count_false IS GREATER THAN zero OTHERWISE the character representing true  \n                ELSE IF operator EQUALS the character representing or  \n                    SET c TO the character representing true IF count_true IS GREATER THAN zero OTHERWISE the character representing false  \n                END IF  \n                APPEND c TO stk  \n            END IF  \n        END FOR  \n        RETURN whether the first element of stk EQUALS the character representing true  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "string-transforms-into-another-string", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION canConvert WITH PARAMETERS str1 str2  \n        ASSIGN True TO resultFlag  \n        IF NOT (str1 = str2) THEN  \n            DECLARE charMapping AS empty dictionary of character to character  \n            DECLARE indexCounter AS 0  \n            WHILE indexCounter < LENGTH(str1) DO  \n                DECLARE currentChar1 AS str1[indexCounter]  \n                DECLARE currentChar2 AS str2[indexCounter]  \n                IF currentChar1 IN charMapping THEN  \n                    IF charMapping[currentChar1] ≠ currentChar2 THEN  \n                        ASSIGN False TO resultFlag  \n                        BREAK  \n                    END IF  \n                ELSE  \n                    charMapping[currentChar1] ← currentChar2  \n                END IF  \n                INCREMENT indexCounter BY 1  \n            END WHILE  \n            IF SIZE(SET OF str2) = 26 THEN  \n                ASSIGN False TO resultFlag  \n            END IF  \n        END IF  \n        RETURN resultFlag  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canConvert(str1 str2)  \n        IF str1 EQUALS str2  \n            RETURN True  \n        END IF  \n        SET conversion_map TO empty mapping  \n        FOR each pair of char1 AND char2 IN corresponding elements of str1 AND str2  \n            IF char1 IN keys of conversion_map  \n                IF value at key char1 of conversion_map NOT EQUALS char2  \n                    RETURN False  \n                END IF  \n            ELSE  \n                SET value at key char1 of conversion_map TO char2  \n            END IF  \n        END FOR  \n        IF the LENGTH OF the set of all unique characters in str2 EQUALS twenty six  \n            RETURN False  \n        END IF  \n        RETURN True  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "count-vowels-permutation", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION countVowelPermutation(n)  \n        ASSIGN 1_000_000_007 TO MOD  \n        ASSIGN 1 TO alpha  \n        ASSIGN 1 TO bravo  \n        ASSIGN 1 TO charlie  \n        ASSIGN 1 TO delta  \n        ASSIGN 1 TO echo  \n        ASSIGN 2 TO counter  \n        WHILE counter IS NOT GREATER THAN n  \n            ASSIGN (bravo PLUS charlie PLUS echo) TO alpha_next  \n            ASSIGN (alpha PLUS charlie) TO bravo_next  \n            ASSIGN (bravo PLUS delta) TO charlie_next  \n            ASSIGN charlie TO delta_next  \n            ASSIGN (charlie PLUS delta) TO echo_next  \n            ASSIGN alpha_next MOD MOD TO alpha  \n            ASSIGN bravo_next MOD MOD TO bravo  \n            ASSIGN charlie_next MOD MOD TO charlie  \n            ASSIGN delta_next MOD MOD TO delta  \n            ASSIGN echo_next MOD MOD TO echo  \n            INCREMENT counter BY 1  \n        END WHILE  \n        ASSIGN (alpha PLUS bravo PLUS charlie PLUS delta PLUS echo) TO temp_sum  \n        ASSIGN temp_sum MOD MOD TO output  \n        RETURN output  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION countVowelPermutation WITH PARAMETER n  \n        SET MOD TO ten RAISED TO THE POWER OF nine PLUS one  \n        SET a TO one  \n        SET e TO one  \n        SET i TO one  \n        SET o TO one  \n        SET u TO one  \n        FOR each number FROM two TO n  \n            SET a_next TO the sum of e PLUS i PLUS u  \n            SET e_next TO the sum of a PLUS i  \n            SET i_next TO the sum of e PLUS o  \n            SET o_next TO i  \n            SET u_next TO the sum of i PLUS o  \n            SET a TO the remainder of a_next DIVIDED BY MOD  \n            SET e TO the remainder of e_next DIVIDED BY MOD  \n            SET i TO the remainder of i_next DIVIDED BY MOD  \n            SET o TO the remainder of o_next DIVIDED BY MOD  \n            SET u TO the remainder of u_next DIVIDED BY MOD  \n        END FOR  \n        SET result TO the remainder of a PLUS e PLUS i PLUS o PLUS u DIVIDED BY MOD  \n        RETURN result  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "largest-multiple-of-three", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION largestMultipleOfThree(digits)\n        ASSIGN a map named freq_map WITH count of occurrences in digits\n        ASSIGN sum_total WITH 0\n        ASSIGN index_i WITH 0\n        WHILE index_i LESS THAN length of digits DO\n            INCREMENT sum_total BY digits[index_i]\n            INCREMENT index_i BY 1\n        END WHILE\n\n        ASSIGN rem TO sum_total MOD 3\n\n        IF rem IS 1 THEN\n            ASSIGN option_found TO FALSE\n            ASSIGN arr_chk TO [1,4,7]\n            ASSIGN pos_j TO 0\n            WHILE pos_j LESS THAN length of arr_chk AND NOT option_found DO\n                ASSIGN key_d TO arr_chk[pos_j]\n                IF freq_map[key_d] GREATER THAN 0 THEN\n                    DECREMENT freq_map[key_d] BY 1\n                    ASSIGN option_found TO TRUE\n                END IF\n                INCREMENT pos_j BY 1\n            END WHILE\n\n            IF NOT option_found THEN\n                ASSIGN arr_alt TO [2,5,8]\n                ASSIGN pos_k TO 0\n                WHILE pos_k LESS THAN length of arr_alt AND NOT option_found DO\n                    ASSIGN key_e TO arr_alt[pos_k]\n                    IF freq_map[key_e] GREATER THAN 1 THEN\n                        DECREMENT freq_map[key_e] BY 2\n                        ASSIGN option_found TO TRUE\n                    END IF\n                    INCREMENT pos_k BY 1\n                END WHILE\n            END IF\n\n        ELSE IF rem IS 2 THEN\n            ASSIGN found_flag TO FALSE\n            ASSIGN first_arr TO [2,5,8]\n            ASSIGN pos_m TO 0\n            WHILE pos_m LESS THAN length of first_arr AND NOT found_flag DO\n                ASSIGN val_n TO first_arr[pos_m]\n                IF freq_map[val_n] GREATER THAN 0 THEN\n                    DECREMENT freq_map[val_n] BY 1\n                    ASSIGN found_flag TO TRUE\n                END IF\n                INCREMENT pos_m BY 1\n            END WHILE\n\n            IF NOT found_flag THEN\n                ASSIGN second_arr TO [1,4,7]\n                ASSIGN pos_o TO 0\n                WHILE pos_o LESS THAN length of second_arr AND NOT found_flag DO\n                    ASSIGN val_p TO second_arr[pos_o]\n                    IF freq_map[val_p] GREATER THAN 1 THEN\n                        DECREMENT freq_map[val_p] BY 2\n                        ASSIGN found_flag TO TRUE\n                    END IF\n                    INCREMENT pos_o BY 1\n                END WHILE\n            END IF\n        END IF\n\n        ASSIGN output_list TO empty array\n        ASSIGN digit_d TO 9\n        WHILE digit_d GREATER THAN OR EQUAL TO 0 DO\n            ASSIGN count_q TO freq_map[digit_d]\n            ASSIGN run_idx TO 0\n            WHILE run_idx LESS THAN count_q DO\n                APPEND string representation of digit_d TO output_list\n                INCREMENT run_idx BY 1\n            END WHILE\n            DECREMENT digit_d BY 1\n        END WHILE\n\n        ASSIGN final_str TO concatenate all strings in output_list without separator\n\n        IF final_str IS NOT EMPTY AND NOT (final_str[0] NOT EQUAL 0) THEN\n            RETURN \"0\"\n        END IF\n\n        RETURN final_str\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION largestMultipleOfThree(digits)  \n        SET count TO a mapping of digits to their frequencies  \n        SET total_sum TO the sum of all elements in digits  \n        SET remainder TO the remainder when total_sum is divided by three  \n        IF remainder EQUALS one  \n            FOR each digit IN the list containing one four seven  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing two five eight  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        IF remainder EQUALS two  \n            FOR each digit IN the list containing two five eight  \n                IF the frequency of digit in count IS GREATER THAN zero  \n                    DECREMENT the frequency of digit in count BY one  \n                    BREAK the loop  \n                END IF  \n            END FOR  \n            OTHERWISE  \n                FOR each digit IN the list containing one four seven  \n                    IF the frequency of digit in count IS GREATER THAN one  \n                        DECREMENT the frequency of digit in count BY two  \n                        BREAK the loop  \n                    END IF  \n                END FOR  \n            END OTHERWISE  \n        END IF  \n        SET result TO an empty list  \n        FOR digit FROM nine DOWN TO zero  \n            APPEND the string form of digit repeated frequency of digit in count times TO result  \n        END FOR  \n        SET final_number TO the concatenation of all elements in result  \n        IF final_number IS NOT empty AND the element at position one of final_number EQUALS zero  \n            RETURN zero as string  \n        ELSE  \n            RETURN final_number  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-cut-a-stick", "label": "cosmetic", "pseudocode": "CLASS Solution\n\t FUNCTION minCost(n, cuts)\n\t\t ASSIGN temp_array TO array_with_elements_of(cuts)\n\t\t ATTACH_ELEMENT temp_array WITH zero\n\t\t ATTACH_ELEMENT temp_array WITH n\n\t\t SORT_ARRAY temp_array ASCENDING\n\n\t\t FUNCTION dp(left, right)\n\t\t\t IF (right - left) > 1 THEN\n\t\t\t\t ASSIGN best_val TO +∞\n\t\t\t\t ASSIGN iter_var TO left + 1\n\t\t\t\t WHILE iter_var < right\n\t\t\t\t\t ASSIGN current_cost TO (temp_array[right] - temp_array[left]) + dp(left, iter_var) + dp(iter_var, right)\n\t\t\t\t\t IF current_cost < best_val THEN\n\t\t\t\t\t\t ASSIGN best_val TO current_cost\n\t\t\t\t\t ENDIF\n\t\t\t\t\t ASSIGN iter_var TO iter_var + 1\n\t\t\t\t ENDWHILE\n\n\t\t\t\t YIELD best_val\n\t\t\t ELSE\n\t\t\t\t YIELD 0\n\t\t\t ENDIF\n\t\t END FUNCTION\n\n\t\t YIELD dp(0, LENGTH_OF(temp_array) - 1)\n\t END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minCost(n, cuts)  \n        SET cuts TO the sorted result of appending zero and n to cuts  \n        \n        FUNCTION dp(left, right)  \n            IF the result of right MINUS left is LESS THAN OR EQUAL TO one THEN  \n                RETURN zero  \n            END IF  \n            \n            SET min_cost TO a value representing infinity  \n            FOR i FROM the result of left PLUS one TO the result of right MINUS one  \n                SET cost TO the element at position right of cuts MINUS the element at position left of cuts PLUS dp(left, i) PLUS dp(i, right)  \n                IF cost IS LESS THAN min_cost THEN  \n                    SET min_cost TO cost  \n                END IF  \n            END FOR  \n            \n            RETURN min_cost  \n        END FUNCTION  \n        \n        RETURN dp(zero, the result of the length of cuts MINUS one)  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-connect-two-groups-of-points", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION connectTwoGroups(cost)\n        ASSIGN countA ← LENGTH(cost)\n        ASSIGN countB ← LENGTH(cost[0])\n        ASSIGN dpTable ← ARRAY OF size (countA + 1) × (2 ^ countB), ALL SET TO infinity\n        dpTable[0][0] ← 0\n\n        DECLARE outerIndex ← 0\n        WHILE outerIndex ≤ countA - 1 DO\n            DECLARE subsetMask ← 0\n            WHILE subsetMask < (1 << countB) DO\n                DECLARE midIndex ← 0\n                WHILE midIndex ≤ countB - 1 DO\n                    DECLARE newMask ← subsetMask OR (1 << midIndex)\n                    ASSIGN newVal ← dpTable[outerIndex][subsetMask] + cost[outerIndex][midIndex]\n                    IF newVal < dpTable[outerIndex + 1][newMask] THEN\n                        dpTable[outerIndex + 1][newMask] ← newVal\n                    END IF\n                    midIndex ← midIndex + 1\n                END WHILE\n\n                DECLARE innerIndex ← 0\n                WHILE innerIndex ≤ countB - 1 DO\n                    IF (subsetMask AND (1 << innerIndex)) ≠ 0 THEN\n                        DECLARE toggledMask ← subsetMask XOR (1 << innerIndex)\n                        DECLARE candidate ← dpTable[outerIndex + 1][toggledMask] + cost[outerIndex][innerIndex]\n                        IF candidate < dpTable[outerIndex + 1][subsetMask] THEN\n                            dpTable[outerIndex + 1][subsetMask] ← candidate\n                        END IF\n                    END IF\n                    innerIndex ← innerIndex + 1\n                END WHILE\n\n                subsetMask ← subsetMask + 1\n            END WHILE\n            outerIndex ← outerIndex + 1\n        END WHILE\n\n        RETURN dpTable[countA][(1 << countB) - 1]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution\n    FUNCTION connectTwoGroups(cost)\n        SET size one TO the LENGTH OF cost\n        SET size two TO the LENGTH OF the element at position zero OF cost\n\n        SET dp_table TO a list of lists WHERE EACH inner list CONTAINS the INFINITY value REPEATED a number of times EQUAL TO TWO RAISED TO the POWER OF size two\n        AND the number of such lists IS size one PLUS one\n\n        SET the element at position zero OF the element at position zero OF dp_table TO zero\n\n        FOR index i FROM zero TO size one MINUS one INCLUSIVE\n            FOR index mask FROM zero TO TWO RAISED TO the POWER OF size two MINUS one INCLUSIVE\n                FOR index j FROM zero TO size two MINUS one INCLUSIVE\n                    SET dp_table at position i PLUS one at position mask OR TWO RAISED TO the POWER OF j TO the LESSER OF\n                        the current value at dp_table at position i PLUS one at position mask OR TWO RAISED TO the POWER OF j\n                        AND the sum of dp_table at position i at position mask PLUS the element at position i at position j OF cost\n                END FOR\n\n                FOR index j FROM zero TO size two MINUS one INCLUSIVE\n                    IF the bitwise AND of mask AND TWO RAISED TO the POWER OF j HOLDS TRUE\n                        SET dp_table at position i PLUS one at position mask TO the LESSER OF\n                            the current value at dp_table at position i PLUS one at position mask\n                            AND the sum of dp_table at position i PLUS one at position mask with the bitwise exclusive OR of mask AND TWO RAISED TO the POWER OF j PLUS the element at position i at position j OF cost\n                    END IF\n                END FOR\n            END FOR\n        END FOR\n\n        RETURN the element at position size one at position TWO RAISED TO the POWER OF size two MINUS one OF dp_table\n    END FUNCTION\nEND CLASS"}
{"task_id": "minimum-incompatibility", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minimumIncompatibility(nums k)\n        ASSIGN length_nums ← LENGTH OF nums\n        COMPUTE group_size ← length_nums DIVIDED BY k\n        FORM frequency_map AS A MAPPING OF ELEMENT TO ITS OCCURRENCE COUNT IN nums\n\n        FOR each occurrence_count IN VALUES OF frequency_map DO\n            IF occurrence_count GREATER THAN k THEN\n                RETURN -1\n            ENDIF\n        ENDFOR\n\n        INITIATE dictionary incompatibility_map AS EMPTY\n\n        ASSIGN upper_limit ← (2 TO THE POWER OF length_nums) - 1\n\n        FOR candidate_subset FROM 0 TO upper_limit DO\n            CALCULATE bits_set ← NUMBER OF 1 BITS IN BINARY REPRESENTATION OF candidate_subset\n            IF bits_set IS EQUAL TO group_size THEN\n                INITIALIZE list current_elements AS EMPTY\n                FOR index FROM 0 TO length_nums - 1 DO\n                    COMPUTE current_bit ← 1 LEFT SHIFTED BY index\n                    IF (candidate_subset BITWISE-AND current_bit) IS NOT ZERO THEN\n                        APPEND nums AT index TO current_elements\n                    ENDIF\n                ENDFOR\n\n                ASSIGN unique_count ← COUNT OF UNIQUE MEMBERS IN current_elements\n                IF unique_count EQUALS group_size THEN\n                    CALCULATE max_val ← MAXIMUM VALUE IN current_elements\n                    CALCULATE min_val ← MINIMUM VALUE IN current_elements\n                    ASSIGN incompatibility_map[candidate_subset] ← max_val MINUS min_val\n                ENDIF\n            ENDIF\n        ENDFOR\n\n        DEFINE dp_array AS A LIST OF SIZE (2 TO THE POWER OF length_nums) FILLED WITH infinity\n        SET dp_array[0] TO 0\n\n        FOR state_mask FROM 0 TO upper_limit DO\n            COMPUTE selected_bits ← NUMBER OF 1 BITS IN BINARY REPRESENTATION OF state_mask\n            IF (selected_bits MODULO group_size) NOT EQUAL TO 0 THEN\n                CONTINUE TO NEXT ITERATION\n            ENDIF\n\n            FOR valid_subset IN KEYS OF incompatibility_map DO\n                IF (state_mask BITWISE-AND valid_subset) EQUALS valid_subset THEN\n                    COMPUTE potential_score ← dp_array[state_mask - valid_subset] + incompatibility_map[valid_subset]\n                    IF potential_score LESS THAN dp_array[state_mask] THEN\n                        SET dp_array[state_mask] TO potential_score\n                    ENDIF\n                ENDIF\n            ENDFOR\n        ENDFOR\n\n        ASSIGN complete_mask ← upper_limit\n        IF dp_array[complete_mask] DIFFERENT FROM infinity THEN\n            RETURN dp_array[complete_mask]\n        ELSE\n            RETURN -1\n        ENDIF\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minimumIncompatibility(nums, k)  \n        SET n TO the LENGTH OF nums  \n        SET subset_size TO n DIVIDED BY k  \n        \n        IF there EXISTS a count of any number in nums WHERE the count GREATER THAN k  \n            RETURN negative one  \n        END IF  \n        \n        SET subset_incompatibility TO an empty mapping  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF bit_count EQUALS subset_size  \n                SET elements TO an empty list  \n                FOR i FROM zero TO n MINUS one  \n                    IF the BIT AT position i OF mask EQUALS one  \n                        APPEND the element at position i OF nums TO elements  \n                    END IF  \n                END FOR  \n                \n                IF the NUMBER OF UNIQUE elements IN elements EQUALS subset_size  \n                    SET incompatibility TO the MAXIMUM OF elements MINUS the MINIMUM OF elements  \n                    ASSIGN incompatibility TO the ENTRY of mask IN subset_incompatibility  \n                END IF  \n            END IF  \n        END FOR  \n        \n        SET dp TO a list of LENGTH two RAISED TO THE POWER OF n FILLED WITH positive infinity  \n        SET the ELEMENT AT position zero OF dp TO zero  \n        \n        FOR mask FROM zero TO two RAISED TO THE POWER OF n MINUS one  \n            SET bit_count TO the COUNT OF positions IN mask WHERE the BIT AT position OF mask EQUALS one  \n            IF the REMAINDER of bit_count DIVIDED BY subset_size NOT EQUAL TO zero  \n                CONTINUE to the next iteration  \n            END IF  \n            \n            FOR each subset_mask IN the KEYS OF subset_incompatibility  \n                IF the BINARY AND OF mask AND subset_mask EQUALS subset_mask  \n                    SET dp AT position mask TO the MINIMUM OF the CURRENT dp AT position mask AND the dp AT position of the BINARY XOR OF mask AND subset_mask PLUS the VALUE of subset_mask IN subset_incompatibility  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET full_mask TO two RAISED TO THE POWER OF n MINUS one  \n        IF the ELEMENT AT position full_mask OF dp NOT EQUAL TO positive infinity  \n            RETURN the ELEMENT AT position full_mask OF dp  \n        ELSE  \n            RETURN negative one  \n        END IF  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "sum-of-special-evenly-spaced-elements-in-array", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION solve(nums list OF integers, queries list OF list OF integers) RETURNS list OF integers\n        ASSIGN 1_000_000_007 TO MOD\n        ASSIGN LENGTH(nums) TO count\n        ASSIGN MAXIMUM(pair[1] FOR pair IN queries) TO peak_y\n        ALLOCATE prefixArrays AS ARRAY OF peak_y + 1 ELEMENTS WHERE EACH ELEMENT IS ARRAY OF count ZEROS\n        \n        SET idx_y TO 1\n        WHILE idx_y <= peak_y DO\n            SET idx_i TO count - 1\n            WHILE idx_i >= 0 DO\n                IF NOT (idx_i + idx_y >= count) THEN\n                    ASSIGN prefixArrays[idx_y][idx_i] TO nums[idx_i] + prefixArrays[idx_y][idx_i + idx_y]\n                ELSE\n                    ASSIGN prefixArrays[idx_y][idx_i] TO nums[idx_i]\n                ENDIF\n                DECREMENT idx_i BY 1\n            ENDWHILE\n            INCREMENT idx_y BY 1\n        ENDWHILE\n        \n        ASSIGN EMPTY LIST TO results\n        SET query_counter TO 0\n        SET total_queries TO LENGTH(queries)\n        WHILE query_counter < total_queries DO\n            LET current_query BE queries[query_counter]\n            LET start_x BE current_query[0]\n            LET height_y BE current_query[1]\n            LET value TO prefixArrays[height_y][start_x] MODULO MOD\n            APPEND value TO results\n            INCREMENT query_counter BY 1\n        ENDWHILE\n        \n        RETURN results\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION solve(nums parameters LIST OF INTEGER, queries parameters LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER  \n        SET MOD TO one billion PLUS seven  \n        SET n TO the LENGTH OF nums  \n        SET max_y TO the MAXIMUM VALUE OF the second element in each pair OF queries  \n        INITIALIZE prefix_sums AS a LIST containing max_y PLUS one ELEMENTS each being a LIST of zeroes with LENGTH n  \n        FOR y FROM one TO max_y  \n            FOR i FROM n MINUS one DOWN TO zero  \n                IF i PLUS y LESS THAN n THEN  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums PLUS element at position i PLUS y of prefix_sums at position y  \n                ELSE  \n                    SET element at position i of prefix_sums at position y TO element at position i of nums  \n                END IF  \n            END FOR  \n        END FOR  \n        INITIALIZE answer AS an empty LIST  \n        FOR each pair x and y IN queries  \n            APPEND to answer the element at position x of prefix_sums at position y MODULO MOD  \n        END FOR  \n        RETURN answer  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "cat-and-mouse-ii", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        ASSIGN row_count TO LENGTH OF grid  \n        ASSIGN col_count TO LENGTH OF grid[0]  \n        ASSIGN start_cat TO 0  \n        ASSIGN start_mouse TO 0  \n        ASSIGN position_food TO 0  \n        ASSIGN directions TO [(-1,0),(1,0),(0,-1),(0,1)]  \n  \n        ASSIGN moves_mouse TO ARRAY OF EMPTY ARRAYS WITH SIZE row_count * col_count  \n        ASSIGN moves_cat TO ARRAY OF EMPTY ARRAYS WITH SIZE row_count * col_count  \n  \n        FOR row_index, row_value IN ENUMERATE(grid) DO  \n            FOR col_index, cell_value IN ENUMERATE(row_value) DO  \n                IF cell_value == '#' THEN  \n                    CONTINUE TO NEXT ITERATION  \n                END IF  \n                ASSIGN pos_linear TO row_index * col_count + col_index  \n                IF cell_value == 'C' THEN  \n                    start_cat = pos_linear  \n                ELSE IF cell_value == 'M' THEN  \n                    start_mouse = pos_linear  \n                ELSE IF cell_value == 'F' THEN  \n                    position_food = pos_linear  \n                END IF  \n  \n                FOR dir_x, dir_y IN directions DO  \n                    VAR step_mouse = 0  \n                    WHILE step_mouse <= mouseJump DO  \n                        ASSIGN new_x TO row_index + step_mouse * dir_x  \n                        ASSIGN new_y TO col_index + step_mouse * dir_y  \n                        IF new_x < 0 OR new_x >= row_count OR new_y < 0 OR new_y >= col_count OR grid[new_x][new_y] == '#' THEN  \n                            BREAK  \n                        END IF  \n                        moves_mouse[pos_linear].APPEND(new_x * col_count + new_y)  \n                        step_mouse = step_mouse + 1  \n                    END WHILE  \n  \n                    VAR step_cat = 0  \n                    WHILE step_cat <= catJump DO  \n                        ASSIGN new_x TO row_index + step_cat * dir_x  \n                        ASSIGN new_y TO col_index + step_cat * dir_y  \n                        IF new_x < 0 OR new_x >= row_count OR new_y < 0 OR new_y >= col_count OR grid[new_x][new_y] == '#' THEN  \n                            BREAK  \n                        END IF  \n                        moves_cat[pos_linear].APPEND(new_x * col_count + new_y)  \n                        step_cat = step_cat + 1  \n                    END WHILE  \n                END FOR  \n            END FOR  \n        END FOR  \n  \n        RETURN calc(moves_mouse, moves_cat, start_mouse, start_cat, position_food) == 1  \n    END FUNCTION  \n  \n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            ASSIGN mouse_pos TO state[0]  \n            ASSIGN cat_pos TO state[1]  \n            ASSIGN turn TO state[2]  \n            ASSIGN previous_turn TO turn XOR 1  \n            ASSIGN result TO EMPTY LIST  \n  \n            IF previous_turn == 1 THEN  \n                FOR cat_prev IN g_cat[cat_pos] DO  \n                    IF ans[mouse_pos][cat_prev][1] == 0 THEN  \n                        result.APPEND([mouse_pos, cat_prev, previous_turn])  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR mouse_prev IN g_mouse[mouse_pos] DO  \n                    IF ans[mouse_prev][cat_pos][0] == 0 THEN  \n                        result.APPEND([mouse_prev, cat_pos, previous_turn])  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN result  \n        END FUNCTION  \n  \n        ASSIGN total_states TO LENGTH(g_mouse)  \n        ASSIGN degree TO THREE-DIMENSIONAL ARRAY FILLED WITH 0 OF SIZE [total_states][total_states][2]  \n  \n        FOR i FROM 0 TO total_states - 1 DO  \n            FOR j FROM 0 TO total_states - 1 DO  \n                degree[i][j][0] = LENGTH(g_mouse[i])  \n                degree[i][j][1] = LENGTH(g_cat[j])  \n            END FOR  \n        END FOR  \n  \n        ASSIGN ans TO THREE-DIMENSIONAL ARRAY FILLED WITH 0 OF SIZE [total_states][total_states][2]  \n        ASSIGN queue TO EMPTY DEQUE  \n  \n        FOR idx FROM 0 TO total_states - 1 DO  \n            ans[hole][idx][1] = 1  \n            ans[idx][hole][0] = 2  \n            ans[idx][idx][1] = 2  \n            ans[idx][idx][0] = 2  \n  \n            queue.ADD_LAST([hole, idx, 1])  \n            queue.ADD_LAST([idx, hole, 0])  \n            queue.ADD_LAST([idx, idx, 0])  \n            queue.ADD_LAST([idx, idx, 1])  \n        END FOR  \n  \n        WHILE queue IS NOT EMPTY DO  \n            ASSIGN current_state TO queue.REMOVE_FIRST()  \n            ASSIGN current_result TO ans[current_state[0]][current_state[1]][current_state[2]]  \n  \n            FOR prev_state IN get_prev_states(current_state) DO  \n                ASSIGN pm TO prev_state[0]  \n                ASSIGN pc TO prev_state[1]  \n                ASSIGN pt TO prev_state[2]  \n  \n                IF pt == current_result - 1 THEN  \n                    ans[pm][pc][pt] = current_result  \n                    queue.ADD_LAST(prev_state)  \n                ELSE  \n                    degree[pm][pc][pt] = degree[pm][pc][pt] - 1  \n                    IF degree[pm][pc][pt] == 0 THEN  \n                        ans[pm][pc][pt] = current_result  \n                        queue.ADD_LAST(prev_state)  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n  \n        RETURN ans[mouse_start][cat_start][0]  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION canMouseWin(grid, catJump, mouseJump)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET cat_start TO zero  \n        SET mouse_start TO zero  \n        SET food TO zero  \n        SET dirs TO the sequence of negative one zero one zero negative one  \n        SET g_mouse TO a list containing m MULTIPLIED BY n empty lists  \n        SET g_cat TO a list containing m MULTIPLIED BY n empty lists  \n        FOR each pair of index i AND element row IN grid WITH enumeration  \n            FOR each pair of index j AND element c IN row WITH enumeration  \n                IF c EQUALS the character hash  \n                    CONTINUE to next iteration  \n                END IF  \n                SET v TO i MULTIPLIED BY n PLUS j  \n                IF c EQUALS the character C  \n                    SET cat_start TO v  \n                ELSE IF c EQUALS the character M  \n                    SET mouse_start TO v  \n                ELSE IF c EQUALS the character F  \n                    SET food TO v  \n                END IF  \n                FOR each pair of consecutive elements a AND b IN dirs  \n                    FOR k FROM zero TO mouseJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_mouse  \n                    END FOR  \n                    FOR k FROM zero TO catJump INCLUSIVE  \n                        SET x TO i PLUS k MULTIPLIED BY a  \n                        SET y TO j PLUS k MULTIPLIED BY b  \n                        IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO m OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO n OR the element at position x of grid EQUALS the character hash  \n                            BREAK the loop  \n                        END IF  \n                        APPEND x MULTIPLIED BY n PLUS y TO the element at position v of g_cat  \n                    END FOR  \n                END FOR  \n            END FOR  \n        END FOR  \n        RETURN the result of the FUNCTION calc WITH parameters g_mouse g_cat mouse_start cat_start food EQUALS one  \n    END FUNCTION  \n\n    FUNCTION calc(g_mouse, g_cat, mouse_start, cat_start, hole)  \n        FUNCTION get_prev_states(state)  \n            DECOMPOSE state INTO m c t  \n            SET pt TO t XOR one  \n            SET pre TO empty list  \n            IF pt EQUALS one  \n                FOR each pc IN the element at position c of g_cat  \n                    IF the element at position m THEN at position pc THEN at position one OF ans EQUALS zero  \n                        APPEND the tuple m pc pt TO pre  \n                    END IF  \n                END FOR  \n            ELSE  \n                FOR each pm IN the element at position m of g_mouse  \n                    IF the element at position pm THEN at position c THEN at position zero OF ans EQUALS zero  \n                        APPEND the tuple pm c zero TO pre  \n                    END IF  \n                END FOR  \n            END IF  \n            RETURN pre  \n        END FUNCTION  \n\n        SET n TO the LENGTH OF g_mouse  \n        SET degree TO a three dimensional list of zeros with dimensions n by n by two  \n        FOR i FROM zero TO n MINUS one  \n            FOR j FROM zero TO n MINUS one  \n                SET the element at position zero of the element at position j of the element at position i of degree TO the LENGTH OF the element at position i of g_mouse  \n                SET the element at position one of the element at position j of the element at position i of degree TO the LENGTH OF the element at position j of g_cat  \n            END FOR  \n        END FOR  \n\n        SET ans TO a three dimensional list of zeros with dimensions n by n by two  \n        SET q TO an empty double ended queue  \n        FOR i FROM zero TO n MINUS one  \n            SET the element at position one of the element at position i of the element at position hole of ans TO one  \n            SET the element at position zero of the element at position hole of the element at position i of ans TO two  \n            SET the element at position one of the element at position i of the element at position i of ans TO two  \n            SET the element at position zero of the element at position i of the element at position i of ans TO two  \n            APPEND the tuple hole i one TO q  \n            APPEND the tuple i hole zero TO q  \n            APPEND the tuple i i zero TO q  \n            APPEND the tuple i i one TO q  \n        END FOR  \n\n        WHILE q is not empty  \n            SET state TO the element removed from the left of q  \n            SET t TO the element at position two OF ans at dimension positions state at zero state at one state at two  \n            FOR each prev_state IN the result of calling get_prev_states WITH state  \n                DECOMPOSE prev_state INTO pm pc pt  \n                IF pt EQUALS t MINUS one  \n                    SET the element at position pt OF ans at dimension positions pm pc TO t  \n                    APPEND prev_state TO q  \n                ELSE  \n                    DECREMENT the element at position pt OF degree at dimension positions pm pc BY one  \n                    IF the element at position pt OF degree at dimension positions pm pc EQUALS zero  \n                        SET the element at position pt OF ans at dimension positions pm pc TO t  \n                        APPEND prev_state TO q  \n                    END IF  \n                END IF  \n            END FOR  \n        END WHILE  \n        RETURN the element at position zero OF ans at dimension positions mouse_start cat_start  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "maximum-fruits-harvested-after-at-most-k-steps", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION maxTotalFruits(fruits AS list of list of integers, startPos AS integer, k AS integer) RETURNS integer\n        ASSIGN 0 TO peak\n        ASSIGN 0 TO aggregate\n        ASSIGN 0 TO beginIndex\n\n        ASSIGN fruits.LENGTH TO ceiling\n        ASSIGN 0 TO cursor\n\n        WHILE cursor < ceiling\n            ASSIGN fruits[cursor][0] TO spot\n            ASSIGN fruits[cursor][1] TO quantity\n            ASSIGN aggregate + quantity TO aggregate\n\n            LOOP\n                EXIT WHEN beginIndex > cursor\n                IF (startPos - k <= fruits[beginIndex][0]) AND (fruits[beginIndex][0] <= startPos + k) AND (startPos - k <= fruits[cursor][0]) AND (fruits[cursor][0] <= startPos + k) THEN\n                    ASSIGN MIN(ABS(fruits[cursor][0] - startPos), ABS(fruits[beginIndex][0] - startPos)) + (fruits[cursor][0] - fruits[beginIndex][0]) <= k TO rangeCheck\n                    IF rangeCheck THEN\n                        BREAK\n                    END IF\n                END IF\n                ASSIGN aggregate - fruits[beginIndex][1] TO aggregate\n                ASSIGN beginIndex + 1 TO beginIndex\n            END LOOP\n\n            IF peak < aggregate THEN\n                ASSIGN aggregate TO peak\n            END IF\n            ASSIGN cursor + 1 TO cursor\n        END WHILE\n\n        RETURN peak\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION maxTotalFruits(fruits, startPos, k)  \n        SET max_fruits TO zero  \n        SET total_fruits TO zero  \n        SET left TO zero  \n        FOR right FROM zero TO the LENGTH OF fruits MINUS one  \n            SET position TO the element at position right of fruits at position zero  \n            SET amount TO the element at position right of fruits at position one  \n            INCREMENT total_fruits BY amount  \n            WHILE left LESS THAN OR EQUAL TO right AND NOT (startPos MINUS k LESS THAN OR EQUAL TO the element at position left of fruits at position zero AND the element at position left of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND startPos MINUS k LESS THAN OR EQUAL TO the element at position right of fruits at position zero AND the element at position right of fruits at position zero LESS THAN OR EQUAL TO startPos PLUS k AND the MINIMUM OF the ABSOLUTE VALUE OF the element at position right of fruits at position zero MINUS startPos AND the ABSOLUTE VALUE OF the element at position left of fruits at position zero MINUS startPos PLUS the element at position right of fruits at position zero MINUS the element at position left of fruits at position zero LESS THAN OR EQUAL TO k)  \n                DECREMENT total_fruits BY the element at position left of fruits at position one  \n                INCREMENT left BY one  \n            END WHILE  \n            SET max_fruits TO the GREATER OF max_fruits AND total_fruits  \n        END FOR  \n        RETURN max_fruits  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "longest-substring-of-one-repeating-character", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION longestRepeating(s queryCharacters queryIndices)\n        FUNCTION merge_intervals()\n            ASSIGN 0 TO z\n            WHILE z < (LENGTH(intervals) - 1)\n                IF (intervals[z][2] = intervals[z + 1][2])\n                    ASSIGN (intervals[z][0], intervals[z + 1][1], intervals[z][2]) TO intervals[z]\n                    REMOVE intervals AT (z + 1)\n                ELSE\n                    ASSIGN (z + 1) TO z\n                END IF\n            END WHILE\n        END FUNCTION\n\n        ASSIGN [] TO intervals\n        ASSIGN LENGTH(s) TO m\n        ASSIGN 0 TO alpha\n        ASSIGN 1 TO beta\n        WHILE beta < m\n            IF s[beta] <> s[alpha]\n                APPEND (alpha, beta - 1, s[alpha]) TO intervals\n                ASSIGN beta TO alpha\n            END IF\n            ASSIGN (beta + 1) - 1 TO beta\n        END WHILE\n        APPEND (alpha, m - 1, s[alpha]) TO intervals\n\n        ASSIGN [] TO outputs\n        ASSIGN MAXIMUM OF ((e - b) + 1) FOR EACH (b e t) IN intervals TO max_len\n\n        ASSIGN 0 TO cc\n        WHILE cc < LENGTH(queryCharacters)\n            ASSIGN queryCharacters[cc] TO newChar\n            ASSIGN queryIndices[cc] TO posIdx\n\n            ASSIGN 0 TO rr\n            WHILE rr < LENGTH(intervals)\n                ASSIGN intervals[rr] TO (start_i, end_i, char_i)\n                IF NOT (posIdx < start_i OR posIdx > end_i)\n                    BREAK\n                END IF\n                ASSIGN (rr + 1) TO rr\n            END WHILE\n\n            IF posIdx > start_i\n                INSERT (start_i, posIdx - 1, char_i) INTO intervals AT rr\n                ASSIGN (posIdx, end_i, char_i) TO intervals[rr + 1]\n            END IF\n            IF posIdx < end_i\n                INSERT (posIdx + 1, end_i, char_i) INTO intervals AT (rr + 1)\n                ASSIGN (start_i, posIdx, char_i) TO intervals[rr]\n            END IF\n\n            ASSIGN (intervals[rr][0], intervals[rr][1], newChar) TO intervals[rr]\n\n            CALL merge_intervals()\n\n            ASSIGN MAXIMUM OF ((e - b) + 1) FOR EACH (b e t) IN intervals TO max_len\n            APPEND max_len TO outputs\n\n            ASSIGN (cc + 1) TO cc\n        END WHILE\n\n        RETURN outputs\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION longestRepeating(s, queryCharacters, queryIndices)  \n        FUNCTION merge_intervals()  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals MINUS one  \n                IF element at position i of intervals at position two EQUALS element at position i plus one of intervals at position two  \n                    SET element at position i of intervals TO a tuple with first element as element at position i of intervals at position zero second element as element at position i plus one of intervals at position one third element as element at position i of intervals at position two  \n                    REMOVE element at position i plus one FROM intervals  \n                ELSE  \n                    INCREMENT i BY one  \n                END IF  \n            END WHILE  \n        END FUNCTION  \n      \n        SET intervals TO empty list  \n        SET n TO the LENGTH OF s  \n        SET start TO zero  \n        FOR i FROM one TO n MINUS one  \n            IF element at position i of s NOT EQUALS element at position start of s  \n                APPEND a tuple with first element start second element i MINUS one third element element at position start of s TO intervals  \n                SET start TO i  \n            END IF  \n        END FOR  \n        APPEND a tuple with first element start second element n MINUS one third element element at position start of s TO intervals  \n      \n        SET results TO empty list  \n        SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n      \n        FOR each pair of char and idx in the parallel elements of queryCharacters and queryIndices  \n            SET i TO zero  \n            WHILE i LESS THAN the LENGTH OF intervals  \n                SET start TO element at position i of intervals at position zero  \n                SET end TO element at position i of intervals at position one  \n                SET c TO element at position i of intervals at position two  \n                IF start LESS THAN OR EQUAL TO idx AND idx LESS THAN OR EQUAL TO end  \n                    BREAK the loop  \n                END IF  \n                INCREMENT i BY one  \n            END WHILE  \n      \n            IF idx GREATER THAN start  \n                INSERT at position i a tuple with first element start second element idx MINUS one third element c INTO intervals  \n                SET element at position i plus one of intervals TO a tuple with first element idx second element end third element c  \n            END IF  \n            IF idx LESS THAN end  \n                INSERT at position i plus one a tuple with first element idx PLUS one second element end third element c INTO intervals  \n                SET element at position i of intervals TO a tuple with first element start second element idx third element c  \n            END IF  \n      \n            SET element at position i of intervals TO a tuple with first element element at position i of intervals at position zero second element element at position i of intervals at position one third element char  \n      \n            CALL merge_intervals()  \n      \n            SET longest TO the maximum value of for each tuple in intervals subtract the first element FROM the second element PLUS one  \n            APPEND longest TO results  \n        END FOR  \n      \n        RETURN results  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "valid-number", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        ASSIGN pattern_string TO \"^[\\+\\-]?((\\d+(\\.\\d*)?)|(\\.\\d+))([eE][\\+\\-]?\\d+)?$\"  \n        ASSIGN match_result TO MATCH_ENTIRE_STRING(s, pattern_string)  \n        IF match_result == NULL  \n            RETURN false  \n        ELSE  \n            RETURN true  \n        END IF  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION isNumber(s)  \n        RETURN the RESULT OF matching the ENTIRE string s AGAINST the REGULAR expression representing optional plus or minus SIGN followed BY either one or more digits FOLLOWED BY an optional decimal POINT FOLLOWED BY zero or more digits OR a decimal POINT FOLLOWED BY one or more digits FOLLOWED optionally BY the letter e FOLLOWED optionally BY plus or minus SIGN FOLLOWED BY one or more digits IS NOT EQUAL TO no match  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "minimum-cost-to-change-the-final-value-of-expression", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION minOperationsToFlip(expression)\n        INITIALIZE container AS empty array\n        INITIALIZE idx AS 0\n        WHILE idx < LENGTH(expression)\n            ASSIGN expression[idx] TO currentChar\n\n            IF NOT (currentChar == \"(\" OR currentChar == \"&\" OR currentChar == \"|\")\n                IF currentChar == \")\"\n                    ASSIGN container.REMOVE_LAST() TO removedPair\n                    container.REMOVE_LAST()  // remove opening parenthesis\n                ELSE\n                    ASSIGN (currentChar, 1) TO removedPair\n                END IF\n            ELSE\n                APPEND (currentChar, 0) TO container\n                INCREMENT idx BY 1\n                CONTINUE WHILE\n            END IF\n\n            IF LENGTH(container) > 0 AND (container[-1][0] == \"&\" OR container[-1][0] == \"|\")\n                ASSIGN container.REMOVE_LAST()[0] TO operatorSymbol\n                ASSIGN container.REMOVE_LAST() TO (valA, costA)\n                ASSIGN removedPair TO (valB, costB)\n\n                IF operatorSymbol == \"&\"\n                    IF valA == 0 AND valB == 0\n                        ASSIGN (0, 1 + MIN(costA, costB)) TO removedPair\n                    ELSE IF valA == 0 AND valB == 1\n                        ASSIGN (0, 1) TO removedPair\n                    ELSE IF valA == 1 AND valB == 0\n                        ASSIGN (0, 1) TO removedPair\n                    ELSE\n                        ASSIGN (1, MIN(costA, costB)) TO removedPair\n                    END IF\n                ELSE\n                    IF valA == 0 AND valB == 0\n                        ASSIGN (0, MIN(costA, costB)) TO removedPair\n                    ELSE IF valA == 0 AND valB == 1\n                        ASSIGN (1, 1) TO removedPair\n                    ELSE IF valA == 1 AND valB == 0\n                        ASSIGN (1, 1) TO removedPair\n                    ELSE\n                        ASSIGN (1, 1 + MIN(costA, costB)) TO removedPair\n                    END IF\n                END IF\n            END IF\n\n            APPEND removedPair TO container\n\n            INCREMENT idx BY 1\n        END WHILE\n\n        RETURN container[-1][1]\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION minOperationsToFlip(expression)  \n        SET stack TO an empty list  \n        FOR each element e IN expression  \n            IF element e EQUALS one of open parenthesis AND sign AND vertical bar  \n                APPEND a pair of element e AND zero TO stack  \n                CONTINUE to next iteration  \n            ELSE IF element e EQUALS closing parenthesis  \n                SET lastPair TO the last element REMOVED FROM stack  \n                REMOVE the last element FROM stack  \n            ELSE  \n                SET lastPair TO a pair of element e AND one  \n            END IF  \n            IF stack is not empty AND the last element in stack AT position zero EQUALS one of sign AND vertical bar  \n                SET op TO the last element AT position zero REMOVED FROM stack  \n                SET a AND costA TO the last pair REMOVED FROM stack  \n                SET b AND costB TO lastPair  \n                IF op EQUALS sign  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND one INCREMENTED BY the minimum of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a pair of zero AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND one  \n                    ELSE  \n                        SET lastPair TO a pair of one AND the minimum of costA AND costB  \n                    END IF  \n                ELSE  \n                    IF a EQUALS zero AND b EQUALS zero  \n                        SET lastPair TO a pair of zero AND the minimum of costA AND costB  \n                    ELSE IF a EQUALS zero AND b EQUALS one  \n                        SET lastPair TO a pair of one AND one  \n                    ELSE IF a EQUALS one AND b EQUALS zero  \n                        SET lastPair TO a pair of one AND one  \n                    ELSE  \n                        SET lastPair TO a pair of one AND one INCREMENTED BY the minimum of costA AND costB  \n                    END IF  \n                END IF  \n            END IF  \n            APPEND lastPair TO stack  \n        END FOR  \n        RETURN the second element of the last element in stack  \n    END FUNCTION  \nEND CLASS"}
{"task_id": "number-of-distinct-islands-ii", "label": "cosmetic", "pseudocode": "CLASS Solution\n    FUNCTION numDistinctIslands2(grid)\n        FUNCTION dfs(x, y, island)\n            IF (x < 0) OR (x >= LENGTH grid) OR (y < 0) OR (y >= LENGTH grid[0]) OR (grid[x][y] = 0)\n                RETURN\n            END IF\n            ASSIGN 0 TO grid[x][y]\n            APPEND (x, y) TO island\n            dfs(x + 1, y, island)\n            dfs(x - 1, y, island)\n            dfs(x, y + 1, island)\n            dfs(x, y - 1, island)\n        END FUNCTION\n\n        FUNCTION normalize(island)\n            ASSIGN [] TO shapes\n            ASSIGN [(1, 1), (1, -1), (-1, 1), (-1, -1)] TO directions\n            FOR each (a, b) IN directions\n                ASSIGN [] TO transformed\n                FOR each (px, py) IN island\n                    APPEND (px * a, py * b) TO transformed\n                END FOR\n                SORT transformed BY ascending order\n                ASSIGN minimum x value from transformed TO base_x\n                ASSIGN minimum y value from transformed TO base_y\n                ASSIGN []\n                    TO normalized\n                FOR each (qx, qy) IN transformed\n                    APPEND (qx - base_x, qy - base_y) TO normalized\n                END FOR\n                APPEND TUPLE(normalized) TO shapes\n            END FOR\n\n            ASSIGN LENGTH shapes TO n\n            FOR idx FROM 0 TO n - 1\n                ASSIGN rotated_shape TO []\n                FOR each (cx, cy) IN shapes[idx]\n                    APPEND (cy, -cx) TO rotated_shape\n                END FOR\n                APPEND TUPLE(rotated_shape) TO shapes\n            END FOR\n            \n            RETURN minimal element IN shapes USING lex order\n        END FUNCTION\n\n        ASSIGN empty set TO distinct_set\n        ASSIGN LENGTH grid TO row_count\n        ASSIGN LENGTH grid[0] TO col_count\n        FOR row FROM 0 TO row_count - 1\n            FOR col FROM 0 TO col_count - 1\n                IF grid[row][col] = 1 THEN\n                    ASSIGN [] TO current_island\n                    CALL dfs(row, col, current_island)\n                    INSERT normalize(current_island) INTO distinct_set\n                END IF\n            END FOR\n        END FOR\n\n        RETURN SIZE OF distinct_set\n    END FUNCTION\nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution\n    FUNCTION numDistinctIslands2(grid)\n        FUNCTION dfs(x, y, island)\n            IF x LESS THAN zero OR x GREATER THAN OR EQUAL TO the LENGTH OF grid OR y LESS THAN zero OR y GREATER THAN OR EQUAL TO the LENGTH OF element at position zero OF grid OR element at position x OF grid AT position y EQUALS zero\n                RETURN\n            END IF\n            SET element at position x OF grid AT position y TO zero\n            APPEND tuple of x AND y TO island\n            CALL dfs WITH x PLUS one, y, AND island\n            CALL dfs WITH x MINUS one, y, AND island\n            CALL dfs WITH x, y PLUS one, AND island\n            CALL dfs WITH x, y MINUS one, AND island\n        END FUNCTION\n\n        FUNCTION normalize(island)\n            SET shapes TO empty list\n            FOR each pair dx AND dy IN list of pairs consisting of one and one, one and negative one, negative one and one, negative one and negative one\n                SET new_island TO empty list\n                FOR each pair x AND y IN island\n                    APPEND tuple of x MULTIPLIED BY dx AND y MULTIPLIED BY dy TO new_island\n                END FOR\n                SORT new_island IN ascending order\n                SET min_x TO the minimum x value FOR all pairs x AND y IN new_island\n                SET min_y TO the minimum y value FOR all pairs x AND y IN new_island\n                APPEND tuple of pairs where each pair is x MINUS min_x AND y MINUS min_y FOR each pair x AND y IN new_island TO shapes\n            END FOR\n            FOR index i FROM zero TO the LENGTH OF shapes MINUS one INCLUSIVE\n                APPEND tuple of pairs where each pair is y AND negative x FOR each pair x AND y IN element at position i OF shapes TO shapes\n            END FOR\n            RETURN the minimum element IN shapes\n        END FUNCTION\n\n        SET islands TO empty set\n        FOR index i FROM zero TO the LENGTH OF grid MINUS one INCLUSIVE\n            FOR index j FROM zero TO the LENGTH OF element at position zero OF grid MINUS one INCLUSIVE\n                IF element at position i OF grid AT position j EQUALS one\n                    SET island TO empty list\n                    CALL dfs WITH i, j, AND island\n                    ADD normalize(island) TO islands\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the LENGTH OF islands\n    END FUNCTION\nEND CLASS"}
{"task_id": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "label": "cosmetic", "pseudocode": "CLASS Solution  \n    FUNCTION getProbability(balls)  \n        FUNCTION dfs(ind, leftCount, delta)  \n            IF NOT (ind < k) THEN  \n                IF (leftCount = 0) AND (delta = 0) THEN  \n                    OUTPUT 1  \n                ELSE  \n                    OUTPUT 0  \n                END IF  \n            ELSE IF leftCount < 0 THEN  \n                OUTPUT 0  \n            END IF  \n\n            SET accumulator AS 0  \n            SET upper_bound TO balls[ind]  \n            SET indexVar TO 0  \n            WHILE indexVar <= upper_bound DO  \n                IF indexVar = upper_bound THEN  \n                    SET offset TO 1  \n                ELSE  \n                    IF indexVar = 0 THEN  \n                        SET offset TO -1  \n                    ELSE  \n                        SET offset TO 0  \n                    END IF  \n                END IF  \n                SET partialResult TO dfs(ind + 1, leftCount - indexVar, delta + offset)  \n                SET accumulator TO accumulator + (partialResult * combination(balls[ind], indexVar))  \n                SET indexVar TO indexVar + 1  \n            END WHILE  \n            OUTPUT accumulator  \n        END FUNCTION  \n\n        SET halfSum AS (sum over val IN balls: val) / 2  \n        SET k AS LENGTH OF balls  \n        OUTPUT dfs(0, halfSum, 0) / combination(halfSum + halfSum, halfSum)  \n    END FUNCTION  \nEND CLASS", "score": 1.0, "true_positive": "CLASS Solution  \n    FUNCTION getProbability WITH PARAMETER balls  \n        FUNCTION dfs WITH PARAMETERS i, j, diff  \n            IF i GREATER THAN OR EQUAL TO k  \n                IF j EQUALS zero AND diff EQUALS zero  \n                    RETURN one  \n                ELSE  \n                    RETURN zero  \n                END IF  \n            END IF  \n            IF j LESS THAN zero  \n                RETURN zero  \n            END IF  \n            SET ans TO zero  \n            FOR x FROM zero TO element at position i OF balls INCLUSIVE  \n                IF x EQUALS element at position i OF balls  \n                    SET y TO one  \n                ELSE IF x EQUALS zero  \n                    SET y TO negative one  \n                ELSE  \n                    SET y TO zero  \n                END IF  \n                SET ans TO ans PLUS dfs WITH ARGUMENTS i PLUS one, j MINUS x, diff PLUS y MULTIPLIED BY combination of element at position i OF balls AND x  \n            END FOR  \n            RETURN ans  \n        END FUNCTION  \n        SET n TO sum of balls DIVIDED BY two  \n        SET k TO length of balls  \n        RETURN dfs WITH ARGUMENTS zero, n, zero DIVIDED BY combination of n MULTIPLIED BY two AND n  \n    END FUNCTION  \nEND CLASS"}
